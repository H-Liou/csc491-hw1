id,workload,policy,policy_description,workload_description,cpp_file_path,cache_hit_rate,score
127,astar,LRU,"Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.454542233057875,0.416873389476646
128,astar,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.357354779439449,0.375792279833843
129,astar,"Less is More","The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.389017739443507,0.433282689768878
130,astar,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.0370956710938497,0.11453256801665
131,astar,"Reordering-based Cache Replacement","This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/red.cc,0.411020177465308,0.346602607438665
132,astar,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.33821173935846,0.375597937960249
133,lbm,LRU,"Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.439857834435407,0.416873389476646
134,lbm,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.272899835162444,0.375792279833843
135,lbm,"Less is More","The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.329722405165823,0.433282689768878
136,lbm,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.0115936433677206,0.11453256801665
137,lbm,"Reordering-based Cache Replacement","This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/red.cc,0.193584772113498,0.346602607438665
138,lbm,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.261584609998202,0.375597937960249
139,mcf,LRU,"Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.407402088663104,0.416873389476646
140,mcf,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.508772568892301,0.375792279833843
141,mcf,"Less is More","The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.52301754091011,0.433282689768878
142,mcf,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.515161598323247,0.11453256801665
143,mcf,"Reordering-based Cache Replacement","This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/red.cc,0.520031271059279,0.346602607438665
144,mcf,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.524743749964974,0.375597937960249
145,milc,LRU,"Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.321911410095802,0.416873389476646
146,milc,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.064566934835659,0.375792279833843
147,milc,"Less is More","The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.234603213683136,0.433282689768878
148,milc,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.000264306972635177,0.11453256801665
149,milc,"Reordering-based Cache Replacement","This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/red.cc,0.146273995814536,0.346602607438665
150,milc,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.054986712238499,0.375597937960249
151,omnetpp,LRU,"Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.46065338113104,0.416873389476646
152,omnetpp,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.675367280839363,0.375792279833843
153,omnetpp,"Less is More","The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.690052549641815,0.433282689768878
154,omnetpp,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.00854762032579974,0.11453256801665
155,omnetpp,"Reordering-based Cache Replacement","This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/red.cc,0.462102820740705,0.346602607438665
156,omnetpp,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.698462878241108,0.375597937960249
157,all,LRU,"Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.","",ChampSim_CRC2/champ_repl_pol/lru.cc,0.416873389476646,0.416873389476646
158,all,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.375792279833843,0.375792279833843
159,all,"Less is More","The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","",ChampSim_CRC2/champ_repl_pol/lime.cc,0.433282689768878,0.433282689768878
160,all,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.11453256801665,0.11453256801665
161,all,"Reordering-based Cache Replacement","This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","",ChampSim_CRC2/champ_repl_pol/red.cc,0.346602607438665,0.346602607438665
162,all,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.375597937960249,0.375597937960249
163,astar,"Adaptive Phase-Aware Replacement (APAR)","The Adaptive Phase-Aware Replacement (APAR) policy dynamically adjusts its cache management strategy based on workload phase behavior, leveraging both temporal and spatial locality signals. It uses a lightweight phase detector to classify workload behavior into distinct phases (e.g., compute-intensive, memory-bound, or mixed). For each phase, APAR applies a tailored replacement strategy: temporal locality optimization for compute-intensive phases, spatial locality optimization for memory-bound phases, and hybrid strategies for mixed phases. By adapting to workload characteristics in real-time, APAR minimizes cache pollution, reduces thrashing, and improves hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_replacement__apar.cc,0.290550325850833,0.290550325850833
164,lbm,"Adaptive Phase-Aware Replacement (APAR)","The Adaptive Phase-Aware Replacement (APAR) policy dynamically adjusts its cache management strategy based on workload phase behavior, leveraging both temporal and spatial locality signals. It uses a lightweight phase detector to classify workload behavior into distinct phases (e.g., compute-intensive, memory-bound, or mixed). For each phase, APAR applies a tailored replacement strategy: temporal locality optimization for compute-intensive phases, spatial locality optimization for memory-bound phases, and hybrid strategies for mixed phases. By adapting to workload characteristics in real-time, APAR minimizes cache pollution, reduces thrashing, and improves hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_replacement__apar.cc,0.439737459318921,0.439737459318921
165,mcf,"Adaptive Phase-Aware Replacement (APAR)","The Adaptive Phase-Aware Replacement (APAR) policy dynamically adjusts its cache management strategy based on workload phase behavior, leveraging both temporal and spatial locality signals. It uses a lightweight phase detector to classify workload behavior into distinct phases (e.g., compute-intensive, memory-bound, or mixed). For each phase, APAR applies a tailored replacement strategy: temporal locality optimization for compute-intensive phases, spatial locality optimization for memory-bound phases, and hybrid strategies for mixed phases. By adapting to workload characteristics in real-time, APAR minimizes cache pollution, reduces thrashing, and improves hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_replacement__apar.cc,0.290716921273147,0.290716921273147
166,milc,"Adaptive Phase-Aware Replacement (APAR)","The Adaptive Phase-Aware Replacement (APAR) policy dynamically adjusts its cache management strategy based on workload phase behavior, leveraging both temporal and spatial locality signals. It uses a lightweight phase detector to classify workload behavior into distinct phases (e.g., compute-intensive, memory-bound, or mixed). For each phase, APAR applies a tailored replacement strategy: temporal locality optimization for compute-intensive phases, spatial locality optimization for memory-bound phases, and hybrid strategies for mixed phases. By adapting to workload characteristics in real-time, APAR minimizes cache pollution, reduces thrashing, and improves hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_replacement__apar.cc,0.304256381006702,0.304256381006702
167,astar,"Adaptive Phase-Aware Reuse Predictor (APARP)","The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.287261646150133,0.287261646150133
168,lbm,"Adaptive Phase-Aware Reuse Predictor (APARP)","The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.40733804839912,0.40733804839912
169,mcf,"Adaptive Phase-Aware Reuse Predictor (APARP)","The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.161530592305659,0.161530592305659
170,milc,"Adaptive Phase-Aware Reuse Predictor (APARP)","The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.279837444745473,0.279837444745473
171,omnetpp,"Adaptive Phase-Aware Reuse Predictor (APARP)","The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.00303888593851419,0.00303888593851419
172,all,"Adaptive Phase-Aware Reuse Predictor (APARP)","The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.22780132350778,0.22780132350778
173,astar,"Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO)","The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.","",ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.0158701424088825,0.0158701424088825
174,lbm,"Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO)","The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.","",ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.0305630806712605,0.0305630806712605
175,mcf,"Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO)","The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.","",ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.0142642858374377,0.0142642858374377
176,milc,"Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO)","The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.","",ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.00709396834450307,0.00709396834450307
177,omnetpp,"Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO)","The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.","",ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.00014751873487933,0.00014751873487933
178,all,"Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO)","The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.","",ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.0135877991993926,0.0135877991993926
179,astar,"Adaptive Phase-Aware Replacement Policy (APARP)","The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.0158701424088825,0.0158701424088825
180,lbm,"Adaptive Phase-Aware Replacement Policy (APARP)","The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.0300903619934183,0.0300903619934183
181,mcf,"Adaptive Phase-Aware Replacement Policy (APARP)","The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.0138849776725421,0.0138849776725421
182,milc,"Adaptive Phase-Aware Replacement Policy (APARP)","The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.00709396834450307,0.00709396834450307
183,omnetpp,"Adaptive Phase-Aware Replacement Policy (APARP)","The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.00014751873487933,0.00014751873487933
184,all,"Adaptive Phase-Aware Replacement Policy (APARP)","The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.0134173938308451,0.0134173938308451
185,astar,"Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA)","The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.","",ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.0158701424088825,0.0158701424088825
186,lbm,"Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA)","The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.","",ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.0300903619934183,0.0300903619934183
187,mcf,"Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA)","The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.","",ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.0138849776725421,0.0138849776725421
188,milc,"Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA)","The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.","",ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.00709396834450307,0.00709396834450307
189,omnetpp,"Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA)","The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.","",ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.00014751873487933,0.00014751873487933
190,all,"Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA)","The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.","",ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.0134173938308451,0.0134173938308451
191,astar,"**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**","PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.290520154477432,0.290520154477432
192,lbm,"**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**","PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.4174469555099,0.4174469555099
193,mcf,"**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**","PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.240067129137379,0.240067129137379
194,milc,"**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**","PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.304256381006702,0.304256381006702
195,omnetpp,"**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**","PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.0053696819496076,0.0053696819496076
196,all,"**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**","PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.251532060416204,0.251532060416204
197,astar,"**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**","HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.0300506879073135,0.0300506879073135
198,lbm,"**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**","HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.0300925505027547,0.0300925505027547
199,mcf,"**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**","HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.0702294814397618,0.0702294814397618
200,milc,"**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**","HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.0168615428489947,0.0168615428489947
201,omnetpp,"**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**","HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.000295037469758659,0.000295037469758659
202,all,"**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**","HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.0295058600337167,0.0295058600337167
203,astar,"**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**","PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.","",ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.0301412020275163,0.0301412020275163
204,lbm,"**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**","PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.","",ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.0300925505027547,0.0300925505027547
205,mcf,"**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**","PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.","",ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.0708789029948104,0.0708789029948104
206,milc,"**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**","PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.","",ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.0168615428489947,0.0168615428489947
207,omnetpp,"**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**","PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.","",ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.000295037469758659,0.000295037469758659
208,all,"**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**","PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.","",ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.0296538471687669,0.0296538471687669
209,astar,"**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**","MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.","",ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.290188269370022,0.290188269370022
210,lbm,"**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**","MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.","",ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.439373829566735,0.439373829566735
211,mcf,"**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**","MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.","",ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.29062329377281,0.29062329377281
212,milc,"**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**","MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.","",ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.30389990018537,0.30389990018537
213,omnetpp,"**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**","MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.","",ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.00451407328730749,0.00451407328730749
214,all,"**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**","MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.","",ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.265719873236449,0.265719873236449
215,astar,"Phase-Aware Multi-Signal Replacement (PAMSR)","PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.290278783490224,0.290278783490224
216,lbm,"Phase-Aware Multi-Signal Replacement (PAMSR)","PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.43951928146761,0.43951928146761
217,mcf,"Phase-Aware Multi-Signal Replacement (PAMSR)","PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.290647953377703,0.290647953377703
218,milc,"Phase-Aware Multi-Signal Replacement (PAMSR)","PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.303971196349636,0.303971196349636
219,omnetpp,"Phase-Aware Multi-Signal Replacement (PAMSR)","PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.00454357703428335,0.00454357703428335
220,all,"Phase-Aware Multi-Signal Replacement (PAMSR)","PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.265792158343891,0.265792158343891
221,astar,"Dual-Partition Adaptive Replacement (DPAR)","DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.","",ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.285391020999276,0.285391020999276
222,lbm,"Dual-Partition Adaptive Replacement (DPAR)","DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.","",ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.423701387247505,0.423701387247505
223,mcf,"Dual-Partition Adaptive Replacement (DPAR)","DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.","",ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.29014701318406,0.29014701318406
224,milc,"Dual-Partition Adaptive Replacement (DPAR)","DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.","",ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.304256381006702,0.304256381006702
225,omnetpp,"Dual-Partition Adaptive Replacement (DPAR)","DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.","",ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.0053696819496076,0.0053696819496076
226,all,"Dual-Partition Adaptive Replacement (DPAR)","DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.","",ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.26177309687743,0.26177309687743
227,astar,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.","",ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.0165942553705045,0.0165942553705045
228,lbm,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.","",ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.0439082925764986,0.0439082925764986
229,mcf,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.","",ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.0198212695037499,0.0198212695037499
230,milc,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.","",ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.00709396834450307,0.00709396834450307
231,omnetpp,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.","",ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.000295037469758659,0.000295037469758659
232,all,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.","",ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.0175425646530029,0.0175425646530029
233,astar,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.","",ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.152818006275646,0.152818006275646
234,lbm,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.","",ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.235450264540645,0.235450264540645
235,mcf,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.","",ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.15906778930429,0.15906778930429
236,milc,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.","",ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.155568230429203,0.155568230429203
237,omnetpp,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.","",ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.00522216321472827,0.00522216321472827
238,all,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.","",ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.141625290752902,0.141625290752902
239,astar,"PC-BRRIP (PC-based Bypass and Reuse-biased RRIP)","PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).","",ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.0169563118513155,0.0169563118513155
240,lbm,"PC-BRRIP (PC-based Bypass and Reuse-biased RRIP)","PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).","",ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.0468900565444265,0.0468900565444265
241,mcf,"PC-BRRIP (PC-based Bypass and Reuse-biased RRIP)","PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).","",ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.0225455882944547,0.0225455882944547
242,milc,"PC-BRRIP (PC-based Bypass and Reuse-biased RRIP)","PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).","",ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.00766433765863397,0.00766433765863397
243,omnetpp,"PC-BRRIP (PC-based Bypass and Reuse-biased RRIP)","PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).","",ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.00660883932259397,0.00660883932259397
244,all,"PC-BRRIP (PC-based Bypass and Reuse-biased RRIP)","PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).","",ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.0201330267342849,0.0201330267342849
245,astar,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.","",ChampSim_CRC2/new_policies/004_drrip.cc,0.286326333574704,0.286326333574704
246,lbm,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.","",ChampSim_CRC2/new_policies/004_drrip.cc,0.417246959146197,0.417246959146197
247,mcf,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.","",ChampSim_CRC2/new_policies/004_drrip.cc,0.292414062634704,0.292414062634704
248,milc,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.","",ChampSim_CRC2/new_policies/004_drrip.cc,0.299657778411521,0.299657778411521
249,omnetpp,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.","",ChampSim_CRC2/new_policies/004_drrip.cc,0.00528117070868,0.00528117070868
250,all,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.","",ChampSim_CRC2/new_policies/004_drrip.cc,0.260185260895161,0.260185260895161
251,astar,"Reuse Distance Aware Replacement (ReDRe)","ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.","",ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.0158701424088825,0.0158701424088825
252,lbm,"Reuse Distance Aware Replacement (ReDRe)","ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.","",ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.0489263831566699,0.0489263831566699
253,mcf,"Reuse Distance Aware Replacement (ReDRe)","ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.","",ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.0143560743205577,0.0143560743205577
254,milc,"Reuse Distance Aware Replacement (ReDRe)","ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.","",ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.00709396834450307,0.00709396834450307
255,omnetpp,"Reuse Distance Aware Replacement (ReDRe)","ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.","",ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.00014751873487933,0.00014751873487933
256,all,"Reuse Distance Aware Replacement (ReDRe)","ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.","",ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.0172788173930985,0.0172788173930985
257,astar,"DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling)","DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.","",ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.268645908761767,0.268645908761767
258,lbm,"DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling)","DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.","",ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.393992836493882,0.393992836493882
259,mcf,"DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling)","DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.","",ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.290427146075682,0.290427146075682
260,milc,"DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling)","DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.","",ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.299550834165122,0.299550834165122
261,omnetpp,"DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling)","DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.","",ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.00534017820263173,0.00534017820263173
262,all,"DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling)","DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.","",ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.251591380739817,0.251591380739817
263,astar,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.","",ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.290369297610427,0.290369297610427
264,lbm,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.","",ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.42542862857039,0.42542862857039
265,mcf,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.","",ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.258038931705719,0.258038931705719
266,milc,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.","",ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.29056751746756,0.29056751746756
267,omnetpp,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.","",ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.00539918569658347,0.00539918569658347
268,all,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.","",ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.253960712210136,0.253960712210136
269,astar,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.","",ChampSim_CRC2/new_policies/003_ship_msp.cc,0.289886555636013,0.289886555636013
270,lbm,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.","",ChampSim_CRC2/new_policies/003_ship_msp.cc,0.435410265267904,0.435410265267904
271,mcf,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.","",ChampSim_CRC2/new_policies/003_ship_msp.cc,0.234640628053196,0.234640628053196
272,milc,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.","",ChampSim_CRC2/new_policies/003_ship_msp.cc,0.292670754313418,0.292670754313418
273,omnetpp,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.","",ChampSim_CRC2/new_policies/003_ship_msp.cc,0.00539918569658347,0.00539918569658347
274,all,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.","",ChampSim_CRC2/new_policies/003_ship_msp.cc,0.251601477793423,0.251601477793423
275,astar,"DIP-SHiP Hybrid","This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.","",ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.0158701424088825,0.0158701424088825
276,lbm,"DIP-SHiP Hybrid","This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.","",ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.0300903619934183,0.0300903619934183
277,mcf,"DIP-SHiP Hybrid","This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.","",ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.0138849776725421,0.0138849776725421
278,milc,"DIP-SHiP Hybrid","This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.","",ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.00709396834450307,0.00709396834450307
279,omnetpp,"DIP-SHiP Hybrid","This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.","",ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.00014751873487933,0.00014751873487933
280,all,"DIP-SHiP Hybrid","This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.","",ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.0134173938308451,0.0134173938308451
281,astar,"Adaptive Phase-Aware Hybrid (APAH) Replacement","The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.290399468983828,0.290399468983828
282,lbm,"Adaptive Phase-Aware Hybrid (APAH) Replacement","The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.436155706259886,0.436155706259886
283,mcf,"Adaptive Phase-Aware Hybrid (APAH) Replacement","The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.249551713832502,0.249551713832502
284,milc,"Adaptive Phase-Aware Hybrid (APAH) Replacement","The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.304256381006702,0.304256381006702
285,omnetpp,"Adaptive Phase-Aware Hybrid (APAH) Replacement","The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.00486811825101788,0.00486811825101788
286,all,"Adaptive Phase-Aware Hybrid (APAH) Replacement","The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.257046277666787,0.257046277666787
287,astar,"Dynamic Multi-Signal Reuse-based Replacement (DMRR)","DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.","",ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.0158701424088825,0.0158701424088825
288,lbm,"Dynamic Multi-Signal Reuse-based Replacement (DMRR)","DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.","",ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.0300903619934183,0.0300903619934183
289,mcf,"Dynamic Multi-Signal Reuse-based Replacement (DMRR)","DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.","",ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.0138849776725421,0.0138849776725421
290,milc,"Dynamic Multi-Signal Reuse-based Replacement (DMRR)","DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.","",ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.00709396834450307,0.00709396834450307
291,omnetpp,"Dynamic Multi-Signal Reuse-based Replacement (DMRR)","DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.","",ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.00014751873487933,0.00014751873487933
292,all,"Dynamic Multi-Signal Reuse-based Replacement (DMRR)","DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.","",ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.0134173938308451,0.0134173938308451
293,astar,"**Multi-Policy Adaptive Replacement (MPAR)**","MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.","",ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.0158701424088825,0.0158701424088825
294,lbm,"**Multi-Policy Adaptive Replacement (MPAR)**","MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.","",ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.0300903619934183,0.0300903619934183
295,mcf,"**Multi-Policy Adaptive Replacement (MPAR)**","MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.","",ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.0138849776725421,0.0138849776725421
296,milc,"**Multi-Policy Adaptive Replacement (MPAR)**","MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.","",ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.00709396834450307,0.00709396834450307
297,omnetpp,"**Multi-Policy Adaptive Replacement (MPAR)**","MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.","",ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.00014751873487933,0.00014751873487933
298,all,"**Multi-Policy Adaptive Replacement (MPAR)**","MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.","",ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.0134173938308451,0.0134173938308451
299,astar,"**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**","DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.","",ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.286477190441709,0.286477190441709
300,lbm,"**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**","DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.","",ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.433573935019363,0.433573935019363
301,mcf,"**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**","DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.","",ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.286483597324076,0.286483597324076
302,milc,"**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**","DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.","",ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.299622130329388,0.299622130329388
303,omnetpp,"**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**","DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.","",ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.00483861450404201,0.00483861450404201
304,all,"**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**","DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.","",ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.262199093523716,0.262199093523716
305,astar,"Adaptive Hybrid LRU-BRRIP with Phase Detection","This policy combines the strengths of LRU and Bimodal RRIP (BRRIP), adapting dynamically to workload phase changes and access patterns. For workloads with high spatial locality (like lbm and milc), it leans toward LRU to retain recently used blocks. For irregular, memory-bound, or pointer-chasing workloads (like mcf, omnetpp, astar), it shifts toward BRRIP to prevent cache pollution and retain blocks with longer reuse intervals. Phase detection is accomplished by monitoring per-set hit/miss rates over windows; sets with frequent hits favor LRU, while sets with frequent misses favor BRRIP. This hybrid approach allows the cache to respond to both regular and irregular access patterns, improving overall hit rate by dynamically tuning replacement aggressiveness based on observed behavior.","",ChampSim_CRC2/new_policies/001_adaptive_hybrid_lru_brrip_with_phase_detection.cc,0.290580497224234,0.290580497224234
306,astar,"Adaptive Reuse-Phase Predictor (ARPP)","ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.","",ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.0274559497948347,0.0274559497948347
307,lbm,"Adaptive Reuse-Phase Predictor (ARPP)","ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.","",ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.0359811639788368,0.0359811639788368
308,mcf,"Adaptive Reuse-Phase Predictor (ARPP)","ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.","",ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.0153617158226248,0.0153617158226248
309,milc,"Adaptive Reuse-Phase Predictor (ARPP)","ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.","",ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.0578924853842863,0.0578924853842863
310,omnetpp,"Adaptive Reuse-Phase Predictor (ARPP)","ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.","",ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.000560571192541453,0.000560571192541453
311,all,"Adaptive Reuse-Phase Predictor (ARPP)","ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.","",ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.0274503772346248,0.0274503772346248
312,astar,"Hybrid Hawkeye-LRU with Streaming Detector (HHLSD)","HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.","",ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.12303886072894,0.12303886072894
313,lbm,"Hybrid Hawkeye-LRU with Streaming Detector (HHLSD)","HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.","",ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.174778640388357,0.174778640388357
314,mcf,"Hybrid Hawkeye-LRU with Streaming Detector (HHLSD)","HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.","",ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.127665932954408,0.127665932954408
315,milc,"Hybrid Hawkeye-LRU with Streaming Detector (HHLSD)","HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.","",ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.125944674176529,0.125944674176529
316,omnetpp,"Hybrid Hawkeye-LRU with Streaming Detector (HHLSD)","HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.","",ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.00236029975806927,0.00236029975806927
317,all,"Hybrid Hawkeye-LRU with Streaming Detector (HHLSD)","HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.","",ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.110757681601261,0.110757681601261
318,astar,"Adaptive Reuse and Spatial Locality (ARSL) Replacement","ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.12303886072894,0.12303886072894
319,lbm,"Adaptive Reuse and Spatial Locality (ARSL) Replacement","ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.174778640388357,0.174778640388357
320,mcf,"Adaptive Reuse and Spatial Locality (ARSL) Replacement","ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.127665932954408,0.127665932954408
321,milc,"Adaptive Reuse and Spatial Locality (ARSL) Replacement","ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.125944674176529,0.125944674176529
322,omnetpp,"Adaptive Reuse and Spatial Locality (ARSL) Replacement","ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.00236029975806927,0.00236029975806927
323,all,"Adaptive Reuse and Spatial Locality (ARSL) Replacement","ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.110757681601261,0.110757681601261
324,astar,"**Multi-Signal Dynamic Priority Replacement (MSDP)**","MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.290489983104031,0.290489983104031
325,lbm,"**Multi-Signal Dynamic Priority Replacement (MSDP)**","MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.436282976673151,0.436282976673151
326,mcf,"**Multi-Signal Dynamic Priority Replacement (MSDP)**","MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.128979235274171,0.128979235274171
327,milc,"**Multi-Signal Dynamic Priority Replacement (MSDP)**","MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.279155973766752,0.279155973766752
328,omnetpp,"**Multi-Signal Dynamic Priority Replacement (MSDP)**","MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.00781849294860447,0.00781849294860447
329,all,"**Multi-Signal Dynamic Priority Replacement (MSDP)**","MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.228545332353342,0.228545332353342
330,astar,"**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**","A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.290520154477432,0.290520154477432
331,lbm,"**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**","A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.425392265595171,0.425392265595171
332,mcf,"**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**","A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.29651597181512,0.29651597181512
333,milc,"**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**","A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.304256381006702,0.304256381006702
334,omnetpp,"**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**","A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.0053696819496076,0.0053696819496076
335,all,"**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**","A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.264410890968806,0.264410890968806
336,astar,"**Hybrid Multi-Signal Replacement (HMSR)**","HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.287442674390538,0.287442674390538
337,lbm,"**Hybrid Multi-Signal Replacement (HMSR)**","HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.407374411374339,0.407374411374339
338,mcf,"**Hybrid Multi-Signal Replacement (HMSR)**","HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.163414732268576,0.163414732268576
339,milc,"**Hybrid Multi-Signal Replacement (HMSR)**","HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.27958368976333,0.27958368976333
340,omnetpp,"**Hybrid Multi-Signal Replacement (HMSR)**","HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.00548769693751106,0.00548769693751106
341,all,"**Hybrid Multi-Signal Replacement (HMSR)**","HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.","",ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.228660640946859,0.228660640946859
342,astar,"Adaptive Dynamic Reuse Distance (ADRD)","ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.287442674390538,0.287442674390538
343,lbm,"Adaptive Dynamic Reuse Distance (ADRD)","ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.407374411374339,0.407374411374339
344,mcf,"Adaptive Dynamic Reuse Distance (ADRD)","ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.16052391105696,0.16052391105696
345,milc,"Adaptive Dynamic Reuse Distance (ADRD)","ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.27958368976333,0.27958368976333
346,omnetpp,"Adaptive Dynamic Reuse Distance (ADRD)","ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.00548769693751106,0.00548769693751106
347,all,"Adaptive Dynamic Reuse Distance (ADRD)","ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.228082476704536,0.228082476704536
348,astar,"Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP)","HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.","",ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.290580497224234,0.290580497224234
349,lbm,"Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP)","HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.","",ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.439737459318921,0.439737459318921
350,mcf,"Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP)","HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.","",ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.28938187878962,0.28938187878962
351,milc,"Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP)","HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.","",ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.304256381006702,0.304256381006702
352,omnetpp,"Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP)","HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.","",ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.00460258452823509,0.00460258452823509
353,all,"Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP)","HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.","",ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.265711760173542,0.265711760173542
354,astar,"Adaptive Hawkeye-Enhanced SRRIP (AHES)","AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.","",ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.287442674390538,0.287442674390538
355,lbm,"Adaptive Hawkeye-Enhanced SRRIP (AHES)","AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.","",ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.407374411374339,0.407374411374339
356,mcf,"Adaptive Hawkeye-Enhanced SRRIP (AHES)","AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.","",ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.16052391105696,0.16052391105696
357,milc,"Adaptive Hawkeye-Enhanced SRRIP (AHES)","AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.","",ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.27958368976333,0.27958368976333
358,omnetpp,"Adaptive Hawkeye-Enhanced SRRIP (AHES)","AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.","",ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.00548769693751106,0.00548769693751106
359,all,"Adaptive Hawkeye-Enhanced SRRIP (AHES)","AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.","",ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.228082476704536,0.228082476704536
360,astar,"Phase-Aware Dynamic Insertion Policy (PADIP)","PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.290580497224234,0.290580497224234
361,lbm,"Phase-Aware Dynamic Insertion Policy (PADIP)","PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.439737459318921,0.439737459318921
362,mcf,"Phase-Aware Dynamic Insertion Policy (PADIP)","PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.286784102991465,0.286784102991465
363,milc,"Phase-Aware Dynamic Insertion Policy (PADIP)","PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.304256381006702,0.304256381006702
364,omnetpp,"Phase-Aware Dynamic Insertion Policy (PADIP)","PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.00460258452823509,0.00460258452823509
365,all,"Phase-Aware Dynamic Insertion Policy (PADIP)","PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.265192205013911,0.265192205013911
366,astar,"Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP)","HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.","",ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.287412503017137,0.287412503017137
367,lbm,"Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP)","HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.","",ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.431719423283213,0.431719423283213
368,mcf,"Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP)","HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.","",ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.160593799928735,0.160593799928735
369,milc,"Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP)","HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.","",ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.279338371595608,0.279338371595608
370,omnetpp,"Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP)","HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.","",ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.00858559036997699,0.00858559036997699
371,all,"Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP)","HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.","",ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.233529937638934,0.233529937638934
372,astar,"Adaptive Signature-based Dynamic Insertion Policy (ASDIP)","ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.","",ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.287442674390538,0.287442674390538
373,lbm,"Adaptive Signature-based Dynamic Insertion Policy (ASDIP)","ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.","",ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.417283322121416,0.417283322121416
374,mcf,"Adaptive Signature-based Dynamic Insertion Policy (ASDIP)","ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.","",ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.160623459025156,0.160623459025156
375,milc,"Adaptive Signature-based Dynamic Insertion Policy (ASDIP)","ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.","",ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.27958368976333,0.27958368976333
376,omnetpp,"Adaptive Signature-based Dynamic Insertion Policy (ASDIP)","ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.","",ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.00855608662300112,0.00855608662300112
377,all,"Adaptive Signature-based Dynamic Insertion Policy (ASDIP)","ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.","",ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.230697846384688,0.230697846384688
378,astar,"**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**","HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.","",ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.287321988896935,0.287321988896935
379,lbm,"**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**","HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.","",ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.416846966418792,0.416846966418792
380,mcf,"**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**","HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.","",ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.155545977011494,0.155545977011494
381,milc,"**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**","HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.","",ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.279552260088407,0.279552260088407
382,omnetpp,"**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**","HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.","",ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.00784799669558034,0.00784799669558034
383,all,"**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**","HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.","",ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.229423037822242,0.229423037822242
384,astar,"**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**","ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.288347815592566,0.288347815592566
385,lbm,"**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**","ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.411174342284686,0.411174342284686
386,mcf,"**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**","ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.188187152652057,0.188187152652057
387,milc,"**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**","ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.28350919720519,0.28350919720519
388,omnetpp,"**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**","ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.0053696819496076,0.0053696819496076
389,all,"**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**","ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.235317637936821,0.235317637936821
390,astar,"**Dynamic Multi-Feature Replacement (DMFR)**","DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.","",ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.290520154477432,0.290520154477432
391,lbm,"**Dynamic Multi-Feature Replacement (DMFR)**","DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.","",ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.436519336012072,0.436519336012072
392,mcf,"**Dynamic Multi-Feature Replacement (DMFR)**","DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.","",ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.138348803126527,0.138348803126527
393,milc,"**Dynamic Multi-Feature Replacement (DMFR)**","DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.","",ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.279904476760764,0.279904476760764
394,omnetpp,"**Dynamic Multi-Feature Replacement (DMFR)**","DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.","",ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.00475010326311442,0.00475010326311442
395,all,"**Dynamic Multi-Feature Replacement (DMFR)**","DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.","",ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.230008574727982,0.230008574727982
396,astar,"**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**","ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.","",ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.290520154477432,0.290520154477432
397,lbm,"**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**","ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.","",ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.425392265595171,0.425392265595171
398,mcf,"**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**","ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.","",ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.29651597181512,0.29651597181512
399,milc,"**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**","ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.","",ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.304256381006702,0.304256381006702
400,omnetpp,"**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**","ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.","",ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.0053696819496076,0.0053696819496076
401,all,"**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**","ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.","",ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.264410890968806,0.264410890968806
402,astar,"**Dynamic Signature-based RRIP (DS-RRIP)**","DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.287563359884142,0.287563359884142
403,lbm,"**Dynamic Signature-based RRIP (DS-RRIP)**","DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.407465318812385,0.407465318812385
404,mcf,"**Dynamic Signature-based RRIP (DS-RRIP)**","DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.191177062200792,0.191177062200792
405,milc,"**Dynamic Signature-based RRIP (DS-RRIP)**","DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.279552260088407,0.279552260088407
406,omnetpp,"**Dynamic Signature-based RRIP (DS-RRIP)**","DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.00548769693751106,0.00548769693751106
407,all,"**Dynamic Signature-based RRIP (DS-RRIP)**","DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.234249139584647,0.234249139584647
408,astar,"**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**","HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.289283128167994,0.289283128167994
409,lbm,"**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**","HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.426646788240214,0.426646788240214
410,mcf,"**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**","HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.28185867409983,0.28185867409983
411,milc,"**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**","HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.298303151290461,0.298303151290461
412,omnetpp,"**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**","HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.00516315572077654,0.00516315572077654
413,all,"**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**","HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.260250979503855,0.260250979503855
414,astar,"**Segmented Adaptive RRIP (SARRIP)**","SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.","",ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.269762249577601,0.269762249577601
415,lbm,"**Segmented Adaptive RRIP (SARRIP)**","SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.","",ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.348230032181233,0.348230032181233
416,mcf,"**Segmented Adaptive RRIP (SARRIP)**","SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.","",ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.139492649509776,0.139492649509776
417,milc,"**Segmented Adaptive RRIP (SARRIP)**","SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.","",ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.278300541773596,0.278300541773596
418,omnetpp,"**Segmented Adaptive RRIP (SARRIP)**","SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.","",ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.00445506579335576,0.00445506579335576
419,all,"**Segmented Adaptive RRIP (SARRIP)**","SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.","",ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.208048107767112,0.208048107767112
420,astar,"**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**","DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.","",ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.287352160270335,0.287352160270335
421,lbm,"**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**","DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.","",ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.409392556498973,0.409392556498973
422,mcf,"**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**","DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.","",ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.161627365674515,0.161627365674515
423,milc,"**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**","DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.","",ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.280439121756487,0.280439121756487
424,omnetpp,"**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**","DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.","",ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.00843807163509766,0.00843807163509766
425,all,"**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**","DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.","",ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.229449855167082,0.229449855167082
426,astar,"**Adaptive Signature-based Locality and Frequency Policy (ASLF)**","ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.","",ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.289765870142409,0.289765870142409
427,lbm,"**Adaptive Signature-based Locality and Frequency Policy (ASLF)**","ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.","",ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.415919710550717,0.415919710550717
428,mcf,"**Adaptive Signature-based Locality and Frequency Policy (ASLF)**","ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.","",ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.239152174162921,0.239152174162921
429,milc,"**Adaptive Signature-based Locality and Frequency Policy (ASLF)**","ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.","",ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.298481391701126,0.298481391701126
430,omnetpp,"**Adaptive Signature-based Locality and Frequency Policy (ASLF)**","ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.","",ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.00498613323892134,0.00498613323892134
431,all,"**Adaptive Signature-based Locality and Frequency Policy (ASLF)**","ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.","",ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.249661055959219,0.249661055959219
432,astar,"**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**","PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.287412503017137,0.287412503017137
433,lbm,"**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**","PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.419646915510627,0.419646915510627
434,mcf,"**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**","PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.18463430614145,0.18463430614145
435,milc,"**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**","PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.27958368976333,0.27958368976333
436,omnetpp,"**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**","PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.00548769693751106,0.00548769693751106
437,all,"**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**","PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.235353022274011,0.235353022274011
438,astar,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.287442674390538,0.287442674390538
439,lbm,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.407374411374339,0.407374411374339
440,mcf,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.160680931280424,0.160680931280424
441,milc,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.27958368976333,0.27958368976333
442,omnetpp,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.00548769693751106,0.00548769693751106
443,all,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.","",ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.228113880749229,0.228113880749229
444,astar,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.287442674390538,0.287442674390538
445,lbm,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.407374411374339,0.407374411374339
446,mcf,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.16052391105696,0.16052391105696
447,milc,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.27958368976333,0.27958368976333
448,omnetpp,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.00548769693751106,0.00548769693751106
449,all,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.228082476704536,0.228082476704536
450,astar,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.","",ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.287442674390538,0.287442674390538
451,lbm,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.","",ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.407374411374339,0.407374411374339
452,mcf,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.","",ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.16052391105696,0.16052391105696
453,milc,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.","",ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.27958368976333,0.27958368976333
454,omnetpp,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.","",ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.00548769693751106,0.00548769693751106
455,all,"**Multi-Signal Locality-Aware Replacement (MSLAR)**","MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.","",ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.228082476704536,0.228082476704536
456,astar,"**Dynamic Phase-Aware RRIP (DPAR)**","DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.","",ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.28554187786628,0.28554187786628
457,lbm,"**Dynamic Phase-Aware RRIP (DPAR)**","DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.","",ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.395810985254814,0.395810985254814
458,mcf,"**Dynamic Phase-Aware RRIP (DPAR)**","DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.","",ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.164690601670125,0.164690601670125
459,milc,"**Dynamic Phase-Aware RRIP (DPAR)**","DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.","",ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.27891059461001,0.27891059461001
460,omnetpp,"**Dynamic Phase-Aware RRIP (DPAR)**","DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.","",ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.00858559036997699,0.00858559036997699
461,all,"**Dynamic Phase-Aware RRIP (DPAR)**","DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.","",ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.226707929954241,0.226707929954241
462,astar,"**Spatial-Temporal Adaptive Replacement (STAR)**","STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.","",ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.290520154477432,0.290520154477432
463,lbm,"**Spatial-Temporal Adaptive Replacement (STAR)**","STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.","",ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.435137542953765,0.435137542953765
464,mcf,"**Spatial-Temporal Adaptive Replacement (STAR)**","STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.","",ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.274271230861189,0.274271230861189
465,milc,"**Spatial-Temporal Adaptive Replacement (STAR)**","STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.","",ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.304256381006702,0.304256381006702
466,omnetpp,"**Spatial-Temporal Adaptive Replacement (STAR)**","STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.","",ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.00486811825101788,0.00486811825101788
467,all,"**Spatial-Temporal Adaptive Replacement (STAR)**","STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.","",ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.261810685510021,0.261810685510021
468,astar,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.","",ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.290248612116824,0.290248612116824
469,lbm,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.","",ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.432101234523009,0.432101234523009
470,mcf,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.","",ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.283716679885513,0.283716679885513
471,milc,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.","",ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.304256381006702,0.304256381006702
472,omnetpp,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.","",ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.00486811825101788,0.00486811825101788
473,all,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.","",ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.263038205156613,0.263038205156613
474,astar,"**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**","ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.","",ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.290520154477432,0.290520154477432
475,lbm,"**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**","ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.","",ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.4174469555099,0.4174469555099
476,mcf,"**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**","ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.","",ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.237838800891975,0.237838800891975
477,milc,"**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**","ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.","",ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.304256381006702,0.304256381006702
478,omnetpp,"**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**","ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.","",ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.0053696819496076,0.0053696819496076
479,all,"**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**","ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.","",ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.251086394767123,0.251086394767123
480,astar,"**Dynamic Signature-Locality Adaptive Replacement (DSLR)**","DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.","",ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.290520154477432,0.290520154477432
481,lbm,"**Dynamic Signature-Locality Adaptive Replacement (DSLR)**","DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.","",ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.418083307576226,0.418083307576226
482,mcf,"**Dynamic Signature-Locality Adaptive Replacement (DSLR)**","DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.","",ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.261644213527059,0.261644213527059
483,milc,"**Dynamic Signature-Locality Adaptive Replacement (DSLR)**","DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.","",ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.304256381006702,0.304256381006702
484,omnetpp,"**Dynamic Signature-Locality Adaptive Replacement (DSLR)**","DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.","",ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.0053696819496076,0.0053696819496076
485,all,"**Dynamic Signature-Locality Adaptive Replacement (DSLR)**","DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.","",ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.255974747707405,0.255974747707405
486,astar,"**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**","PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.288015930485156,0.288015930485156
487,lbm,"**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**","PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.408338030217632,0.408338030217632
488,mcf,"**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**","PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.185835469373211,0.185835469373211
489,milc,"**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**","PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.285612434051048,0.285612434051048
490,omnetpp,"**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**","PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.0055467044314628,0.0055467044314628
491,all,"**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**","PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.234669713711702,0.234669713711702
492,astar,"**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**","AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.162744388124547,0.162744388124547
493,lbm,"**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**","AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.321848693660115,0.321848693660115
494,mcf,"**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**","AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.255686846975253,0.255686846975253
495,milc,"**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**","AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.132503921289035,0.132503921289035
496,omnetpp,"**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**","AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.000354044963710391,0.000354044963710391
497,all,"**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**","AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.174627579002532,0.174627579002532
498,astar,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.","",ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.128922278542119,0.128922278542119
499,lbm,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.","",ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.291849239104744,0.291849239104744
500,mcf,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.","",ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.270695402298851,0.270695402298851
501,milc,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.","",ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.0933623271068017,0.0933623271068017
502,omnetpp,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.","",ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.000295037469758659,0.000295037469758659
503,all,"**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**","DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.","",ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.157024856904455,0.157024856904455
504,astar,"**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**","DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.","",ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.290580497224234,0.290580497224234
505,lbm,"**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**","DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.","",ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.439737459318921,0.439737459318921
506,mcf,"**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**","DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.","",ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.296248189613554,0.296248189613554
507,milc,"**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**","DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.","",ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.304256381006702,0.304256381006702
508,omnetpp,"**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**","DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.","",ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.0053696819496076,0.0053696819496076
509,all,"**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**","DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.","",ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.267238441822604,0.267238441822604
510,astar,"**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**","ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.287442674390538,0.287442674390538
511,lbm,"**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**","ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.407374411374339,0.407374411374339
512,mcf,"**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**","ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.16052391105696,0.16052391105696
513,milc,"**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**","ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.27958368976333,0.27958368976333
514,omnetpp,"**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**","ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.00548769693751106,0.00548769693751106
515,all,"**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**","ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.","",ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.228082476704536,0.228082476704536
516,astar,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.0163528843832971,0.0163528843832971
517,lbm,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.0434173924110471,0.0434173924110471
518,mcf,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.0201435623933196,0.0201435623933196
519,milc,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.00709396834450307,0.00709396834450307
520,omnetpp,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.000295037469758659,0.000295037469758659
521,all,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.0174605690003851,0.0174605690003851
522,astar,"Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF)","HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.290550325850833,0.290550325850833
523,lbm,"Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF)","HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.439737459318921,0.439737459318921
524,mcf,"Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF)","HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.290716921273147,0.290716921273147
525,milc,"Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF)","HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.304256381006702,0.304256381006702
526,omnetpp,"Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF)","HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.00486811825101788,0.00486811825101788
527,all,"Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF)","HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.266025841140124,0.266025841140124
528,astar,"**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**","DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.","",ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.290520154477432,0.290520154477432
529,lbm,"**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**","DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.","",ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.439737459318921,0.439737459318921
530,mcf,"**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**","DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.","",ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.294868184352244,0.294868184352244
531,milc,"**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**","DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.","",ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.304256381006702,0.304256381006702
532,omnetpp,"**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**","DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.","",ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.0053696819496076,0.0053696819496076
533,all,"**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**","DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.","",ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.266950372220981,0.266950372220981
534,astar,"Adaptive Multi-Signal Replacement (AMSR)","AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.","",ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.290550325850833,0.290550325850833
535,lbm,"Adaptive Multi-Signal Replacement (AMSR)","AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.","",ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.439737459318921,0.439737459318921
536,mcf,"Adaptive Multi-Signal Replacement (AMSR)","AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.","",ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.290716921273147,0.290716921273147
537,milc,"Adaptive Multi-Signal Replacement (AMSR)","AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.","",ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.304256381006702,0.304256381006702
538,omnetpp,"Adaptive Multi-Signal Replacement (AMSR)","AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.","",ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.00486811825101788,0.00486811825101788
539,all,"Adaptive Multi-Signal Replacement (AMSR)","AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.","",ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.266025841140124,0.266025841140124
540,astar,"Dynamic Reuse-Pattern Replacement (DRPR)","DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.","",ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.290550325850833,0.290550325850833
541,lbm,"Dynamic Reuse-Pattern Replacement (DRPR)","DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.","",ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.439737459318921,0.439737459318921
542,mcf,"Dynamic Reuse-Pattern Replacement (DRPR)","DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.","",ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.293475637090934,0.293475637090934
543,milc,"Dynamic Reuse-Pattern Replacement (DRPR)","DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.","",ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.304256381006702,0.304256381006702
544,omnetpp,"Dynamic Reuse-Pattern Replacement (DRPR)","DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.","",ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.00486811825101788,0.00486811825101788
545,all,"Dynamic Reuse-Pattern Replacement (DRPR)","DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.","",ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.266577584303682,0.266577584303682
546,astar,"**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**","HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.","",ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.290520154477432,0.290520154477432
547,lbm,"**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**","HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.","",ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.425392265595171,0.425392265595171
548,mcf,"**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**","HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.","",ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.29651597181512,0.29651597181512
549,milc,"**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**","HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.","",ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.304256381006702,0.304256381006702
550,omnetpp,"**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**","HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.","",ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.0053696819496076,0.0053696819496076
551,all,"**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**","HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.","",ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.264410890968806,0.264410890968806
552,astar,"Dynamic Hawkeye-LRU Hybrid Replacement (DHLR)","DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.","",ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.290550325850833,0.290550325850833
553,lbm,"Dynamic Hawkeye-LRU Hybrid Replacement (DHLR)","DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.","",ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.439737459318921,0.439737459318921
554,mcf,"Dynamic Hawkeye-LRU Hybrid Replacement (DHLR)","DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.","",ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.290716921273147,0.290716921273147
555,milc,"Dynamic Hawkeye-LRU Hybrid Replacement (DHLR)","DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.","",ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.304256381006702,0.304256381006702
556,omnetpp,"Dynamic Hawkeye-LRU Hybrid Replacement (DHLR)","DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.","",ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.00486811825101788,0.00486811825101788
557,all,"Dynamic Hawkeye-LRU Hybrid Replacement (DHLR)","DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.","",ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.266025841140124,0.266025841140124
558,astar,"Spatial-Temporal Reuse Adaptive Replacement (STRAR)","STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.241491672700941,0.241491672700941
559,lbm,"Spatial-Temporal Reuse Adaptive Replacement (STRAR)","STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.18557844402829,0.18557844402829
560,mcf,"Spatial-Temporal Reuse Adaptive Replacement (STRAR)","STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.257513146929509,0.257513146929509
561,milc,"Spatial-Temporal Reuse Adaptive Replacement (STRAR)","STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.211214886639099,0.211214886639099
562,omnetpp,"Spatial-Temporal Reuse Adaptive Replacement (STRAR)","STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.00156369858972089,0.00156369858972089
563,all,"Spatial-Temporal Reuse Adaptive Replacement (STRAR)","STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.","",ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.179472369777512,0.179472369777512
564,astar,"Dynamic Multi-Signal Reuse Predictor (DMRP)","DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.290489983104031,0.290489983104031
565,lbm,"Dynamic Multi-Signal Reuse Predictor (DMRP)","DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.423374120470537,0.423374120470537
566,mcf,"Dynamic Multi-Signal Reuse Predictor (DMRP)","DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.207604641405985,0.207604641405985
567,milc,"Dynamic Multi-Signal Reuse Predictor (DMRP)","DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.304185084842436,0.304185084842436
568,omnetpp,"Dynamic Multi-Signal Reuse Predictor (DMRP)","DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.0053696819496076,0.0053696819496076
569,all,"Dynamic Multi-Signal Reuse Predictor (DMRP)","DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.246204702354519,0.246204702354519
570,astar,"Adaptive Reuse Interval Predictor (ARIP)","ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.","",ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.290550325850833,0.290550325850833
571,lbm,"Adaptive Reuse Interval Predictor (ARIP)","ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.","",ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.439737459318921,0.439737459318921
572,mcf,"Adaptive Reuse Interval Predictor (ARIP)","ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.","",ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.290716921273147,0.290716921273147
573,milc,"Adaptive Reuse Interval Predictor (ARIP)","ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.","",ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.304256381006702,0.304256381006702
574,omnetpp,"Adaptive Reuse Interval Predictor (ARIP)","ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.","",ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.00486811825101788,0.00486811825101788
575,all,"Adaptive Reuse Interval Predictor (ARIP)","ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.","",ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.266025841140124,0.266025841140124
576,astar,"Dynamic Signature-based Reuse Predictor (DSRP)","DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.","",ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.289252956794593,0.289252956794593
577,lbm,"Dynamic Signature-based Reuse Predictor (DSRP)","DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.","",ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.403410847075508,0.403410847075508
578,mcf,"Dynamic Signature-based Reuse Predictor (DSRP)","DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.","",ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.200808059909079,0.200808059909079
579,milc,"Dynamic Signature-based Reuse Predictor (DSRP)","DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.","",ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.302759161557108,0.302759161557108
580,omnetpp,"Dynamic Signature-based Reuse Predictor (DSRP)","DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.","",ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.00858559036997699,0.00858559036997699
581,all,"Dynamic Signature-based Reuse Predictor (DSRP)","DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.","",ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.240963323141253,0.240963323141253
582,astar,"Adaptive Multi-Feature Replacement (AMFR)","AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.","",ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.290550325850833,0.290550325850833
583,lbm,"Adaptive Multi-Feature Replacement (AMFR)","AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.","",ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.425028635842985,0.425028635842985
584,mcf,"Adaptive Multi-Feature Replacement (AMFR)","AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.","",ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.254018793643495,0.254018793643495
585,milc,"Adaptive Multi-Feature Replacement (AMFR)","AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.","",ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.304256381006702,0.304256381006702
586,omnetpp,"Adaptive Multi-Feature Replacement (AMFR)","AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.","",ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.00486811825101788,0.00486811825101788
587,all,"Adaptive Multi-Feature Replacement (AMFR)","AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.","",ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.255744450919007,0.255744450919007
588,astar,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.","",ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.290550325850833,0.290550325850833
589,lbm,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.","",ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.425028635842985,0.425028635842985
590,mcf,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.","",ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.254018793643495,0.254018793643495
591,milc,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.","",ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.304256381006702,0.304256381006702
592,omnetpp,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.","",ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.00486811825101788,0.00486811825101788
593,all,"**Phase-Aware Dynamic Reuse (PADR)**","PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.","",ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.255744450919007,0.255744450919007
594,astar,"**Hybrid Locality Predictor Replacement (HLPR)**","HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.","",ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.290520154477432,0.290520154477432
595,lbm,"**Hybrid Locality Predictor Replacement (HLPR)**","HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.","",ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.4174469555099,0.4174469555099
596,mcf,"**Hybrid Locality Predictor Replacement (HLPR)**","HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.","",ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.238209363541272,0.238209363541272
597,milc,"**Hybrid Locality Predictor Replacement (HLPR)**","HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.","",ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.304256381006702,0.304256381006702
598,omnetpp,"**Hybrid Locality Predictor Replacement (HLPR)**","HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.","",ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.0053696819496076,0.0053696819496076
599,all,"**Hybrid Locality Predictor Replacement (HLPR)**","HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.","",ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.251160507296983,0.251160507296983
600,astar,"**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**","ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.288287472845764,0.288287472845764
601,lbm,"**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**","ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.398065489718369,0.398065489718369
602,mcf,"**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**","ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.177642657226108,0.177642657226108
603,milc,"**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**","ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.278696706117211,0.278696706117211
604,omnetpp,"**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**","ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.00840856788812179,0.00840856788812179
605,all,"**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**","ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.230220178759115,0.230220178759115
606,astar,"**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**","HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.","",ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.290580497224234,0.290580497224234
607,lbm,"**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**","HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.","",ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.439737459318921,0.439737459318921
608,mcf,"**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**","HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.","",ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.29017500502888,0.29017500502888
609,milc,"**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**","HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.","",ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.289925851989163,0.289925851989163
610,omnetpp,"**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**","HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.","",ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.00472059951613855,0.00472059951613855
611,all,"**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**","HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.","",ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.263027882615467,0.263027882615467
612,astar,"**Adaptive Recency and Pointer-Aware Replacement (ARP)**","ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.290550325850833,0.290550325850833
613,lbm,"**Adaptive Recency and Pointer-Aware Replacement (ARP)**","ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.438428392211051,0.438428392211051
614,mcf,"**Adaptive Recency and Pointer-Aware Replacement (ARP)**","ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.284669099686773,0.284669099686773
615,milc,"**Adaptive Recency and Pointer-Aware Replacement (ARP)**","ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.304256381006702,0.304256381006702
616,omnetpp,"**Adaptive Recency and Pointer-Aware Replacement (ARP)**","ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.00486811825101788,0.00486811825101788
617,all,"**Adaptive Recency and Pointer-Aware Replacement (ARP)**","ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.264554463401275,0.264554463401275
618,astar,"**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**","DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.290520154477432,0.290520154477432
619,lbm,"**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**","DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.416737877493137,0.416737877493137
620,mcf,"**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**","DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.237688006115048,0.237688006115048
621,milc,"**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**","DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.304256381006702,0.304256381006702
622,omnetpp,"**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**","DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.0053696819496076,0.0053696819496076
623,all,"**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**","DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.","",ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.250914420208385,0.250914420208385
624,astar,"**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**","SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.","",ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.290550325850833,0.290550325850833
625,lbm,"**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**","SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.","",ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.439737459318921,0.439737459318921
626,mcf,"**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**","SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.","",ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.297501091979126,0.297501091979126
627,milc,"**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**","SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.","",ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.304256381006702,0.304256381006702
628,omnetpp,"**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**","SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.","",ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.00486811825101788,0.00486811825101788
629,all,"**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**","SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.","",ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.26738267528132,0.26738267528132
630,astar,"**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**","HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.","",ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.290399468983828,0.290399468983828
631,lbm,"**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**","HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.","",ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.417865129724914,0.417865129724914
632,mcf,"**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**","HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.","",ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.202655172413793,0.202655172413793
633,milc,"**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**","HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.","",ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.304256381006702,0.304256381006702
634,omnetpp,"**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**","HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.","",ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.0053696819496076,0.0053696819496076
635,all,"**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**","HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.","",ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.244109166815769,0.244109166815769
636,astar,"**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**","DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.","",ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.287442674390538,0.287442674390538
637,lbm,"**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**","DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.","",ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.407374411374339,0.407374411374339
638,mcf,"**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**","DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.","",ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.159000913798355,0.159000913798355
639,milc,"**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**","DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.","",ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.279552260088407,0.279552260088407
640,omnetpp,"**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**","DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.","",ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.00548769693751106,0.00548769693751106
641,all,"**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**","DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.","",ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.22777159131783,0.22777159131783
642,astar,"**Phase-Adaptive Segmented Frequency and Recency (PASFR)**","PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.28554187786628,0.28554187786628
643,lbm,"**Phase-Adaptive Segmented Frequency and Recency (PASFR)**","PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.394701914510645,0.394701914510645
644,mcf,"**Phase-Adaptive Segmented Frequency and Recency (PASFR)**","PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.165166666666667,0.165166666666667
645,milc,"**Phase-Adaptive Segmented Frequency and Recency (PASFR)**","PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.27891059461001,0.27891059461001
646,omnetpp,"**Phase-Adaptive Segmented Frequency and Recency (PASFR)**","PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.00858559036997699,0.00858559036997699
647,all,"**Phase-Adaptive Segmented Frequency and Recency (PASFR)**","PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.","",ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.226581328804716,0.226581328804716
648,astar,"**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**","DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.","",ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.288408158339368,0.288408158339368
649,lbm,"**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**","DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.","",ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.439737459318921,0.439737459318921
650,mcf,"**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**","DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.","",ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.204533437550289,0.204533437550289
651,milc,"**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**","DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.","",ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.279552260088407,0.279552260088407
652,omnetpp,"**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**","DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.","",ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.00475010326311442,0.00475010326311442
653,all,"**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**","DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.","",ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.24339628371202,0.24339628371202
654,astar,"Adaptive Frequency-Spatial Hybrid Replacement (AFSHR)","AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.","",ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.287955587738354,0.287955587738354
655,lbm,"Adaptive Frequency-Spatial Hybrid Replacement (AFSHR)","AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.","",ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.419137833857566,0.419137833857566
656,mcf,"Adaptive Frequency-Spatial Hybrid Replacement (AFSHR)","AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.","",ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.160863917976069,0.160863917976069
657,milc,"Adaptive Frequency-Spatial Hybrid Replacement (AFSHR)","AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.","",ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.27958368976333,0.27958368976333
658,omnetpp,"Adaptive Frequency-Spatial Hybrid Replacement (AFSHR)","AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.","",ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.00548769693751106,0.00548769693751106
659,all,"Adaptive Frequency-Spatial Hybrid Replacement (AFSHR)","AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.","",ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.230605745254566,0.230605745254566
660,astar,"Dynamic Multi-Signal Replacement (DMSR)","DMSR leverages a combination of recency (LRU), frequency (LFU), and reuse distance prediction to adaptively select the most suitable eviction candidate for each workload phase. Each cache line tracks its last access time, access frequency, and a lightweight reuse distance estimate using a saturating counter. The policy dynamically weights these signals based on observed set-level hit/miss trends and stride regularity: for workloads with regular spatial access (LBM, MILC), DMSR emphasizes reuse distance and recency to retain blocks likely to be reused soon; for pointer-heavy, irregular workloads (MCF, OMNETPP, ASTAR), it prioritizes frequency and recency to avoid retaining dead blocks. Phase changes are detected via a moving hit/miss window, triggering adaptive weighting of signals. This multi-signal, phase-aware approach improves overall hit rates by tailoring eviction logic to workload characteristics, outperforming single-signal and static hybrid policies.","",ChampSim_CRC2/new_policies/025_dynamic_multi_signal_replacement__dmsr.cc,0.290520154477432,0.290520154477432
661,lbm,"Dynamic Multi-Signal Replacement (DMSR)","DMSR leverages a combination of recency (LRU), frequency (LFU), and reuse distance prediction to adaptively select the most suitable eviction candidate for each workload phase. Each cache line tracks its last access time, access frequency, and a lightweight reuse distance estimate using a saturating counter. The policy dynamically weights these signals based on observed set-level hit/miss trends and stride regularity: for workloads with regular spatial access (LBM, MILC), DMSR emphasizes reuse distance and recency to retain blocks likely to be reused soon; for pointer-heavy, irregular workloads (MCF, OMNETPP, ASTAR), it prioritizes frequency and recency to avoid retaining dead blocks. Phase changes are detected via a moving hit/miss window, triggering adaptive weighting of signals. This multi-signal, phase-aware approach improves overall hit rates by tailoring eviction logic to workload characteristics, outperforming single-signal and static hybrid policies.","",ChampSim_CRC2/new_policies/025_dynamic_multi_signal_replacement__dmsr.cc,0.418628752204505,0.418628752204505
662,astar,"Adaptive SRRIP-Bimodal Replacement (ASBR)","ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.","",ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.256456673907796,0.256456673907796
663,lbm,"Adaptive SRRIP-Bimodal Replacement (ASBR)","ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.","",ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.0435992072871402,0.0435992072871402
664,mcf,"Adaptive SRRIP-Bimodal Replacement (ASBR)","ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.","",ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.260303338563309,0.260303338563309
665,milc,"Adaptive SRRIP-Bimodal Replacement (ASBR)","ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.","",ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.00712961642663625,0.00712961642663625
666,omnetpp,"Adaptive SRRIP-Bimodal Replacement (ASBR)","ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.","",ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.00362896087803151,0.00362896087803151
667,all,"Adaptive SRRIP-Bimodal Replacement (ASBR)","ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.","",ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.114223559412583,0.114223559412583
668,astar,"Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA)","DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.","",ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.258206613565049,0.258206613565049
669,lbm,"Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA)","DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.","",ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.274322285049363,0.274322285049363
670,mcf,"Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA)","DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.","",ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.159571716753737,0.159571716753737
671,milc,"Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA)","DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.","",ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.281548552687865,0.281548552687865
672,omnetpp,"Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA)","DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.","",ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.00392399834779017,0.00392399834779017
673,all,"Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA)","DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.","",ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.195514633280761,0.195514633280761
674,astar,"Adaptive RRIP with Dynamic Bypass (ARRIP-DB)","ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.","",ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.0163528843832971,0.0163528843832971
675,lbm,"Adaptive RRIP with Dynamic Bypass (ARRIP-DB)","ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.","",ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.0435810257995309,0.0435810257995309
676,mcf,"Adaptive RRIP with Dynamic Bypass (ARRIP-DB)","ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.","",ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.0190626706129134,0.0190626706129134
677,milc,"Adaptive RRIP with Dynamic Bypass (ARRIP-DB)","ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.","",ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.00709396834450307,0.00709396834450307
678,omnetpp,"Adaptive RRIP with Dynamic Bypass (ARRIP-DB)","ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.","",ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.000295037469758659,0.000295037469758659
679,all,"Adaptive RRIP with Dynamic Bypass (ARRIP-DB)","ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.","",ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.0172771173220006,0.0172771173220006
680,astar,"Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F)","HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.287442674390538,0.287442674390538
681,lbm,"Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F)","HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.407374411374339,0.407374411374339
682,mcf,"Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F)","HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.16052391105696,0.16052391105696
683,milc,"Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F)","HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.27958368976333,0.27958368976333
684,omnetpp,"Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F)","HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.00548769693751106,0.00548769693751106
685,all,"Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F)","HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.","",ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.228082476704536,0.228082476704536
686,astar,"**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**","DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.290520154477432,0.290520154477432
687,lbm,"**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**","DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.437555680805804,0.437555680805804
688,mcf,"**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**","DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.291983723763765,0.291983723763765
689,milc,"**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**","DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.304256381006702,0.304256381006702
690,omnetpp,"**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**","DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.00460258452823509,0.00460258452823509
691,all,"**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**","DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.265783704916387,0.265783704916387
692,astar,"Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP)","AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.","",ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.290520154477432,0.290520154477432
693,lbm,"Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP)","AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.","",ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.437555680805804,0.437555680805804
694,mcf,"Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP)","AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.","",ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.291983723763765,0.291983723763765
695,milc,"Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP)","AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.","",ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.304256381006702,0.304256381006702
696,omnetpp,"Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP)","AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.","",ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.00460258452823509,0.00460258452823509
697,all,"Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP)","AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.","",ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.265783704916387,0.265783704916387
698,astar,"Dynamic Segmented Frequency and Recency Replacement (DSFRR)","DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.","",ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.289554670528602,0.289554670528602
699,lbm,"Dynamic Segmented Frequency and Recency Replacement (DSFRR)","DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.","",ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.430337630224905,0.430337630224905
700,mcf,"Dynamic Segmented Frequency and Recency Replacement (DSFRR)","DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.","",ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.262652444280969,0.262652444280969
701,milc,"Dynamic Segmented Frequency and Recency Replacement (DSFRR)","DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.","",ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.304256381006702,0.304256381006702
702,omnetpp,"Dynamic Segmented Frequency and Recency Replacement (DSFRR)","DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.","",ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.00244881099899687,0.00244881099899687
703,all,"Dynamic Segmented Frequency and Recency Replacement (DSFRR)","DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.","",ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.257849987408035,0.257849987408035
704,astar,"Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion","AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.0163528843832971,0.0163528843832971
705,lbm,"Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion","AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.0435810257995309,0.0435810257995309
706,mcf,"Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion","AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.0190626706129134,0.0190626706129134
707,milc,"Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion","AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.00709396834450307,0.00709396834450307
708,omnetpp,"Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion","AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.000295037469758659,0.000295037469758659
709,all,"Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion","AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.","",ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.0172771173220006,0.0172771173220006
710,astar,"Multi-Feature Signature-Based Dynamic Replacement (MF-SDR)","MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.","",ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.0170769973449191,0.0170769973449191
711,lbm,"Multi-Feature Signature-Based Dynamic Replacement (MF-SDR)","MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.","",ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.0501809058017127,0.0501809058017127
712,mcf,"Multi-Feature Signature-Based Dynamic Replacement (MF-SDR)","MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.","",ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.024016689271511,0.024016689271511
713,milc,"Multi-Feature Signature-Based Dynamic Replacement (MF-SDR)","MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.","",ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.00830600313703123,0.00830600313703123
714,omnetpp,"Multi-Feature Signature-Based Dynamic Replacement (MF-SDR)","MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.","",ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.00477960701009028,0.00477960701009028
715,all,"Multi-Feature Signature-Based Dynamic Replacement (MF-SDR)","MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.","",ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.0208720405130529,0.0208720405130529
716,astar,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.0158701424088825,0.0158701424088825
717,lbm,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.0300903619934183,0.0300903619934183
718,mcf,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.0138849776725421,0.0138849776725421
719,milc,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.00709396834450307,0.00709396834450307
720,omnetpp,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.00014751873487933,0.00014751873487933
721,all,"Adaptive Phase-Aware Reuse Predictor (APARP)","APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.0134173938308451,0.0134173938308451
722,astar,"**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**","MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.","",ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.170287231474777,0.170287231474777
723,lbm,"**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**","MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.","",ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.264340648351848,0.264340648351848
724,mcf,"**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**","MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.","",ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.209001201156328,0.209001201156328
725,milc,"**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**","MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.","",ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.190681591330386,0.190681591330386
726,omnetpp,"**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**","MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.","",ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.0025963297338762,0.0025963297338762
727,all,"**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**","MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.","",ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.167381400409443,0.167381400409443
728,astar,"Adaptive Segmented Reuse and Frequency (ASRF)","ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.","",ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.0190381366159788,0.0190381366159788
729,lbm,"Adaptive Segmented Reuse and Frequency (ASRF)","ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.","",ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.0346357338957474,0.0346357338957474
730,mcf,"Adaptive Segmented Reuse and Frequency (ASRF)","ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.","",ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.0169768163584327,0.0169768163584327
731,milc,"Adaptive Segmented Reuse and Frequency (ASRF)","ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.","",ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.00983887066875802,0.00983887066875802
732,omnetpp,"Adaptive Segmented Reuse and Frequency (ASRF)","ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.","",ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.00318640467339352,0.00318640467339352
733,all,"Adaptive Segmented Reuse and Frequency (ASRF)","ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.","",ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.0167351924424621,0.0167351924424621
734,astar,"**Phase-Adaptive Multi-Locality Replacement (PAMLR)**","PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.","",ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.0158701424088825,0.0158701424088825
735,lbm,"**Phase-Adaptive Multi-Locality Replacement (PAMLR)**","PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.","",ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.0300903619934183,0.0300903619934183
736,mcf,"**Phase-Adaptive Multi-Locality Replacement (PAMLR)**","PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.","",ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.0138849776725421,0.0138849776725421
737,milc,"**Phase-Adaptive Multi-Locality Replacement (PAMLR)**","PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.","",ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.00709396834450307,0.00709396834450307
738,omnetpp,"**Phase-Adaptive Multi-Locality Replacement (PAMLR)**","PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.","",ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.00014751873487933,0.00014751873487933
739,all,"**Phase-Adaptive Multi-Locality Replacement (PAMLR)**","PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.","",ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.0134173938308451,0.0134173938308451
740,astar,"**Hybrid RRIP-Bloom Replacement (HRBR)**","HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.","",ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.290520154477432,0.290520154477432
741,lbm,"**Hybrid RRIP-Bloom Replacement (HRBR)**","HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.","",ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.425392265595171,0.425392265595171
742,mcf,"**Hybrid RRIP-Bloom Replacement (HRBR)**","HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.","",ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.296513632810704,0.296513632810704
743,milc,"**Hybrid RRIP-Bloom Replacement (HRBR)**","HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.","",ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.304256381006702,0.304256381006702
744,omnetpp,"**Hybrid RRIP-Bloom Replacement (HRBR)**","HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.","",ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.0053696819496076,0.0053696819496076
745,all,"**Hybrid RRIP-Bloom Replacement (HRBR)**","HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.","",ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.264410423167923,0.264410423167923
746,astar,"**Adaptive Segmented Locality Replacement (ASLR)**","ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.","",ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.200699975862901,0.200699975862901
747,lbm,"**Adaptive Segmented Locality Replacement (ASLR)**","ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.","",ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.361666151524518,0.361666151524518
748,mcf,"**Adaptive Segmented Locality Replacement (ASLR)**","ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.","",ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.231154739189407,0.231154739189407
749,milc,"**Adaptive Segmented Locality Replacement (ASLR)**","ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.","",ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.159204334806787,0.159204334806787
750,omnetpp,"**Adaptive Segmented Locality Replacement (ASLR)**","ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.","",ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.00380598335988671,0.00380598335988671
751,all,"**Adaptive Segmented Locality Replacement (ASLR)**","ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.","",ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.1913062369487,0.1913062369487
752,astar,"Adaptive Phase-aware Spatial-Temporal Predictor (APSTP)","APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.290550325850833,0.290550325850833
753,lbm,"Adaptive Phase-aware Spatial-Temporal Predictor (APSTP)","APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.439737459318921,0.439737459318921
754,mcf,"Adaptive Phase-aware Spatial-Temporal Predictor (APSTP)","APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.290807207103652,0.290807207103652
755,milc,"Adaptive Phase-aware Spatial-Temporal Predictor (APSTP)","APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.304256381006702,0.304256381006702
756,omnetpp,"Adaptive Phase-aware Spatial-Temporal Predictor (APSTP)","APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.00486811825101788,0.00486811825101788
757,all,"Adaptive Phase-aware Spatial-Temporal Predictor (APSTP)","APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.266043898306225,0.266043898306225
758,astar,"**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**","MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.","",ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.0158701424088825,0.0158701424088825
759,lbm,"**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**","MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.","",ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.0300903619934183,0.0300903619934183
760,mcf,"**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**","MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.","",ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.0138849776725421,0.0138849776725421
761,milc,"**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**","MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.","",ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.00709396834450307,0.00709396834450307
762,omnetpp,"**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**","MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.","",ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.00014751873487933,0.00014751873487933
763,all,"**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**","MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.","",ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.0134173938308451,0.0134173938308451
764,astar,"**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**","ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.","",ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.0158701424088825,0.0158701424088825
765,lbm,"**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**","ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.","",ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.0300903619934183,0.0300903619934183
766,mcf,"**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**","ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.","",ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.0138849776725421,0.0138849776725421
767,milc,"**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**","ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.","",ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.00709396834450307,0.00709396834450307
768,omnetpp,"**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**","ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.","",ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.00014751873487933,0.00014751873487933
769,all,"**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**","ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.","",ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.0134173938308451,0.0134173938308451
770,astar,"Phase-Aware Dynamic Segmented LRU (PA-DSLRU)","PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.290550325850833,0.290550325850833
771,lbm,"Phase-Aware Dynamic Segmented LRU (PA-DSLRU)","PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.439737459318921,0.439737459318921
772,mcf,"Phase-Aware Dynamic Segmented LRU (PA-DSLRU)","PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.290716921273147,0.290716921273147
773,milc,"Phase-Aware Dynamic Segmented LRU (PA-DSLRU)","PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.304256381006702,0.304256381006702
774,omnetpp,"Phase-Aware Dynamic Segmented LRU (PA-DSLRU)","PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.00486811825101788,0.00486811825101788
775,all,"Phase-Aware Dynamic Segmented LRU (PA-DSLRU)","PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.266025841140124,0.266025841140124
776,astar,"Adaptive RRIP with Dynamic Bypass (A-RRIP-DB)","A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.","",ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.290520154477432,0.290520154477432
777,lbm,"Adaptive RRIP with Dynamic Bypass (A-RRIP-DB)","A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.","",ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.425392265595171,0.425392265595171
778,mcf,"Adaptive RRIP with Dynamic Bypass (A-RRIP-DB)","A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.","",ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.29651597181512,0.29651597181512
779,milc,"Adaptive RRIP with Dynamic Bypass (A-RRIP-DB)","A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.","",ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.304256381006702,0.304256381006702
780,omnetpp,"Adaptive RRIP with Dynamic Bypass (A-RRIP-DB)","A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.","",ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.0053696819496076,0.0053696819496076
781,all,"Adaptive RRIP with Dynamic Bypass (A-RRIP-DB)","A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.","",ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.264410890968806,0.264410890968806
782,astar,"SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD)","SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.","",ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.29045981173063,0.29045981173063
783,lbm,"SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD)","SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.","",ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.42542862857039,0.42542862857039
784,mcf,"SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD)","SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.","",ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.296347596195293,0.296347596195293
785,milc,"SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD)","SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.","",ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.304256381006702,0.304256381006702
786,omnetpp,"SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD)","SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.","",ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.00534017820263173,0.00534017820263173
787,all,"SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD)","SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.","",ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.264366519141129,0.264366519141129
788,astar,"**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**","This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.","",ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.290520154477432,0.290520154477432
789,lbm,"**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**","This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.","",ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.425392265595171,0.425392265595171
790,mcf,"**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**","This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.","",ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.29651597181512,0.29651597181512
791,milc,"**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**","This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.","",ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.304256381006702,0.304256381006702
792,omnetpp,"**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**","This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.","",ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.0053696819496076,0.0053696819496076
793,all,"**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**","This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.","",ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.264410890968806,0.264410890968806
794,astar,"**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**","DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.","",ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.290520154477432,0.290520154477432
795,lbm,"**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**","DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.","",ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.425392265595171,0.425392265595171
796,mcf,"**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**","DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.","",ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.29651597181512,0.29651597181512
797,milc,"**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**","DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.","",ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.304256381006702,0.304256381006702
798,omnetpp,"**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**","DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.","",ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.0053696819496076,0.0053696819496076
799,all,"**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**","DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.","",ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.264410890968806,0.264410890968806
800,astar,"Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF)","AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.","",ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.287442674390538,0.287442674390538
801,lbm,"Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF)","AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.","",ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.407374411374339,0.407374411374339
802,mcf,"Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF)","AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.","",ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.16052391105696,0.16052391105696
803,milc,"Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF)","AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.","",ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.27958368976333,0.27958368976333
804,omnetpp,"Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF)","AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.","",ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.00548769693751106,0.00548769693751106
805,all,"Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF)","AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.","",ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.228082476704536,0.228082476704536
806,astar,"**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**","DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.","",ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.237629736905624,0.237629736905624
807,lbm,"**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**","DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.","",ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.268849657278959,0.268849657278959
808,mcf,"**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**","DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.","",ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.15411008109242,0.15411008109242
809,milc,"**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**","DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.","",ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.258840724369029,0.258840724369029
810,omnetpp,"**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**","DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.","",ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.00578273440726972,0.00578273440726972
811,all,"**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**","DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.","",ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.18504258681066,0.18504258681066
812,astar,"Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB)","AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.","",ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.287382331643736,0.287382331643736
813,lbm,"Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB)","AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.","",ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.406428974018654,0.406428974018654
814,mcf,"Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB)","AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.","",ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.157873563218391,0.157873563218391
815,milc,"Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB)","AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.","",ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.279552260088407,0.279552260088407
816,omnetpp,"Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB)","AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.","",ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.00475010326311442,0.00475010326311442
817,all,"Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB)","AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.","",ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.227197446446461,0.227197446446461
818,astar,"Adaptive SRRIP-LRU Hybrid","This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.","",ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.290550325850833,0.290550325850833
819,lbm,"Adaptive SRRIP-LRU Hybrid","This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.","",ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.439737459318921,0.439737459318921
820,mcf,"Adaptive SRRIP-LRU Hybrid","This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.","",ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.29072099772982,0.29072099772982
821,milc,"Adaptive SRRIP-LRU Hybrid","This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.","",ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.304256381006702,0.304256381006702
822,omnetpp,"Adaptive SRRIP-LRU Hybrid","This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.","",ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.00486811825101788,0.00486811825101788
823,all,"Adaptive SRRIP-LRU Hybrid","This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.","",ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.266026656431459,0.266026656431459
824,astar,"Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH)","This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.","",ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.0250724112961622,0.0250724112961622
825,lbm,"Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH)","This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.","",ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.0573625934073926,0.0573625934073926
826,mcf,"Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH)","This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.","",ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.0341773752327533,0.0341773752327533
827,milc,"Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH)","This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.","",ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.0173962640809924,0.0173962640809924
828,omnetpp,"Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH)","This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.","",ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.000590074939517319,0.000590074939517319
829,all,"Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH)","This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.","",ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.0269197437913636,0.0269197437913636
830,astar,"Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH)","This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.0250724112961622,0.0250724112961622
831,lbm,"Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH)","This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.0573625934073926,0.0573625934073926
832,mcf,"Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH)","This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.034159937932818,0.034159937932818
833,milc,"Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH)","This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.0173962640809924,0.0173962640809924
834,omnetpp,"Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH)","This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.000590074939517319,0.000590074939517319
835,all,"Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH)","This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.0269162563313765,0.0269162563313765
836,astar,"Signature-Based Adaptive RRIP-LRU (SARRL)","SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.","",ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.0163528843832971,0.0163528843832971
837,lbm,"Signature-Based Adaptive RRIP-LRU (SARRL)","SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.","",ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.0435810257995309,0.0435810257995309
838,mcf,"Signature-Based Adaptive RRIP-LRU (SARRL)","SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.","",ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.0192124228457144,0.0192124228457144
839,milc,"Signature-Based Adaptive RRIP-LRU (SARRL)","SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.","",ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.00709396834450307,0.00709396834450307
840,omnetpp,"Signature-Based Adaptive RRIP-LRU (SARRL)","SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.","",ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.000295037469758659,0.000295037469758659
841,all,"Signature-Based Adaptive RRIP-LRU (SARRL)","SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.","",ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.0173070677685608,0.0173070677685608
842,astar,"**Dynamic Reuse and Stream Detector (DRSD)**","DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.0165037412503017,0.0165037412503017
843,lbm,"**Dynamic Reuse and Stream Detector (DRSD)**","DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.0442719223286849,0.0442719223286849
844,mcf,"**Dynamic Reuse and Stream Detector (DRSD)**","DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.0184823337394543,0.0184823337394543
845,milc,"**Dynamic Reuse and Stream Detector (DRSD)**","DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.00709396834450307,0.00709396834450307
846,omnetpp,"**Dynamic Reuse and Stream Detector (DRSD)**","DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.000295037469758659,0.000295037469758659
847,all,"**Dynamic Reuse and Stream Detector (DRSD)**","DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.0173294006265405,0.0173294006265405
848,astar,"**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**","ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.","",ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.237116823557808,0.237116823557808
849,lbm,"**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**","ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.","",ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.437555680805804,0.437555680805804
850,mcf,"**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**","ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.","",ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.256918222727978,0.256918222727978
851,milc,"**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**","ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.","",ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.24618565521175,0.24618565521175
852,omnetpp,"**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**","ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.","",ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.00858559036997699,0.00858559036997699
853,all,"**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**","ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.","",ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.237272394534663,0.237272394534663
854,astar,"Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR)","DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.","",ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.290520154477432,0.290520154477432
855,lbm,"Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR)","DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.","",ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.437555680805804,0.437555680805804
856,mcf,"Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR)","DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.","",ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.28953130837093,0.28953130837093
857,milc,"Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR)","DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.","",ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.304256381006702,0.304256381006702
858,omnetpp,"Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR)","DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.","",ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.00460258452823509,0.00460258452823509
859,all,"Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR)","DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.","",ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.26529322183782,0.26529322183782
860,astar,"Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA)","SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.","",ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.290520154477432,0.290520154477432
861,lbm,"Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA)","SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.","",ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.437555680805804,0.437555680805804
862,mcf,"Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA)","SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.","",ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.277712321760071,0.277712321760071
863,milc,"Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA)","SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.","",ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.304256381006702,0.304256381006702
864,omnetpp,"Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA)","SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.","",ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.00460258452823509,0.00460258452823509
865,all,"Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA)","SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.","",ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.262929424515649,0.262929424515649
866,astar,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.","",ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.290520154477432,0.290520154477432
867,lbm,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.","",ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.437555680805804,0.437555680805804
868,mcf,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.","",ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.290966458999057,0.290966458999057
869,milc,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.","",ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.304256381006702,0.304256381006702
870,omnetpp,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.","",ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.00460258452823509,0.00460258452823509
871,all,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.","",ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.265580251963446,0.265580251963446
872,astar,"**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**","SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.","",ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.289252956794593,0.289252956794593
873,lbm,"**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**","SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.","",ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.426410428901293,0.426410428901293
874,mcf,"**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**","SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.","",ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.209084325716125,0.209084325716125
875,milc,"**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**","SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.","",ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.289711963496364,0.289711963496364
876,omnetpp,"**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**","SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.","",ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.00829055290021833,0.00829055290021833
877,all,"**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**","SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.","",ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.244550045561719,0.244550045561719
878,astar,"**Adaptive Multi-Signal Locality Replacement (AMSLR)**","AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.","",ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.290520154477432,0.290520154477432
879,lbm,"**Adaptive Multi-Signal Locality Replacement (AMSLR)**","AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.","",ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.4174469555099,0.4174469555099
880,mcf,"**Adaptive Multi-Signal Locality Replacement (AMSLR)**","AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.","",ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.237838800891975,0.237838800891975
881,milc,"**Adaptive Multi-Signal Locality Replacement (AMSLR)**","AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.","",ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.304256381006702,0.304256381006702
882,omnetpp,"**Adaptive Multi-Signal Locality Replacement (AMSLR)**","AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.","",ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.0053696819496076,0.0053696819496076
883,all,"**Adaptive Multi-Signal Locality Replacement (AMSLR)**","AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.","",ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.251086394767123,0.251086394767123
884,astar,"**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**","PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.","",ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.290339126237026,0.290339126237026
885,lbm,"**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**","PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.","",ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.417283322121416,0.417283322121416
886,mcf,"**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**","PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.","",ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.238337442599585,0.238337442599585
887,milc,"**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**","PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.","",ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.304256381006702,0.304256381006702
888,omnetpp,"**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**","PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.","",ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.00834956039417006,0.00834956039417006
889,all,"**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**","PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.","",ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.25171316647178,0.25171316647178
890,astar,"Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR)","HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.","",ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.290097755249819,0.290097755249819
891,lbm,"Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR)","HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.","",ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.434898816342115,0.434898816342115
892,mcf,"Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR)","HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.","",ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.136462122910165,0.136462122910165
893,milc,"Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR)","HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.","",ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.279873092827606,0.279873092827606
894,omnetpp,"Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR)","HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.","",ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.00516315572077654,0.00516315572077654
895,all,"Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR)","HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.","",ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.229298988610096,0.229298988610096
896,astar,"Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR)","ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.28554187786628,0.28554187786628
897,lbm,"Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR)","ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.394701914510645,0.394701914510645
898,mcf,"Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR)","ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.165166666666667,0.165166666666667
899,milc,"Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR)","ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.27891059461001,0.27891059461001
900,omnetpp,"Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR)","ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.00858559036997699,0.00858559036997699
901,all,"Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR)","ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.","",ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.226581328804716,0.226581328804716
902,astar,"**Multi-Feature Phase-Adaptive Replacement (MPAR)**","MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.0733164373642288,0.0733164373642288
903,lbm,"**Multi-Feature Phase-Adaptive Replacement (MPAR)**","MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.123288667478773,0.123288667478773
904,mcf,"**Multi-Feature Phase-Adaptive Replacement (MPAR)**","MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.0890261774086952,0.0890261774086952
905,milc,"**Multi-Feature Phase-Adaptive Replacement (MPAR)**","MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.0779623556252674,0.0779623556252674
906,omnetpp,"**Multi-Feature Phase-Adaptive Replacement (MPAR)**","MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.00241930725202101,0.00241930725202101
907,all,"**Multi-Feature Phase-Adaptive Replacement (MPAR)**","MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.","",ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.0732025890257971,0.0732025890257971
908,astar,"**Dynamic Reuse-Aware Replacement (DRAR)**","DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.","",ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.0762128892107169,0.0762128892107169
909,lbm,"**Dynamic Reuse-Aware Replacement (DRAR)**","DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.","",ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.125997709132561,0.125997709132561
910,mcf,"**Dynamic Reuse-Aware Replacement (DRAR)**","DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.","",ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.0894294925949553,0.0894294925949553
911,milc,"**Dynamic Reuse-Aware Replacement (DRAR)**","DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.","",ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.0821688293169827,0.0821688293169827
912,omnetpp,"**Dynamic Reuse-Aware Replacement (DRAR)**","DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.","",ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.00241930725202101,0.00241930725202101
913,all,"**Dynamic Reuse-Aware Replacement (DRAR)**","DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.","",ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.0752456455014474,0.0752456455014474
914,astar,"Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR)","HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.","",ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.0762128892107169,0.0762128892107169
915,lbm,"Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR)","HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.","",ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.125997709132561,0.125997709132561
916,mcf,"Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR)","HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.","",ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.0894352396223054,0.0894352396223054
917,milc,"Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR)","HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.","",ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.0821688293169827,0.0821688293169827
918,omnetpp,"Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR)","HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.","",ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.00241930725202101,0.00241930725202101
919,all,"Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR)","HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.","",ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.0752467949069174,0.0752467949069174
920,astar,"Phase-Adaptive Multi-Signature Replacement (PAMSR)","PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.","",ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.0728638667632151,0.0728638667632151
921,lbm,"Phase-Adaptive Multi-Signature Replacement (PAMSR)","PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.","",ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.125361357066235,0.125361357066235
922,mcf,"Phase-Adaptive Multi-Signature Replacement (PAMSR)","PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.","",ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.0884227464728025,0.0884227464728025
923,milc,"Phase-Adaptive Multi-Signature Replacement (PAMSR)","PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.","",ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.0771424497362042,0.0771424497362042
924,omnetpp,"Phase-Adaptive Multi-Signature Replacement (PAMSR)","PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.","",ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.00215377352923821,0.00215377352923821
925,all,"Phase-Adaptive Multi-Signature Replacement (PAMSR)","PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.","",ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.073188838713539,0.073188838713539
926,astar,"**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**","DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.287442674390538,0.287442674390538
927,lbm,"**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**","DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.407374411374339,0.407374411374339
928,mcf,"**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**","DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.16052391105696,0.16052391105696
929,milc,"**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**","DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.27958368976333,0.27958368976333
930,omnetpp,"**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**","DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.00548769693751106,0.00548769693751106
931,all,"**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**","DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.","",ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.228082476704536,0.228082476704536
932,astar,"Adaptive Hawkeye-Like Predictor Replacement (AHLPR)","AHLPR leverages a lightweight per-set predictor, inspired by Hawkeye, to estimate whether incoming accesses are cache-friendly (likely to be reused soon) or cache-averse (unlikely to be reused). The policy tracks recent PC and region signatures to dynamically classify accesses, maintaining a history of past evictions and hits per set. Each block is tagged with a ""cache-friendliness"" score, updated on hits and evictions. On replacement, blocks with the lowest score (least likely to be reused) are preferentially evicted, but the policy also considers spatial locality by boosting scores for blocks in the same region as the current access. This approach adapts to both temporal and spatial locality, as well as irregular behaviors found in pointer-chasing and phase-changing workloads. By combining predictor-driven retention with region-aware scoring, AHLPR improves hit rates over recency, frequency, or static spatial policies, especially for workloads with mixed or rapidly changing access patterns.","",ChampSim_CRC2/new_policies/021_adaptive_hawkeye_like_predictor_replacement__ahlpr.cc,0.288649529326575,0.288649529326575
933,lbm,"Adaptive Hawkeye-Like Predictor Replacement (AHLPR)","AHLPR leverages a lightweight per-set predictor, inspired by Hawkeye, to estimate whether incoming accesses are cache-friendly (likely to be reused soon) or cache-averse (unlikely to be reused). The policy tracks recent PC and region signatures to dynamically classify accesses, maintaining a history of past evictions and hits per set. Each block is tagged with a ""cache-friendliness"" score, updated on hits and evictions. On replacement, blocks with the lowest score (least likely to be reused) are preferentially evicted, but the policy also considers spatial locality by boosting scores for blocks in the same region as the current access. This approach adapts to both temporal and spatial locality, as well as irregular behaviors found in pointer-chasing and phase-changing workloads. By combining predictor-driven retention with region-aware scoring, AHLPR improves hit rates over recency, frequency, or static spatial policies, especially for workloads with mixed or rapidly changing access patterns.","",ChampSim_CRC2/new_policies/021_adaptive_hawkeye_like_predictor_replacement__ahlpr.cc,0.41504699914547,0.41504699914547
934,astar,"Adaptive Phase-aware Reuse and Locality Predictor (APRLP)","APRLP combines phase detection, spatial-temporal locality tracking, and program-context-aware reuse prediction to dynamically adjust cache replacement decisions. It maintains lightweight phase signatures per set, tracks recent access patterns (stride, reuse distance, PC clustering), and adaptively learns which lines are likely to be reused based on both current phase and historical access telemetry. By blending per-set phase awareness with PC-based reuse predictors and spatial locality hints, APRLP can respond to abrupt changes (e.g., MILC phase shifts), exploit regularity (LBM), and avoid pollution in pointer-heavy workloads (MCF, omnetpp). This hybrid approach leverages the strengths of LIME, Hawkeye, and SHiP++ while introducing explicit phase adaptation and spatial pattern learning, aiming to outperform all previous policies.","",ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_and_locality_predictor__aprlp.cc,0.016383055756698,0.016383055756698
