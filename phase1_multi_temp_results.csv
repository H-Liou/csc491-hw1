id,workload,policy,policy_description,workload_description,cpp_file_path,cache_hit_rate,score,
127,astar,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,"The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.454542233,0.416873389,
128,astar,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.357354779,0.37579228,
129,astar,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.389017739,0.43328269,
130,astar,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.037095671,0.114532568,
131,astar,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/red.cc,0.411020177,0.346602607,
132,astar,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","The A* workload models a pathfinding algorithm commonly used in game AI and robotics. It is characterized by deeply nested control-flow, frequent branching, and high rates of speculative execution due to unpredictable decisions in the search space. Memory access patterns are moderately sparse with irregular access strides and limited reuse, making it a stress test for branch predictors and instruction-level parallelism. Cache-wise, it has a moderate trace size and shows limited temporal locality, challenging replacement policies to avoid pollution from control-dominated paths.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.338211739,0.375597938,
133,lbm,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,"LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.439857834,0.416873389,
134,lbm,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.272899835,0.37579228,
135,lbm,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.329722405,0.43328269,
136,lbm,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.011593643,0.114532568,
137,lbm,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/red.cc,0.193584772,0.346602607,
138,lbm,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","LBM (Lattice-Boltzmann Method) simulates fluid dynamics by performing stencil-based updates across 3D grids. It exhibits dense, regular memory access patterns with high spatial locality but limited temporal reuse. Cache pressure is significant due to large working sets and repetitive accesses across neighboring cells, making it ideal for evaluating how well a policy handles spatial locality and prefetching alignment. LBM's deterministic access stride also exposes weaknesses in replacement strategies that fail to retain blocks until their reuse window arrives.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.26158461,0.375597938,
139,mcf,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,"The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.407402089,0.416873389,
140,mcf,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.508772569,0.37579228,
141,mcf,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.523017541,0.43328269,
142,mcf,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.515161598,0.114532568,
143,mcf,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/red.cc,0.520031271,0.346602607,
144,mcf,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","The MCF workload solves the Minimum Cost Flow problem using network simplex algorithms. It is known for pointer-chasing behavior, deep data dependencies, and highly irregular, sparse memory accesses. This leads to poor cache locality and low IPC due to frequent pipeline stalls from memory latency. MCF is a classical example of memory-bound workloads and is particularly harsh on cache replacement policies that rely on recency or frequency heuristics. Its access patterns are difficult to predict, making it valuable for testing adaptive and learned policies.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.52474375,0.375597938,
145,milc,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,"MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.32191141,0.416873389,
146,milc,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.064566935,0.37579228,
147,milc,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.234603214,0.43328269,
148,milc,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.000264307,0.114532568,
149,milc,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/red.cc,0.146273996,0.346602607,
150,milc,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","MILC simulates Quantum Chromodynamics (QCD) calculations on 4D space-time lattices, often used in particle physics research. The workload includes extensive use of floating-point arithmetic within nested loops, coupled with both regular and irregular memory accesses. MILC combines phases of high spatial reuse with intermittent pointer dereferencing and indirect indexing, leading to inconsistent locality characteristics. This makes it a strong candidate for evaluating how well a replacement policy can respond to phase changes in workload behavior.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.054986712,0.375597938,
151,omnetpp,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,"Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/lru.cc,0.460653381,0.416873389,
152,omnetpp,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.675367281,0.37579228,
153,omnetpp,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.69005255,0.43328269,
154,omnetpp,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.00854762,0.114532568,
155,omnetpp,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/red.cc,0.462102821,0.346602607,
156,omnetpp,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.","Omnet++ models a discrete-event network simulator, simulating communication protocols with complex object-oriented structures. It features heavy dynamic memory allocation, small object usage, and highly unpredictable control flow. Its access pattern is dominated by pointer dereferencing and virtual function calls, resulting in low spatial and temporal locality. Frequent branching and irregular memory usage make it a demanding workload for branch predictors and cache systems, especially those relying on stable reuse signals.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.698462878,0.375597938,
157,all,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,,ChampSim_CRC2/champ_repl_pol/lru.cc,0.416873389,0.416873389,
158,all,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.",,ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.37579228,0.37579228,
159,all,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.",,ChampSim_CRC2/champ_repl_pol/lime.cc,0.43328269,0.43328269,
160,all,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.",,ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.114532568,0.114532568,
161,all,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.",,ChampSim_CRC2/champ_repl_pol/red.cc,0.346602607,0.346602607,
162,all,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.",,ChampSim_CRC2/champ_repl_pol/ship++.cc,0.375597938,0.375597938,
163,astar,Adaptive Phase-Aware Replacement (APAR),"The Adaptive Phase-Aware Replacement (APAR) policy dynamically adjusts its cache management strategy based on workload phase behavior, leveraging both temporal and spatial locality signals. It uses a lightweight phase detector to classify workload behavior into distinct phases (e.g., compute-intensive, memory-bound, or mixed). For each phase, APAR applies a tailored replacement strategy: temporal locality optimization for compute-intensive phases, spatial locality optimization for memory-bound phases, and hybrid strategies for mixed phases. By adapting to workload characteristics in real-time, APAR minimizes cache pollution, reduces thrashing, and improves hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_replacement__apar.cc,0.290550326,0.290550326,0%
164,lbm,Adaptive Phase-Aware Replacement (APAR),"The Adaptive Phase-Aware Replacement (APAR) policy dynamically adjusts its cache management strategy based on workload phase behavior, leveraging both temporal and spatial locality signals. It uses a lightweight phase detector to classify workload behavior into distinct phases (e.g., compute-intensive, memory-bound, or mixed). For each phase, APAR applies a tailored replacement strategy: temporal locality optimization for compute-intensive phases, spatial locality optimization for memory-bound phases, and hybrid strategies for mixed phases. By adapting to workload characteristics in real-time, APAR minimizes cache pollution, reduces thrashing, and improves hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_replacement__apar.cc,0.439737459,0.439737459,0%
165,mcf,Adaptive Phase-Aware Replacement (APAR),"The Adaptive Phase-Aware Replacement (APAR) policy dynamically adjusts its cache management strategy based on workload phase behavior, leveraging both temporal and spatial locality signals. It uses a lightweight phase detector to classify workload behavior into distinct phases (e.g., compute-intensive, memory-bound, or mixed). For each phase, APAR applies a tailored replacement strategy: temporal locality optimization for compute-intensive phases, spatial locality optimization for memory-bound phases, and hybrid strategies for mixed phases. By adapting to workload characteristics in real-time, APAR minimizes cache pollution, reduces thrashing, and improves hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_replacement__apar.cc,0.290716921,0.290716921,0%
166,milc,Adaptive Phase-Aware Replacement (APAR),"The Adaptive Phase-Aware Replacement (APAR) policy dynamically adjusts its cache management strategy based on workload phase behavior, leveraging both temporal and spatial locality signals. It uses a lightweight phase detector to classify workload behavior into distinct phases (e.g., compute-intensive, memory-bound, or mixed). For each phase, APAR applies a tailored replacement strategy: temporal locality optimization for compute-intensive phases, spatial locality optimization for memory-bound phases, and hybrid strategies for mixed phases. By adapting to workload characteristics in real-time, APAR minimizes cache pollution, reduces thrashing, and improves hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_replacement__apar.cc,0.304256381,0.304256381,0%
167,astar,Adaptive Phase-Aware Reuse Predictor (APARP),"The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.287261646,0.287261646,0%
168,lbm,Adaptive Phase-Aware Reuse Predictor (APARP),"The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.407338048,0.407338048,0%
169,mcf,Adaptive Phase-Aware Reuse Predictor (APARP),"The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.161530592,0.161530592,0%
170,milc,Adaptive Phase-Aware Reuse Predictor (APARP),"The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.279837445,0.279837445,0%
171,omnetpp,Adaptive Phase-Aware Reuse Predictor (APARP),"The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.003038886,0.003038886,0%
172,all,Adaptive Phase-Aware Reuse Predictor (APARP),"The Adaptive Phase-Aware Reuse Predictor (APARP) is a hybrid cache replacement policy that dynamically adapts to workload phase behavior by combining phase detection with fine-grained reuse prediction. APARP tracks phase changes in workload behavior (e.g., transitions between high spatial locality, irregular access patterns, or pointer-chasing) using a lightweight phase detector based on memory access entropy. For each phase, it employs a tailored reuse predictor: a confidence-based filter for sparse reuse phases, a temporal locality tracker for dense reuse phases, and a bypass mechanism for streaming phases. By dynamically switching strategies based on phase characteristics, APARP minimizes cache pollution, improves reuse, and handles diverse workloads effectively.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.227801324,0.227801324,23%
173,astar,Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO),"The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.015870142,0.015870142,0%
174,lbm,Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO),"The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.030563081,0.030563081,0%
175,mcf,Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO),"The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.014264286,0.014264286,0%
176,milc,Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO),"The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.007093968,0.007093968,0%
177,omnetpp,Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO),"The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.000147519,0.000147519,0%
178,all,Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO),"The Phase-Aware Dynamic Reuse and Bypass Optimization (PADRBO) policy builds upon the idea of phase detection but introduces a more granular approach to handling workload diversity. It combines dynamic reuse prediction with a dual-mode bypass mechanism. PADRBO uses a lightweight phase detector based on access entropy and hit/miss ratios to classify workload behavior into three categories: high-reuse, low-reuse, and streaming phases. For high-reuse phases, it prioritizes blocks with high temporal locality using a reuse counter. For low-reuse phases, it aggressively bypasses incoming blocks to reduce cache pollution. For streaming phases, it uses a FIFO-based eviction strategy to quickly cycle through blocks. By dynamically adapting to workload phases and leveraging both reuse prediction and bypassing, PADRBO achieves better cache utilization and minimizes pollution, leading to improved performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_phase_aware_dynamic_reuse_and_bypass_optimization__padrbo.cc,0.013587799,0.013587799,1%
179,astar,Adaptive Phase-Aware Replacement Policy (APARP),"The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.015870142,0.015870142,0%
180,lbm,Adaptive Phase-Aware Replacement Policy (APARP),"The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.030090362,0.030090362,0%
181,mcf,Adaptive Phase-Aware Replacement Policy (APARP),"The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.013884978,0.013884978,0%
182,milc,Adaptive Phase-Aware Replacement Policy (APARP),"The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.007093968,0.007093968,0%
183,omnetpp,Adaptive Phase-Aware Replacement Policy (APARP),"The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.000147519,0.000147519,0%
184,all,Adaptive Phase-Aware Replacement Policy (APARP),"The Adaptive Phase-Aware Replacement Policy (APARP) dynamically adjusts its replacement strategy based on the observed workload characteristics. It combines recency-based tracking for workloads with high temporal locality (e.g., LBM, MILC) and frequency-based tracking for workloads with sparse and irregular access patterns (e.g., MCF, omnetpp). Additionally, it incorporates a phase-detection mechanism to identify and adapt to workload behavior changes, such as transitioning between compute-intensive and memory-intensive phases. By leveraging both recency and frequency heuristics and adapting to phase changes, APARP aims to improve hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/002_adaptive_phase_aware_replacement_policy__aparp.cc,0.013417394,0.013417394,1%
185,astar,Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA),"The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.",,ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.015870142,0.015870142,0%
186,lbm,Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA),"The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.",,ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.030090362,0.030090362,0%
187,mcf,Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA),"The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.",,ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.013884978,0.013884978,0%
188,milc,Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA),"The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.",,ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.007093968,0.007093968,0%
189,omnetpp,Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA),"The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.",,ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.000147519,0.000147519,0%
190,all,Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA),"The Hybrid Adaptive Replacement Policy with Spatial and Temporal Awareness (HARP-STA) is designed to address the diverse characteristics of workloads by combining spatial locality tracking, temporal locality tracking, and phase-aware adaptation. HARP-STA introduces a dual-score mechanism: one score prioritizes blocks with high spatial reuse (e.g., LBM), while the other prioritizes blocks with high temporal reuse (e.g., MILC). For irregular workloads (e.g., MCF, omnetpp), the policy uses a dynamic penalty for blocks with poor reuse signals. Additionally, HARP-STA incorporates a lightweight phase-detection mechanism to adjust the weighting of spatial and temporal scores dynamically, ensuring responsiveness to workload phase changes. This hybrid approach balances recency, frequency, and spatial locality, improving hit rates across a wide range of workloads.",,ChampSim_CRC2/new_policies/003_hybrid_adaptive_replacement_policy_with_spatial_and_temporal_awareness__harp_sta.cc,0.013417394,0.013417394,1%
191,astar,**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**,"PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.290520154,0.290520154,0%
192,lbm,**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**,"PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.417446956,0.417446956,0%
193,mcf,**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**,"PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.240067129,0.240067129,0%
194,milc,**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**,"PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.304256381,0.304256381,0%
195,omnetpp,**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**,"PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.005369682,0.005369682,0%
196,all,**Phase-Adaptive Spatial-Temporal Predictor (PAST-P)**,"PAST-P combines phase detection, spatial-temporal reuse prediction, and adaptive filtering to dynamically tailor cache replacement to workload behavior. It tracks recent access patterns to identify phase changes (e.g., switching from regular to irregular access), then adapts its eviction strategy: in regular phases (like LBM/MILC), it prioritizes spatial locality and retains blocks with nearby addresses; in irregular phases (like MCF/omnetpp/astar), it filters for blocks with demonstrated temporal reuse, using PC-based and address-based reuse counters. PAST-P also incorporates a lightweight history of miss/hit rates to tune aggressiveness, and uses a hybrid scoring system for victim selection. This approach aims to outperform existing policies by responding to workload phase shifts and balancing spatial/temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/000_phase_adaptive_spatial_temporal_predictor__past_p.cc,0.25153206,0.25153206,25%
197,astar,**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**,"HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.030050688,0.030050688,0%
198,lbm,**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**,"HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.030092551,0.030092551,0%
199,mcf,**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**,"HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.070229481,0.070229481,0%
200,milc,**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**,"HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.016861543,0.016861543,0%
201,omnetpp,**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**,"HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.000295037,0.000295037,0%
202,all,**Hybrid Reuse-Pattern Adaptive Replacement (HyRPAR)**,"HyRPAR combines lightweight reuse distance tracking, program counter (PC)-based access pattern recognition, and spatial locality hints to adaptively select cache victims. Each block maintains a small reuse distance counter and a PC signature. The policy uses a set-level history table to classify the dominant access pattern: spatial (stride/stencil), temporal (pointer-chasing/loop reuse), or random (branch-heavy, unpredictable). Victim selection prioritizes blocks with high reuse distance (i.e., not reused recently), low PC reuse (i.e., PCs not seen recently), and weak spatial proximity to current accesses. For workloads with regular patterns (LBM, MILC), HyRPAR retains blocks with spatial proximity and short reuse distance; for irregular workloads (MCF, omnetpp, astar), it favors blocks with repeated PC signatures and short reuse distance. This hybrid approach improves hit rate by dynamically responding to both spatial and temporal locality, while avoiding cache pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/001_hybrid_reuse_pattern_adaptive_replacement__hyrpar.cc,0.02950586,0.02950586,3%
203,astar,**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**,"PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.",,ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.030141202,0.030141202,0%
204,lbm,**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**,"PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.",,ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.030092551,0.030092551,0%
205,mcf,**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**,"PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.",,ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.070878903,0.070878903,0%
206,milc,**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**,"PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.",,ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.016861543,0.016861543,0%
207,omnetpp,**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**,"PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.",,ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.000295037,0.000295037,0%
208,all,**Phase-Aware Dynamic Reuse and Frequency Replacement (PADRFR)**,"PADRFR is a phase-aware hybrid policy that dynamically adapts to workload characteristics by tracking both block reuse distance and access frequency, while also detecting phase changes in memory access patterns. Each set maintains a lightweight phase detector that monitors the ratio of spatially local accesses, temporally repeated accesses (by PC), and random accesses. Based on the current phase (spatial, temporal, or random), PADRFR adjusts its victim selection strategy: in spatial phases (e.g., LBM, MILC), it prioritizes retaining blocks with high spatial proximity and frequent accesses; in temporal phases (e.g., MCF, omnetpp, astar), it favors blocks with recent reuse and high access frequency by PC; in random phases, it falls back to evicting blocks with the lowest frequency and oldest age. This approach ensures that the policy responds quickly to phase changes, minimizes cache pollution, and improves hit rates by leveraging both reuse and frequency signals tailored to the workload's current behavior.",,ChampSim_CRC2/new_policies/002_phase_aware_dynamic_reuse_and_frequency_replacement__padrfr.cc,0.029653847,0.029653847,3%
209,astar,**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**,"MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.",,ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.290188269,0.290188269,0%
210,lbm,**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**,"MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.",,ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.43937383,0.43937383,0%
211,mcf,**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**,"MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.",,ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.290623294,0.290623294,0%
212,milc,**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**,"MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.",,ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.3038999,0.3038999,0%
213,omnetpp,**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**,"MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.",,ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.004514073,0.004514073,0%
214,all,**Multi-Signal Adaptive Replacement with PC and Spatial Correlation (MSAR-PSC)**,"MSAR-PSC is a hybrid cache replacement policy that combines recency (LRU), program counter (PC) correlation, and spatial locality signals to adaptively select victims based on workload behavior. Each cache block tracks its last access timestamp, last access PC, and a spatial locality score based on recent accesses in the set. The policy maintains a small per-set history of recent PCs and addresses to detect both temporal and spatial reuse patterns. Victim selection prioritizes blocks with low recency, low PC correlation (i.e., not recently accessed by the same PC), and low spatial proximity to current accesses. This approach improves performance by retaining blocks likely to be reused (either by the same PC or in spatially adjacent regions), while evicting blocks that are both old and weakly correlated with current access patterns. MSAR-PSC is robust across diverse workloads: it handles pointer-chasing and irregular accesses (mcf, omnetpp, astar) by leveraging PC correlation, and exploits spatial locality in regular workloads (lbm, milc) via spatial scoring, adapting dynamically without explicit phase detection.",,ChampSim_CRC2/new_policies/003_multi_signal_adaptive_replacement_with_pc_and_spatial_correlation__msar_psc.cc,0.265719873,0.265719873,27%
215,astar,Phase-Aware Multi-Signal Replacement (PAMSR),"PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.290278783,0.290278783,0%
216,lbm,Phase-Aware Multi-Signal Replacement (PAMSR),"PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.439519281,0.439519281,0%
217,mcf,Phase-Aware Multi-Signal Replacement (PAMSR),"PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.290647953,0.290647953,0%
218,milc,Phase-Aware Multi-Signal Replacement (PAMSR),"PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.303971196,0.303971196,0%
219,omnetpp,Phase-Aware Multi-Signal Replacement (PAMSR),"PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.004543577,0.004543577,0%
220,all,Phase-Aware Multi-Signal Replacement (PAMSR),"PAMSR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both temporal and spatial locality, as well as pointer-chasing and control-flow signals. It maintains per-set phase detection using lightweight counters that monitor the ratio of hits from spatially adjacent blocks versus hits from the same program counter (PC). When spatial locality dominates (as in lbm, milc), PAMSR prioritizes retaining blocks with high spatial reuse; when pointer-chasing or irregular control flow is detected (as in mcf, omnetpp, astar), it shifts to favor blocks with recent PC correlation. The policy uses per-block recency, PC, and spatial scores, but weights them according to the detected phase, allowing rapid adaptation to phase changes and mixed access patterns. This approach improves performance by avoiding cache pollution during irregular phases and maximizing reuse during regular phases, outperforming static or single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_multi_signal_replacement__pamsr.cc,0.265792158,0.265792158,27%
221,astar,Dual-Partition Adaptive Replacement (DPAR),"DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.",,ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.285391021,0.285391021,0%
222,lbm,Dual-Partition Adaptive Replacement (DPAR),"DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.",,ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.423701387,0.423701387,0%
223,mcf,Dual-Partition Adaptive Replacement (DPAR),"DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.",,ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.290147013,0.290147013,0%
224,milc,Dual-Partition Adaptive Replacement (DPAR),"DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.",,ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.304256381,0.304256381,0%
225,omnetpp,Dual-Partition Adaptive Replacement (DPAR),"DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.",,ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.005369682,0.005369682,0%
226,all,Dual-Partition Adaptive Replacement (DPAR),"DPAR divides the cache into two dynamic partitions—a temporal region for blocks with high reuse confidence and a spatial region for blocks exhibiting streaming behavior. Each incoming block is classified via lightweight on-line PC‐based reuse counters and stride counters to decide whether it is likely to be reused (temporal) or part of a stream (spatial). A hardware‐friendly epoch engine monitors hits in each region and adjusts the partition boundary to favor whichever region delivers higher hit rates. Within each region, simple per‐set LRU is used to select victims. This hybrid approach adapts on the fly to phase changes (e.g., regular stencils vs. pointer chasing) while filtering out low‐value blocks and preserving high‐value ones.",,ChampSim_CRC2/new_policies/000_dual_partition_adaptive_replacement__dpar.cc,0.261773097,0.261773097,26%
227,astar,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.",,ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.016594255,0.016594255,0%
228,lbm,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.",,ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.043908293,0.043908293,0%
229,mcf,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.",,ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.01982127,0.01982127,0%
230,milc,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.",,ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.007093968,0.007093968,0%
231,omnetpp,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.",,ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.000295037,0.000295037,0%
232,all,PC-SRRIP-BP,"We use a small PC‐indexed signature table to predict whether an incoming block will be reused (temporal) or is part of a one‐pass stream.  On misses, blocks with high reuse confidence are inserted with a near‐MRU Re‐Reference Prediction Value (RRPV), while predicted streams receive the maximum RRPV (quick eviction), effectively bypassing them.  Hits reset RRPV to zero and increment the PC counter; misses decrement the counter.  Victims are selected via standard SRRIP (search for RRPV==MAX, aging otherwise).  This lightweight SHiP‐inspired design unifies temporal capture and streaming bypass with minimal hardware and adapts dynamically across regular stencils, pointer chasing, and mixed‐phase codes.",,ChampSim_CRC2/new_policies/001_pc_srrip_bp.cc,0.017542565,0.017542565,2%
233,astar,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.",,ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.152818006,0.152818006,0%
234,lbm,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.",,ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.235450265,0.235450265,0%
235,mcf,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.",,ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.159067789,0.159067789,0%
236,milc,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.",,ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.15556823,0.15556823,0%
237,omnetpp,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.",,ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.005222163,0.005222163,0%
238,all,DRRIP_SHiP,"DRRIP_SHiP dynamically duels two insertion strategies—standard SRRIP (Static Re‐Reference Interval Prediction) and a PC‐indexed SHiP (Signature‐based Hit Predictor) variant—on a small set of sampling sets, tracks their comparative hit rates, and then applies the better policy to the rest of the cache.  SRRIP handles streaming and low‐reuse workloads (e.g., lbm, mcf) via recency‐biased insertion, while SHiP captures temporal and phase‐changing patterns (e.g., astar, milc, omnetpp) by predicting which PCs are likely to generate re‐references.  A lightweight dueling infrastructure periodically updates the global policy mode, enabling rapid adaptation across all five workloads.",,ChampSim_CRC2/new_policies/002_drrip_ship.cc,0.141625291,0.141625291,14%
239,astar,PC-BRRIP (PC-based Bypass and Reuse-biased RRIP),"PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).",,ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.016956312,0.016956312,0%
240,lbm,PC-BRRIP (PC-based Bypass and Reuse-biased RRIP),"PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).",,ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.046890057,0.046890057,0%
241,mcf,PC-BRRIP (PC-based Bypass and Reuse-biased RRIP),"PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).",,ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.022545588,0.022545588,0%
242,milc,PC-BRRIP (PC-based Bypass and Reuse-biased RRIP),"PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).",,ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.007664338,0.007664338,0%
243,omnetpp,PC-BRRIP (PC-based Bypass and Reuse-biased RRIP),"PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).",,ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.006608839,0.006608839,0%
244,all,PC-BRRIP (PC-based Bypass and Reuse-biased RRIP),"PC-BRRIP uses a small PC‐indexed predictor to classify incoming blocks into low‐, medium‐, or high‐reuse candidates and assigns them different insertion priorities in the RRIP framework. Blocks from PCs with historically low reuse are effectively “bypassed” (inserted with the highest RRPV), medium‐reuse blocks get a near‐MRU insertion, and high‐confidence blocks are placed at MRU to maximize retention. On hits, the predictor is strengthened, and on misses it is weakened. This approach avoids polluting the cache with streaming or pointer‐chasing data (e.g., mcf, omnetpp), while giving strong retention to frequently reused data (e.g., astar, milc) and still accommodating regular but limited‐reuse patterns (e.g., lbm).",,ChampSim_CRC2/new_policies/003_pc_brrip__pc_based_bypass_and_reuse_biased_rrip.cc,0.020133027,0.020133027,2%
245,astar,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.",,ChampSim_CRC2/new_policies/004_drrip.cc,0.286326334,0.286326334,0%
246,lbm,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.",,ChampSim_CRC2/new_policies/004_drrip.cc,0.417246959,0.417246959,0%
247,mcf,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.",,ChampSim_CRC2/new_policies/004_drrip.cc,0.292414063,0.292414063,0%
248,milc,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.",,ChampSim_CRC2/new_policies/004_drrip.cc,0.299657778,0.299657778,0%
249,omnetpp,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.",,ChampSim_CRC2/new_policies/004_drrip.cc,0.005281171,0.005281171,0%
250,all,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal Insertion Policy (BRRIP) based on observed reuse behavior. A small number of “sample sets” always use SRRIP or BRRIP, and a global policy-selection counter (PSEL) tracks which policy yields more hits in its sample sets. Follower sets then use the winning policy on every fill, dynamically coping with streaming/pointer-chasing workloads (favoring BRRIP to avoid cache pollution) and high-reuse or regular workloads (favoring SRRIP to retain useful data). Continuous sampling allows quick response to phase changes, making DRRIP broadly effective across all five workloads.",,ChampSim_CRC2/new_policies/004_drrip.cc,0.260185261,0.260185261,26%
251,astar,Reuse Distance Aware Replacement (ReDRe),"ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.",,ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.015870142,0.015870142,0%
252,lbm,Reuse Distance Aware Replacement (ReDRe),"ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.",,ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.048926383,0.048926383,0%
253,mcf,Reuse Distance Aware Replacement (ReDRe),"ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.",,ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.014356074,0.014356074,0%
254,milc,Reuse Distance Aware Replacement (ReDRe),"ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.",,ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.007093968,0.007093968,0%
255,omnetpp,Reuse Distance Aware Replacement (ReDRe),"ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.",,ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.000147519,0.000147519,0%
256,all,Reuse Distance Aware Replacement (ReDRe),"ReDRe builds a lightweight PC‐indexed reuse predictor that classifies each load/store instruction into low, medium, or high reuse based on a saturating counter (incremented on hits, decremented on misses).  On a miss, the new block is inserted with a priority corresponding to its PC’s reuse class.  When evicting, the policy always removes the block with the lowest priority, breaking ties by true LRU (using a per‐block timestamp).  This hybrid recency‐frequency scheme dynamically adapts to workloads with irregular branching (A*), dense stencils (LBM), pointer‐chasers (MCF), and phase shifts (MILC, omnetpp), aiming to outperform pure LRU, SHiP, Hawkeye, and LIME.",,ChampSim_CRC2/new_policies/000_reuse_distance_aware_replacement__redre.cc,0.017278817,0.017278817,2%
257,astar,DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling),"DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.",,ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.268645909,0.268645909,0%
258,lbm,DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling),"DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.",,ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.393992836,0.393992836,0%
259,mcf,DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling),"DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.",,ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.290427146,0.290427146,0%
260,milc,DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling),"DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.",,ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.299550834,0.299550834,0%
261,omnetpp,DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling),"DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.",,ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.005340178,0.005340178,0%
262,all,DRRIP (Dynamic Re-Reference Interval Prediction with Set Dueling),"DRRIP dynamically chooses between two re‐reference interval insertion policies—SRRIP (short re‐reference, favoring high reuse) and BRRIP (bimodal re‐reference, favoring streaming)—using lightweight set dueling. A small number of “leader” sets force SRRIP or BRRIP insertion and update a global PSEL counter based on misses; the remaining “follower” sets adaptively pick the policy indicated by PSEL. This approach balances retention of frequently reused lines (helpful for pointer‐chasing and phase‐locality workloads) against aggressive eviction of one‐time streams (helpful for stencil and streaming workloads), and rapidly adapts to phase changes and irregular patterns, yielding high hit rates across all examined kernels.",,ChampSim_CRC2/new_policies/001_drrip__dynamic_re_reference_interval_prediction_with_set_dueling.cc,0.251591381,0.251591381,25%
263,astar,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.",,ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.290369298,0.290369298,0%
264,lbm,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.",,ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.425428629,0.425428629,0%
265,mcf,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.",,ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.258038932,0.258038932,0%
266,milc,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.",,ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.290567517,0.290567517,0%
267,omnetpp,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.",,ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.005399186,0.005399186,0%
268,all,SHiP-RRIP,"This policy integrates a lightweight signature-based Hit Predictor (SHiP) with RRIP-style replacement to distinguish between streaming and re-referenced blocks. We maintain a Signature History Counter Table (SHCT) indexed by a hash of the access PC and block address. On each miss we consult the SHCT to decide whether to insert the new line with a short RRPV (SRRIP) for predicted-reuse or a long RRPV (BRRIP) for predicted-streaming, thereby preventing one‐time-use streams from polluting the cache. On hits we promote the block and increment its SHCT counter, and on evictions of never‐reused blocks we decrement the SHCT. This adaptive approach captures both regular and irregular access patterns, rapidly adapts to phase changes, and improves overall hit rates across pointer-chasing, stencil, mixed, and streaming workloads.",,ChampSim_CRC2/new_policies/002_ship_rrip.cc,0.253960712,0.253960712,25%
269,astar,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.",,ChampSim_CRC2/new_policies/003_ship_msp.cc,0.289886556,0.289886556,0%
270,lbm,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.",,ChampSim_CRC2/new_policies/003_ship_msp.cc,0.435410265,0.435410265,0%
271,mcf,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.",,ChampSim_CRC2/new_policies/003_ship_msp.cc,0.234640628,0.234640628,0%
272,milc,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.",,ChampSim_CRC2/new_policies/003_ship_msp.cc,0.292670754,0.292670754,0%
273,omnetpp,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.",,ChampSim_CRC2/new_policies/003_ship_msp.cc,0.005399186,0.005399186,0%
274,all,SHiP-MSP,"SHiP-MSP extends the original SHiP-RRIP by adding an adaptive Miss Counter Table (MCT) to dynamically bypass low‐reuse streams and a lightweight Set-based Promotion (SP) mechanism to capture spatial locality. On a miss, if a signature has incurred multiple consecutive misses (tracked in MCT), the block is bypassed entirely, preventing pollution from pointer‐chasing and strided streams. Otherwise we use the signature history (SHCT) to choose between SRRIP (for predicted reuse) and BRRIP (for predicted streaming). On a hit, we not only promote the hit block to RRPV=0 and update SHCT, but also decrement the RRPV of all other blocks in the same set, capturing spatial reuse in stencil and dense workloads. This hybrid approach adapts to phase changes, reduces pollution, and exploits spatial locality, yielding improved hit rates across irregular and streaming applications.",,ChampSim_CRC2/new_policies/003_ship_msp.cc,0.251601478,0.251601478,25%
275,astar,DIP-SHiP Hybrid,"This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.015870142,0.015870142,0%
276,lbm,DIP-SHiP Hybrid,"This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.030090362,0.030090362,0%
277,mcf,DIP-SHiP Hybrid,"This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.013884978,0.013884978,0%
278,milc,DIP-SHiP Hybrid,"This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.007093968,0.007093968,0%
279,omnetpp,DIP-SHiP Hybrid,"This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.000147519,0.000147519,0%
280,all,DIP-SHiP Hybrid,"This policy combines Dynamic Insertion Policy (DIP) sampling with SHiP’s signature‐based reuse prediction, streaming bypass detection, and set‐based spatial promotion. A global PSEL counter, trained by dedicated SRRIP and BRRIP sample sets, chooses whether to insert new lines with short RRPV (favoring reuse) or long RRPV (favoring streaming/bypass). Per‐PC signatures drive a Miss Counter Table (MCT) to dynamically bypass pointer‐chasing and purely streaming streams, while a Signature History Counter Table (SHCT) promotes lines with proven temporal reuse. On hits, set‐based promotions aggressively decrement RRPV of neighbors to capture spatial locality in stencil and dense grid codes. Epoch‐based PSEL updates and decaying SHCT/MCT counters ensure rapid adaptation to phase changes, yielding robust hit‐rate improvements across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/004_dip_ship_hybrid.cc,0.013417394,0.013417394,1%
281,astar,Adaptive Phase-Aware Hybrid (APAH) Replacement,"The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.290399469,0.290399469,0%
282,lbm,Adaptive Phase-Aware Hybrid (APAH) Replacement,"The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.436155706,0.436155706,0%
283,mcf,Adaptive Phase-Aware Hybrid (APAH) Replacement,"The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.249551714,0.249551714,0%
284,milc,Adaptive Phase-Aware Hybrid (APAH) Replacement,"The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.304256381,0.304256381,0%
285,omnetpp,Adaptive Phase-Aware Hybrid (APAH) Replacement,"The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.004868118,0.004868118,0%
286,all,Adaptive Phase-Aware Hybrid (APAH) Replacement,"The Adaptive Phase-Aware Hybrid (APAH) policy dynamically monitors access patterns at each cache set, using lightweight online classification to detect current workload phases (e.g., high spatial reuse, intensive pointer chasing, irregular control flow, etc.). For each set, it maintains short history windows of access distances, PC signatures, and stride patterns. Based on live statistics (reuse intervals, stride regularity, branch density), it adaptively switches between LRU, Belady-style predictors, spatial clustering, and pointer-focused bypass strategies on a per-set basis. This ensures high hit rates in both regular (LBM, milc) and irregular (astar, mcf, omnetpp) phases by fine-tuning cache allocation at runtime. Tunable knobs control history depths, phase switching sensitivity, and predictor weighting. Telemetry includes per-set phase transitions, hit/miss breakdowns by phase, and policy switch rates. APAH is robust to rapid phase changes and workload diversity, outperforming static and non-adaptive learned policies.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_hybrid__apah__replacement.cc,0.257046278,0.257046278,26%
287,astar,Dynamic Multi-Signal Reuse-based Replacement (DMRR),"DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.",,ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.015870142,0.015870142,0%
288,lbm,Dynamic Multi-Signal Reuse-based Replacement (DMRR),"DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.",,ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.030090362,0.030090362,0%
289,mcf,Dynamic Multi-Signal Reuse-based Replacement (DMRR),"DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.",,ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.013884978,0.013884978,0%
290,milc,Dynamic Multi-Signal Reuse-based Replacement (DMRR),"DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.",,ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.007093968,0.007093968,0%
291,omnetpp,Dynamic Multi-Signal Reuse-based Replacement (DMRR),"DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.",,ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.000147519,0.000147519,0%
292,all,Dynamic Multi-Signal Reuse-based Replacement (DMRR),"DMRR is a hybrid cache replacement policy that integrates three key signals: access recency, program counter correlation (PC-aware reuse), and spatial locality clustering, adapting the weight of each based on recent set-level statistics. Each cache set tracks recency (LRU stack position), short PC signatures, and local access strides. On each access, DMRR dynamically computes a ""reuse score"" per cache block by combining: (1) time since last access, (2) PC similarity to last access streams, and (3) how closely the block's address matches current stride/locality patterns. Blocks predicted as unlikely to be reused (low score) are replaced first. The policy also adapts: in highly irregular/branchy phases (astar, mcf, omnetpp), PC-awareness and recency dominate; in structured phases (lbm, milc), stride clustering and spatial scoring dominate. Lightweight adaptive boosting ensures sensitivity to phase changes, addressing past weaknesses in temporal tracking; this increases overall hit rates by retaining blocks more likely to be reused, regardless of the underlying workload's access regularity.",,ChampSim_CRC2/new_policies/002_dynamic_multi_signal_reuse_based_replacement__dmrr.cc,0.013417394,0.013417394,1%
293,astar,**Multi-Policy Adaptive Replacement (MPAR)**,"MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.",,ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.015870142,0.015870142,0%
294,lbm,**Multi-Policy Adaptive Replacement (MPAR)**,"MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.",,ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.030090362,0.030090362,0%
295,mcf,**Multi-Policy Adaptive Replacement (MPAR)**,"MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.",,ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.013884978,0.013884978,0%
296,milc,**Multi-Policy Adaptive Replacement (MPAR)**,"MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.",,ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.007093968,0.007093968,0%
297,omnetpp,**Multi-Policy Adaptive Replacement (MPAR)**,"MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.",,ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.000147519,0.000147519,0%
298,all,**Multi-Policy Adaptive Replacement (MPAR)**,"MPAR combines the strengths of Belady-inspired frequency tracking, a spatial recency window (SRW), and program counter correlation into an adaptive selection mechanism. Each cache set dynamically toggles between three simple, low-overhead policies—(1) LFU (frequency of reuse via last N hits per block), (2) SRW (spatial recency via last few block addresses), and (3) PC correlation (per-set PC histogram-based pinning)—based on short-term hit/miss statistics. LFU excels for MCF, Omnetpp’s unpredictable pointer-chasing, and astar’s branch-heavy irregularity; SRW benefits LBM and MILC’s regular, high-locality phases; and PC correlation provides fallback protection for phase change-sensitive codes and code-streamed structure accesses. With a phase control FSM per set, the policy boosts hit rate across both highly irregular and regular workloads, transitioning policy use in under 16 accesses. In addition, blocks that show local re-access or matching PC clusters get their victim priority dynamically lowered. MPAR thus integrates the best of classical and practical learned policies for varied workload traces with almost no cross-set global learning complexity.",,ChampSim_CRC2/new_policies/003_multi_policy_adaptive_replacement__mpar.cc,0.013417394,0.013417394,1%
299,astar,**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**,"DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.",,ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.28647719,0.28647719,0%
300,lbm,**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**,"DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.",,ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.433573935,0.433573935,0%
301,mcf,**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**,"DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.",,ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.286483597,0.286483597,0%
302,milc,**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**,"DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.",,ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.29962213,0.29962213,0%
303,omnetpp,**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**,"DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.",,ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.004838615,0.004838615,0%
304,all,**Dynamic Set Dueling with Adaptive Segmented LRU (DAS-LRU)**,"DAS-LRU combines adaptive segmented LRU with set-dueling to optimize for both regular and irregular access patterns. Each cache set is dynamically classified (via set-dueling) into one of two policies: (1) classic LRU for workloads with high spatial and temporal locality (LBM, MILC); or (2) Bimodal Segmented LRU (BS-LRU)—which maintains a ""protected"" segment for recently reused blocks and a ""probationary"" segment for blocks not recently reused—for workloads with irregular or phase-changing behavior (MCF, Omnetpp, Astar). The assignment uses a small percentage of “leader” sets to evaluate hit rates for each policy every epoch; the majority of sets follow the better performing policy. BS-LRU avoids cache pollution by only promoting blocks to protected status on re-use, thereby improving performance for irregular pointer-chasing and phase-sensitive workloads. Rapid leader-based policy selection ensures responsiveness to access pattern changes, providing strong overall hit rates across the diverse workload suite.",,ChampSim_CRC2/new_policies/004_dynamic_set_dueling_with_adaptive_segmented_lru__das_lru.cc,0.262199094,0.262199094,26%
305,astar,Adaptive Hybrid LRU-BRRIP with Phase Detection,"This policy combines the strengths of LRU and Bimodal RRIP (BRRIP), adapting dynamically to workload phase changes and access patterns. For workloads with high spatial locality (like lbm and milc), it leans toward LRU to retain recently used blocks. For irregular, memory-bound, or pointer-chasing workloads (like mcf, omnetpp, astar), it shifts toward BRRIP to prevent cache pollution and retain blocks with longer reuse intervals. Phase detection is accomplished by monitoring per-set hit/miss rates over windows; sets with frequent hits favor LRU, while sets with frequent misses favor BRRIP. This hybrid approach allows the cache to respond to both regular and irregular access patterns, improving overall hit rate by dynamically tuning replacement aggressiveness based on observed behavior.",,ChampSim_CRC2/new_policies/001_adaptive_hybrid_lru_brrip_with_phase_detection.cc,0.290580497,0.290580497,0%
306,astar,Adaptive Reuse-Phase Predictor (ARPP),"ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.",,ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.02745595,0.02745595,0%
307,lbm,Adaptive Reuse-Phase Predictor (ARPP),"ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.",,ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.035981164,0.035981164,0%
308,mcf,Adaptive Reuse-Phase Predictor (ARPP),"ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.",,ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.015361716,0.015361716,0%
309,milc,Adaptive Reuse-Phase Predictor (ARPP),"ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.",,ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.057892485,0.057892485,0%
310,omnetpp,Adaptive Reuse-Phase Predictor (ARPP),"ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.",,ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.000560571,0.000560571,0%
311,all,Adaptive Reuse-Phase Predictor (ARPP),"ARPP combines per-PC reuse prediction, spatial locality tracking, and phase-change detection to dynamically tailor cache replacement to each workload’s current behavior. For each cache set, ARPP maintains PC-based reuse counters (like Hawkeye/SHiP), a spatial locality score, and a lightweight phase detector using moving averages of reuse distance and miss rates. When a cache miss occurs, ARPP selects the victim by blending three signals: (1) predicted reuse (favoring lines with high future reuse), (2) spatial locality (retaining lines accessed in spatial clusters), and (3) phase behavior (adjusting aggressiveness based on detected streaming, thrashing, or reuse-rich phases). This multi-modal approach allows ARPP to adapt to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies.",,ChampSim_CRC2/new_policies/000_adaptive_reuse_phase_predictor__arpp.cc,0.027450377,0.027450377,3%
312,astar,Hybrid Hawkeye-LRU with Streaming Detector (HHLSD),"HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.",,ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.123038861,0.123038861,0%
313,lbm,Hybrid Hawkeye-LRU with Streaming Detector (HHLSD),"HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.",,ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.17477864,0.17477864,0%
314,mcf,Hybrid Hawkeye-LRU with Streaming Detector (HHLSD),"HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.",,ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.127665933,0.127665933,0%
315,milc,Hybrid Hawkeye-LRU with Streaming Detector (HHLSD),"HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.",,ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.125944674,0.125944674,0%
316,omnetpp,Hybrid Hawkeye-LRU with Streaming Detector (HHLSD),"HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.",,ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.0023603,0.0023603,0%
317,all,Hybrid Hawkeye-LRU with Streaming Detector (HHLSD),"HHLSD blends Hawkeye-style PC-based reuse prediction with a lightweight streaming detector and per-set LRU stack tracking. For each set, it maintains a small history of recently evicted PCs to estimate future reuse: lines brought in by PCs with high predicted reuse are protected, while those with low reuse are demoted. If the streaming detector observes a sustained high miss rate (indicating LBM-like or phase streaming), the policy switches to evict the oldest (LRU) line to minimize pollution. Otherwise, it selects victims with the lowest reuse prediction, falling back to LRU on ties. This hybrid approach adapts to irregular pointer-chasing (MCF, omnetpp), regular stencils (LBM, MILC), and control-dominated workloads (astar), outperforming static and single-signal policies by protecting reuse-rich lines and responding quickly to phase changes.",,ChampSim_CRC2/new_policies/002_hybrid_hawkeye_lru_with_streaming_detector__hhlsd.cc,0.110757682,0.110757682,11%
318,astar,Adaptive Reuse and Spatial Locality (ARSL) Replacement,"ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.123038861,0.123038861,0%
319,lbm,Adaptive Reuse and Spatial Locality (ARSL) Replacement,"ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.17477864,0.17477864,0%
320,mcf,Adaptive Reuse and Spatial Locality (ARSL) Replacement,"ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.127665933,0.127665933,0%
321,milc,Adaptive Reuse and Spatial Locality (ARSL) Replacement,"ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.125944674,0.125944674,0%
322,omnetpp,Adaptive Reuse and Spatial Locality (ARSL) Replacement,"ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.0023603,0.0023603,0%
323,all,Adaptive Reuse and Spatial Locality (ARSL) Replacement,"ARSL combines per-PC reuse prediction with dynamic spatial locality detection to adapt to both irregular and streaming workloads. For each cache line, it tracks the PC that brought it in and maintains a small reuse score table per PC. Simultaneously, it monitors per-set access strides and detects regular spatial patterns indicative of streaming or stencil workloads (like LBM, MILC). When spatial locality is high and reuse is low, ARSL prioritizes retaining lines with high spatial reuse, evicting the least recently used among low-reuse lines. For irregular workloads (MCF, omnetpp, astar), it protects lines with strong PC reuse signals, falling back to LRU for ties. By dynamically switching between reuse and spatial locality modes based on observed access patterns, ARSL improves hit rates across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/003_adaptive_reuse_and_spatial_locality__arsl__replacement.cc,0.110757682,0.110757682,11%
324,astar,**Multi-Signal Dynamic Priority Replacement (MSDP)**,"MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.290489983,0.290489983,0%
325,lbm,**Multi-Signal Dynamic Priority Replacement (MSDP)**,"MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.436282977,0.436282977,0%
326,mcf,**Multi-Signal Dynamic Priority Replacement (MSDP)**,"MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.128979235,0.128979235,0%
327,milc,**Multi-Signal Dynamic Priority Replacement (MSDP)**,"MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.279155974,0.279155974,0%
328,omnetpp,**Multi-Signal Dynamic Priority Replacement (MSDP)**,"MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.007818493,0.007818493,0%
329,all,**Multi-Signal Dynamic Priority Replacement (MSDP)**,"MSDP fuses three key signals—recency (LRU), frequency (LFU), and spatial locality—into a dynamic per-set scoring system, adapting to workload phases and access patterns. Each cache line tracks its access count (frequency), last access timestamp (recency), and a spatial reuse flag. On every access, the policy updates these metrics and periodically assesses the set’s dominant access pattern: if streaming/stencil-like (LBM, MILC), it boosts priority for lines with high spatial reuse; if pointer-chasing/irregular (MCF, omnetpp, astar), it emphasizes recency and frequency. Victim selection uses a weighted score combining these signals, with weights dynamically tuned per set based on recent miss/hit ratios and stride regularity. This approach ensures retention of lines likely to be reused soon, whether due to spatial patterns or repeated accesses, and adapts quickly to phase changes, yielding robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/004_multi_signal_dynamic_priority_replacement__msdp.cc,0.228545332,0.228545332,23%
330,astar,**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**,"A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.290520154,0.290520154,0%
331,lbm,**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**,"A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.425392266,0.425392266,0%
332,mcf,**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**,"A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.296515972,0.296515972,0%
333,milc,**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**,"A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.304256381,0.304256381,0%
334,omnetpp,**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**,"A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.005369682,0.005369682,0%
335,all,**Adaptive Dynamic Re-Reference Interval Prediction (A-DRRIP+)**,"A-DRRIP+ combines the proven strengths of Dynamic Re-Reference Interval Prediction (DRRIP) with lightweight per-set phase detection and selective spatial reuse boosting. Each cache line maintains a re-reference prediction value (RRPV) to estimate when it will be reused, and insertion policies alternate between ""long"" (low reuse) and ""short"" (high reuse) lifetimes. The policy dynamically adapts insertion aggressiveness based on recent miss/hit ratios per set, allowing it to respond to workload phase changes (e.g., streaming, pointer-chasing, mixed). For sets with detected spatial locality (e.g., LBM, MILC), A-DRRIP+ temporarily favors retaining lines with neighboring addresses. For irregular workloads (e.g., MCF, omnetpp, astar), it falls back to standard DRRIP behavior, which is robust against unpredictable reuse. This hybrid approach balances retention of reusable lines and rapid eviction of dead data, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_adaptive_dynamic_re_reference_interval_prediction__a_drrip.cc,0.264410891,0.264410891,26%
336,astar,**Hybrid Multi-Signal Replacement (HMSR)**,"HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.287442674,0.287442674,0%
337,lbm,**Hybrid Multi-Signal Replacement (HMSR)**,"HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.407374411,0.407374411,0%
338,mcf,**Hybrid Multi-Signal Replacement (HMSR)**,"HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.163414732,0.163414732,0%
339,milc,**Hybrid Multi-Signal Replacement (HMSR)**,"HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.27958369,0.27958369,0%
340,omnetpp,**Hybrid Multi-Signal Replacement (HMSR)**,"HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.005487697,0.005487697,0%
341,all,**Hybrid Multi-Signal Replacement (HMSR)**,"HMSR fuses recency, frequency, and spatial locality signals to adapt cache line retention to workload behavior. Each cache line tracks an LFU (Least Frequently Used) counter and a recency bit, while each set monitors spatial access patterns and phase changes. For streaming and stencil workloads (e.g., LBM, MILC), HMSR prioritizes spatially adjacent lines, leveraging a neighborhood-aware insertion and retention strategy. For pointer-chasing and irregular workloads (e.g., MCF, omnetpp, astar), HMSR dynamically ages out lines with low frequency and recency, ensuring dead data is evicted quickly. The policy alternates between LFU and LRU victim selection based on per-set phase detection, and boosts retention for lines with repeated spatial hits. This multi-signal approach increases hit rates by capturing both long-term reuse (frequency) and short-term bursts (recency/spatial), outperforming single-signal policies across diverse workloads.",,ChampSim_CRC2/new_policies/006_hybrid_multi_signal_replacement__hmsr.cc,0.228660641,0.228660641,23%
342,astar,Adaptive Dynamic Reuse Distance (ADRD),"ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.287442674,0.287442674,0%
343,lbm,Adaptive Dynamic Reuse Distance (ADRD),"ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.407374411,0.407374411,0%
344,mcf,Adaptive Dynamic Reuse Distance (ADRD),"ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.160523911,0.160523911,0%
345,milc,Adaptive Dynamic Reuse Distance (ADRD),"ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.27958369,0.27958369,0%
346,omnetpp,Adaptive Dynamic Reuse Distance (ADRD),"ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.005487697,0.005487697,0%
347,all,Adaptive Dynamic Reuse Distance (ADRD),"ADRD tracks the reuse distance of each cache line to dynamically adapt retention and victim selection, blending recency, frequency, and phase-awareness for optimal performance across diverse workloads. Each cache line maintains a reuse distance counter, incremented on every access to the set and reset on hits, providing a fine-grained signal of temporal locality. The set monitors access patterns to detect streaming/stencil phases (short reuse distances and high spatial locality) versus irregular/pointer-chasing phases (long reuse distances and sparse locality). During streaming phases (LBM, MILC), ADRD prioritizes retaining lines with short reuse distances and spatial adjacency, effectively prefetching and protecting hot regions. In irregular phases (MCF, omnetpp, astar), it aggressively evicts lines with long reuse distances, minimizing dead data. This adaptive strategy outperforms static recency/frequency policies by responding to real-time workload changes, boosting hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_reuse_distance__adrd.cc,0.228082477,0.228082477,23%
348,astar,Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP),"HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.",,ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.290580497,0.290580497,0%
349,lbm,Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP),"HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.",,ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.439737459,0.439737459,0%
350,mcf,Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP),"HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.",,ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.289381879,0.289381879,0%
351,milc,Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP),"HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.",,ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.304256381,0.304256381,0%
352,omnetpp,Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP),"HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.",,ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.004602585,0.004602585,0%
353,all,Hybrid SRRIP-Bimodal with Phase-Aware Protection (HSBP),"HSBP combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for general-purpose retention, a bimodal bypass for streaming/pointer-chasing phases, and a lightweight phase detector to adapt to workload changes. Each cache line maintains an RRIP value (2 bits) that predicts its likelihood of reuse. The policy detects streaming/stencil phases (LBM, MILC) by monitoring spatial adjacency and bypasses lines with low reuse, preventing cache pollution. For pointer-chasing/irregular workloads (MCF, omnetpp, astar), it increases the insertion RRIP (i.e., lines are more likely to be evicted soon), quickly removing dead data. During regular phases, it inserts lines with low RRIP (favoring retention). This hybrid approach dynamically switches between aggressive eviction and conservative retention, improving hit rates by tailoring replacement to real-time access patterns and workload phase, outperforming static policies and pure recency/frequency heuristics.",,ChampSim_CRC2/new_policies/009_hybrid_srrip_bimodal_with_phase_aware_protection__hsbp.cc,0.26571176,0.26571176,27%
354,astar,Adaptive Hawkeye-Enhanced SRRIP (AHES),"AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.",,ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.287442674,0.287442674,0%
355,lbm,Adaptive Hawkeye-Enhanced SRRIP (AHES),"AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.",,ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.407374411,0.407374411,0%
356,mcf,Adaptive Hawkeye-Enhanced SRRIP (AHES),"AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.",,ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.160523911,0.160523911,0%
357,milc,Adaptive Hawkeye-Enhanced SRRIP (AHES),"AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.",,ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.27958369,0.27958369,0%
358,omnetpp,Adaptive Hawkeye-Enhanced SRRIP (AHES),"AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.",,ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.005487697,0.005487697,0%
359,all,Adaptive Hawkeye-Enhanced SRRIP (AHES),"AHES combines the predictive power of Hawkeye (which learns which blocks are cache-friendly vs. cache-averse by tracking their future reuse) with the stability and simplicity of SRRIP for victim selection. For each set, a lightweight history table tracks the reuse behavior of recently evicted blocks using their PC signatures. On insertion, blocks accessed by cache-friendly PCs are given low RRIP (retained longer), while cache-averse PCs are inserted with high RRIP (evicted quickly). This adaptive insertion minimizes pollution from streaming or pointer-chasing phases (e.g., MCF, omnetpp, astar) and retains blocks with high temporal locality (e.g., LBM, MILC). The policy dynamically responds to phase changes, branching, and irregularity by using PC-based learning, outperforming static and phase-only heuristics. The result is improved hit rates across diverse workloads by leveraging both access history and SRRIP's robust victim selection.",,ChampSim_CRC2/new_policies/010_adaptive_hawkeye_enhanced_srrip__ahes.cc,0.228082477,0.228082477,23%
360,astar,Phase-Aware Dynamic Insertion Policy (PADIP),"PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.290580497,0.290580497,0%
361,lbm,Phase-Aware Dynamic Insertion Policy (PADIP),"PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.439737459,0.439737459,0%
362,mcf,Phase-Aware Dynamic Insertion Policy (PADIP),"PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.286784103,0.286784103,0%
363,milc,Phase-Aware Dynamic Insertion Policy (PADIP),"PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.304256381,0.304256381,0%
364,omnetpp,Phase-Aware Dynamic Insertion Policy (PADIP),"PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.004602585,0.004602585,0%
365,all,Phase-Aware Dynamic Insertion Policy (PADIP),"PADIP combines phase detection with dynamic insertion control to optimize cache replacement for diverse workloads. By monitoring per-set access patterns—specifically, hit/miss rates and spatial locality—it identifies whether the current phase is streaming (pointer-chasing, sparse, or irregular), spatial (regular stencils), or temporal (high reuse). In streaming phases (e.g., MCF, omnetpp, astar), PADIP aggressively inserts new blocks with high RRIP values to minimize pollution, while in spatial phases (e.g., LBM, MILC), it uses a spatial locality detector to selectively retain blocks likely to be reused soon. The policy adapts insertion RRIP based on phase: for detected streaming, it favors quick eviction; for spatial/temporal, it retains blocks longer. This approach is lightweight, responsive to phase changes, and leverages both local set-level behavior and simple stride detection, resulting in improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/011_phase_aware_dynamic_insertion_policy__padip.cc,0.265192205,0.265192205,27%
366,astar,Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP),"HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.",,ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.287412503,0.287412503,0%
367,lbm,Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP),"HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.",,ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.431719423,0.431719423,0%
368,mcf,Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP),"HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.",,ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.1605938,0.1605938,0%
369,milc,Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP),"HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.",,ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.279338372,0.279338372,0%
370,omnetpp,Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP),"HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.",,ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.00858559,0.00858559,0%
371,all,Hybrid SRRIP-Bimodal with Lightweight Temporal/Spatial Predictor (HSB-TSP),"HSB-TSP combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight per-set predictor that distinguishes between temporal, spatial, and streaming behaviors using recent hit/miss and stride history, but augments this with a global bimodal insertion selector. For each set, a small saturating counter tracks whether temporal or spatial reuse is dominant, while a global counter steers insertion toward either ""retain for reuse"" or ""evict quickly"" based on overall workload hit/miss trends. Streaming sets (high miss, irregular stride) insert with high RRIP (evict fast); spatial sets (regular stride, moderate hits) insert with mid RRIP; temporal sets (high hit, irregular stride) insert with low RRIP (retain). The global bimodal selector periodically flips insertion bias for all sets if overall miss rate rises, helping to quickly adapt to phase changes and avoid persistent cache pollution. This hybrid approach balances local adaptation with global responsiveness, improving hit rates for both regular (LBM, MILC) and irregular (MCF, omnetpp, astar) workloads.",,ChampSim_CRC2/new_policies/012_hybrid_srrip_bimodal_with_lightweight_temporal_spatial_predictor__hsb_tsp.cc,0.233529938,0.233529938,23%
372,astar,Adaptive Signature-based Dynamic Insertion Policy (ASDIP),"ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.",,ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.287442674,0.287442674,0%
373,lbm,Adaptive Signature-based Dynamic Insertion Policy (ASDIP),"ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.",,ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.417283322,0.417283322,0%
374,mcf,Adaptive Signature-based Dynamic Insertion Policy (ASDIP),"ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.",,ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.160623459,0.160623459,0%
375,milc,Adaptive Signature-based Dynamic Insertion Policy (ASDIP),"ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.",,ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.27958369,0.27958369,0%
376,omnetpp,Adaptive Signature-based Dynamic Insertion Policy (ASDIP),"ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.",,ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.008556087,0.008556087,0%
377,all,Adaptive Signature-based Dynamic Insertion Policy (ASDIP),"ASDIP leverages lightweight per-set access signatures to dynamically classify cache sets as spatial, temporal, or streaming, and adapts insertion and promotion policies accordingly. Each set maintains a compact signature (bit-vector) that encodes recent block access patterns: repeated accesses to the same block suggest temporal reuse (e.g., MCF, omnetpp, astar), regular sequential accesses indicate spatial locality (e.g., LBM, MILC), and random, non-repeating accesses imply streaming. ASDIP uses these signatures to select insertion RRIP values: temporal sets retain blocks longer, spatial sets use mid-range retention, and streaming sets evict quickly. Additionally, ASDIP tracks global miss rate trends and, during miss spikes, temporarily increases aggressiveness by raising insertion RRIP for all sets to rapidly clear cache pollution. This design improves performance by quickly adapting to phase changes and workload diversity, ensuring blocks are retained only when reuse is likely, and minimizing pollution from unpredictable or streaming access patterns.",,ChampSim_CRC2/new_policies/013_adaptive_signature_based_dynamic_insertion_policy__asdip.cc,0.230697846,0.230697846,23%
378,astar,**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**,"HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.",,ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.287321989,0.287321989,0%
379,lbm,**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**,"HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.",,ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.416846966,0.416846966,0%
380,mcf,**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**,"HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.",,ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.155545977,0.155545977,0%
381,milc,**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**,"HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.",,ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.27955226,0.27955226,0%
382,omnetpp,**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**,"HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.",,ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.007847997,0.007847997,0%
383,all,**Hybrid Dynamic Reuse-aware Replacement Policy (HDRRIP)**,"HDRRIP combines the strengths of Re-reference Interval Prediction (RRIP) with lightweight per-set reuse tracking and a global streaming detector to dynamically adapt cache block retention according to workload behavior. Each set maintains a small reuse counter that is incremented on hits and decayed on misses, classifying sets as temporal (high reuse), spatial (moderate reuse), or streaming (low reuse). Blocks are inserted with short RRIP for temporal sets, mid RRIP for spatial sets, and long RRIP for streaming sets. Additionally, a global streaming detector tracks the overall cache miss rate and, during streaming phases (high miss rate), raises insertion RRIP globally to quickly evict non-reused blocks. This hybrid approach ensures blocks are retained when reuse is likely (benefiting workloads like mcf, milc, astar), while minimizing pollution from streaming or unpredictable access patterns (lbm, omnetpp). By combining set-level reuse awareness with global streaming detection, HDRRIP robustly adapts to phase changes and diverse workload locality, improving hit rate and overall performance.",,ChampSim_CRC2/new_policies/014_hybrid_dynamic_reuse_aware_replacement_policy__hdrrip.cc,0.229423038,0.229423038,23%
384,astar,**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**,"ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.288347816,0.288347816,0%
385,lbm,**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**,"ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.411174342,0.411174342,0%
386,mcf,**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**,"ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.188187153,0.188187153,0%
387,milc,**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**,"ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.283509197,0.283509197,0%
388,omnetpp,**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**,"ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.005369682,0.005369682,0%
389,all,**Adaptive Signature-based Reuse and Frequency Policy (ASRFP)**,"ASRFP combines signature-based history tracking (inspired by SHiP) with lightweight per-set frequency counters and a global spatial locality detector to adapt cache block retention to workload behavior. Each block is tagged with a PC-derived signature, and a small table tracks the reuse history of each signature, allowing the policy to learn which code regions produce reusable data (benefiting astar, mcf, milc, omnetpp). Per-set frequency counters classify sets as temporal, spatial, or streaming, influencing insertion priority. A global detector monitors spatial locality phases (e.g., lbm, milc) by tracking stride patterns and boosts retention for blocks accessed in regular strides. On insertion, blocks from high-reuse signatures or spatial phases are given longer retention, while blocks from streaming or low-reuse signatures are evicted faster. This hybrid approach robustly adapts to phase changes, unpredictable control flow, and both spatial and temporal locality, improving hit rate and performance across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_signature_based_reuse_and_frequency_policy__asrfp.cc,0.235317638,0.235317638,24%
390,astar,**Dynamic Multi-Feature Replacement (DMFR)**,"DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.",,ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.290520154,0.290520154,0%
391,lbm,**Dynamic Multi-Feature Replacement (DMFR)**,"DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.",,ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.436519336,0.436519336,0%
392,mcf,**Dynamic Multi-Feature Replacement (DMFR)**,"DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.",,ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.138348803,0.138348803,0%
393,milc,**Dynamic Multi-Feature Replacement (DMFR)**,"DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.",,ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.279904477,0.279904477,0%
394,omnetpp,**Dynamic Multi-Feature Replacement (DMFR)**,"DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.",,ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.004750103,0.004750103,0%
395,all,**Dynamic Multi-Feature Replacement (DMFR)**,"DMFR fuses recency (LRU), frequency (LFU), and spatial locality detection with simple phase adaptation to robustly handle diverse workload characteristics. Each set tracks both LRU position and lightweight per-block frequency counters, enabling retention of blocks that are both recently and frequently accessed—a strong fit for workloads with mixed locality (milc, astar, omnetpp). A per-set stride detector identifies spatial phases (lbm, milc) and boosts retention for blocks accessed in regular strides. For pointer-chasing or irregular workloads (mcf, omnetpp), the policy prioritizes blocks with high frequency regardless of spatial signals. On insertion, blocks are ranked by a composite score (weighted recency, frequency, and spatial phase), and victims are chosen by lowest score, ensuring adaptive retention. This hybrid approach improves hit rate by balancing recency, frequency, and spatial reuse, and responds quickly to phase changes and unpredictable patterns.",,ChampSim_CRC2/new_policies/016_dynamic_multi_feature_replacement__dmfr.cc,0.230008575,0.230008575,23%
396,astar,**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**,"ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.",,ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.290520154,0.290520154,0%
397,lbm,**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**,"ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.",,ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.425392266,0.425392266,0%
398,mcf,**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**,"ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.",,ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.296515972,0.296515972,0%
399,milc,**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**,"ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.",,ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.304256381,0.304256381,0%
400,omnetpp,**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**,"ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.",,ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.005369682,0.005369682,0%
401,all,**Adaptive RRIP with Locality Phase Detection (ARRIP-LPD)**,"ARRIP-LPD combines Re-Reference Interval Prediction (RRIP) with lightweight per-set phase detection to adaptively respond to workload locality characteristics. RRIP is robust against both recency and frequency pitfalls, excelling in irregular/pointer-chasing workloads (mcf, omnetpp) and regular access patterns (lbm, milc). This policy augments RRIP by monitoring each set for spatial (stride-based) and temporal (reuse) phases: during detected spatial phases, insertion priority is increased (lower RRIP value) to retain blocks longer, boosting hit rates for workloads like lbm and milc. For irregular or control-dominated phases (mcf, astar, omnetpp), insertion RRIP is raised, favoring quick eviction and reducing pollution. This dynamic adaptation enables the cache to respond to phase changes and workload diversity, outperforming static or hybrid recency/frequency policies.",,ChampSim_CRC2/new_policies/017_adaptive_rrip_with_locality_phase_detection__arrip_lpd.cc,0.264410891,0.264410891,26%
402,astar,**Dynamic Signature-based RRIP (DS-RRIP)**,"DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.28756336,0.28756336,0%
403,lbm,**Dynamic Signature-based RRIP (DS-RRIP)**,"DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.407465319,0.407465319,0%
404,mcf,**Dynamic Signature-based RRIP (DS-RRIP)**,"DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.191177062,0.191177062,0%
405,milc,**Dynamic Signature-based RRIP (DS-RRIP)**,"DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.27955226,0.27955226,0%
406,omnetpp,**Dynamic Signature-based RRIP (DS-RRIP)**,"DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.005487697,0.005487697,0%
407,all,**Dynamic Signature-based RRIP (DS-RRIP)**,"DS-RRIP augments RRIP with a lightweight signature-based tracking mechanism to dynamically adapt insertion and promotion priorities based on observed access patterns. Each cache set maintains a small table mapping recent program counter (PC) signatures to their hit/miss behavior, enabling the policy to distinguish between streaming (low reuse), looping (high reuse), and pointer-chasing (irregular) accesses. When a block is inserted, its RRIP value is chosen based on the recent behavior of its PC signature: blocks from PCs with high hit rates are inserted with low RRIP (retained longer), while those from PCs with frequent misses are inserted with high RRIP (evicted quickly). This approach enables the cache to rapidly adapt to phase changes, spatial/temporal locality, and irregular access patterns, outperforming static or purely recency-based policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_signature_based_rrip__ds_rrip.cc,0.23424914,0.23424914,23%
408,astar,**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**,"HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.289283128,0.289283128,0%
409,lbm,**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**,"HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.426646788,0.426646788,0%
410,mcf,**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**,"HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.281858674,0.281858674,0%
411,milc,**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**,"HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.298303151,0.298303151,0%
412,omnetpp,**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**,"HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.005163156,0.005163156,0%
413,all,**Hybrid RRIP-Bloom Adaptive Replacement (HRBAR)**,"HRBAR combines RRIP with a lightweight, per-set Bloom filter to dynamically track recently reused blocks, enabling the policy to distinguish between streaming, looping, and pointer-chasing behaviors without heavy per-PC tracking. The Bloom filter flags blocks that have been accessed multiple times recently, signaling high temporal locality (as in lbm, milc, and some phases of astar). On insertion, blocks flagged by the Bloom filter are given a low RRIP (retained longer), while others are inserted with a high RRIP (evicted quickly). This approach is robust to phase changes, adapts quickly to irregular workloads (mcf, omnetpp), and efficiently exploits spatial locality (lbm) without the overhead of explicit PC signature tables. The Bloom filter is reset periodically to avoid stale reuse signals, ensuring responsiveness to workload shifts. This hybrid method leverages RRIP's strengths for streaming/irregular accesses and augments it with a fast, low-cost locality detector for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/023_hybrid_rrip_bloom_adaptive_replacement__hrbar.cc,0.26025098,0.26025098,26%
414,astar,**Segmented Adaptive RRIP (SARRIP)**,"SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.",,ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.26976225,0.26976225,0%
415,lbm,**Segmented Adaptive RRIP (SARRIP)**,"SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.",,ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.348230032,0.348230032,0%
416,mcf,**Segmented Adaptive RRIP (SARRIP)**,"SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.",,ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.13949265,0.13949265,0%
417,milc,**Segmented Adaptive RRIP (SARRIP)**,"SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.",,ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.278300542,0.278300542,0%
418,omnetpp,**Segmented Adaptive RRIP (SARRIP)**,"SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.",,ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.004455066,0.004455066,0%
419,all,**Segmented Adaptive RRIP (SARRIP)**,"SARRIP divides each cache set into two logical segments: a ""protected"" segment for blocks with proven temporal or spatial locality, and a ""probationary"" segment for newly inserted or suspected streaming blocks. On insertion, blocks are placed in the probationary segment with high RRIP (evictable soon). Only blocks that are hit (reused) are promoted to the protected segment and given low RRIP (retained longer). The protected segment is smaller (e.g., 1/4 of the set) and managed with standard RRIP, while the probationary segment is managed with aggressive RRIP aging. This structure allows the cache to quickly evict streaming and pointer-chasing blocks (common in mcf, omnetpp, astar) while retaining blocks with real reuse (lbm, milc, and locality phases in astar/milc). SARRIP adapts to phase changes by demoting protected blocks if they are not reused, and by periodically rebalancing segment boundaries. This hybrid segmentation approach improves hit rate by preventing cache pollution from irregular workloads and by efficiently capturing both temporal and spatial locality.",,ChampSim_CRC2/new_policies/024_segmented_adaptive_rrip__sarrip.cc,0.208048108,0.208048108,21%
420,astar,**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**,"DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.",,ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.28735216,0.28735216,0%
421,lbm,**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**,"DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.",,ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.409392556,0.409392556,0%
422,mcf,**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**,"DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.",,ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.161627366,0.161627366,0%
423,milc,**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**,"DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.",,ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.280439122,0.280439122,0%
424,omnetpp,**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**,"DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.",,ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.008438072,0.008438072,0%
425,all,**Dynamic Bimodal Insertion Policy with Per-Set Locality Tracking (DBIP-LT)**,"DBIP-LT combines the strengths of RRIP and Bimodal Insertion Policy (BIP) while adding lightweight per-set locality tracking to adaptively tune insertion and aging aggressiveness. For each cache set, a saturating counter tracks recent hits, indicating whether the set is experiencing high locality (reuse) or streaming/irregular access. On insertion, blocks are placed with low RRIP (long retention) if the set shows high reuse, and with high RRIP (quick eviction) otherwise. A small fraction of insertions always use high RRIP to allow new blocks a chance, as in BIP. Hits reset RRIP and increment the locality counter. Aging is performed more aggressively in low-locality sets to quickly evict dead blocks. This approach adapts to phase changes and workload diversity: it retains blocks in sets with reuse (LBM, MILC, locality phases in ASTAR), while evicting quickly in sets with streaming/pointer-chasing (MCF, OMNETPP, ASTAR). The per-set adaptation avoids global pollution and improves overall hit rate across mixed workloads.",,ChampSim_CRC2/new_policies/025_dynamic_bimodal_insertion_policy_with_per_set_locality_tracking__dbip_lt.cc,0.229449855,0.229449855,23%
426,astar,**Adaptive Signature-based Locality and Frequency Policy (ASLF)**,"ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.",,ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.28976587,0.28976587,0%
427,lbm,**Adaptive Signature-based Locality and Frequency Policy (ASLF)**,"ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.",,ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.415919711,0.415919711,0%
428,mcf,**Adaptive Signature-based Locality and Frequency Policy (ASLF)**,"ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.",,ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.239152174,0.239152174,0%
429,milc,**Adaptive Signature-based Locality and Frequency Policy (ASLF)**,"ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.",,ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.298481392,0.298481392,0%
430,omnetpp,**Adaptive Signature-based Locality and Frequency Policy (ASLF)**,"ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.",,ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.004986133,0.004986133,0%
431,all,**Adaptive Signature-based Locality and Frequency Policy (ASLF)**,"ASLF combines signature-based tracking of memory access patterns (to identify spatial locality and streaming behavior) with lightweight per-set frequency counters to adapt insertion and eviction decisions. Each cache set maintains a small table of recent block ""signatures"" (derived from address bits and PC) and a frequency counter for each way. On insertion, blocks matching recent signatures or high-frequency ways are given longer retention (low RRIP), while others are inserted with short retention (high RRIP). Aging is more aggressive for blocks with low frequency or signatures not recently seen, evicting dead/streaming data quickly. This approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, retaining blocks with spatial or temporal reuse while evicting those with streaming or pointer-chasing behavior. By leveraging both spatial signatures and frequency, ASLF improves hit rates across diverse phases and workload types.",,ChampSim_CRC2/new_policies/026_adaptive_signature_based_locality_and_frequency_policy__aslf.cc,0.249661056,0.249661056,25%
432,astar,**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**,"PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.287412503,0.287412503,0%
433,lbm,**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**,"PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.419646916,0.419646916,0%
434,mcf,**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**,"PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.184634306,0.184634306,0%
435,milc,**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**,"PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.27958369,0.27958369,0%
436,omnetpp,**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**,"PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.005487697,0.005487697,0%
437,all,**Phase-Adaptive Dynamic Reuse and Stream Detector (PADRSD)**,"PADRSD is a hybrid replacement policy that dynamically adapts to workload phase changes by combining per-set reuse tracking, streaming detection, and lightweight phase monitoring. Each cache set maintains a small reuse table (tracking recently accessed blocks by address and PC), a streaming counter (detecting consecutive misses/insertions), and a phase indicator (switching between ""reuse-favoring"" and ""streaming-eviction"" modes). When reuse is detected (frequent hits to the same blocks or stable PC patterns), insertions are biased toward longer retention (low RRIP), favoring temporal and spatial locality (ideal for LBM, MILC, ASTAR). If the streaming counter signals rapid block turnover (high miss rates, pointer chasing, or irregular accesses as in MCF, OMNETPP), the set enters streaming mode, aggressively inserting with high RRIP and evicting dead-on-arrival blocks. The policy automatically transitions between modes based on recent access statistics, ensuring adaptability to both regular and irregular phases. This approach improves hit rates by retaining useful blocks during locality-rich phases and minimizing pollution during streaming or pointer-chasing phases, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/027_phase_adaptive_dynamic_reuse_and_stream_detector__padrsd.cc,0.235353022,0.235353022,24%
438,astar,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.287442674,0.287442674,0%
439,lbm,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.407374411,0.407374411,0%
440,mcf,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.160680931,0.160680931,0%
441,milc,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.27958369,0.27958369,0%
442,omnetpp,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.005487697,0.005487697,0%
443,all,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR combines three complementary signals—recency, frequency, and spatial proximity—using lightweight per-set tracking to adaptively retain blocks that are likely to be reused, while aggressively evicting blocks that show streaming or pointer-chasing behavior. Each cache set maintains a small frequency counter table for recently accessed tags, a spatial reuse bitmap for neighboring blocks, and a recency stack for LRU approximation. Insertions are biased: blocks with frequent accesses or spatial neighbors are retained longer (low RRIP), while blocks with low frequency and no spatial reuse are inserted with high RRIP. The victim selection prefers blocks with low frequency and no spatial reuse, breaking ties with recency. This approach improves hit rates for workloads with regular spatial/temporal locality (LBM, MILC), adapts to phase changes (ASTAR, MILC), and mitigates pollution from irregular accesses (MCF, OMNETPP) by quickly evicting dead-on-arrival blocks. By fusing multiple locality signals, MSLAR outperforms policies relying on a single heuristic and provides robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/028_multi_signal_locality_aware_replacement__mslar.cc,0.228113881,0.228113881,23%
444,astar,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.287442674,0.287442674,0%
445,lbm,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.407374411,0.407374411,0%
446,mcf,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.160523911,0.160523911,0%
447,milc,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.27958369,0.27958369,0%
448,omnetpp,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.005487697,0.005487697,0%
449,all,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a hybrid cache replacement policy that dynamically adapts its strategy based on observed workload reuse and access phase behavior. It tracks both block-level reuse (via a simple reuse counter) and set-level access phase changes (via a moving window of recent hits/misses). When a set shows stable high reuse, DRPAR behaves like SRRIP, retaining blocks longer to exploit temporal locality (ideal for LBM, MILC, ASTAR). When a set enters a streaming or pointer-chasing phase (detected by a surge in misses or low reuse), DRPAR switches to a more aggressive insertion and eviction mode, similar to Bimodal Insertion Policy (BIP) or LFU, quickly evicting blocks with low reuse. This phase-adaptive approach allows DRPAR to respond to phase changes (MILC, ASTAR), mitigate cache pollution from irregular accesses (MCF, OMNETPP), and exploit regular locality when present. By combining per-block reuse tracking with lightweight per-set phase detection, DRPAR provides robust performance across diverse workloads, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/029_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.228082477,0.228082477,23%
450,astar,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.",,ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.287442674,0.287442674,0%
451,lbm,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.",,ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.407374411,0.407374411,0%
452,mcf,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.",,ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.160523911,0.160523911,0%
453,milc,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.",,ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.27958369,0.27958369,0%
454,omnetpp,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.",,ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.005487697,0.005487697,0%
455,all,**Multi-Signal Locality-Aware Replacement (MSLAR)**,"MSLAR is a multi-signal cache replacement policy that integrates spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. Each cache block tracks both a reuse counter and a spatial locality score (based on neighboring block accesses), while each set maintains a streaming detector to identify pointer-chasing or streaming phases. In regular phases (high spatial or temporal locality), MSLAR retains blocks with high reuse or strong spatial correlation, leveraging SRRIP-like insertion and promotion. In detected streaming/irregular phases, it aggressively evicts blocks with low reuse and spatial scores, similar to BIP/LFU, to prevent pollution. This hybrid approach allows MSLAR to adapt to phase changes, exploit spatial locality in workloads like LBM/MILC, and mitigate cache pollution from workloads like MCF/OMNETPP, delivering robust performance across diverse memory access patterns.",,ChampSim_CRC2/new_policies/030_multi_signal_locality_aware_replacement__mslar.cc,0.228082477,0.228082477,23%
456,astar,**Dynamic Phase-Aware RRIP (DPAR)**,"DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.",,ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.285541878,0.285541878,0%
457,lbm,**Dynamic Phase-Aware RRIP (DPAR)**,"DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.",,ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.395810985,0.395810985,0%
458,mcf,**Dynamic Phase-Aware RRIP (DPAR)**,"DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.",,ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.164690602,0.164690602,0%
459,milc,**Dynamic Phase-Aware RRIP (DPAR)**,"DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.",,ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.278910595,0.278910595,0%
460,omnetpp,**Dynamic Phase-Aware RRIP (DPAR)**,"DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.",,ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.00858559,0.00858559,0%
461,all,**Dynamic Phase-Aware RRIP (DPAR)**,"DPAR is a phase-adaptive cache replacement policy that dynamically switches between three proven strategies—SRRIP (Static Re-Reference Interval Prediction), BIP (Bimodal Insertion Policy), and LFU (Least Frequently Used)—based on real-time detection of workload phase characteristics. By monitoring per-set hit/miss ratios and pointer-chasing signals, DPAR identifies whether the workload is regular (high locality), streaming (low reuse), or irregular (pointer-heavy). In regular phases, DPAR uses SRRIP to retain blocks likely to be reused, maximizing hit rate for workloads like LBM and MILC. In streaming phases, it switches to BIP, evicting blocks quickly to avoid pollution from non-reusable data, ideal for workloads like MCF and OMNETPP. In detected pointer-chasing or irregular phases, DPAR leverages LFU to retain blocks with demonstrated reuse, mitigating unpredictable access patterns as seen in astar and mcf. This hybrid, phase-aware approach allows DPAR to outperform single-mode policies by adapting to workload phase changes and optimizing retention and eviction decisions for each workload type.",,ChampSim_CRC2/new_policies/031_dynamic_phase_aware_rrip__dpar.cc,0.22670793,0.22670793,23%
462,astar,**Spatial-Temporal Adaptive Replacement (STAR)**,"STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.",,ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.290520154,0.290520154,0%
463,lbm,**Spatial-Temporal Adaptive Replacement (STAR)**,"STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.",,ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.435137543,0.435137543,0%
464,mcf,**Spatial-Temporal Adaptive Replacement (STAR)**,"STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.",,ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.274271231,0.274271231,0%
465,milc,**Spatial-Temporal Adaptive Replacement (STAR)**,"STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.",,ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.304256381,0.304256381,0%
466,omnetpp,**Spatial-Temporal Adaptive Replacement (STAR)**,"STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.",,ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.004868118,0.004868118,0%
467,all,**Spatial-Temporal Adaptive Replacement (STAR)**,"STAR is a cache replacement policy that dynamically balances spatial locality, temporal reuse, and irregular access detection to optimize cache retention and eviction decisions. It tracks per-set spatial locality (neighboring block access patterns), temporal reuse (recency counters), and irregularity signals (pointer-chasing via PC entropy). When a set exhibits high spatial locality (e.g., LBM, MILC), STAR prioritizes retaining blocks with nearby addresses and recent accesses. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it switches to a frequency-biased policy, retaining blocks with repeated hits and evicting those with low reuse. STAR adapts phase behavior using lightweight statistics, ensuring that streaming phases (low reuse) quickly evict blocks to minimize pollution. This hybrid approach leverages spatial and temporal signals to outperform single-mode policies, especially across workloads with mixed or phase-changing locality characteristics.",,ChampSim_CRC2/new_policies/032_spatial_temporal_adaptive_replacement__star.cc,0.261810686,0.261810686,26%
468,astar,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.",,ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.290248612,0.290248612,0%
469,lbm,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.",,ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.432101235,0.432101235,0%
470,mcf,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.",,ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.28371668,0.28371668,0%
471,milc,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.",,ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.304256381,0.304256381,0%
472,omnetpp,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.",,ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.004868118,0.004868118,0%
473,all,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-aware cache replacement policy that combines lightweight reuse distance tracking with adaptive phase detection to optimize retention and eviction across diverse workloads. Each set monitors recent access patterns to classify its current phase as streaming, spatial, or irregular. For streaming phases (e.g., low reuse, as in LBM), PADR aggressively evicts the oldest blocks to minimize pollution. In spatial phases (e.g., high locality, as in MILC), it retains blocks with nearby addresses and recent hits. For irregular/pointer-heavy phases (e.g., MCF, astar, omnetpp), PADR prioritizes blocks with repeated hits (frequency) and avoids evicting blocks accessed by high-entropy PCs. The policy uses a small per-set history of addresses and PCs to detect phase changes and adapts its victim selection accordingly. This hybrid approach balances recency, frequency, and spatial awareness, improving performance by quickly responding to phase shifts and workload-specific locality characteristics.",,ChampSim_CRC2/new_policies/033_phase_aware_dynamic_reuse__padr.cc,0.263038205,0.263038205,26%
474,astar,**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**,"ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.",,ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.290520154,0.290520154,0%
475,lbm,**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**,"ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.",,ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.417446956,0.417446956,0%
476,mcf,**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**,"ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.",,ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.237838801,0.237838801,0%
477,milc,**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**,"ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.",,ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.304256381,0.304256381,0%
478,omnetpp,**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**,"ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.",,ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.005369682,0.005369682,0%
479,all,**Adaptive Reuse-Recency-Spatial (ARRS) Replacement**,"ARRS is a hybrid cache replacement policy that dynamically balances recency, frequency (reuse), and spatial locality to optimize retention and eviction decisions across diverse workloads. Each cache set tracks a compact history of block accesses and their spatial proximity, updating per-block reuse counters and recency (LRU) positions. For workloads with regular, spatially local accesses (e.g., LBM, MILC), ARRS favors retaining blocks with high spatial proximity and reuse, avoiding premature eviction of blocks likely to be reused soon. For irregular, pointer-heavy workloads (e.g., MCF, astar, omnetpp), it prioritizes blocks with demonstrated reuse (high frequency), but also considers recency to prevent cache pollution. The policy adaptively weighs these factors based on observed hit/miss patterns, ensuring quick response to phase changes and robust performance across streaming, irregular, and mixed workloads.",,ChampSim_CRC2/new_policies/034_adaptive_reuse_recency_spatial__arrs__replacement.cc,0.251086395,0.251086395,25%
480,astar,**Dynamic Signature-Locality Adaptive Replacement (DSLR)**,"DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.",,ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.290520154,0.290520154,0%
481,lbm,**Dynamic Signature-Locality Adaptive Replacement (DSLR)**,"DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.",,ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.418083308,0.418083308,0%
482,mcf,**Dynamic Signature-Locality Adaptive Replacement (DSLR)**,"DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.",,ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.261644214,0.261644214,0%
483,milc,**Dynamic Signature-Locality Adaptive Replacement (DSLR)**,"DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.",,ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.304256381,0.304256381,0%
484,omnetpp,**Dynamic Signature-Locality Adaptive Replacement (DSLR)**,"DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.",,ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.005369682,0.005369682,0%
485,all,**Dynamic Signature-Locality Adaptive Replacement (DSLR)**,"DSLR is a hybrid cache replacement policy that dynamically adapts to both spatial and temporal locality, as well as irregular pointer-chasing and phase-changing workloads. It combines lightweight signature-based tracking of access patterns (using partial address hashing) to identify streaming and spatially local phases, with per-block reuse counters and recency (LRU) positions. For regular, spatial workloads (LBM, MILC), DSLR retains blocks with matching signatures and high spatial proximity, preventing premature eviction. For irregular workloads (MCF, astar, omnetpp), it relies on per-block reuse counters and recency, evicting blocks with low reuse and distant signatures. The policy adaptively switches weighting between locality and reuse based on observed hit/miss ratios in each set, enabling robust performance across mixed and phase-changing workloads.",,ChampSim_CRC2/new_policies/036_dynamic_signature_locality_adaptive_replacement__dslr.cc,0.255974748,0.255974748,26%
486,astar,**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**,"PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.28801593,0.28801593,0%
487,lbm,**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**,"PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.40833803,0.40833803,0%
488,mcf,**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**,"PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.185835469,0.185835469,0%
489,milc,**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**,"PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.285612434,0.285612434,0%
490,omnetpp,**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**,"PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.005546704,0.005546704,0%
491,all,**Phase-Aware Dynamic Re-reference Interval Prediction (PA-DRRIP)**,"PA-DRRIP is a hybrid cache replacement policy that combines phase detection with the proven Dynamic Re-reference Interval Prediction (DRRIP) strategy. It tracks both signature-based phase behavior (using partial address hashing) and access recency, dynamically switching between SRRIP (static RRIP) and BRRIP (bimodal RRIP) modes based on observed locality and miss/hit rates. For workloads with high spatial or temporal locality (e.g., LBM, MILC), PA-DRRIP aggressively retains blocks by using SRRIP, while for pointer-chasing or irregular workloads (e.g., MCF, astar, omnetpp), it switches to BRRIP to prevent cache pollution. Phase changes are detected using a moving window of signatures and miss/hit counters per set, allowing the policy to adapt to changing workload characteristics. This approach leverages DRRIP’s robust predictive eviction while adding phase-awareness, improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/037_phase_aware_dynamic_re_reference_interval_prediction__pa_drrip.cc,0.234669714,0.234669714,23%
492,astar,**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**,"AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.162744388,0.162744388,0%
493,lbm,**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**,"AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.321848694,0.321848694,0%
494,mcf,**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**,"AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.255686847,0.255686847,0%
495,milc,**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**,"AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.132503921,0.132503921,0%
496,omnetpp,**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**,"AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.000354045,0.000354045,0%
497,all,**Adaptive Multi-Policy Replacement (AMPR): Locality+Reuse+Pointer-Aware Hybrid**,"AMPR is a hybrid cache replacement policy that dynamically blends three strategies—LRU (for high temporal locality), SRRIP (for spatial/reuse locality), and a Pointer-Aware Bypass (for pointer-chasing and irregular workloads)—using lightweight per-set statistics. Each LLC set tracks recent hit/miss patterns and detects pointer-chasing using address stride randomness and frequent misses. For sets with high hit rates and regular access (LBM, MILC), AMPR favors LRU or SRRIP to retain blocks. For sets with high miss rates and irregular access (MCF, astar, omnetpp), AMPR selectively bypasses insertion or evicts blocks aggressively, preventing cache pollution. The policy adapts online, switching strategies per set based on moving-window statistics, thus improving performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/038_adaptive_multi_policy_replacement__ampr___locality_reuse_pointer_aware_hybrid.cc,0.174627579,0.174627579,17%
498,astar,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.",,ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.128922279,0.128922279,0%
499,lbm,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.",,ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.291849239,0.291849239,0%
500,mcf,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.",,ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.270695402,0.270695402,0%
501,milc,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.",,ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.093362327,0.093362327,0%
502,omnetpp,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.",,ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.000295037,0.000295037,0%
503,all,**Dynamic Reuse-Phase Adaptive Replacement (DRPAR)**,"DRPAR is a phase-adaptive cache replacement policy that dynamically switches between three strategies—SRRIP (for regular, spatially local workloads), LRU (for phases with high temporal reuse), and Bimodal Insertion Policy (BIP, for pointer-chasing and irregular phases)—based on online detection of workload phase and reuse patterns per set. Each LLC set maintains a small moving window of hit/miss history and tracks the frequency of reuse (recency) and stride randomness. When the set exhibits high hit rates and frequent reuse, DRPAR uses LRU to maximize temporal locality. For regular, stride-based access patterns (e.g., LBM, MILC), it switches to SRRIP for spatial locality. In phases with low reuse and high stride randomness (e.g., MCF, omnetpp, astar), DRPAR activates BIP, inserting most blocks with low priority to minimize cache pollution. This adaptive approach ensures optimal block retention and eviction across diverse workloads and phase changes, significantly improving overall hit rate and robustness.",,ChampSim_CRC2/new_policies/039_dynamic_reuse_phase_adaptive_replacement__drpar.cc,0.157024857,0.157024857,16%
504,astar,**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**,"DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.",,ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.290580497,0.290580497,0%
505,lbm,**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**,"DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.",,ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.439737459,0.439737459,0%
506,mcf,**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**,"DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.",,ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.29624819,0.29624819,0%
507,milc,**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**,"DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.",,ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.304256381,0.304256381,0%
508,omnetpp,**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**,"DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.",,ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.005369682,0.005369682,0%
509,all,**Dynamic Signature-based Reuse and Frequency (DSRF) Replacement**,"DSRF is a hybrid cache replacement policy that combines signature-based reuse prediction (as in SHiP) with block-level frequency and recency tracking, dynamically adapting to workload characteristics. Each cache block is associated with a signature derived from the PC of the memory access, and a per-signature reuse counter is maintained to estimate future reuse. Blocks are inserted with low priority unless their signature has demonstrated frequent reuse, reducing pollution from irregular/pointer-chasing workloads (MCF, omnetpp, astar). For workloads with regular or spatial locality (LBM, MILC), the policy boosts retention of blocks with high access frequency or recent reuse, leveraging both signature and frequency signals. This dual approach enables robust adaptation to phase changes and diverse access patterns, outperforming static policies by retaining blocks likely to be reused and evicting those with low predicted utility.",,ChampSim_CRC2/new_policies/040_dynamic_signature_based_reuse_and_frequency__dsrf__replacement.cc,0.267238442,0.267238442,27%
510,astar,**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**,"ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.287442674,0.287442674,0%
511,lbm,**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**,"ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.407374411,0.407374411,0%
512,mcf,**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**,"ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.160523911,0.160523911,0%
513,milc,**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**,"ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.27958369,0.27958369,0%
514,omnetpp,**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**,"ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.005487697,0.005487697,0%
515,all,**Adaptive Reuse-Frequency with Spatial Bypass (ARFSB) Replacement**,"ARFSB is a hybrid cache replacement policy that combines per-block reuse and frequency tracking with spatial locality detection and selective bypassing. For each block, it maintains recency (RRPV), frequency of reuse, and a simple spatial locality flag. On insertion, ARFSB dynamically decides whether to bypass the cache for blocks with low predicted reuse and spatial locality (e.g., pointer-chasing or control-dominated accesses typical of MCF, omnetpp, astar), minimizing pollution. For workloads with high spatial locality (LBM, MILC), blocks are retained longer if they show frequent reuse or access patterns matching their neighbors. The policy adapts to phase changes by periodically sampling block reuse and spatial correlation, updating insertion and bypass thresholds. This approach improves performance by reducing pollution from irregular workloads and boosting retention for blocks with strong reuse or spatial patterns, outperforming static or single-signal policies.",,ChampSim_CRC2/new_policies/041_adaptive_reuse_frequency_with_spatial_bypass__arfsb__replacement.cc,0.228082477,0.228082477,23%
516,astar,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.016352884,0.016352884,0%
517,lbm,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.043417392,0.043417392,0%
518,mcf,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.020143562,0.020143562,0%
519,milc,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.007093968,0.007093968,0%
520,omnetpp,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.000295037,0.000295037,0%
521,all,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines multi-phase detection, spatial-temporal reuse tracking, and dynamic filtering to adaptively select cache lines for eviction. It maintains per-set phase signatures (using lightweight hashing of recent PCs and access strides) to detect phase changes (e.g., switching from regular to irregular access). For each line, APARP tracks both temporal reuse (recency counters) and spatial reuse (neighbor access counters), and uses a confidence score to filter lines with low predicted reuse. When a phase change is detected, APARP dynamically tunes its eviction aggressiveness and filtering thresholds, allowing it to respond quickly to workload shifts (e.g., MILC's phase changes, LBM's regularity, MCF's sparsity). This hybrid approach is designed to outperform static heuristics (like LRU), learned policies (Hawkeye/SHiP++), and filtering-based schemes (LIME) by combining their strengths and adding phase-awareness.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.017460569,0.017460569,2%
522,astar,Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF),"HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.290550326,0.290550326,0%
523,lbm,Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF),"HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.439737459,0.439737459,0%
524,mcf,Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF),"HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.290716921,0.290716921,0%
525,milc,Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF),"HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.304256381,0.304256381,0%
526,omnetpp,Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF),"HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.004868118,0.004868118,0%
527,all,Hybrid Dynamic Reuse and Frequency-based Replacement (HDRF),"HDRF combines lightweight dynamic reuse tracking (recency and frequency) with per-set adaptive filtering to select cache victims, tailored to the diverse workload behaviors described. For each cache line, HDRF maintains both an LRU stack position and a small saturating frequency counter, incremented on hits and decayed periodically. Sets monitor their miss/hit patterns and, if a set experiences frequent misses (indicative of phase change or irregular access), HDRF temporarily prioritizes evicting lines with low frequency rather than just LRU. This hybrid approach allows HDRF to retain frequently reused lines for regular workloads (LBM, MILC regular phases), while quickly adapting to irregular, sparse, or phase-changing workloads (MCF, omnetpp, MILC irregular phases) by not over-prioritizing recency alone. The policy is simple, fast, and robust against pollution, outperforming pure LRU or frequency-based schemes and providing improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/001_hybrid_dynamic_reuse_and_frequency_based_replacement__hdrf.cc,0.266025841,0.266025841,27%
528,astar,**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**,"DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.",,ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.290520154,0.290520154,0%
529,lbm,**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**,"DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.",,ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.439737459,0.439737459,0%
530,mcf,**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**,"DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.",,ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.294868184,0.294868184,0%
531,milc,**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**,"DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.",,ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.304256381,0.304256381,0%
532,omnetpp,**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**,"DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.",,ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.005369682,0.005369682,0%
533,all,**Dynamic Segmented LRU with Spatial Reuse Boost (DSLR-SRB)**,"DSLR-SRB augments traditional LRU with two adaptive mechanisms: (1) **Segmented LRU** divides each set into ""protected"" and ""probation"" segments, dynamically adjusting the boundary based on recent miss/hit trends to better handle phase changes and irregular access (e.g., MCF, omnetpp, MILC irregular). (2) **Spatial Reuse Boost** tracks recent stride patterns and spatial locality within each set, temporarily ""boosting"" the priority of lines that are part of detected spatially reused regions (ideal for LBM, MILC regular). On insertion, lines are placed in the probation segment unless they match recent spatial patterns, in which case they go to protected. Victim selection evicts from the probation segment unless the protected segment is full, and the segment boundary shifts based on observed miss/hit rates. This hybrid approach is robust: it preserves spatially reused blocks for regular workloads, adapts quickly to phase changes, and avoids cache pollution from irregular accesses, outperforming pure LRU, frequency, or recency-based schemes.",,ChampSim_CRC2/new_policies/003_dynamic_segmented_lru_with_spatial_reuse_boost__dslr_srb.cc,0.266950372,0.266950372,27%
534,astar,Adaptive Multi-Signal Replacement (AMSR),"AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.",,ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.290550326,0.290550326,0%
535,lbm,Adaptive Multi-Signal Replacement (AMSR),"AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.",,ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.439737459,0.439737459,0%
536,mcf,Adaptive Multi-Signal Replacement (AMSR),"AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.",,ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.290716921,0.290716921,0%
537,milc,Adaptive Multi-Signal Replacement (AMSR),"AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.",,ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.304256381,0.304256381,0%
538,omnetpp,Adaptive Multi-Signal Replacement (AMSR),"AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.",,ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.004868118,0.004868118,0%
539,all,Adaptive Multi-Signal Replacement (AMSR),"AMSR combines recency, frequency, and spatial-temporal locality signals in a lightweight, per-set adaptive framework. Each cache line tracks both its LRU position and a small saturating frequency counter, while each set maintains a simple phase detector using recent hit/miss history. On insertion, lines matching regular spatial stride patterns (good for LBM, MILC regular) or showing repeated access (frequency, good for astar, mcf, omnetpp pointer chasing) get a frequency boost. Victim selection prioritizes eviction of lines with low frequency and least recent use, but dynamically weights recency vs. frequency based on the set’s current phase (detected via hit/miss ratio). This hybrid approach adapts to phase changes, preserves lines with spatial or temporal reuse, and avoids cache pollution from irregular accesses, outperforming pure LRU, LFU, or static hybrid schemes across diverse workloads.",,ChampSim_CRC2/new_policies/004_adaptive_multi_signal_replacement__amsr.cc,0.266025841,0.266025841,27%
540,astar,Dynamic Reuse-Pattern Replacement (DRPR),"DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.",,ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.290550326,0.290550326,0%
541,lbm,Dynamic Reuse-Pattern Replacement (DRPR),"DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.",,ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.439737459,0.439737459,0%
542,mcf,Dynamic Reuse-Pattern Replacement (DRPR),"DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.",,ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.293475637,0.293475637,0%
543,milc,Dynamic Reuse-Pattern Replacement (DRPR),"DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.",,ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.304256381,0.304256381,0%
544,omnetpp,Dynamic Reuse-Pattern Replacement (DRPR),"DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.",,ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.004868118,0.004868118,0%
545,all,Dynamic Reuse-Pattern Replacement (DRPR),"DRPR leverages a per-set, per-line reuse pattern table to dynamically classify cache lines as either ""reusable"" or ""transient"" based on observed access intervals and hit/miss sequences. Each line tracks a short history of access distances (intervals between accesses) and recent hit/miss outcomes. Sets maintain a simple classifier that distinguishes between regular reuse (LBM, MILC regular), irregular reuse (MCF, OMNETPP, ASTAR), and transient/no reuse phases. On insertion, lines with short access intervals or repeated hits are marked as ""reusable,"" while those with long intervals or repeated misses are marked ""transient."" Victim selection prioritizes eviction of transient lines, falling back to LRU among reusable lines. This approach adapts to phase changes, preserves lines with demonstrated reuse, and quickly evicts lines that pollute the cache, outperforming static or frequency-based policies by tailoring retention to actual observed reuse patterns.",,ChampSim_CRC2/new_policies/005_dynamic_reuse_pattern_replacement__drpr.cc,0.266577584,0.266577584,27%
546,astar,**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**,"HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.290520154,0.290520154,0%
547,lbm,**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**,"HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.425392266,0.425392266,0%
548,mcf,**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**,"HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.296515972,0.296515972,0%
549,milc,**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**,"HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.304256381,0.304256381,0%
550,omnetpp,**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**,"HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.005369682,0.005369682,0%
551,all,**Hybrid SRRIP-Bimodal Adaptive Replacement (HSBAR)**,"HSBAR combines the strengths of Static Re-Reference Interval Prediction (SRRIP) and a lightweight bimodal frequency detector to adaptively manage cache lines based on both spatial/temporal reuse and irregular access patterns. Each line maintains an SRRIP-style ""re-reference value"" (RRPV) to estimate future reuse, while sets track a simple frequency counter to detect phase changes and irregular access bursts. For regular workloads (LBM, MILC regular), SRRIP retains lines with predicted reuse, leveraging spatial locality. For irregular workloads (MCF, OMNETPP, ASTAR), the bimodal detector identifies sets with frequent misses or pointer chasing, increasing the aggressiveness of eviction by lowering RRPV on insertion and favoring lines with high miss frequency. This hybrid approach dynamically balances retention and eviction, improving hit rates across both regular and irregular workloads by responding to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/006_hybrid_srrip_bimodal_adaptive_replacement__hsbar.cc,0.264410891,0.264410891,26%
552,astar,Dynamic Hawkeye-LRU Hybrid Replacement (DHLR),"DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.",,ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.290550326,0.290550326,0%
553,lbm,Dynamic Hawkeye-LRU Hybrid Replacement (DHLR),"DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.",,ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.439737459,0.439737459,0%
554,mcf,Dynamic Hawkeye-LRU Hybrid Replacement (DHLR),"DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.",,ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.290716921,0.290716921,0%
555,milc,Dynamic Hawkeye-LRU Hybrid Replacement (DHLR),"DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.",,ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.304256381,0.304256381,0%
556,omnetpp,Dynamic Hawkeye-LRU Hybrid Replacement (DHLR),"DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.",,ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.004868118,0.004868118,0%
557,all,Dynamic Hawkeye-LRU Hybrid Replacement (DHLR),"DHLR combines the strengths of Hawkeye (a learned cache replacement predictor) with a fallback to LRU for sets and phases where prediction is unreliable. For each cache set, DHLR tracks recent accesses and uses simple PC-based signatures to estimate whether a block is likely to be reused (cache-friendly) or not (cache-averse), inspired by Hawkeye's approach. Sets with high prediction confidence use Hawkeye's predicted cache-friendliness to retain or evict lines, while sets with low confidence or erratic access patterns fall back to LRU, which is robust for regular workloads like LBM and MILC. The policy adapts online, switching between Hawkeye and LRU based on local miss/hit history and prediction accuracy, allowing it to handle both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads and respond to phase changes. This hybrid, adaptive approach improves hit rates by leveraging learned reuse prediction where possible and falling back to a proven baseline elsewhere.",,ChampSim_CRC2/new_policies/007_dynamic_hawkeye_lru_hybrid_replacement__dhlr.cc,0.266025841,0.266025841,27%
558,astar,Spatial-Temporal Reuse Adaptive Replacement (STRAR),"STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.241491673,0.241491673,0%
559,lbm,Spatial-Temporal Reuse Adaptive Replacement (STRAR),"STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.185578444,0.185578444,0%
560,mcf,Spatial-Temporal Reuse Adaptive Replacement (STRAR),"STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.257513147,0.257513147,0%
561,milc,Spatial-Temporal Reuse Adaptive Replacement (STRAR),"STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.211214887,0.211214887,0%
562,omnetpp,Spatial-Temporal Reuse Adaptive Replacement (STRAR),"STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.001563699,0.001563699,0%
563,all,Spatial-Temporal Reuse Adaptive Replacement (STRAR),"STRAR is a hybrid policy that dynamically adapts between spatial locality exploitation and temporal reuse prediction, tailored for diverse workload behaviors. For workloads with regular, stride-based access patterns (like LBM, MILC), STRAR leverages a per-set spatial reuse tracker to retain blocks that are likely to be revisited soon, using address deltas and simple stride detection. For workloads with irregular, pointer-chasing or phase-changing behaviors (MCF, OMNETPP, ASTAR), STRAR switches to a temporal reuse predictor using a small, per-set history of recently used PCs and recency counters, evicting blocks with the lowest predicted reuse. The policy monitors per-set miss/hit ratios and stride regularity to switch modes online, ensuring robust performance across both regular and irregular phases. This approach improves hit rates by retaining blocks with high spatial or temporal reuse, while minimizing pollution from unpredictable accesses.",,ChampSim_CRC2/new_policies/008_spatial_temporal_reuse_adaptive_replacement__strar.cc,0.17947237,0.17947237,18%
564,astar,Dynamic Multi-Signal Reuse Predictor (DMRP),"DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.290489983,0.290489983,0%
565,lbm,Dynamic Multi-Signal Reuse Predictor (DMRP),"DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.42337412,0.42337412,0%
566,mcf,Dynamic Multi-Signal Reuse Predictor (DMRP),"DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.207604641,0.207604641,0%
567,milc,Dynamic Multi-Signal Reuse Predictor (DMRP),"DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.304185085,0.304185085,0%
568,omnetpp,Dynamic Multi-Signal Reuse Predictor (DMRP),"DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.005369682,0.005369682,0%
569,all,Dynamic Multi-Signal Reuse Predictor (DMRP),"DMRP is a hybrid cache replacement policy that dynamically combines recency, frequency, and program context (PC-based) reuse signals to adapt to diverse workload behaviors. For regular, spatially local workloads (like LBM, MILC), DMRP leverages a simple frequency counter per line to retain blocks with repeated accesses. For irregular, pointer-chasing, or control-dominated workloads (MCF, OMNETPP, ASTAR), it tracks recent PCs per set and boosts retention for blocks accessed by frequently recurring PCs, capturing temporal locality and phase changes. A lightweight per-set phase detector monitors access regularity and switches between frequency-dominant and PC-dominant eviction strategies online. By integrating recency (LRU stack position), frequency, and PC reuse, DMRP mitigates cache pollution and adapts quickly to phase transitions, improving hit rates across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/009_dynamic_multi_signal_reuse_predictor__dmrp.cc,0.246204702,0.246204702,25%
570,astar,Adaptive Reuse Interval Predictor (ARIP),"ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.",,ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.290550326,0.290550326,0%
571,lbm,Adaptive Reuse Interval Predictor (ARIP),"ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.",,ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.439737459,0.439737459,0%
572,mcf,Adaptive Reuse Interval Predictor (ARIP),"ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.",,ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.290716921,0.290716921,0%
573,milc,Adaptive Reuse Interval Predictor (ARIP),"ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.",,ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.304256381,0.304256381,0%
574,omnetpp,Adaptive Reuse Interval Predictor (ARIP),"ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.",,ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.004868118,0.004868118,0%
575,all,Adaptive Reuse Interval Predictor (ARIP),"ARIP is an adaptive cache replacement policy that estimates the expected reuse interval of each cache block using lightweight per-line history and set-level access tracking. For regular workloads (LBM, MILC), ARIP detects stride-based or spatially local accesses and retains blocks whose predicted reuse interval is short, effectively preempting blocks just before their next expected use. For irregular workloads (MCF, OMNETPP, ASTAR), ARIP falls back to a recency-biased policy but boosts retention for blocks with recent hits or short observed reuse intervals. The policy uses a small per-line reuse interval counter (reset on hit, incremented on miss), and per-set stride detectors to dynamically switch between interval-based and recency-based eviction. This approach improves hit rates by anticipating both regular and irregular reuse patterns, minimizing premature evictions and cache pollution.",,ChampSim_CRC2/new_policies/010_adaptive_reuse_interval_predictor__arip.cc,0.266025841,0.266025841,27%
576,astar,Dynamic Signature-based Reuse Predictor (DSRP),"DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.",,ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.289252957,0.289252957,0%
577,lbm,Dynamic Signature-based Reuse Predictor (DSRP),"DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.",,ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.403410847,0.403410847,0%
578,mcf,Dynamic Signature-based Reuse Predictor (DSRP),"DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.",,ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.20080806,0.20080806,0%
579,milc,Dynamic Signature-based Reuse Predictor (DSRP),"DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.",,ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.302759162,0.302759162,0%
580,omnetpp,Dynamic Signature-based Reuse Predictor (DSRP),"DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.",,ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.00858559,0.00858559,0%
581,all,Dynamic Signature-based Reuse Predictor (DSRP),"DSRP combines signature-based access correlation with lightweight reuse tracking to dynamically adapt to both regular and irregular workload patterns. For each set, the policy maintains a compact history of recent program counters (PCs) and memory access signatures, allowing it to learn which blocks are likely to be reused soon based on access context (e.g., loop, pointer-chasing, or control-dominated code). Each cache line tracks a reuse score that is incremented on hits and decayed on misses, reflecting both temporal and contextual locality. When selecting a victim, DSRP prefers to evict lines with low reuse scores and signatures not recently observed, protecting blocks involved in regular strides (LBM, MILC) and adaptively responding to phase and control changes (MCF, OMNETPP, ASTAR). This hybrid approach improves hit rate by leveraging both recency and context-aware reuse prediction, outperforming pure recency or interval-based policies.",,ChampSim_CRC2/new_policies/011_dynamic_signature_based_reuse_predictor__dsrp.cc,0.240963323,0.240963323,24%
582,astar,Adaptive Multi-Feature Replacement (AMFR),"AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.",,ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.290550326,0.290550326,0%
583,lbm,Adaptive Multi-Feature Replacement (AMFR),"AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.",,ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.425028636,0.425028636,0%
584,mcf,Adaptive Multi-Feature Replacement (AMFR),"AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.",,ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.254018794,0.254018794,0%
585,milc,Adaptive Multi-Feature Replacement (AMFR),"AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.",,ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.304256381,0.304256381,0%
586,omnetpp,Adaptive Multi-Feature Replacement (AMFR),"AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.",,ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.004868118,0.004868118,0%
587,all,Adaptive Multi-Feature Replacement (AMFR),"AMFR combines three orthogonal features—recency (LRU stack), spatial locality (per-set stride detection), and irregularity (pointer-chase detection via PC hashing)—to adapt victim selection to workload phases and access patterns. For each set, AMFR maintains a stride detector to identify regular accesses (favoring retention for LBM, MILC), a lightweight PC-based irregularity counter (to protect blocks accessed by pointer-chasing code in MCF, OMNETPP, ASTAR), and a recency stack for fallback. Victims are chosen by first evicting blocks with neither recent reuse nor spatial/irregular protection, then by lowest recency. This hybrid approach improves hit rate by dynamically responding to both regular and irregular phases, leveraging spatial reuse when present and protecting unpredictable blocks when needed, outperforming pure recency or context-only policies across diverse workloads.",,ChampSim_CRC2/new_policies/012_adaptive_multi_feature_replacement__amfr.cc,0.255744451,0.255744451,26%
588,astar,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.",,ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.290550326,0.290550326,0%
589,lbm,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.",,ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.425028636,0.425028636,0%
590,mcf,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.",,ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.254018794,0.254018794,0%
591,milc,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.",,ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.304256381,0.304256381,0%
592,omnetpp,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.",,ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.004868118,0.004868118,0%
593,all,**Phase-Aware Dynamic Reuse (PADR)**,"PADR is a phase-adaptive cache replacement policy that dynamically detects and responds to workload phase changes by leveraging both reuse distance and access regularity. For each set, PADR tracks the reuse interval of blocks (using a small per-set reuse counter table) and maintains a lightweight phase detector that classifies the current access pattern as regular (stride-based), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), PADR favors retaining blocks with predicted upcoming reuse based on stride and recent accesses, evicting those with long reuse intervals. In irregular phases (e.g., MCF, OMNETPP, ASTAR), PADR prioritizes blocks accessed by irregular code paths (using PC hashing and recency), protecting them from eviction. The policy adapts victim selection criteria on-the-fly based on detected phase, outperforming static or single-feature policies by ensuring blocks with imminent reuse are retained while minimizing pollution from phase transitions. This approach improves hit rate across diverse workloads by combining phase detection, reuse interval tracking, and access pattern classification.",,ChampSim_CRC2/new_policies/013_phase_aware_dynamic_reuse__padr.cc,0.255744451,0.255744451,26%
594,astar,**Hybrid Locality Predictor Replacement (HLPR)**,"HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.",,ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.290520154,0.290520154,0%
595,lbm,**Hybrid Locality Predictor Replacement (HLPR)**,"HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.",,ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.417446956,0.417446956,0%
596,mcf,**Hybrid Locality Predictor Replacement (HLPR)**,"HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.",,ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.238209364,0.238209364,0%
597,milc,**Hybrid Locality Predictor Replacement (HLPR)**,"HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.",,ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.304256381,0.304256381,0%
598,omnetpp,**Hybrid Locality Predictor Replacement (HLPR)**,"HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.",,ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.005369682,0.005369682,0%
599,all,**Hybrid Locality Predictor Replacement (HLPR)**,"HLPR is a hybrid cache replacement policy that combines spatial locality prediction, temporal reuse tracking, and irregular access protection to adaptively optimize cache retention decisions. For each set, HLPR maintains a per-block reuse counter (for recency), a spatial locality flag (set when accesses follow regular strides or neighbor patterns), and an irregular access flag (set for blocks accessed via pointer-chasing or unpredictable PCs). The victim selection process prioritizes retaining blocks with high spatial or temporal locality, while blocks with low reuse and no locality protection are evicted first. HLPR dynamically adjusts to workload phases: in regular, stride-heavy phases (LBM, MILC), it protects spatially local blocks; in irregular, pointer-chasing phases (MCF, OMNETPP, ASTAR), it protects blocks accessed by irregular PCs. This hybrid approach improves hit rates by minimizing pollution and maximizing retention of blocks most likely to be reused, outperforming static or single-feature policies across diverse workload characteristics.",,ChampSim_CRC2/new_policies/014_hybrid_locality_predictor_replacement__hlpr.cc,0.251160507,0.251160507,25%
600,astar,**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**,"ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.288287473,0.288287473,0%
601,lbm,**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**,"ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.39806549,0.39806549,0%
602,mcf,**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**,"ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.177642657,0.177642657,0%
603,milc,**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**,"ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.278696706,0.278696706,0%
604,omnetpp,**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**,"ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.008408568,0.008408568,0%
605,all,**Adaptive Dynamic Reuse and Phase-Aware Replacement (ADRPAR)**,"ADRPAR is a phase-aware cache replacement policy that dynamically adapts to workload characteristics by tracking both per-block reuse intervals and set-level access patterns. It combines a lightweight dynamic reuse distance predictor (for temporal locality) with a set-level phase detector that identifies whether the current access pattern is regular (stride/spatial), irregular (pointer-chasing), or mixed. In regular phases (e.g., LBM, MILC), ADRPAR prioritizes retaining blocks with high spatial reuse, using a per-set stride detector. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it boosts retention for blocks accessed via frequently seen PCs (indicative of pointer-chasing or control-dominated paths). Phase transitions are detected via entropy in address and PC histories, allowing ADRPAR to switch eviction priorities on-the-fly. This approach minimizes cache pollution during phase changes and optimizes retention for blocks most likely to be reused, outperforming static or single-feature policies across diverse workloads.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_phase_aware_replacement__adrpar.cc,0.230220179,0.230220179,23%
606,astar,**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**,"HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.",,ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.290580497,0.290580497,0%
607,lbm,**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**,"HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.",,ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.439737459,0.439737459,0%
608,mcf,**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**,"HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.",,ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.290175005,0.290175005,0%
609,milc,**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**,"HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.",,ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.289925852,0.289925852,0%
610,omnetpp,**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**,"HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.",,ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.0047206,0.0047206,0%
611,all,**Hybrid Locality and PC-Frequency Replacement (HLPCFR)**,"HLPCFR combines spatial locality tracking, temporal reuse estimation, and program counter (PC) frequency analysis to select cache victims adaptively. For workloads with regular, stride-based memory accesses (e.g., LBM, MILC regular phases), it prioritizes blocks with high spatial locality and recent reuse, retaining those likely to be reused soon. For workloads dominated by pointer-chasing or irregular access (e.g., MCF, OMNETPP, ASTAR), it favors blocks accessed by frequently observed PCs, assuming these PCs represent recurring pointer dereferences. On every access, HLPCFR updates per-block reuse counters, per-set stride detection, and per-set PC frequency tables. Victim selection uses a hybrid score: blocks are ranked by a weighted sum of their reuse distance, spatial proximity to recent accesses, and PC frequency, with weights dynamically adjusted based on detected access patterns. This approach balances retention of both spatially local and pointer-chased blocks, minimizing cache pollution and improving hit rates across diverse workload behaviors.",,ChampSim_CRC2/new_policies/016_hybrid_locality_and_pc_frequency_replacement__hlpcfr.cc,0.263027883,0.263027883,26%
612,astar,**Adaptive Recency and Pointer-Aware Replacement (ARP)**,"ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.290550326,0.290550326,0%
613,lbm,**Adaptive Recency and Pointer-Aware Replacement (ARP)**,"ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.438428392,0.438428392,0%
614,mcf,**Adaptive Recency and Pointer-Aware Replacement (ARP)**,"ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.2846691,0.2846691,0%
615,milc,**Adaptive Recency and Pointer-Aware Replacement (ARP)**,"ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.304256381,0.304256381,0%
616,omnetpp,**Adaptive Recency and Pointer-Aware Replacement (ARP)**,"ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.004868118,0.004868118,0%
617,all,**Adaptive Recency and Pointer-Aware Replacement (ARP)**,"ARP is a hybrid cache replacement policy that dynamically balances recency, spatial locality, and pointer-chasing awareness to maximize hit rates across diverse workloads. It maintains per-line LRU stack positions for temporal locality, tracks recent access strides for spatial reuse, and monitors pointer-chasing intensity by counting dereference-dominated PCs within each set. During victim selection, ARP adaptively prioritizes LRU eviction for regular/spatial workloads (e.g., LBM, MILC), but switches to pointer-aware retention for irregular, pointer-heavy workloads (e.g., MCF, OMNETPP, ASTAR) by protecting lines frequently accessed via pointer-chasing PCs. The policy detects workload phase changes by observing stride regularity and pointer PC frequency, dynamically shifting eviction preference. This approach reduces cache pollution from unpredictable accesses while retaining blocks likely to be reused, improving overall performance across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/017_adaptive_recency_and_pointer_aware_replacement__arp.cc,0.264554463,0.264554463,26%
618,astar,**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**,"DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.290520154,0.290520154,0%
619,lbm,**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**,"DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.416737877,0.416737877,0%
620,mcf,**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**,"DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.237688006,0.237688006,0%
621,milc,**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**,"DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.304256381,0.304256381,0%
622,omnetpp,**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**,"DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.005369682,0.005369682,0%
623,all,**Dynamic Reuse and Spatial-Temporal Adaptive Replacement (DRSTAR)**,"DRSTAR is a hybrid cache replacement policy that combines dynamic reuse distance tracking, spatial locality awareness, and adaptive phase detection to optimize cache performance across diverse workloads. Each cache line maintains a lightweight reuse counter and a spatial reuse flag, while each set tracks recent access patterns to detect whether the workload is currently regular (spatial/temporal locality) or irregular (pointer-chasing, unpredictable branching). In regular phases (e.g., LBM, MILC), DRSTAR prioritizes retention of lines with high reuse counts and spatial locality, evicting those with low reuse and poor spatial alignment. In irregular phases (e.g., MCF, OMNETPP, ASTAR), it shifts to a recency-biased policy, evicting the least recently used lines, but opportunistically protects lines with recent hits. Phase changes are detected using moving averages of reuse distances and stride regularity. This approach leverages both short-term and long-term reuse signals, adapting to phase transitions and minimizing cache pollution, leading to improved hit rates across all workload types.",,ChampSim_CRC2/new_policies/018_dynamic_reuse_and_spatial_temporal_adaptive_replacement__drstar.cc,0.25091442,0.25091442,25%
624,astar,**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**,"SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.",,ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.290550326,0.290550326,0%
625,lbm,**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**,"SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.",,ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.439737459,0.439737459,0%
626,mcf,**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**,"SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.",,ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.297501092,0.297501092,0%
627,milc,**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**,"SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.",,ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.304256381,0.304256381,0%
628,omnetpp,**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**,"SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.",,ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.004868118,0.004868118,0%
629,all,**Segmented Adaptive Replacement with Dynamic Frequency and Recency (SARD-FR)**,"SARD-FR divides each cache set into two logical segments: a ""Recency Segment"" and a ""Frequency Segment."" The Recency Segment tracks blocks that have been recently accessed, capturing short-term temporal locality, while the Frequency Segment retains blocks with high hit counts, targeting long-term reuse and spatial locality. The policy dynamically adjusts the segment sizes per set based on ongoing hit/miss patterns and stride regularity, detected via lightweight history buffers. On insertion, blocks are placed in the Recency Segment; on repeated hits, they migrate to the Frequency Segment. Victim selection prefers evicting blocks from the Recency Segment unless the Frequency Segment is underutilized or polluted. This hybrid approach adapts to both regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads, balancing protection of frequently reused lines with responsiveness to phase changes and unpredictable access patterns. The result is improved hit rates by minimizing cache pollution and retaining blocks with both short-term and long-term reuse potential.",,ChampSim_CRC2/new_policies/019_segmented_adaptive_replacement_with_dynamic_frequency_and_recency__sard_fr.cc,0.267382675,0.267382675,27%
630,astar,**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**,"HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.",,ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.290399469,0.290399469,0%
631,lbm,**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**,"HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.",,ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.41786513,0.41786513,0%
632,mcf,**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**,"HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.",,ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.202655172,0.202655172,0%
633,milc,**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**,"HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.",,ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.304256381,0.304256381,0%
634,omnetpp,**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**,"HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.",,ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.005369682,0.005369682,0%
635,all,**Hybrid Signature-based Reuse and Adaptive Recency (HSRAR)**,"HSRAR combines signature-based reuse prediction with adaptive recency management to dynamically balance protection of frequently reused lines and responsiveness to phase changes and irregular access patterns. Each cache set tracks a compact history of access signatures (derived from PC and address bits), enabling detection of blocks likely to be reused soon even in irregular workloads (e.g., MCF, OMNETPP, ASTAR). For regular workloads (e.g., LBM, MILC), the policy adapts by increasing recency protection when spatial locality is detected. Victim selection prioritizes eviction of blocks with low predicted reuse (based on signature counters) and least recent use, reducing cache pollution and improving hit rates. The policy self-tunes per set using hit/miss feedback and signature reuse statistics, ensuring robust performance across workloads with varying locality and control-flow characteristics.",,ChampSim_CRC2/new_policies/020_hybrid_signature_based_reuse_and_adaptive_recency__hsrar.cc,0.244109167,0.244109167,24%
636,astar,**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**,"DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.",,ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.287442674,0.287442674,0%
637,lbm,**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**,"DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.",,ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.407374411,0.407374411,0%
638,mcf,**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**,"DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.",,ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.159000914,0.159000914,0%
639,milc,**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**,"DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.",,ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.27955226,0.27955226,0%
640,omnetpp,**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**,"DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.",,ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.005487697,0.005487697,0%
641,all,**Dynamic Multi-Feature Reuse and Locality Tracker (DMFRLT)**,"DMFRLT combines per-block reuse prediction, spatial locality tracking, and adaptive aging to robustly handle diverse workloads. Each cache line maintains a reuse counter (updated on hits/misses), a spatial locality flag (set when stride patterns are detected), and an adaptive aging value (decays with misses to allow phase changes). The policy uses recent access history (PC, address stride, and set-level hit/miss statistics) to dynamically boost protection for blocks with high reuse or spatial locality, while allowing rapid eviction of blocks that lose locality or reuse. Victim selection prioritizes blocks with low reuse, no spatial locality, and high age, but falls back to LRU if all blocks are predicted useful. This hybrid approach ensures strong performance on regular (LBM, MILC) and irregular (MCF, OMNETPP, ASTAR) workloads by balancing retention of useful lines and responsiveness to changing access patterns.",,ChampSim_CRC2/new_policies/021_dynamic_multi_feature_reuse_and_locality_tracker__dmfrlt.cc,0.227771591,0.227771591,23%
642,astar,**Phase-Adaptive Segmented Frequency and Recency (PASFR)**,"PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.285541878,0.285541878,0%
643,lbm,**Phase-Adaptive Segmented Frequency and Recency (PASFR)**,"PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.394701915,0.394701915,0%
644,mcf,**Phase-Adaptive Segmented Frequency and Recency (PASFR)**,"PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.165166667,0.165166667,0%
645,milc,**Phase-Adaptive Segmented Frequency and Recency (PASFR)**,"PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.278910595,0.278910595,0%
646,omnetpp,**Phase-Adaptive Segmented Frequency and Recency (PASFR)**,"PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.00858559,0.00858559,0%
647,all,**Phase-Adaptive Segmented Frequency and Recency (PASFR)**,"PASFR divides each cache set into two logical segments: a ""hot"" segment for blocks with high reuse/frequency and a ""cold"" segment for recently inserted or less-reused blocks. Each line tracks a frequency counter (updated on hits), a recency timestamp, and a short-term reuse window to detect phase changes. On insertion, blocks are placed in the cold segment; frequent hits promote them to hot. Victim selection prefers evicting the coldest, least-frequent block, but adapts by demoting hot blocks if their reuse drops or if phase changes are detected (e.g., a surge in misses or a drop in hit rate). This design combines the strengths of LFU and LRU, while adaptively responding to phase changes and workload diversity (e.g., regular for LBM/MILC, irregular for MCF/OMNETPP/ASTAR). PASFR avoids cache pollution by quickly evicting non-reused blocks, but retains frequently reused lines even if their recency decays, improving hit rate across both regular and irregular workloads.",,ChampSim_CRC2/new_policies/022_phase_adaptive_segmented_frequency_and_recency__pasfr.cc,0.226581329,0.226581329,23%
648,astar,**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**,"DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.",,ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.288408158,0.288408158,0%
649,lbm,**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**,"DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.",,ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.439737459,0.439737459,0%
650,mcf,**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**,"DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.",,ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.204533438,0.204533438,0%
651,milc,**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**,"DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.",,ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.27955226,0.27955226,0%
652,omnetpp,**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**,"DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.",,ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.004750103,0.004750103,0%
653,all,**Dynamic Reuse-Interval and Spatial Correlation Replacement (DRISCR)**,"DRISCR is a hybrid policy that dynamically adapts to workload characteristics by combining per-line reuse interval tracking, spatial correlation detection, and fallback LRU. Each cache line records its last access timestamp and a predicted reuse interval, allowing the policy to estimate when a block will be reused. For workloads with strong spatial locality (e.g., LBM, MILC), DRISCR identifies access strides and prefetches or retains blocks that are likely to be accessed soon. For irregular workloads (e.g., MCF, OMNETPP, ASTAR), it prioritizes eviction of lines with long predicted reuse intervals and low spatial correlation. Phase changes are detected by monitoring the set-level hit/miss ratio, triggering more aggressive eviction of blocks with decaying reuse or spatial signals. This approach improves hit rate by retaining blocks with imminent reuse, adapting to both regular and irregular access patterns, and reducing cache pollution from transient accesses.",,ChampSim_CRC2/new_policies/023_dynamic_reuse_interval_and_spatial_correlation_replacement__driscr.cc,0.243396284,0.243396284,24%
654,astar,Adaptive Frequency-Spatial Hybrid Replacement (AFSHR),"AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.",,ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.287955588,0.287955588,0%
655,lbm,Adaptive Frequency-Spatial Hybrid Replacement (AFSHR),"AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.",,ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.419137834,0.419137834,0%
656,mcf,Adaptive Frequency-Spatial Hybrid Replacement (AFSHR),"AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.",,ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.160863918,0.160863918,0%
657,milc,Adaptive Frequency-Spatial Hybrid Replacement (AFSHR),"AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.",,ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.27958369,0.27958369,0%
658,omnetpp,Adaptive Frequency-Spatial Hybrid Replacement (AFSHR),"AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.",,ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.005487697,0.005487697,0%
659,all,Adaptive Frequency-Spatial Hybrid Replacement (AFSHR),"AFSHR combines frequency-based replacement (LFU) with spatial locality detection, dynamically adapting its eviction strategy based on observed workload behavior. Each cache line tracks both its access frequency and a spatial locality score based on recent stride patterns. For workloads with regular, stride-based accesses (LBM, MILC), AFSHR prioritizes retaining lines with high spatial scores, boosting hit rates by keeping blocks likely to be reused soon. For irregular, pointer-heavy workloads (MCF, OMNETPP, ASTAR), the policy falls back to evicting lines with the lowest frequency, which are least likely to be reused. Phase changes are detected by monitoring the set-level hit/miss ratio; during low-locality phases, the policy increases the weight of frequency in eviction decisions. This hybrid approach balances retention of frequently accessed blocks and blocks with strong spatial correlation, improving performance across diverse workload patterns.",,ChampSim_CRC2/new_policies/024_adaptive_frequency_spatial_hybrid_replacement__afshr.cc,0.230605745,0.230605745,23%
660,astar,Dynamic Multi-Signal Replacement (DMSR),"DMSR leverages a combination of recency (LRU), frequency (LFU), and reuse distance prediction to adaptively select the most suitable eviction candidate for each workload phase. Each cache line tracks its last access time, access frequency, and a lightweight reuse distance estimate using a saturating counter. The policy dynamically weights these signals based on observed set-level hit/miss trends and stride regularity: for workloads with regular spatial access (LBM, MILC), DMSR emphasizes reuse distance and recency to retain blocks likely to be reused soon; for pointer-heavy, irregular workloads (MCF, OMNETPP, ASTAR), it prioritizes frequency and recency to avoid retaining dead blocks. Phase changes are detected via a moving hit/miss window, triggering adaptive weighting of signals. This multi-signal, phase-aware approach improves overall hit rates by tailoring eviction logic to workload characteristics, outperforming single-signal and static hybrid policies.",,ChampSim_CRC2/new_policies/025_dynamic_multi_signal_replacement__dmsr.cc,0.290520154,0.290520154,0%
661,lbm,Dynamic Multi-Signal Replacement (DMSR),"DMSR leverages a combination of recency (LRU), frequency (LFU), and reuse distance prediction to adaptively select the most suitable eviction candidate for each workload phase. Each cache line tracks its last access time, access frequency, and a lightweight reuse distance estimate using a saturating counter. The policy dynamically weights these signals based on observed set-level hit/miss trends and stride regularity: for workloads with regular spatial access (LBM, MILC), DMSR emphasizes reuse distance and recency to retain blocks likely to be reused soon; for pointer-heavy, irregular workloads (MCF, OMNETPP, ASTAR), it prioritizes frequency and recency to avoid retaining dead blocks. Phase changes are detected via a moving hit/miss window, triggering adaptive weighting of signals. This multi-signal, phase-aware approach improves overall hit rates by tailoring eviction logic to workload characteristics, outperforming single-signal and static hybrid policies.",,ChampSim_CRC2/new_policies/025_dynamic_multi_signal_replacement__dmsr.cc,0.418628752,0.418628752,0%
662,astar,Adaptive SRRIP-Bimodal Replacement (ASBR),"ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.",,ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.256456674,0.256456674,0%
663,lbm,Adaptive SRRIP-Bimodal Replacement (ASBR),"ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.",,ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.043599207,0.043599207,0%
664,mcf,Adaptive SRRIP-Bimodal Replacement (ASBR),"ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.",,ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.260303339,0.260303339,0%
665,milc,Adaptive SRRIP-Bimodal Replacement (ASBR),"ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.",,ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.007129616,0.007129616,0%
666,omnetpp,Adaptive SRRIP-Bimodal Replacement (ASBR),"ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.",,ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.003628961,0.003628961,0%
667,all,Adaptive SRRIP-Bimodal Replacement (ASBR),"ASBR combines Static Re-Reference Interval Prediction (SRRIP) with a lightweight bimodal bypassing mechanism. SRRIP assigns re-reference prediction values to cache lines, favoring retention of lines likely to be reused soon, which benefits workloads with both spatial and temporal locality (e.g., lbm, milc). For sets experiencing frequent misses and low reuse (e.g., mcf, omnetpp), ASBR dynamically bypasses insertion of new blocks with a small probability, reducing pollution from one-shot or streaming accesses. The policy adapts insertion and promotion based on recent hit/miss statistics per set, allowing it to respond to phase changes and irregular patterns. This hybrid approach improves hit rates by better retaining reusable lines and avoiding cache pollution from unpredictable workloads.",,ChampSim_CRC2/new_policies/001_adaptive_srrip_bimodal_replacement__asbr.cc,0.114223559,0.114223559,11%
668,astar,Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA),"DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.",,ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.258206614,0.258206614,0%
669,lbm,Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA),"DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.",,ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.274322285,0.274322285,0%
670,mcf,Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA),"DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.",,ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.159571717,0.159571717,0%
671,milc,Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA),"DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.",,ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.281548553,0.281548553,0%
672,omnetpp,Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA),"DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.",,ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.003923998,0.003923998,0%
673,all,Dynamic Segmented LRU with Frequency Adaptation (DS-LRUFA),"DS-LRUFA divides each cache set into two logical segments: an ""LRU"" segment for lines with demonstrated reuse and a ""FIFO"" segment for lines with low or unpredictable reuse, dynamically adapting segment sizes per set. Hits in the LRU segment promote lines to the MRU position, while hits in the FIFO segment move lines into the LRU segment, indicating a transition to reusable behavior. The policy tracks per-set hit/miss patterns and recent reuse frequency to adjust the segment boundary: sets with high locality (e.g., lbm, milc) expand the LRU segment, while sets with streaming or sparse accesses (e.g., mcf, omnetpp, astar) shrink it, favoring FIFO eviction to reduce pollution. Additionally, a lightweight frequency counter per block helps retain frequently reused lines, and blocks with zero frequency in the FIFO segment are prioritized for eviction. This hybrid approach balances spatial/temporal locality retention for regular workloads and aggressive eviction for irregular ones, improving hit rates across diverse access patterns and phase changes.",,ChampSim_CRC2/new_policies/002_dynamic_segmented_lru_with_frequency_adaptation__ds_lrufa.cc,0.195514633,0.195514633,20%
674,astar,Adaptive RRIP with Dynamic Bypass (ARRIP-DB),"ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.016352884,0.016352884,0%
675,lbm,Adaptive RRIP with Dynamic Bypass (ARRIP-DB),"ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.043581026,0.043581026,0%
676,mcf,Adaptive RRIP with Dynamic Bypass (ARRIP-DB),"ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.019062671,0.019062671,0%
677,milc,Adaptive RRIP with Dynamic Bypass (ARRIP-DB),"ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.007093968,0.007093968,0%
678,omnetpp,Adaptive RRIP with Dynamic Bypass (ARRIP-DB),"ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.000295037,0.000295037,0%
679,all,Adaptive RRIP with Dynamic Bypass (ARRIP-DB),"ARRIP-DB combines the proven strengths of Re-Reference Interval Prediction (RRIP) with a lightweight, per-set dynamic bypass mechanism to address the diverse locality and access patterns of the provided workloads. RRIP excels at distinguishing between frequently and infrequently reused lines, making it robust for both regular (lbm, milc) and irregular (mcf, omnetpp, astar) access patterns. To further reduce pollution from streaming or sparse accesses, ARRIP-DB tracks the recent hit/miss ratio per set: if a set is experiencing low hit rates (indicative of streaming or pointer-chasing phases), new incoming lines are probabilistically bypassed (not inserted) into the cache, reducing pollution and preserving useful data. This adaptive bypass is periodically re-evaluated, allowing the cache to respond to phase changes and workload shifts. The combination of RRIP and dynamic bypass ensures high retention for reusable lines, aggressive eviction for non-reusable lines, and rapid adaptation to changing access patterns, improving overall hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_adaptive_rrip_with_dynamic_bypass__arrip_db.cc,0.017277117,0.017277117,2%
680,astar,Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F),"HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.287442674,0.287442674,0%
681,lbm,Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F),"HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.407374411,0.407374411,0%
682,mcf,Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F),"HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.160523911,0.160523911,0%
683,milc,Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F),"HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.27958369,0.27958369,0%
684,omnetpp,Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F),"HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.005487697,0.005487697,0%
685,all,Hybrid SRRIP with Per-Set Frequency Tracking (HSRRIP-F),"HSRRIP-F combines Static Re-Reference Interval Prediction (SRRIP) with lightweight per-set frequency tracking to adapt to both regular and irregular workload phases. SRRIP provides robust retention of reusable lines and quick eviction of non-reusable lines, which is effective for workloads with both spatial and temporal locality (like lbm, milc) and those with irregular access (like mcf, omnetpp, astar). To further improve adaptability, each set maintains a small frequency counter for each way, incremented on hits and decayed periodically. When selecting a victim, the policy prefers blocks with both high RRIP and low frequency, ensuring that frequently reused lines are retained even if their recency is low. On insertion, the policy dynamically chooses between ""long"" (distant re-reference) and ""short"" (imminent re-reference) RRIP values based on the set's recent hit rate, promoting more aggressive retention during high-locality phases and faster eviction during streaming or pointer-chasing phases. This hybrid approach provides resilience against cache pollution, adapts to phase changes, and leverages both recency and frequency signals for improved hit rates across all workloads.",,ChampSim_CRC2/new_policies/004_hybrid_srrip_with_per_set_frequency_tracking__hsrrip_f.cc,0.228082477,0.228082477,23%
686,astar,**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**,"DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.290520154,0.290520154,0%
687,lbm,**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**,"DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.437555681,0.437555681,0%
688,mcf,**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**,"DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.291983724,0.291983724,0%
689,milc,**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**,"DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.304256381,0.304256381,0%
690,omnetpp,**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**,"DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.004602585,0.004602585,0%
691,all,**Dynamic Bimodal RRIP with PC-Based Reuse Prediction (DBRRP-PC)**,"DBRRP-PC augments SRRIP with a lightweight, per-set bimodal insertion policy and a global PC-based reuse predictor. The bimodal insertion adapts between ""protective"" (low RRIP) and ""aggressive"" (high RRIP) modes based on recent set-level hit/miss patterns, improving retention for workloads with both streaming and phase-locality (e.g., lbm, milc). The PC-based predictor tracks whether specific instruction PCs typically lead to cache hits or misses, allowing the policy to insert blocks with short RRIP for PCs with high reuse and long RRIP for streaming or pointer-chasing PCs (e.g., mcf, omnetpp, astar). This combination enables fast adaptation to phase changes, protects reusable lines, and prevents pollution from irregular accesses, yielding higher hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/005_dynamic_bimodal_rrip_with_pc_based_reuse_prediction__dbrrp_pc.cc,0.265783705,0.265783705,27%
692,astar,Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP),"AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.",,ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.290520154,0.290520154,0%
693,lbm,Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP),"AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.",,ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.437555681,0.437555681,0%
694,mcf,Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP),"AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.",,ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.291983724,0.291983724,0%
695,milc,Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP),"AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.",,ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.304256381,0.304256381,0%
696,omnetpp,Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP),"AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.",,ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.004602585,0.004602585,0%
697,all,Adaptive Multi-Feature Reuse and Spatial Locality Predictor (AMFRSLP),"AMFRSLP combines three complementary mechanisms to maximize cache hit rates across diverse workloads: (1) a global PC-based reuse predictor for capturing instruction-driven temporal locality, (2) a per-set spatial locality tracker that detects regular stride patterns and enables selective protection of blocks likely to be reused soon (ideal for lbm and milc), and (3) a lightweight phase detector that adapts insertion aggressiveness based on recent set-level hit/miss statistics. On each insertion, AMFRSLP consults both the PC reuse predictor and the spatial locality tracker: blocks from PCs with high reuse or sets with strong spatial patterns are inserted with low RRIP (protected), while others are inserted with high RRIP (aggressive eviction). The policy dynamically tunes its behavior to streaming, pointer-chasing, and phase-changing workloads, reducing pollution and retaining reusable lines. This hybrid approach is designed to outperform simple recency or PC-only policies, especially in workloads with mixed or evolving locality.",,ChampSim_CRC2/new_policies/006_adaptive_multi_feature_reuse_and_spatial_locality_predictor__amfrslp.cc,0.265783705,0.265783705,27%
698,astar,Dynamic Segmented Frequency and Recency Replacement (DSFRR),"DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.",,ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.289554671,0.289554671,0%
699,lbm,Dynamic Segmented Frequency and Recency Replacement (DSFRR),"DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.",,ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.43033763,0.43033763,0%
700,mcf,Dynamic Segmented Frequency and Recency Replacement (DSFRR),"DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.",,ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.262652444,0.262652444,0%
701,milc,Dynamic Segmented Frequency and Recency Replacement (DSFRR),"DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.",,ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.304256381,0.304256381,0%
702,omnetpp,Dynamic Segmented Frequency and Recency Replacement (DSFRR),"DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.",,ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.002448811,0.002448811,0%
703,all,Dynamic Segmented Frequency and Recency Replacement (DSFRR),"DSFRR divides each cache set into two segments: a ""protected"" segment for blocks with demonstrated high reuse (frequency) and a ""probationary"" segment for newly inserted or low-reuse blocks. Each block tracks both a short frequency counter and a recency position (LRU within segment). On insertion, blocks are placed in the probationary segment; if they are hit multiple times within a short window, they are promoted to the protected segment. Victim selection prefers eviction from the probationary segment unless all blocks are protected. This approach combines the strengths of frequency-based protection (for workloads like lbm and milc with regular reuse) and recency-based eviction (for pointer-chasing, phase-changing, or streaming workloads like mcf, omnetpp, astar), dynamically adapting to workload changes. DSFRR avoids pollution from transient accesses while retaining reusable lines, outperforming pure recency or frequency policies across mixed workloads.",,ChampSim_CRC2/new_policies/007_dynamic_segmented_frequency_and_recency_replacement__dsfrr.cc,0.257849987,0.257849987,26%
704,astar,Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion,"AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.016352884,0.016352884,0%
705,lbm,Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion,"AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.043581026,0.043581026,0%
706,mcf,Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion,"AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.019062671,0.019062671,0%
707,milc,Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion,"AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.007093968,0.007093968,0%
708,omnetpp,Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion,"AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.000295037,0.000295037,0%
709,all,Adaptive Dynamic Re-reference Interval Prediction (AD-RRIP) with Segment-aware Insertion,"AD-RRIP combines the strengths of Re-reference Interval Prediction (RRIP) with adaptive insertion and segment-aware promotion to better handle diverse workload behaviors. Each block is assigned a re-reference prediction value (RRPV) that estimates how soon it will be reused; low RRPV means likely reuse, high RRPV means likely dead. On insertion, the policy dynamically chooses between ""long"" (high RRPV) and ""short"" (low RRPV) insertion based on recent hit/miss patterns in the set, adapting between scan-resistant (good for mcf, omnetpp, astar) and reuse-friendly (good for lbm, milc) modes. Additionally, the policy tracks spatial locality by favoring blocks accessed in nearby addresses (segment-aware), promoting them to lower RRPV when detected. This hybrid approach improves performance by retaining reusable lines, avoiding pollution from transient accesses, and responding quickly to phase changes and locality shifts in the workload.",,ChampSim_CRC2/new_policies/008_adaptive_dynamic_re_reference_interval_prediction__ad_rrip__with_segment_aware_insertion.cc,0.017277117,0.017277117,2%
710,astar,Multi-Feature Signature-Based Dynamic Replacement (MF-SDR),"MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.",,ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.017076997,0.017076997,0%
711,lbm,Multi-Feature Signature-Based Dynamic Replacement (MF-SDR),"MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.",,ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.050180906,0.050180906,0%
712,mcf,Multi-Feature Signature-Based Dynamic Replacement (MF-SDR),"MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.",,ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.024016689,0.024016689,0%
713,milc,Multi-Feature Signature-Based Dynamic Replacement (MF-SDR),"MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.",,ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.008306003,0.008306003,0%
714,omnetpp,Multi-Feature Signature-Based Dynamic Replacement (MF-SDR),"MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.",,ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.004779607,0.004779607,0%
715,all,Multi-Feature Signature-Based Dynamic Replacement (MF-SDR),"MF-SDR leverages a compact signature per cache block, capturing a blend of PC (program counter), address region, and recent reuse history to dynamically classify blocks as either ""reuse-friendly"" or ""transient."" On insertion, the policy uses a learned signature table to decide between protective (low RRPV) or aggressive (high RRPV) insertion, adapting to workload phases. For workloads like lbm and milc with strong spatial locality, the signature table quickly learns to protect blocks with recurring region+PC patterns. For irregular workloads (mcf, omnetpp, astar), the policy rapidly identifies transient patterns and inserts them with high RRPV, minimizing pollution. The signature table is updated on every access, and the policy includes a lightweight recency counter to boost blocks with detected temporal locality. This hybrid, multi-feature approach improves hit rates by dynamically learning and adapting to both spatial and temporal locality, as well as control-flow-driven access patterns.",,ChampSim_CRC2/new_policies/009_multi_feature_signature_based_dynamic_replacement__mf_sdr.cc,0.020872041,0.020872041,2%
716,astar,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.015870142,0.015870142,0%
717,lbm,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.030090362,0.030090362,0%
718,mcf,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.013884978,0.013884978,0%
719,milc,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.007093968,0.007093968,0%
720,omnetpp,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.000147519,0.000147519,0%
721,all,Adaptive Phase-Aware Reuse Predictor (APARP),"APARP combines phase detection, spatial/temporal locality tracking, and program-context reuse prediction to dynamically adapt its eviction decisions. It maintains lightweight phase signatures per set, monitors recent spatial and temporal reuse, and leverages PC-based reuse histories. By detecting phase changes (e.g., switch from regular to irregular access), it shifts between LRU-like, MRU-like, or predictive eviction strategies. APARP’s hybrid approach allows it to excel in workloads with mixed or changing locality (MILC, omnetpp), irregular reuse (mcf, astar), and regular streaming patterns (lbm), outperforming static or single-mode policies. Its tunable knobs include phase window size, reuse confidence thresholds, and spatial locality sensitivity.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_predictor__aparp.cc,0.013417394,0.013417394,1%
722,astar,**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**,"MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.",,ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.170287231,0.170287231,0%
723,lbm,**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**,"MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.",,ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.264340648,0.264340648,0%
724,mcf,**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**,"MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.",,ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.209001201,0.209001201,0%
725,milc,**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**,"MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.",,ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.190681591,0.190681591,0%
726,omnetpp,**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**,"MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.",,ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.00259633,0.00259633,0%
727,all,**Multi-Feature Dynamic Reuse and Recency (MF-DRR)**,"MF-DRR integrates multiple lightweight reuse indicators—recency, frequency, spatial proximity, and program-context (PC) correlation—into a unified scoring system to guide cache block eviction. Each block tracks its last access time, hit count, and last PC, while each set maintains a short history of recent addresses to infer spatial locality. The victim selection process dynamically weighs these features: blocks with low hit count (frequency), distant access time (recency), poor spatial proximity to recent accesses, and PCs with historically low reuse are prioritized for eviction. This multi-feature approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads, improving over static or single-feature policies by leveraging complementary signals and avoiding overfitting to any one pattern. The result is robust performance across diverse access behaviors and phase changes.",,ChampSim_CRC2/new_policies/001_multi_feature_dynamic_reuse_and_recency__mf_drr.cc,0.1673814,0.1673814,17%
728,astar,Adaptive Segmented Reuse and Frequency (ASRF),"ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.",,ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.019038137,0.019038137,0%
729,lbm,Adaptive Segmented Reuse and Frequency (ASRF),"ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.",,ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.034635734,0.034635734,0%
730,mcf,Adaptive Segmented Reuse and Frequency (ASRF),"ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.",,ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.016976816,0.016976816,0%
731,milc,Adaptive Segmented Reuse and Frequency (ASRF),"ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.",,ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.009838871,0.009838871,0%
732,omnetpp,Adaptive Segmented Reuse and Frequency (ASRF),"ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.",,ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.003186405,0.003186405,0%
733,all,Adaptive Segmented Reuse and Frequency (ASRF),"ASRF divides each cache set into two logical segments: a **Reuse Segment** (tracking blocks with recent reuse) and a **Frequency Segment** (tracking blocks accessed frequently but not necessarily recently). Each block maintains a lightweight reuse counter and a frequency counter. On every access, blocks are promoted between segments based on recent hits and frequency thresholds. Victim selection prioritizes blocks in the Frequency Segment with low frequency and reuse, while blocks in the Reuse Segment are protected unless their reuse counter drops. This hybrid approach adapts to both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by dynamically balancing recency and frequency: regular patterns benefit from frequency retention, while irregular/pointer-heavy workloads favor recency-based eviction. The segmentation prevents pollution from phase changes and speculative execution, improving hit rates across diverse access behaviors.",,ChampSim_CRC2/new_policies/002_adaptive_segmented_reuse_and_frequency__asrf.cc,0.016735192,0.016735192,2%
734,astar,**Phase-Adaptive Multi-Locality Replacement (PAMLR)**,"PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.",,ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.015870142,0.015870142,0%
735,lbm,**Phase-Adaptive Multi-Locality Replacement (PAMLR)**,"PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.",,ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.030090362,0.030090362,0%
736,mcf,**Phase-Adaptive Multi-Locality Replacement (PAMLR)**,"PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.",,ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.013884978,0.013884978,0%
737,milc,**Phase-Adaptive Multi-Locality Replacement (PAMLR)**,"PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.",,ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.007093968,0.007093968,0%
738,omnetpp,**Phase-Adaptive Multi-Locality Replacement (PAMLR)**,"PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.",,ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.000147519,0.000147519,0%
739,all,**Phase-Adaptive Multi-Locality Replacement (PAMLR)**,"PAMLR dynamically adapts to both regular and irregular workload phases by combining three locality heuristics: **Recency**, **Frequency**, and **Spatial Grouping**. Each cache block tracks a lightweight recency counter (for LRU-like behavior), a frequency counter (for repeated accesses), and a spatial group tag (for blocks accessed together in bursts, e.g., stencils or pointer traversals). The policy periodically detects workload phase shifts by monitoring locality statistics at the set level. During regular phases (e.g., lbm, milc), it prioritizes retaining blocks with high spatial and frequency locality, supporting predictable stride and reuse. During irregular or control-dominated phases (e.g., mcf, astar, omnetpp), it shifts to recency-based eviction to quickly respond to unpredictable accesses. Victim selection uses a weighted score combining all three metrics, with weights auto-tuned per set based on observed hit/miss patterns. This approach prevents cache pollution during phase transitions and improves hit rates by adapting to both deterministic and unpredictable access patterns.",,ChampSim_CRC2/new_policies/003_phase_adaptive_multi_locality_replacement__pamlr.cc,0.013417394,0.013417394,1%
740,astar,**Hybrid RRIP-Bloom Replacement (HRBR)**,"HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.",,ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.290520154,0.290520154,0%
741,lbm,**Hybrid RRIP-Bloom Replacement (HRBR)**,"HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.",,ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.425392266,0.425392266,0%
742,mcf,**Hybrid RRIP-Bloom Replacement (HRBR)**,"HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.",,ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.296513633,0.296513633,0%
743,milc,**Hybrid RRIP-Bloom Replacement (HRBR)**,"HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.",,ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.304256381,0.304256381,0%
744,omnetpp,**Hybrid RRIP-Bloom Replacement (HRBR)**,"HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.",,ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.005369682,0.005369682,0%
745,all,**Hybrid RRIP-Bloom Replacement (HRBR)**,"HRBR combines the proven Re-Reference Interval Prediction (RRIP) scheme with a lightweight Bloom filter to dynamically protect blocks exhibiting strong spatial or temporal locality, while efficiently evicting those unlikely to be reused. RRIP assigns each cache block a ""re-reference interval"" counter that predicts its likelihood of reuse: blocks with low counters are protected, while those with high counters are prime eviction candidates. To further boost performance on workloads with regular access patterns (like LBM, MILC) and pointer-chasing (MCF, OMNETPP), HRBR maintains a per-set Bloom filter that tracks recently accessed spatial groups (e.g., page hashes) and pointer-targeted addresses. When selecting a victim, blocks matching the Bloom filter are given a ""bonus"" (their RRIP is temporarily reduced), making them less likely to be evicted. This hybrid approach adapts to both regular (spatial) and irregular (pointer-heavy) phases, prevents pollution, and improves hit rates by leveraging both predictive and history-based locality signals.",,ChampSim_CRC2/new_policies/008_hybrid_rrip_bloom_replacement__hrbr.cc,0.264410423,0.264410423,26%
746,astar,**Adaptive Segmented Locality Replacement (ASLR)**,"ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.",,ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.200699976,0.200699976,0%
747,lbm,**Adaptive Segmented Locality Replacement (ASLR)**,"ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.",,ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.361666152,0.361666152,0%
748,mcf,**Adaptive Segmented Locality Replacement (ASLR)**,"ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.",,ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.231154739,0.231154739,0%
749,milc,**Adaptive Segmented Locality Replacement (ASLR)**,"ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.",,ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.159204335,0.159204335,0%
750,omnetpp,**Adaptive Segmented Locality Replacement (ASLR)**,"ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.",,ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.003805983,0.003805983,0%
751,all,**Adaptive Segmented Locality Replacement (ASLR)**,"ASLR divides each cache set into two logical segments: a ""Locality"" segment and a ""General"" segment. The Locality segment is reserved for blocks that demonstrate strong spatial or temporal locality, detected via recent hits and access patterns (e.g., repeated page or pointer accesses). The General segment handles all other blocks, managed by a simple RRIP scheme. A lightweight per-set access history tracks recent page hashes and pointer targets, dynamically adjusting segment boundaries based on observed phase changes and hit/miss statistics. Blocks with repeated hits or matching locality signals are promoted to the Locality segment, where they are protected from eviction unless the segment is full. This approach improves performance by preventing pollution from irregular accesses (MCF, OMNETPP) while retaining blocks with high reuse (LBM, MILC, ASTAR), and adapts to phase changes by adjusting segment membership and boundaries. The result is a cache that balances protection for locality-heavy blocks with flexibility for diverse workloads.",,ChampSim_CRC2/new_policies/009_adaptive_segmented_locality_replacement__aslr.cc,0.191306237,0.191306237,19%
752,astar,Adaptive Phase-aware Spatial-Temporal Predictor (APSTP),"APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.290550326,0.290550326,0%
753,lbm,Adaptive Phase-aware Spatial-Temporal Predictor (APSTP),"APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.439737459,0.439737459,0%
754,mcf,Adaptive Phase-aware Spatial-Temporal Predictor (APSTP),"APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.290807207,0.290807207,0%
755,milc,Adaptive Phase-aware Spatial-Temporal Predictor (APSTP),"APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.304256381,0.304256381,0%
756,omnetpp,Adaptive Phase-aware Spatial-Temporal Predictor (APSTP),"APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.004868118,0.004868118,0%
757,all,Adaptive Phase-aware Spatial-Temporal Predictor (APSTP),"APSTP combines phase detection, spatial and temporal locality tracking, and PC-based reuse prediction to dynamically adapt its replacement decisions to workload behavior. By monitoring access patterns and detecting phase shifts (e.g., regular vs. irregular, pointer-chasing vs. stencil), APSTP switches between spatially-focused and temporally-focused heuristics. It maintains per-set phase statistics and uses PC signatures to inform reuse likelihood, leveraging spatial clustering for workloads like lbm/milc and temporal recency for astar/mcf/omnetpp. This hybrid, phase-aware approach reduces cache pollution during irregular phases and maximizes reuse during regular phases, outperforming static or single-aspect policies across diverse workloads.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_spatial_temporal_predictor__apstp.cc,0.266043898,0.266043898,27%
758,astar,**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**,"MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.",,ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.015870142,0.015870142,0%
759,lbm,**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**,"MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.",,ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.030090362,0.030090362,0%
760,mcf,**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**,"MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.",,ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.013884978,0.013884978,0%
761,milc,**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**,"MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.",,ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.007093968,0.007093968,0%
762,omnetpp,**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**,"MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.",,ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.000147519,0.000147519,0%
763,all,**Multi-Aspect Dynamic Reuse and Locality (MADRL) Replacement**,"MADRL is a hybrid policy that synergistically combines dynamic reuse prediction, spatial locality clustering, and adaptive recency management to optimize cache replacement across diverse workloads. It tracks per-set access patterns to distinguish between regular (stencil-like) and irregular (pointer-chasing, control-heavy) phases, but instead of hard phase switching, it maintains weighted scores for each line based on recent hits, PC-based reuse, and spatial proximity to other active lines. The policy selects victims by minimizing a composite score that balances recency, predicted reuse, and spatial locality, ensuring that lines likely to be reused (either temporally or spatially) are retained. This approach is robust to phase changes and workload diversity, improving hit rates for both regular (lbm, milc) and irregular (mcf, astar, omnetpp) workloads by avoiding cache pollution and maximizing retention of valuable blocks.",,ChampSim_CRC2/new_policies/001_multi_aspect_dynamic_reuse_and_locality__madrl__replacement.cc,0.013417394,0.013417394,1%
764,astar,**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**,"ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.",,ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.015870142,0.015870142,0%
765,lbm,**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**,"ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.",,ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.030090362,0.030090362,0%
766,mcf,**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**,"ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.",,ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.013884978,0.013884978,0%
767,milc,**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**,"ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.",,ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.007093968,0.007093968,0%
768,omnetpp,**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**,"ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.",,ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.000147519,0.000147519,0%
769,all,**Adaptive Dynamic Reuse with Frequency and Recency (ADR-FR)**,"ADR-FR is a hybrid cache replacement policy combining dynamic reuse distance tracking, frequency-based retention, and recency management to optimize hit rate across diverse workloads. For each cache line, ADR-FR maintains a small saturating counter for access frequency, a recency counter, and a lightweight reuse-distance estimator. On every access, the policy updates these metrics, favoring retention of lines that are both frequently and recently accessed, while deprioritizing lines with long reuse distances. For pointer-chasing and irregular workloads (e.g., mcf, omnetpp), ADR-FR adapts by more aggressively evicting lines with low frequency and long reuse distances, while for regular workloads (e.g., lbm, milc), it retains lines with high frequency and short reuse distances. This approach balances spatial and temporal locality, adapts to phase changes, and avoids cache pollution, resulting in robust performance improvements across all workload types.",,ChampSim_CRC2/new_policies/002_adaptive_dynamic_reuse_with_frequency_and_recency__adr_fr.cc,0.013417394,0.013417394,1%
770,astar,Phase-Aware Dynamic Segmented LRU (PA-DSLRU),"PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.290550326,0.290550326,0%
771,lbm,Phase-Aware Dynamic Segmented LRU (PA-DSLRU),"PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.439737459,0.439737459,0%
772,mcf,Phase-Aware Dynamic Segmented LRU (PA-DSLRU),"PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.290716921,0.290716921,0%
773,milc,Phase-Aware Dynamic Segmented LRU (PA-DSLRU),"PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.304256381,0.304256381,0%
774,omnetpp,Phase-Aware Dynamic Segmented LRU (PA-DSLRU),"PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.004868118,0.004868118,0%
775,all,Phase-Aware Dynamic Segmented LRU (PA-DSLRU),"PA-DSLRU is a phase-aware cache replacement policy that dynamically segments each cache set into ""hot"" and ""cold"" regions based on recent access patterns and adapts its eviction strategy according to detected workload phases. By tracking per-set access frequency and recency, PA-DSLRU identifies periods of regular spatial locality (e.g., in lbm, milc) and switches to a protected LRU for hot lines, while in irregular/pointer-heavy phases (e.g., mcf, omnetpp, astar), it aggressively demotes cold lines and evicts those with minimal reuse. The policy uses lightweight per-set phase detection (via moving average of hits/misses) to guide segment boundaries, ensuring fast adaptation to phase changes. This approach effectively balances retention of frequently reused lines during regular phases and rapid eviction of cache-polluting lines during irregular phases, improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_phase_aware_dynamic_segmented_lru__pa_dslru.cc,0.266025841,0.266025841,27%
776,astar,Adaptive RRIP with Dynamic Bypass (A-RRIP-DB),"A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.",,ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.290520154,0.290520154,0%
777,lbm,Adaptive RRIP with Dynamic Bypass (A-RRIP-DB),"A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.",,ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.425392266,0.425392266,0%
778,mcf,Adaptive RRIP with Dynamic Bypass (A-RRIP-DB),"A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.",,ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.296515972,0.296515972,0%
779,milc,Adaptive RRIP with Dynamic Bypass (A-RRIP-DB),"A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.",,ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.304256381,0.304256381,0%
780,omnetpp,Adaptive RRIP with Dynamic Bypass (A-RRIP-DB),"A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.",,ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.005369682,0.005369682,0%
781,all,Adaptive RRIP with Dynamic Bypass (A-RRIP-DB),"A-RRIP-DB combines the proven Re-Reference Interval Prediction (RRIP) replacement policy with a lightweight, per-set dynamic bypass mechanism that adapts to workload characteristics in real time. RRIP excels at retaining lines with high reuse potential, making it robust for regular, spatially local workloads (like lbm and milc), while its aging mechanism quickly evicts cache-polluting lines common in pointer-heavy, irregular workloads (like mcf, astar, omnetpp). To further boost performance, A-RRIP-DB tracks the hit/miss ratio in each set over a sliding window; if a set’s miss rate is persistently high (indicating cache pollution or thrashing), new incoming lines are probabilistically bypassed (not inserted), reducing pollution and preserving useful data. This hybrid approach leverages RRIP’s adaptability and augments it with selective bypassing, ensuring consistently strong performance across workloads with varying locality and access patterns.",,ChampSim_CRC2/new_policies/005_adaptive_rrip_with_dynamic_bypass__a_rrip_db.cc,0.264410891,0.264410891,26%
782,astar,SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD),"SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.",,ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.290459812,0.290459812,0%
783,lbm,SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD),"SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.",,ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.425428629,0.425428629,0%
784,mcf,SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD),"SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.",,ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.296347596,0.296347596,0%
785,milc,SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD),"SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.",,ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.304256381,0.304256381,0%
786,omnetpp,SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD),"SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.",,ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.005340178,0.005340178,0%
787,all,SRRIP-FIFO Hybrid with Dynamic Set Dueling (SRRIP-FIFO-DSD),"SRRIP-FIFO-DSD combines the strengths of SRRIP (Static Re-Reference Interval Prediction) for workloads with good temporal locality (like lbm, milc, astar) and FIFO for workloads with streaming or highly irregular access patterns (like mcf, omnetpp). The policy uses set dueling: a small fraction of sets are reserved as ""leader"" sets, always using either SRRIP or FIFO. The remaining sets (""follower"" sets) dynamically select the policy that yields the highest hit rate, based on ongoing statistics from the leader sets. This approach allows the cache to adapt globally to workload phase changes and access patterns, leveraging SRRIP's retention for reusable data and FIFO's rapid eviction for cache-polluting streams. By switching policies at the set level, SRRIP-FIFO-DSD robustly handles diverse workloads and phase transitions, improving overall hit rates compared to static or purely adaptive RRIP variants.",,ChampSim_CRC2/new_policies/007_srrip_fifo_hybrid_with_dynamic_set_dueling__srrip_fifo_dsd.cc,0.264366519,0.264366519,26%
788,astar,**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**,"This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.",,ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.290520154,0.290520154,0%
789,lbm,**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**,"This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.",,ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.425392266,0.425392266,0%
790,mcf,**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**,"This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.",,ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.296515972,0.296515972,0%
791,milc,**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**,"This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.",,ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.304256381,0.304256381,0%
792,omnetpp,**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**,"This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.",,ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.005369682,0.005369682,0%
793,all,**Dynamic SRRIP-BIP Hybrid with Per-Set Adaptive Dueling (DSRRIP-BIP-PSAD)**,"This policy combines SRRIP (Static Re-Reference Interval Prediction) and BIP (Bimodal Insertion Policy), leveraging their strengths for different workload behaviors. SRRIP is effective for workloads with moderate to high temporal locality (lbm, milc, astar), while BIP excels at filtering out cache-polluting streams and irregular accesses (mcf, omnetpp) by inserting most lines with low priority and only occasionally with high priority. The policy uses per-set adaptive dueling: each set tracks its own hit/miss statistics for SRRIP and BIP, periodically switching to the policy that yields the best hit rate for that set. This fine-grained adaptation allows sets to respond to local phase changes and access patterns, outperforming global set dueling and static policies. By combining SRRIP’s retention with BIP’s pollution resistance and adapting at the set level, this approach improves overall hit rates across diverse and phase-changing workloads.",,ChampSim_CRC2/new_policies/008_dynamic_srrip_bip_hybrid_with_per_set_adaptive_dueling__dsrrip_bip_psad.cc,0.264410891,0.264410891,26%
794,astar,**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**,"DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.",,ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.290520154,0.290520154,0%
795,lbm,**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**,"DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.",,ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.425392266,0.425392266,0%
796,mcf,**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**,"DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.",,ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.296515972,0.296515972,0%
797,milc,**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**,"DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.",,ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.304256381,0.304256381,0%
798,omnetpp,**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**,"DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.",,ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.005369682,0.005369682,0%
799,all,**Dynamic Multi-Feature Reuse-Aware Replacement (DMRRR)**,"DMRRR combines SRRIP’s recency prediction with real-time, per-set learning of spatial locality and reuse distance, adapting to workload phases and memory patterns. Each set tracks recent hit/miss history, the stride of accesses, and the frequency of reuse for each line. On insertion, lines are prioritized based on predicted reuse: lines with matching stride or recent reuse are inserted with high priority, while others are inserted with low priority (BIP-style). Periodically, sets analyze their own hit/miss and locality statistics to dynamically adjust insertion and promotion policies, favoring SRRIP for temporal locality (lbm, milc, astar) and BIP for irregular/pointer-heavy workloads (mcf, omnetpp). This multi-feature approach enables the policy to respond to spatial, temporal, and phase changes, reducing pollution and improving hit rates across all workload types.",,ChampSim_CRC2/new_policies/009_dynamic_multi_feature_reuse_aware_replacement__dmrrr.cc,0.264410891,0.264410891,26%
800,astar,Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF),"AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.",,ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.287442674,0.287442674,0%
801,lbm,Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF),"AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.",,ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.407374411,0.407374411,0%
802,mcf,Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF),"AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.",,ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.160523911,0.160523911,0%
803,milc,Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF),"AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.",,ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.27958369,0.27958369,0%
804,omnetpp,Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF),"AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.",,ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.005487697,0.005487697,0%
805,all,Adaptive Multi-Granularity Reuse and Frequency Replacement (AMGRF),"AMGRF integrates a lightweight per-set frequency counter (LFU) with SRRIP recency prediction, and augments insertion/promotion decisions using both PC-based access signatures and spatial locality detection. Each set tracks the access frequency of lines (LFU), recent reuse distance (SRRIP), and the last few PCs to identify control-dominated or regular phases. On insertion, lines with matching PC signatures or spatially local accesses are prioritized (low RRIP, high LFU), while others are inserted with low priority. Victim selection prefers lines with low frequency and high RRIP, reducing pollution from irregular/pointer-heavy accesses (mcf, omnetpp) while retaining frequently reused lines for regular workloads (lbm, milc, astar). The policy dynamically adapts insertion and promotion based on observed hit/miss and frequency statistics, responding quickly to phase changes and workload diversity for improved hit rates.",,ChampSim_CRC2/new_policies/010_adaptive_multi_granularity_reuse_and_frequency_replacement__amgrf.cc,0.228082477,0.228082477,23%
806,astar,**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**,"DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.",,ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.237629737,0.237629737,0%
807,lbm,**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**,"DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.",,ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.268849657,0.268849657,0%
808,mcf,**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**,"DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.",,ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.154110081,0.154110081,0%
809,milc,**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**,"DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.",,ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.258840724,0.258840724,0%
810,omnetpp,**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**,"DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.",,ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.005782734,0.005782734,0%
811,all,**Dynamic Segmented SRRIP with Pointer-Aware Bypass (DSSPB)**,"DSSPB combines a segmented SRRIP (Static Re-Reference Interval Prediction) approach with a lightweight pointer-aware bypass mechanism to adapt to both regular and irregular workloads. The policy divides the cache sets into two segments: one optimized for spatial locality (SRRIP with aggressive promotion), and another for pointer-heavy, irregular accesses (SRRIP with conservative insertion and selective bypass). A simple pointer-access detector tags accesses likely to be pointer-chasing (based on stride irregularity and PC diversity). In pointer-heavy phases (e.g., mcf, omnetpp), DSSPB increases the likelihood of bypassing the cache or inserting lines with high RRIP to reduce pollution. In regular phases (e.g., lbm, milc), it aggressively promotes lines with spatial locality. Phase adaptation is performed periodically per set, switching segment behavior based on observed hit rates and pointer-access frequency. This hybrid approach improves hit rate by reducing pollution from unpredictable accesses while retaining blocks for workloads with high reuse or locality.",,ChampSim_CRC2/new_policies/015_dynamic_segmented_srrip_with_pointer_aware_bypass__dsspb.cc,0.185042587,0.185042587,19%
812,astar,Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB),"AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.",,ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.287382332,0.287382332,0%
813,lbm,Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB),"AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.",,ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.406428974,0.406428974,0%
814,mcf,Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB),"AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.",,ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.157873563,0.157873563,0%
815,milc,Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB),"AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.",,ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.27955226,0.27955226,0%
816,omnetpp,Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB),"AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.",,ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.004750103,0.004750103,0%
817,all,Adaptive Multi-Phase RRIP with Dynamic Bypass (AMP-RRIP-DB),"AMP-RRIP-DB combines an adaptive multi-phase RRIP (Re-Reference Interval Prediction) scheme with dynamic bypassing based on real-time detection of workload phases and spatial locality. Each cache set tracks recent hit/miss statistics and access patterns to classify itself into one of three modes: spatial-locality, temporal-locality, or irregular/pointer-heavy. In spatial mode (e.g., lbm, milc), lines are inserted with low RRIP and promoted aggressively to favor reuse. In temporal mode (e.g., astar), insertion is moderate and promotion is cautious, balancing reuse and pollution. In irregular mode (e.g., mcf, omnetpp), lines are inserted with high RRIP and bypassed if the set is experiencing frequent misses from diverse PCs or irregular strides. The policy adapts per set every 1024 accesses, switching modes based on hit rate, PC diversity, and stride regularity. This fine-grained, phase-aware approach improves hit rate by retaining blocks with reuse potential and dynamically bypassing those likely to cause pollution, outperforming static or coarse-grained hybrid policies.",,ChampSim_CRC2/new_policies/016_adaptive_multi_phase_rrip_with_dynamic_bypass__amp_rrip_db.cc,0.227197446,0.227197446,23%
818,astar,Adaptive SRRIP-LRU Hybrid,"This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.",,ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.290550326,0.290550326,0%
819,lbm,Adaptive SRRIP-LRU Hybrid,"This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.",,ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.439737459,0.439737459,0%
820,mcf,Adaptive SRRIP-LRU Hybrid,"This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.",,ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.290720998,0.290720998,0%
821,milc,Adaptive SRRIP-LRU Hybrid,"This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.",,ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.304256381,0.304256381,0%
822,omnetpp,Adaptive SRRIP-LRU Hybrid,"This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.",,ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.004868118,0.004868118,0%
823,all,Adaptive SRRIP-LRU Hybrid,"This policy combines Static Re-Reference Interval Prediction (SRRIP) and Least Recently Used (LRU) strategies, adapting dynamically to workload characteristics. SRRIP is robust for workloads with poor temporal locality and irregular access (e.g., mcf, omnetpp), while LRU is effective for workloads with high spatial or temporal locality (e.g., lbm, milc). The policy tracks hit/miss rates per set and switches between SRRIP and LRU based on recent performance: if misses rise, it favors SRRIP to avoid cache pollution; if hits are stable, it uses LRU to exploit locality. This hybrid approach responds to phase changes and diverse access patterns, improving overall hit rate across all workloads.",,ChampSim_CRC2/new_policies/002_adaptive_srrip_lru_hybrid.cc,0.266026656,0.266026656,27%
824,astar,Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH),"This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.",,ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.025072411,0.025072411,0%
825,lbm,Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH),"This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.",,ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.057362593,0.057362593,0%
826,mcf,Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH),"This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.",,ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.034177375,0.034177375,0%
827,milc,Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH),"This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.",,ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.017396264,0.017396264,0%
828,omnetpp,Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH),"This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.",,ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.000590075,0.000590075,0%
829,all,Dynamic Bimodal RRIP-FIFO Hybrid (DBRFH),"This policy combines Bimodal RRIP (BRRIP) and FIFO replacement, dynamically selecting the best strategy for each set based on observed reuse and access regularity. BRRIP is effective for workloads with irregular or low-locality patterns (e.g., mcf, omnetpp, astar), as it retains blocks longer and minimizes premature eviction. FIFO is optimal for workloads with regular, streaming, or high spatial locality (e.g., lbm, milc), where blocks are accessed in order and reused quickly. The policy tracks reuse distance and hit/miss patterns per set, switching between BRRIP and FIFO when a windowed analysis detects changes in locality or streaming behavior. This approach adapts to phase changes and diverse access patterns, reducing cache pollution and improving hit rates across all considered workloads.",,ChampSim_CRC2/new_policies/003_dynamic_bimodal_rrip_fifo_hybrid__dbrfh.cc,0.026919744,0.026919744,3%
830,astar,Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH),"This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.025072411,0.025072411,0%
831,lbm,Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH),"This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.057362593,0.057362593,0%
832,mcf,Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH),"This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.034159938,0.034159938,0%
833,milc,Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH),"This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.017396264,0.017396264,0%
834,omnetpp,Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH),"This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.000590075,0.000590075,0%
835,all,Dynamic Multi-Phase LRU-BRRIP Hybrid (DMPLBH),"This policy dynamically adapts between LRU and BRRIP on a per-set basis, guided by real-time phase detection using reuse distance and hit/miss statistics. LRU excels in workloads with high spatial and temporal locality (e.g., lbm, milc), while BRRIP is robust against irregular or streaming access patterns (e.g., mcf, omnetpp, astar). DMPLBH tracks per-set reuse and streaming behavior in a sliding window, switching to LRU when frequent block reuse is detected and to BRRIP when accesses are sparse or streaming. Unlike FIFO, LRU better retains recently used blocks during high locality phases, and BRRIP prevents premature eviction in irregular phases. The policy adapts quickly to phase changes, minimizing cache pollution and balancing hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/004_dynamic_multi_phase_lru_brrip_hybrid__dmplbh.cc,0.026916256,0.026916256,3%
836,astar,Signature-Based Adaptive RRIP-LRU (SARRL),"SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.",,ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.016352884,0.016352884,0%
837,lbm,Signature-Based Adaptive RRIP-LRU (SARRL),"SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.",,ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.043581026,0.043581026,0%
838,mcf,Signature-Based Adaptive RRIP-LRU (SARRL),"SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.",,ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.019212423,0.019212423,0%
839,milc,Signature-Based Adaptive RRIP-LRU (SARRL),"SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.",,ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.007093968,0.007093968,0%
840,omnetpp,Signature-Based Adaptive RRIP-LRU (SARRL),"SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.",,ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.000295037,0.000295037,0%
841,all,Signature-Based Adaptive RRIP-LRU (SARRL),"SARRL combines signature-based tracking and adaptive insertion to tailor cache replacement to workload phases and access patterns. Each set maintains a small history of recent PC signatures (from the instruction address causing the access) to identify streams and reuse. For PCs with frequent hits, blocks are inserted with LRU-like priority, favoring temporal locality; for PCs that miss often or exhibit streaming/pointer-chasing, blocks are inserted with low RRIP priority to avoid cache pollution. The policy dynamically adjusts insertion and promotion based on per-PC statistics, blending RRIP’s robustness to irregular accesses with LRU’s effectiveness in high-locality phases. This approach enables fast adaptation to phase changes and better handling of both regular (lbm, milc) and irregular (mcf, omnetpp, astar) workloads, improving overall hit rates.",,ChampSim_CRC2/new_policies/005_signature_based_adaptive_rrip_lru__sarrl.cc,0.017307068,0.017307068,2%
842,astar,**Dynamic Reuse and Stream Detector (DRSD)**,"DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.016503741,0.016503741,0%
843,lbm,**Dynamic Reuse and Stream Detector (DRSD)**,"DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.044271922,0.044271922,0%
844,mcf,**Dynamic Reuse and Stream Detector (DRSD)**,"DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.018482334,0.018482334,0%
845,milc,**Dynamic Reuse and Stream Detector (DRSD)**,"DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.007093968,0.007093968,0%
846,omnetpp,**Dynamic Reuse and Stream Detector (DRSD)**,"DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.000295037,0.000295037,0%
847,all,**Dynamic Reuse and Stream Detector (DRSD)**,"DRSD combines per-set reuse counters and lightweight stream/pointer-chase detection to adapt insertion and victim selection for both regular and irregular workloads. Each set tracks recent block accesses to estimate temporal locality (reuse) and monitors sequential address strides to detect streaming or pointer-chasing patterns. When a block is accessed repeatedly within a short window, it is promoted to MRU, favoring LRU-like retention for workloads with high reuse (lbm, milc). If accesses show streaming or pointer-chasing (large strides, low reuse), new blocks are inserted with low priority, mimicking RRIP to prevent cache pollution (mcf, omnetpp, astar). The policy dynamically adjusts insertion and promotion based on observed access patterns, enabling fast adaptation to phase changes and improving hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/006_dynamic_reuse_and_stream_detector__drsd.cc,0.017329401,0.017329401,2%
848,astar,**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**,"ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.",,ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.237116824,0.237116824,0%
849,lbm,**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**,"ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.",,ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.437555681,0.437555681,0%
850,mcf,**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**,"ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.",,ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.256918223,0.256918223,0%
851,milc,**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**,"ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.",,ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.246185655,0.246185655,0%
852,omnetpp,**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**,"ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.",,ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.00858559,0.00858559,0%
853,all,**Adaptive Segmented RRIP with Pointer-Chase Awareness (ASRRP-PC)**,"ASRRP-PC combines a segmented RRIP (Re-Reference Interval Prediction) policy with lightweight pointer-chase detection to dynamically adapt to both regular (high spatial/temporal locality) and irregular (pointer-chasing, streaming, control-dominated) workloads. Each set maintains per-block RRIP counters to predict reuse, and a small pointer-chase detector tracks recent miss PCs to identify irregular access patterns. If pointer-chasing is detected (frequent misses from a small set of PCs), new blocks are inserted with low priority (high RRIP), reducing pollution. For regular workloads, blocks are inserted with medium RRIP and promoted aggressively on hits, retaining useful data. The segmented approach divides the cache into ""regular"" and ""irregular"" sets based on runtime detection, allowing phase-aware adaptation. This hybrid strategy improves hit rates by preserving locality for regular accesses while minimizing pollution from unpredictable patterns.",,ChampSim_CRC2/new_policies/007_adaptive_segmented_rrip_with_pointer_chase_awareness__asrrp_pc.cc,0.237272395,0.237272395,24%
854,astar,Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR),"DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.",,ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.290520154,0.290520154,0%
855,lbm,Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR),"DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.",,ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.437555681,0.437555681,0%
856,mcf,Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR),"DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.",,ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.289531308,0.289531308,0%
857,milc,Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR),"DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.",,ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.304256381,0.304256381,0%
858,omnetpp,Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR),"DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.",,ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.004602585,0.004602585,0%
859,all,Dynamic Multi-Phase Locality-Aware Replacement (DMP-LAR),"DMP-LAR is a hybrid replacement policy that dynamically adapts to workload phases by combining three locality-aware strategies: SRRIP (Static RRIP) for regular access phases, a simple LRU for high temporal reuse, and a Bimodal Insertion Policy (BIP) for streaming or pointer-chasing phases. Each set maintains lightweight counters to track hit/miss patterns and phase transitions, allowing the policy to switch between modes: LRU for bursts of hits (temporal locality), SRRIP for moderate spatial/temporal locality, and BIP for periods of frequent misses (indicative of streaming or pointer-chasing). This approach preserves useful blocks during reuse-heavy phases, aggressively evicts during streaming/pointer-chase phases to avoid pollution, and balances insertion/promotion strategies for mixed workloads. By responding to phase changes and locality signals, DMP-LAR improves hit rates across diverse workloads with varying memory and control-flow behaviors.",,ChampSim_CRC2/new_policies/008_dynamic_multi_phase_locality_aware_replacement__dmp_lar.cc,0.265293222,0.265293222,27%
860,astar,Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA),"SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.",,ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.290520154,0.290520154,0%
861,lbm,Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA),"SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.",,ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.437555681,0.437555681,0%
862,mcf,Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA),"SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.",,ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.277712322,0.277712322,0%
863,milc,Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA),"SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.",,ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.304256381,0.304256381,0%
864,omnetpp,Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA),"SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.",,ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.004602585,0.004602585,0%
865,all,Signature-Enhanced Dynamic Reuse and Stream Adaptive Replacement (SER-SA),"SER-SA is a hybrid cache replacement policy that combines signature-based reuse detection with adaptive streaming victim selection. Each cache set tracks recent access signatures (derived from PC and address) to identify blocks likely to be reused, even in irregular or pointer-chasing workloads. The policy dynamically classifies accesses as ""reuse"" or ""stream"" by maintaining per-set counters and signature tables. Blocks with matching signatures are protected (inserted/promoted as MRU), while stream-like accesses (no recent signature match, frequent misses) trigger aggressive eviction using a streaming victim selector (BIP-like). For regular, spatially-local workloads, SER-SA falls back to SRRIP for stable performance. This approach improves hit rates by leveraging both fine-grained reuse detection and adaptive streaming handling, making it robust across workloads with mixed locality, irregular branching, and phase changes.",,ChampSim_CRC2/new_policies/009_signature_enhanced_dynamic_reuse_and_stream_adaptive_replacement__ser_sa.cc,0.262929425,0.262929425,26%
866,astar,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.",,ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.290520154,0.290520154,0%
867,lbm,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.",,ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.437555681,0.437555681,0%
868,mcf,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.",,ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.290966459,0.290966459,0%
869,milc,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.",,ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.304256381,0.304256381,0%
870,omnetpp,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.",,ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.004602585,0.004602585,0%
871,all,"**Multi-Phase Adaptive Reuse, Stream, and Spatial (MARS) Replacement**","MARS is a multi-phase adaptive cache replacement policy that dynamically detects and responds to workload phases: spatial locality (streaming/stencil), temporal reuse (pointer-chasing/irregular), and mixed/branch-heavy behaviors. Each set tracks recent access patterns using a compact reuse counter (for signature-based temporal locality), a stream detector (stride-based for spatial locality), and a phase classifier. For spatial phases (like LBM, MILC), MARS uses a spatial-friendly insertion/eviction (SRRIP with prefetch-aware promotion); for temporal phases (MCF, astar, omnetpp), it protects blocks with high signature reuse and aggressively evicts stream-like blocks. Phase transitions are detected using moving windows of hit/miss patterns and stride analysis. This hybrid approach ensures MARS adapts to the locality and access patterns of each workload, improving hit rates by retaining blocks likely to be reused and evicting those with low reuse or predictable streaming behavior.",,ChampSim_CRC2/new_policies/010_multi_phase_adaptive_reuse__stream__and_spatial__mars__replacement.cc,0.265580252,0.265580252,27%
872,astar,**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**,"SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.",,ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.289252957,0.289252957,0%
873,lbm,**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**,"SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.",,ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.426410429,0.426410429,0%
874,mcf,**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**,"SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.",,ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.209084326,0.209084326,0%
875,milc,**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**,"SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.",,ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.289711963,0.289711963,0%
876,omnetpp,**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**,"SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.",,ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.008290553,0.008290553,0%
877,all,**Signature-Enhanced Dynamic Reuse and Stream (SEDRS) Replacement**,"SEDRS is a signature-driven, dynamic cache replacement policy that combines per-set signature tracking (for temporal locality), lightweight stream detection (for spatial locality), and adaptive insertion/eviction logic. Each set maintains a small history of access signatures (derived from PC and address) to estimate future reuse, and a simple stride detector to identify streaming phases. On insertion, blocks with high signature reuse are protected (inserted as MRU), while blocks matching streaming patterns are deprioritized (inserted as LRU, with periodic MRU insertion for BIP-like diversity). Victim selection prefers blocks with low reuse and those matching streaming patterns. This hybrid approach improves over pure phase-based policies by adapting at the block level, allowing fine-grained retention of reusable blocks in pointer-heavy, branchy, or irregular workloads (like mcf, astar, omnetpp), while efficiently evicting stream-like blocks in stencil or regular-access workloads (like lbm, milc). The policy avoids global phase switches, instead using local per-set statistics for fast adaptation and better hit rates across mixed workloads.",,ChampSim_CRC2/new_policies/011_signature_enhanced_dynamic_reuse_and_stream__sedrs__replacement.cc,0.244550046,0.244550046,24%
878,astar,**Adaptive Multi-Signal Locality Replacement (AMSLR)**,"AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.",,ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.290520154,0.290520154,0%
879,lbm,**Adaptive Multi-Signal Locality Replacement (AMSLR)**,"AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.",,ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.417446956,0.417446956,0%
880,mcf,**Adaptive Multi-Signal Locality Replacement (AMSLR)**,"AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.",,ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.237838801,0.237838801,0%
881,milc,**Adaptive Multi-Signal Locality Replacement (AMSLR)**,"AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.",,ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.304256381,0.304256381,0%
882,omnetpp,**Adaptive Multi-Signal Locality Replacement (AMSLR)**,"AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.",,ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.005369682,0.005369682,0%
883,all,**Adaptive Multi-Signal Locality Replacement (AMSLR)**,"AMSLR is a hybrid cache replacement policy that dynamically blends recency, frequency, and streaming detection at the per-set level to adapt to diverse workload behaviors. Each set tracks a small history of block accesses using both LRU stack position and per-block reuse counters, while also monitoring stride patterns to identify streaming phases. On insertion, blocks with high reuse or recent hits are protected as MRU, while blocks detected as part of a stream are inserted with low priority (LRU or high RRIP). Victim selection prioritizes blocks with low reuse and those identified as stream candidates, but falls back to LRU for sets with ambiguous signals. This approach enables AMSLR to retain useful blocks in irregular/pointer-heavy workloads (e.g., mcf, astar, omnetpp), while efficiently evicting transient data in regular or streaming workloads (e.g., lbm, milc). By combining multiple locality signals and adapting at the set level, AMSLR improves hit rates and responsiveness to phase changes without relying on global heuristics.",,ChampSim_CRC2/new_policies/012_adaptive_multi_signal_locality_replacement__amslr.cc,0.251086395,0.251086395,25%
884,astar,**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**,"PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.",,ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.290339126,0.290339126,0%
885,lbm,**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**,"PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.",,ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.417283322,0.417283322,0%
886,mcf,**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**,"PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.",,ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.238337443,0.238337443,0%
887,milc,**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**,"PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.",,ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.304256381,0.304256381,0%
888,omnetpp,**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**,"PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.",,ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.00834956,0.00834956,0%
889,all,**Phase-Adaptive Reuse and Spatial Locality Replacement (PARSLR)**,"PARSLR is a phase-adaptive cache replacement policy that combines per-set reuse tracking with spatial locality detection to optimize for both irregular (pointer-heavy) and regular (streaming/stencil) workloads. Each set maintains a reuse counter for each block, a short history of access addresses to detect spatial patterns, and a lightweight phase detector to distinguish between streaming and irregular phases. In streaming phases (e.g., LBM, MILC), blocks are inserted with low priority and evicted aggressively unless spatial reuse is detected; in irregular phases (e.g., MCF, astar, omnetpp), blocks with high reuse are protected and retained longer, even if their recency is low. The policy adapts insertion and victim selection strategies at the set level, prioritizing blocks with low reuse and weak spatial correlation for eviction. This approach improves hit rates by responding quickly to phase changes and leveraging both reuse and spatial signals, outperforming policies that rely solely on recency or frequency.",,ChampSim_CRC2/new_policies/013_phase_adaptive_reuse_and_spatial_locality_replacement__parslr.cc,0.251713166,0.251713166,25%
890,astar,Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR),"HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.",,ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.290097755,0.290097755,0%
891,lbm,Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR),"HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.",,ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.434898816,0.434898816,0%
892,mcf,Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR),"HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.",,ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.136462123,0.136462123,0%
893,milc,Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR),"HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.",,ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.279873093,0.279873093,0%
894,omnetpp,Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR),"HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.",,ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.005163156,0.005163156,0%
895,all,Hybrid Reuse-Frequency and Spatial Correlation Replacement (HRFSCR),"HRFSCR is a hybrid cache replacement policy that synergistically combines block-level reuse/frequency tracking with spatial correlation analysis, tailored to diverse workload behaviors. Each block maintains both a reuse counter (for temporal locality) and a frequency score (to capture repeated accesses, even across phases), while each set tracks recent access strides to detect spatial patterns. For streaming and stencil workloads (LBM, MILC), the policy aggressively retains blocks with high spatial correlation and moderate frequency, ensuring that blocks likely to be reused soon are protected. For irregular, pointer-heavy workloads (MCF, astar, omnetpp), blocks with high frequency or recent reuse are prioritized, while those with low scores are evicted. The victim selection dynamically balances spatial and frequency signals, adapting to phase changes without explicit phase detection. This approach improves hit rates by leveraging both short-term and long-term locality, outperforming pure recency or frequency-based policies across mixed workloads.",,ChampSim_CRC2/new_policies/014_hybrid_reuse_frequency_and_spatial_correlation_replacement__hrfscr.cc,0.229298989,0.229298989,23%
896,astar,Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR),"ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.285541878,0.285541878,0%
897,lbm,Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR),"ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.394701915,0.394701915,0%
898,mcf,Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR),"ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.165166667,0.165166667,0%
899,milc,Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR),"ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.278910595,0.278910595,0%
900,omnetpp,Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR),"ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.00858559,0.00858559,0%
901,all,Adaptive Dynamic Reuse and Bimodal Spatial Replacement (ADRBSR),"ADRBSR is an adaptive cache replacement policy that dynamically balances temporal reuse and spatial locality using a bimodal approach tailored to workload phases. Each cache set tracks recent access patterns to classify its dominant behavior as either spatial (streaming/stencil) or irregular (pointer-heavy). For spatial-dominated sets (e.g., LBM, MILC phases), the policy prioritizes retaining blocks with high spatial proximity and recent accesses, using a small region-based reuse window to protect streams and stencils. For irregular sets (e.g., MCF, astar, omnetpp), ADRBSR switches to a dynamic reuse counter (DRC) similar to RRIP, penalizing blocks with low reuse and rewarding those with frequent hits. The set classification is updated periodically based on stride histograms and reuse statistics, allowing the policy to adapt to phase changes and mixed behaviors. This approach improves hit rates by specializing eviction logic per workload phase, outperforming static or purely hybrid policies.",,ChampSim_CRC2/new_policies/015_adaptive_dynamic_reuse_and_bimodal_spatial_replacement__adrbsr.cc,0.226581329,0.226581329,23%
902,astar,**Multi-Feature Phase-Adaptive Replacement (MPAR)**,"MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.073316437,0.073316437,0%
903,lbm,**Multi-Feature Phase-Adaptive Replacement (MPAR)**,"MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.123288667,0.123288667,0%
904,mcf,**Multi-Feature Phase-Adaptive Replacement (MPAR)**,"MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.089026177,0.089026177,0%
905,milc,**Multi-Feature Phase-Adaptive Replacement (MPAR)**,"MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.077962356,0.077962356,0%
906,omnetpp,**Multi-Feature Phase-Adaptive Replacement (MPAR)**,"MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.002419307,0.002419307,0%
907,all,**Multi-Feature Phase-Adaptive Replacement (MPAR)**,"MPAR is a hybrid cache replacement policy that dynamically adapts to workload phases by combining recency, frequency, and spatial locality features at both the set and block level. Each cache set tracks access patterns using a lightweight phase detector that monitors the ratio of spatially local accesses (based on region proximity), hit/miss rates, and reuse intervals. Depending on the detected phase—spatial (streaming/stencil), temporal (recency/frequency reuse), or irregular (pointer-heavy)—MPAR switches between three specialized eviction strategies: (1) a region-protecting spatial mode for workloads like LBM and MILC, (2) a frequency-biased recency mode for workloads with temporal locality, and (3) a randomization-biased RRIP mode for highly irregular workloads such as MCF, omnetpp, and astar. Block metadata includes a reuse counter, region ID, and a frequency estimator. This multi-feature approach allows MPAR to respond quickly to phase changes, retain useful blocks longer, and reduce pollution by evicting blocks least likely to be reused under the current access pattern, resulting in improved hit rates across diverse workloads.",,ChampSim_CRC2/new_policies/016_multi_feature_phase_adaptive_replacement__mpar.cc,0.073202589,0.073202589,7%
908,astar,**Dynamic Reuse-Aware Replacement (DRAR)**,"DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.",,ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.076212889,0.076212889,0%
909,lbm,**Dynamic Reuse-Aware Replacement (DRAR)**,"DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.",,ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.125997709,0.125997709,0%
910,mcf,**Dynamic Reuse-Aware Replacement (DRAR)**,"DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.",,ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.089429493,0.089429493,0%
911,milc,**Dynamic Reuse-Aware Replacement (DRAR)**,"DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.",,ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.082168829,0.082168829,0%
912,omnetpp,**Dynamic Reuse-Aware Replacement (DRAR)**,"DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.",,ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.002419307,0.002419307,0%
913,all,**Dynamic Reuse-Aware Replacement (DRAR)**,"DRAR is a lightweight, adaptive cache replacement policy that combines recency, frequency, and reuse distance tracking to optimize cache block retention for diverse workloads. Each cache block maintains a small reuse counter and a frequency estimator, updated on every access. Sets periodically estimate the dominant locality type (spatial, temporal, or none) using hit/miss patterns and region proximity. DRAR prioritizes blocks with high reuse and frequency for retention, but also aggressively evicts blocks with long reuse distances or low frequency, preventing cache pollution from irregular or streaming accesses. For workloads with regular spatial locality (e.g., LBM, MILC), DRAR protects region-local blocks; for temporal locality (e.g., milc phase, omnetpp bursts), it favors frequently reused blocks; for pointer-heavy and unpredictable accesses (e.g., MCF, astar, omnetpp), it falls back to a randomized RRIP variant to avoid thrashing. This simple yet robust combination improves hit rates by quickly adapting to workload phase changes and minimizing retention of blocks unlikely to be reused.",,ChampSim_CRC2/new_policies/017_dynamic_reuse_aware_replacement__drar.cc,0.075245646,0.075245646,8%
914,astar,Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR),"HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.",,ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.076212889,0.076212889,0%
915,lbm,Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR),"HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.",,ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.125997709,0.125997709,0%
916,mcf,Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR),"HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.",,ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.08943524,0.08943524,0%
917,milc,Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR),"HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.",,ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.082168829,0.082168829,0%
918,omnetpp,Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR),"HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.",,ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.002419307,0.002419307,0%
919,all,Hybrid Hawkeye-Inspired Adaptive Replacement (HHAR),"HHAR combines a lightweight version of Hawkeye's reuse prediction with fast spatial locality detection to dynamically select between Belady-inspired and SRRIP replacement strategies. For each set, HHAR maintains a small history of recently evicted blocks and tracks whether their addresses are reused within a short window, building a per-set reuse score. If a set exhibits high reuse (as in mcf, milc, omnetpp pointer-heavy phases), HHAR prioritizes retaining blocks predicted to be reused soon, evicting those with low reuse scores. If spatial locality dominates (as in lbm, milc regular phases), HHAR switches to a region-based policy, protecting blocks within the current region and evicting those outside. For unpredictable workloads (astar, omnetpp), HHAR falls back to SRRIP with random tie-breaking to avoid thrashing. This hybrid approach adapts quickly to phase changes and leverages both history-based and spatial signals, improving hit rates across diverse workload patterns.",,ChampSim_CRC2/new_policies/018_hybrid_hawkeye_inspired_adaptive_replacement__hhar.cc,0.075246795,0.075246795,8%
920,astar,Phase-Adaptive Multi-Signature Replacement (PAMSR),"PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.",,ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.072863867,0.072863867,0%
921,lbm,Phase-Adaptive Multi-Signature Replacement (PAMSR),"PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.",,ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.125361357,0.125361357,0%
922,mcf,Phase-Adaptive Multi-Signature Replacement (PAMSR),"PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.",,ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.088422746,0.088422746,0%
923,milc,Phase-Adaptive Multi-Signature Replacement (PAMSR),"PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.",,ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.07714245,0.07714245,0%
924,omnetpp,Phase-Adaptive Multi-Signature Replacement (PAMSR),"PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.",,ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.002153774,0.002153774,0%
925,all,Phase-Adaptive Multi-Signature Replacement (PAMSR),"PAMSR dynamically adapts its replacement strategy by tracking both spatial and temporal locality using compact per-set signatures and phase detection. Each set maintains a history of recently accessed block addresses, hashed into signatures, and tracks access patterns to identify dominant locality: spatial (region-based), temporal (reuse-based), or random/irregular. The policy uses this information to switch between three modes: (1) Region Protection for workloads like lbm and milc's regular phases, retaining blocks within active regions; (2) Signature-based Reuse for pointer-heavy workloads like mcf, omnetpp, astar, and milc's irregular phases, prioritizing blocks with recent signature hits; and (3) Randomized SRRIP for highly unpredictable phases. PAMSR improves hit rates by quickly detecting phase changes and leveraging both region and signature reuse information, ensuring robust performance across diverse workload behaviors.",,ChampSim_CRC2/new_policies/019_phase_adaptive_multi_signature_replacement__pamsr.cc,0.073188839,0.073188839,7%
926,astar,**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**,"DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.287442674,0.287442674,0%
927,lbm,**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**,"DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.407374411,0.407374411,0%
928,mcf,**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**,"DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.160523911,0.160523911,0%
929,milc,**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**,"DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.27958369,0.27958369,0%
930,omnetpp,**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**,"DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.005487697,0.005487697,0%
931,all,**Dynamic Frequency-Spatial Hybrid Replacement (DFSHR)**,"DFSHR combines frequency-based and spatial locality-aware replacement strategies, dynamically adapting per set based on recent access patterns. Each set tracks per-block access frequency (LFU) and region affinity, periodically classifying its dominant behavior as frequency-sensitive (temporal reuse, e.g., mcf, omnetpp, astar) or spatially-biased (regular stride, e.g., lbm, milc regular phases). In frequency mode, blocks with the lowest access count are evicted, prioritizing retention of frequently reused blocks. In spatial mode, blocks outside the currently accessed region are targeted for eviction, preserving blocks likely to be reused soon due to spatial locality. Phase detection is performed every window of accesses, switching modes to match workload behavior. This approach improves hit rates by retaining blocks with either high reuse or strong spatial affinity, while quickly adapting to phase changes and irregular patterns, outperforming recency-only or static policies across diverse workloads.",,ChampSim_CRC2/new_policies/020_dynamic_frequency_spatial_hybrid_replacement__dfshr.cc,0.228082477,0.228082477,23%
932,astar,Adaptive Hawkeye-Like Predictor Replacement (AHLPR),"AHLPR leverages a lightweight per-set predictor, inspired by Hawkeye, to estimate whether incoming accesses are cache-friendly (likely to be reused soon) or cache-averse (unlikely to be reused). The policy tracks recent PC and region signatures to dynamically classify accesses, maintaining a history of past evictions and hits per set. Each block is tagged with a ""cache-friendliness"" score, updated on hits and evictions. On replacement, blocks with the lowest score (least likely to be reused) are preferentially evicted, but the policy also considers spatial locality by boosting scores for blocks in the same region as the current access. This approach adapts to both temporal and spatial locality, as well as irregular behaviors found in pointer-chasing and phase-changing workloads. By combining predictor-driven retention with region-aware scoring, AHLPR improves hit rates over recency, frequency, or static spatial policies, especially for workloads with mixed or rapidly changing access patterns.",,ChampSim_CRC2/new_policies/021_adaptive_hawkeye_like_predictor_replacement__ahlpr.cc,0.288649529,0.288649529,0%
933,lbm,Adaptive Hawkeye-Like Predictor Replacement (AHLPR),"AHLPR leverages a lightweight per-set predictor, inspired by Hawkeye, to estimate whether incoming accesses are cache-friendly (likely to be reused soon) or cache-averse (unlikely to be reused). The policy tracks recent PC and region signatures to dynamically classify accesses, maintaining a history of past evictions and hits per set. Each block is tagged with a ""cache-friendliness"" score, updated on hits and evictions. On replacement, blocks with the lowest score (least likely to be reused) are preferentially evicted, but the policy also considers spatial locality by boosting scores for blocks in the same region as the current access. This approach adapts to both temporal and spatial locality, as well as irregular behaviors found in pointer-chasing and phase-changing workloads. By combining predictor-driven retention with region-aware scoring, AHLPR improves hit rates over recency, frequency, or static spatial policies, especially for workloads with mixed or rapidly changing access patterns.",,ChampSim_CRC2/new_policies/021_adaptive_hawkeye_like_predictor_replacement__ahlpr.cc,0.415046999,0.415046999,0%
934,astar,Adaptive Phase-aware Reuse and Locality Predictor (APRLP),"APRLP combines phase detection, spatial-temporal locality tracking, and program-context-aware reuse prediction to dynamically adjust cache replacement decisions. It maintains lightweight phase signatures per set, tracks recent access patterns (stride, reuse distance, PC clustering), and adaptively learns which lines are likely to be reused based on both current phase and historical access telemetry. By blending per-set phase awareness with PC-based reuse predictors and spatial locality hints, APRLP can respond to abrupt changes (e.g., MILC phase shifts), exploit regularity (LBM), and avoid pollution in pointer-heavy workloads (MCF, omnetpp). This hybrid approach leverages the strengths of LIME, Hawkeye, and SHiP++ while introducing explicit phase adaptation and spatial pattern learning, aiming to outperform all previous policies.",,ChampSim_CRC2/new_policies/000_adaptive_phase_aware_reuse_and_locality_predictor__aprlp.cc,0.016383056,0.016383056,0%
935,astar,ShipStreamRIP,"ShipStreamRIP combines PC-based hit prediction (a lightweight SHiP-lite table) with a simple streaming detector and SRRIP (Static Re-Reference Interval Prediction). We track a small per-PC hit counter to bias new lines from “good” PCs toward long cache residency (RRPV=0) and lines from “cold” PCs toward early eviction (RRPV=2). A per-PC streaming unit detects small ID-stride scans and forces streaming blocks to be inserted with maximum RRPV, effectively bypassing the cache. On hits, lines are promoted to RRPV=0. This composition targets pointer-chasing/irregular workloads (MCF, Omnet++), streaming/stencil codes (LBM, MILC), and speculative control-flow (A*), achieving strong reuse capture, pollution avoidance, and conflict mitigation with <16 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_shipstreamrip_t02.cc,0.460041957,0.460041957,0%
936,lbm,ShipStreamRIP,"ShipStreamRIP combines PC-based hit prediction (a lightweight SHiP-lite table) with a simple streaming detector and SRRIP (Static Re-Reference Interval Prediction). We track a small per-PC hit counter to bias new lines from “good” PCs toward long cache residency (RRPV=0) and lines from “cold” PCs toward early eviction (RRPV=2). A per-PC streaming unit detects small ID-stride scans and forces streaming blocks to be inserted with maximum RRPV, effectively bypassing the cache. On hits, lines are promoted to RRPV=0. This composition targets pointer-chasing/irregular workloads (MCF, Omnet++), streaming/stencil codes (LBM, MILC), and speculative control-flow (A*), achieving strong reuse capture, pollution avoidance, and conflict mitigation with <16 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_shipstreamrip_t02.cc,0.413221498,0.413221498,0%
937,mcf,ShipStreamRIP,"ShipStreamRIP combines PC-based hit prediction (a lightweight SHiP-lite table) with a simple streaming detector and SRRIP (Static Re-Reference Interval Prediction). We track a small per-PC hit counter to bias new lines from “good” PCs toward long cache residency (RRPV=0) and lines from “cold” PCs toward early eviction (RRPV=2). A per-PC streaming unit detects small ID-stride scans and forces streaming blocks to be inserted with maximum RRPV, effectively bypassing the cache. On hits, lines are promoted to RRPV=0. This composition targets pointer-chasing/irregular workloads (MCF, Omnet++), streaming/stencil codes (LBM, MILC), and speculative control-flow (A*), achieving strong reuse capture, pollution avoidance, and conflict mitigation with <16 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_shipstreamrip_t02.cc,0.47409648,0.47409648,0%
938,milc,ShipStreamRIP,"ShipStreamRIP combines PC-based hit prediction (a lightweight SHiP-lite table) with a simple streaming detector and SRRIP (Static Re-Reference Interval Prediction). We track a small per-PC hit counter to bias new lines from “good” PCs toward long cache residency (RRPV=0) and lines from “cold” PCs toward early eviction (RRPV=2). A per-PC streaming unit detects small ID-stride scans and forces streaming blocks to be inserted with maximum RRPV, effectively bypassing the cache. On hits, lines are promoted to RRPV=0. This composition targets pointer-chasing/irregular workloads (MCF, Omnet++), streaming/stencil codes (LBM, MILC), and speculative control-flow (A*), achieving strong reuse capture, pollution avoidance, and conflict mitigation with <16 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_shipstreamrip_t02.cc,0.289077605,0.289077605,0%
939,omnetpp,ShipStreamRIP,"ShipStreamRIP combines PC-based hit prediction (a lightweight SHiP-lite table) with a simple streaming detector and SRRIP (Static Re-Reference Interval Prediction). We track a small per-PC hit counter to bias new lines from “good” PCs toward long cache residency (RRPV=0) and lines from “cold” PCs toward early eviction (RRPV=2). A per-PC streaming unit detects small ID-stride scans and forces streaming blocks to be inserted with maximum RRPV, effectively bypassing the cache. On hits, lines are promoted to RRPV=0. This composition targets pointer-chasing/irregular workloads (MCF, Omnet++), streaming/stencil codes (LBM, MILC), and speculative control-flow (A*), achieving strong reuse capture, pollution avoidance, and conflict mitigation with <16 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_shipstreamrip_t02.cc,0.55174738,0.55174738,0%
940,astar,SHiP-RRIP-Bypass (SRB),"SRB combines SHiP-lite signature-based reuse prediction with SRRIP-like recency tracking and a streaming bypass detector. A small per-line 4-bit signature and 2-bit RRPV guide replacements: signatures whose history counter (SHCT) predicts reuse are inserted with near-fresh RRPV, low-confidence and streaming-detected lines get distant RRPV or are bypassed. On hits, RRPV is reset and SHCT is incremented; on evictions without hits, SHCT is decremented. A tiny streaming detector tracks monotonic deltas and inserts such lines at max RRPV, preventing pollution from regular, non-reused streams (e.g., LBM), while SHiP helps irregular patterns (ASTAR, MCF, OMNETPP) and SRRIP improves spatial locality handling (MILC).",,ChampSim_CRC2/new_policies/000_01_ship_rrip_bypass__srb_t04.cc,0.358176904,0.358176904,0%
941,lbm,SHiP-RRIP-Bypass (SRB),"SRB combines SHiP-lite signature-based reuse prediction with SRRIP-like recency tracking and a streaming bypass detector. A small per-line 4-bit signature and 2-bit RRPV guide replacements: signatures whose history counter (SHCT) predicts reuse are inserted with near-fresh RRPV, low-confidence and streaming-detected lines get distant RRPV or are bypassed. On hits, RRPV is reset and SHCT is incremented; on evictions without hits, SHCT is decremented. A tiny streaming detector tracks monotonic deltas and inserts such lines at max RRPV, preventing pollution from regular, non-reused streams (e.g., LBM), while SHiP helps irregular patterns (ASTAR, MCF, OMNETPP) and SRRIP improves spatial locality handling (MILC).",,ChampSim_CRC2/new_policies/000_01_ship_rrip_bypass__srb_t04.cc,0.231492609,0.231492609,0%
942,mcf,SHiP-RRIP-Bypass (SRB),"SRB combines SHiP-lite signature-based reuse prediction with SRRIP-like recency tracking and a streaming bypass detector. A small per-line 4-bit signature and 2-bit RRPV guide replacements: signatures whose history counter (SHCT) predicts reuse are inserted with near-fresh RRPV, low-confidence and streaming-detected lines get distant RRPV or are bypassed. On hits, RRPV is reset and SHCT is incremented; on evictions without hits, SHCT is decremented. A tiny streaming detector tracks monotonic deltas and inserts such lines at max RRPV, preventing pollution from regular, non-reused streams (e.g., LBM), while SHiP helps irregular patterns (ASTAR, MCF, OMNETPP) and SRRIP improves spatial locality handling (MILC).",,ChampSim_CRC2/new_policies/000_01_ship_rrip_bypass__srb_t04.cc,0.525303465,0.525303465,0%
943,milc,SHiP-RRIP-Bypass (SRB),"SRB combines SHiP-lite signature-based reuse prediction with SRRIP-like recency tracking and a streaming bypass detector. A small per-line 4-bit signature and 2-bit RRPV guide replacements: signatures whose history counter (SHCT) predicts reuse are inserted with near-fresh RRPV, low-confidence and streaming-detected lines get distant RRPV or are bypassed. On hits, RRPV is reset and SHCT is incremented; on evictions without hits, SHCT is decremented. A tiny streaming detector tracks monotonic deltas and inserts such lines at max RRPV, preventing pollution from regular, non-reused streams (e.g., LBM), while SHiP helps irregular patterns (ASTAR, MCF, OMNETPP) and SRRIP improves spatial locality handling (MILC).",,ChampSim_CRC2/new_policies/000_01_ship_rrip_bypass__srb_t04.cc,0.066532944,0.066532944,0%
944,omnetpp,SHiP-RRIP-Bypass (SRB),"SRB combines SHiP-lite signature-based reuse prediction with SRRIP-like recency tracking and a streaming bypass detector. A small per-line 4-bit signature and 2-bit RRPV guide replacements: signatures whose history counter (SHCT) predicts reuse are inserted with near-fresh RRPV, low-confidence and streaming-detected lines get distant RRPV or are bypassed. On hits, RRPV is reset and SHCT is incremented; on evictions without hits, SHCT is decremented. A tiny streaming detector tracks monotonic deltas and inserts such lines at max RRPV, preventing pollution from regular, non-reused streams (e.g., LBM), while SHiP helps irregular patterns (ASTAR, MCF, OMNETPP) and SRRIP improves spatial locality handling (MILC).",,ChampSim_CRC2/new_policies/000_01_ship_rrip_bypass__srb_t04.cc,0.541738492,0.541738492,0%
945,astar,AddrSig-RRIP,"AddrSig-RRIP augments Static RRIP with a compact address-signature reuse predictor. Each cache line carries a 2-bit RRPV and a 1-bit “reuse seen” flag. On insertion, we hash the incoming block’s physical address to index a small (256-entry) 2-bit saturating predictor table. If the predictor predicts reuse (counter ≥2), we insert with RRPV=2; otherwise we insert with RRPV=3. On every hit, we reset the line’s RRPV to 0 and set its reuse flag. When a block is evicted (on a miss insertion), we recompute its signature index from the victim address and update the predictor counter up or down based on whether its reuse flag was set. This simple AddrSig-RRIP mechanism dynamically learns which addresses are worth caching, bypassing one-time and streaming blocks while retaining highly reused data. It targets pointer-chasing (MCF/Omnet++), phase-shifting (MILC), deep speculative (Astar), and stencil (LBM) patterns with under 16 KB of metadata.",,ChampSim_CRC2/new_policies/000_02_addrsig_rrip_t07.cc,0.045124665,0.045124665,0%
946,lbm,AddrSig-RRIP,"AddrSig-RRIP augments Static RRIP with a compact address-signature reuse predictor. Each cache line carries a 2-bit RRPV and a 1-bit “reuse seen” flag. On insertion, we hash the incoming block’s physical address to index a small (256-entry) 2-bit saturating predictor table. If the predictor predicts reuse (counter ≥2), we insert with RRPV=2; otherwise we insert with RRPV=3. On every hit, we reset the line’s RRPV to 0 and set its reuse flag. When a block is evicted (on a miss insertion), we recompute its signature index from the victim address and update the predictor counter up or down based on whether its reuse flag was set. This simple AddrSig-RRIP mechanism dynamically learns which addresses are worth caching, bypassing one-time and streaming blocks while retaining highly reused data. It targets pointer-chasing (MCF/Omnet++), phase-shifting (MILC), deep speculative (Astar), and stencil (LBM) patterns with under 16 KB of metadata.",,ChampSim_CRC2/new_policies/000_02_addrsig_rrip_t07.cc,0.058753172,0.058753172,0%
947,mcf,AddrSig-RRIP,"AddrSig-RRIP augments Static RRIP with a compact address-signature reuse predictor. Each cache line carries a 2-bit RRPV and a 1-bit “reuse seen” flag. On insertion, we hash the incoming block’s physical address to index a small (256-entry) 2-bit saturating predictor table. If the predictor predicts reuse (counter ≥2), we insert with RRPV=2; otherwise we insert with RRPV=3. On every hit, we reset the line’s RRPV to 0 and set its reuse flag. When a block is evicted (on a miss insertion), we recompute its signature index from the victim address and update the predictor counter up or down based on whether its reuse flag was set. This simple AddrSig-RRIP mechanism dynamically learns which addresses are worth caching, bypassing one-time and streaming blocks while retaining highly reused data. It targets pointer-chasing (MCF/Omnet++), phase-shifting (MILC), deep speculative (Astar), and stencil (LBM) patterns with under 16 KB of metadata.",,ChampSim_CRC2/new_policies/000_02_addrsig_rrip_t07.cc,0.214312084,0.214312084,0%
948,milc,AddrSig-RRIP,"AddrSig-RRIP augments Static RRIP with a compact address-signature reuse predictor. Each cache line carries a 2-bit RRPV and a 1-bit “reuse seen” flag. On insertion, we hash the incoming block’s physical address to index a small (256-entry) 2-bit saturating predictor table. If the predictor predicts reuse (counter ≥2), we insert with RRPV=2; otherwise we insert with RRPV=3. On every hit, we reset the line’s RRPV to 0 and set its reuse flag. When a block is evicted (on a miss insertion), we recompute its signature index from the victim address and update the predictor counter up or down based on whether its reuse flag was set. This simple AddrSig-RRIP mechanism dynamically learns which addresses are worth caching, bypassing one-time and streaming blocks while retaining highly reused data. It targets pointer-chasing (MCF/Omnet++), phase-shifting (MILC), deep speculative (Astar), and stencil (LBM) patterns with under 16 KB of metadata.",,ChampSim_CRC2/new_policies/000_02_addrsig_rrip_t07.cc,0.009520482,0.009520482,0%
949,omnetpp,AddrSig-RRIP,"AddrSig-RRIP augments Static RRIP with a compact address-signature reuse predictor. Each cache line carries a 2-bit RRPV and a 1-bit “reuse seen” flag. On insertion, we hash the incoming block’s physical address to index a small (256-entry) 2-bit saturating predictor table. If the predictor predicts reuse (counter ≥2), we insert with RRPV=2; otherwise we insert with RRPV=3. On every hit, we reset the line’s RRPV to 0 and set its reuse flag. When a block is evicted (on a miss insertion), we recompute its signature index from the victim address and update the predictor counter up or down based on whether its reuse flag was set. This simple AddrSig-RRIP mechanism dynamically learns which addresses are worth caching, bypassing one-time and streaming blocks while retaining highly reused data. It targets pointer-chasing (MCF/Omnet++), phase-shifting (MILC), deep speculative (Astar), and stencil (LBM) patterns with under 16 KB of metadata.",,ChampSim_CRC2/new_policies/000_02_addrsig_rrip_t07.cc,0.001151215,0.001151215,0%
950,all,ShipStreamRIP,"ShipStreamRIP combines PC-based hit prediction (a lightweight SHiP-lite table) with a simple streaming detector and SRRIP (Static Re-Reference Interval Prediction). We track a small per-PC hit counter to bias new lines from “good” PCs toward long cache residency (RRPV=0) and lines from “cold” PCs toward early eviction (RRPV=2). A per-PC streaming unit detects small ID-stride scans and forces streaming blocks to be inserted with maximum RRPV, effectively bypassing the cache. On hits, lines are promoted to RRPV=0. This composition targets pointer-chasing/irregular workloads (MCF, Omnet++), streaming/stencil codes (LBM, MILC), and speculative control-flow (A*), achieving strong reuse capture, pollution avoidance, and conflict mitigation with <16 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_shipstreamrip_t02.cc,0.437636984,0.437636984,44%
951,astar,ShipStreamDRRIP,"ShipStreamDRRIP augments ShipStreamRIP with set-dueling DRRIP (dynamic insertion policy selection between Bimodal Insertion – BIP – and SRRIP) using a 10-bit PSEL and 128 leader sets. We still apply PC-based SHiP-lite to grant “hot” lines RRPV=0 and an ID-stride streaming detector to bypass true streams. In leader sets we force pure BIP or SRRIP and update PSEL on hits, guiding follower sets. This dynamic insertion depth selection improves adaptability across pointer-chasing (MCF, omnetpp), stencil (LBM), mixed (milc), and speculative (astar) workloads, while keeping metadata under 16 KiB.",,ChampSim_CRC2/new_policies/001_00_shipstreamdrrip_t02.cc,0.307717863,0.307717863,0%
952,lbm,ShipStreamDRRIP,"ShipStreamDRRIP augments ShipStreamRIP with set-dueling DRRIP (dynamic insertion policy selection between Bimodal Insertion – BIP – and SRRIP) using a 10-bit PSEL and 128 leader sets. We still apply PC-based SHiP-lite to grant “hot” lines RRPV=0 and an ID-stride streaming detector to bypass true streams. In leader sets we force pure BIP or SRRIP and update PSEL on hits, guiding follower sets. This dynamic insertion depth selection improves adaptability across pointer-chasing (MCF, omnetpp), stencil (LBM), mixed (milc), and speculative (astar) workloads, while keeping metadata under 16 KiB.",,ChampSim_CRC2/new_policies/001_00_shipstreamdrrip_t02.cc,0.236274998,0.236274998,0%
953,mcf,ShipStreamDRRIP,"ShipStreamDRRIP augments ShipStreamRIP with set-dueling DRRIP (dynamic insertion policy selection between Bimodal Insertion – BIP – and SRRIP) using a 10-bit PSEL and 128 leader sets. We still apply PC-based SHiP-lite to grant “hot” lines RRPV=0 and an ID-stride streaming detector to bypass true streams. In leader sets we force pure BIP or SRRIP and update PSEL on hits, guiding follower sets. This dynamic insertion depth selection improves adaptability across pointer-chasing (MCF, omnetpp), stencil (LBM), mixed (milc), and speculative (astar) workloads, while keeping metadata under 16 KiB.",,ChampSim_CRC2/new_policies/001_00_shipstreamdrrip_t02.cc,0.494900947,0.494900947,0%
954,milc,ShipStreamDRRIP,"ShipStreamDRRIP augments ShipStreamRIP with set-dueling DRRIP (dynamic insertion policy selection between Bimodal Insertion – BIP – and SRRIP) using a 10-bit PSEL and 128 leader sets. We still apply PC-based SHiP-lite to grant “hot” lines RRPV=0 and an ID-stride streaming detector to bypass true streams. In leader sets we force pure BIP or SRRIP and update PSEL on hits, guiding follower sets. This dynamic insertion depth selection improves adaptability across pointer-chasing (MCF, omnetpp), stencil (LBM), mixed (milc), and speculative (astar) workloads, while keeping metadata under 16 KiB.",,ChampSim_CRC2/new_policies/001_00_shipstreamdrrip_t02.cc,0.148960513,0.148960513,0%
955,omnetpp,ShipStreamDRRIP,"ShipStreamDRRIP augments ShipStreamRIP with set-dueling DRRIP (dynamic insertion policy selection between Bimodal Insertion – BIP – and SRRIP) using a 10-bit PSEL and 128 leader sets. We still apply PC-based SHiP-lite to grant “hot” lines RRPV=0 and an ID-stride streaming detector to bypass true streams. In leader sets we force pure BIP or SRRIP and update PSEL on hits, guiding follower sets. This dynamic insertion depth selection improves adaptability across pointer-chasing (MCF, omnetpp), stencil (LBM), mixed (milc), and speculative (astar) workloads, while keeping metadata under 16 KiB.",,ChampSim_CRC2/new_policies/001_00_shipstreamdrrip_t02.cc,0.506021437,0.506021437,0%
956,astar,ShipStreamDRRIP,"ShipStreamDRRIP enhances ShipStreamRIP by adding dynamic set‐dueling between SRRIP and Bimodal RRIP (BRRIP) to automatically adjust insertion depth for varying reuse behaviors. We retain the PC‐based SHiP-lite predictor to identify “hot” PCs (strong reuse) and a streaming detector to bypass or deprioritize one‐pass scans, but change our static SRRIP insertion to DRRIP: 32 sets force SRRIP, 32 sets force BRRIP, and the remaining sets follow the policy chosen by a 10-bit PSEL that is incremented/decremented on misses in the leader sets. BRRIP inserts most lines at long re‐reference intervals with rare low‐RRPV insertion (1/32 chance), while SRRIP uses a mid‐RRPV default. This dynamic mechanism better balances high‐locality (milc, lbm) and low‐locality (mcf, omnetpp) phases, reducing both thrashing and underutilization with minimal additional metadata.",,ChampSim_CRC2/new_policies/001_01_shipstreamdrrip_t04.cc,0.461016457,0.461016457,0%
957,lbm,ShipStreamDRRIP,"ShipStreamDRRIP enhances ShipStreamRIP by adding dynamic set‐dueling between SRRIP and Bimodal RRIP (BRRIP) to automatically adjust insertion depth for varying reuse behaviors. We retain the PC‐based SHiP-lite predictor to identify “hot” PCs (strong reuse) and a streaming detector to bypass or deprioritize one‐pass scans, but change our static SRRIP insertion to DRRIP: 32 sets force SRRIP, 32 sets force BRRIP, and the remaining sets follow the policy chosen by a 10-bit PSEL that is incremented/decremented on misses in the leader sets. BRRIP inserts most lines at long re‐reference intervals with rare low‐RRPV insertion (1/32 chance), while SRRIP uses a mid‐RRPV default. This dynamic mechanism better balances high‐locality (milc, lbm) and low‐locality (mcf, omnetpp) phases, reducing both thrashing and underutilization with minimal additional metadata.",,ChampSim_CRC2/new_policies/001_01_shipstreamdrrip_t04.cc,0.26124873,0.26124873,0%
958,mcf,ShipStreamDRRIP,"ShipStreamDRRIP enhances ShipStreamRIP by adding dynamic set‐dueling between SRRIP and Bimodal RRIP (BRRIP) to automatically adjust insertion depth for varying reuse behaviors. We retain the PC‐based SHiP-lite predictor to identify “hot” PCs (strong reuse) and a streaming detector to bypass or deprioritize one‐pass scans, but change our static SRRIP insertion to DRRIP: 32 sets force SRRIP, 32 sets force BRRIP, and the remaining sets follow the policy chosen by a 10-bit PSEL that is incremented/decremented on misses in the leader sets. BRRIP inserts most lines at long re‐reference intervals with rare low‐RRPV insertion (1/32 chance), while SRRIP uses a mid‐RRPV default. This dynamic mechanism better balances high‐locality (milc, lbm) and low‐locality (mcf, omnetpp) phases, reducing both thrashing and underutilization with minimal additional metadata.",,ChampSim_CRC2/new_policies/001_01_shipstreamdrrip_t04.cc,0.497871506,0.497871506,0%
959,milc,ShipStreamDRRIP,"ShipStreamDRRIP enhances ShipStreamRIP by adding dynamic set‐dueling between SRRIP and Bimodal RRIP (BRRIP) to automatically adjust insertion depth for varying reuse behaviors. We retain the PC‐based SHiP-lite predictor to identify “hot” PCs (strong reuse) and a streaming detector to bypass or deprioritize one‐pass scans, but change our static SRRIP insertion to DRRIP: 32 sets force SRRIP, 32 sets force BRRIP, and the remaining sets follow the policy chosen by a 10-bit PSEL that is incremented/decremented on misses in the leader sets. BRRIP inserts most lines at long re‐reference intervals with rare low‐RRPV insertion (1/32 chance), while SRRIP uses a mid‐RRPV default. This dynamic mechanism better balances high‐locality (milc, lbm) and low‐locality (mcf, omnetpp) phases, reducing both thrashing and underutilization with minimal additional metadata.",,ChampSim_CRC2/new_policies/001_01_shipstreamdrrip_t04.cc,0.172109097,0.172109097,0%
960,omnetpp,ShipStreamDRRIP,"ShipStreamDRRIP enhances ShipStreamRIP by adding dynamic set‐dueling between SRRIP and Bimodal RRIP (BRRIP) to automatically adjust insertion depth for varying reuse behaviors. We retain the PC‐based SHiP-lite predictor to identify “hot” PCs (strong reuse) and a streaming detector to bypass or deprioritize one‐pass scans, but change our static SRRIP insertion to DRRIP: 32 sets force SRRIP, 32 sets force BRRIP, and the remaining sets follow the policy chosen by a 10-bit PSEL that is incremented/decremented on misses in the leader sets. BRRIP inserts most lines at long re‐reference intervals with rare low‐RRPV insertion (1/32 chance), while SRRIP uses a mid‐RRPV default. This dynamic mechanism better balances high‐locality (milc, lbm) and low‐locality (mcf, omnetpp) phases, reducing both thrashing and underutilization with minimal additional metadata.",,ChampSim_CRC2/new_policies/001_01_shipstreamdrrip_t04.cc,0.496355503,0.496355503,0%
961,astar,DynamicStreamDRRIP,"DynamicStreamDRRIP combines PC-based streaming detection with a set-dueling DRRIP framework to dynamically choose between SRRIP and BRRIP insertion policies. A small streaming detector (per-PC signature) bypasses pure sequential scans to avoid pollution, while the DRRIP selector (10-bit PSEL and 128 leader sets) steers follower sets toward the better insertion policy for current workload behavior. This design adapts to both heavy-reuse stencil codes (LBM, MILC) and pointer-chasing or irregular codes (MCF, Omnet++), capturing reuse when beneficial and preventing cache pollution by both streams and conflict-prone accesses.",,ChampSim_CRC2/new_policies/001_02_dynamicstreamdrrip_t07.cc,0.421797261,0.421797261,0%
962,lbm,DynamicStreamDRRIP,"DynamicStreamDRRIP combines PC-based streaming detection with a set-dueling DRRIP framework to dynamically choose between SRRIP and BRRIP insertion policies. A small streaming detector (per-PC signature) bypasses pure sequential scans to avoid pollution, while the DRRIP selector (10-bit PSEL and 128 leader sets) steers follower sets toward the better insertion policy for current workload behavior. This design adapts to both heavy-reuse stencil codes (LBM, MILC) and pointer-chasing or irregular codes (MCF, Omnet++), capturing reuse when beneficial and preventing cache pollution by both streams and conflict-prone accesses.",,ChampSim_CRC2/new_policies/001_02_dynamicstreamdrrip_t07.cc,0.403818749,0.403818749,0%
963,mcf,DynamicStreamDRRIP,"DynamicStreamDRRIP combines PC-based streaming detection with a set-dueling DRRIP framework to dynamically choose between SRRIP and BRRIP insertion policies. A small streaming detector (per-PC signature) bypasses pure sequential scans to avoid pollution, while the DRRIP selector (10-bit PSEL and 128 leader sets) steers follower sets toward the better insertion policy for current workload behavior. This design adapts to both heavy-reuse stencil codes (LBM, MILC) and pointer-chasing or irregular codes (MCF, Omnet++), capturing reuse when beneficial and preventing cache pollution by both streams and conflict-prone accesses.",,ChampSim_CRC2/new_policies/001_02_dynamicstreamdrrip_t07.cc,0.457659615,0.457659615,0%
964,milc,DynamicStreamDRRIP,"DynamicStreamDRRIP combines PC-based streaming detection with a set-dueling DRRIP framework to dynamically choose between SRRIP and BRRIP insertion policies. A small streaming detector (per-PC signature) bypasses pure sequential scans to avoid pollution, while the DRRIP selector (10-bit PSEL and 128 leader sets) steers follower sets toward the better insertion policy for current workload behavior. This design adapts to both heavy-reuse stencil codes (LBM, MILC) and pointer-chasing or irregular codes (MCF, Omnet++), capturing reuse when beneficial and preventing cache pollution by both streams and conflict-prone accesses.",,ChampSim_CRC2/new_policies/001_02_dynamicstreamdrrip_t07.cc,0.282480792,0.282480792,0%
965,omnetpp,DynamicStreamDRRIP,"DynamicStreamDRRIP combines PC-based streaming detection with a set-dueling DRRIP framework to dynamically choose between SRRIP and BRRIP insertion policies. A small streaming detector (per-PC signature) bypasses pure sequential scans to avoid pollution, while the DRRIP selector (10-bit PSEL and 128 leader sets) steers follower sets toward the better insertion policy for current workload behavior. This design adapts to both heavy-reuse stencil codes (LBM, MILC) and pointer-chasing or irregular codes (MCF, Omnet++), capturing reuse when beneficial and preventing cache pollution by both streams and conflict-prone accesses.",,ChampSim_CRC2/new_policies/001_02_dynamicstreamdrrip_t07.cc,0.53524882,0.53524882,0%
966,all,DynamicStreamDRRIP,"DynamicStreamDRRIP combines PC-based streaming detection with a set-dueling DRRIP framework to dynamically choose between SRRIP and BRRIP insertion policies. A small streaming detector (per-PC signature) bypasses pure sequential scans to avoid pollution, while the DRRIP selector (10-bit PSEL and 128 leader sets) steers follower sets toward the better insertion policy for current workload behavior. This design adapts to both heavy-reuse stencil codes (LBM, MILC) and pointer-chasing or irregular codes (MCF, Omnet++), capturing reuse when beneficial and preventing cache pollution by both streams and conflict-prone accesses.",,ChampSim_CRC2/new_policies/001_02_dynamicstreamdrrip_t07.cc,0.420201048,0.420201048,42%
967,astar,StrideSHiP-BIP,"StrideSHiP-BIP combines a lightweight PC‐based reuse predictor (SHiP-lite) with a tiny stride detector and a bimodal insertion policy (BIP). We maintain a small SHCT table of 2-bit counters indexed by PC hashes to learn which PCs produce high reuse—those inserts get strong SRRIP treatment (RRPV=INIT_RRPV). A compact stride table tracks per-PC address deltas; repeated identical strides signal streaming scans that are bypassed (inserted at RRPV=MAX_RRPV) to avoid pollution. All other “cold” PCs follow a BIP policy: with low probability (1/32) they get INIT_RRPV, otherwise MAX_RRPV. Hits always reset the block’s RRPV to 0 and train the SHCT. This triage—streaming bypass, SRRIP for heavy reuse, occasional fill for cold—targets high spatial‐reuse stencils (LBM/MILC), irregular pointer chains (MCF/Omnet++), and control-intensive codes (astar) with <16 KiB extra metadata.",,ChampSim_CRC2/new_policies/002_00_strideship_bip_t02.cc,0.421520858,0.421520858,0%
968,lbm,StrideSHiP-BIP,"StrideSHiP-BIP combines a lightweight PC‐based reuse predictor (SHiP-lite) with a tiny stride detector and a bimodal insertion policy (BIP). We maintain a small SHCT table of 2-bit counters indexed by PC hashes to learn which PCs produce high reuse—those inserts get strong SRRIP treatment (RRPV=INIT_RRPV). A compact stride table tracks per-PC address deltas; repeated identical strides signal streaming scans that are bypassed (inserted at RRPV=MAX_RRPV) to avoid pollution. All other “cold” PCs follow a BIP policy: with low probability (1/32) they get INIT_RRPV, otherwise MAX_RRPV. Hits always reset the block’s RRPV to 0 and train the SHCT. This triage—streaming bypass, SRRIP for heavy reuse, occasional fill for cold—targets high spatial‐reuse stencils (LBM/MILC), irregular pointer chains (MCF/Omnet++), and control-intensive codes (astar) with <16 KiB extra metadata.",,ChampSim_CRC2/new_policies/002_00_strideship_bip_t02.cc,0.193801252,0.193801252,0%
969,mcf,StrideSHiP-BIP,"StrideSHiP-BIP combines a lightweight PC‐based reuse predictor (SHiP-lite) with a tiny stride detector and a bimodal insertion policy (BIP). We maintain a small SHCT table of 2-bit counters indexed by PC hashes to learn which PCs produce high reuse—those inserts get strong SRRIP treatment (RRPV=INIT_RRPV). A compact stride table tracks per-PC address deltas; repeated identical strides signal streaming scans that are bypassed (inserted at RRPV=MAX_RRPV) to avoid pollution. All other “cold” PCs follow a BIP policy: with low probability (1/32) they get INIT_RRPV, otherwise MAX_RRPV. Hits always reset the block’s RRPV to 0 and train the SHCT. This triage—streaming bypass, SRRIP for heavy reuse, occasional fill for cold—targets high spatial‐reuse stencils (LBM/MILC), irregular pointer chains (MCF/Omnet++), and control-intensive codes (astar) with <16 KiB extra metadata.",,ChampSim_CRC2/new_policies/002_00_strideship_bip_t02.cc,0.461411722,0.461411722,0%
970,milc,StrideSHiP-BIP,"StrideSHiP-BIP combines a lightweight PC‐based reuse predictor (SHiP-lite) with a tiny stride detector and a bimodal insertion policy (BIP). We maintain a small SHCT table of 2-bit counters indexed by PC hashes to learn which PCs produce high reuse—those inserts get strong SRRIP treatment (RRPV=INIT_RRPV). A compact stride table tracks per-PC address deltas; repeated identical strides signal streaming scans that are bypassed (inserted at RRPV=MAX_RRPV) to avoid pollution. All other “cold” PCs follow a BIP policy: with low probability (1/32) they get INIT_RRPV, otherwise MAX_RRPV. Hits always reset the block’s RRPV to 0 and train the SHCT. This triage—streaming bypass, SRRIP for heavy reuse, occasional fill for cold—targets high spatial‐reuse stencils (LBM/MILC), irregular pointer chains (MCF/Omnet++), and control-intensive codes (astar) with <16 KiB extra metadata.",,ChampSim_CRC2/new_policies/002_00_strideship_bip_t02.cc,0.018785709,0.018785709,0%
971,omnetpp,StrideSHiP-BIP,"StrideSHiP-BIP combines a lightweight PC‐based reuse predictor (SHiP-lite) with a tiny stride detector and a bimodal insertion policy (BIP). We maintain a small SHCT table of 2-bit counters indexed by PC hashes to learn which PCs produce high reuse—those inserts get strong SRRIP treatment (RRPV=INIT_RRPV). A compact stride table tracks per-PC address deltas; repeated identical strides signal streaming scans that are bypassed (inserted at RRPV=MAX_RRPV) to avoid pollution. All other “cold” PCs follow a BIP policy: with low probability (1/32) they get INIT_RRPV, otherwise MAX_RRPV. Hits always reset the block’s RRPV to 0 and train the SHCT. This triage—streaming bypass, SRRIP for heavy reuse, occasional fill for cold—targets high spatial‐reuse stencils (LBM/MILC), irregular pointer chains (MCF/Omnet++), and control-intensive codes (astar) with <16 KiB extra metadata.",,ChampSim_CRC2/new_policies/002_00_strideship_bip_t02.cc,0.459501697,0.459501697,0%
972,astar,SHiP_RRIP,"We replace the PC‐agnostic stream detector and set‐dueling DRRIP with a lightweight SHiP‐lite predictor driving the insertion RRPV in a pure SRRIP framework. A small PC‐signature table (2‐bit saturating counters) learns which PCs produce useful reuse: on a miss we consult the counter to pick a “short” (INIT_RRPV=2) or “long” (MAX_RRPV=3) insertion, then penalize the counter; on a hit we strongly promote the block (RRPV=0) and reward the PC. This steers regular stencil and QCD loops to retain cache blocks, while pointer‐chasing and streaming PCs remain at long RRPV and naturally bypass, reducing pollution. The metadata overhead is ~33 KiB, well under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_ship_rrip_t04.cc,0.147774065,0.147774065,0%
973,lbm,SHiP_RRIP,"We replace the PC‐agnostic stream detector and set‐dueling DRRIP with a lightweight SHiP‐lite predictor driving the insertion RRPV in a pure SRRIP framework. A small PC‐signature table (2‐bit saturating counters) learns which PCs produce useful reuse: on a miss we consult the counter to pick a “short” (INIT_RRPV=2) or “long” (MAX_RRPV=3) insertion, then penalize the counter; on a hit we strongly promote the block (RRPV=0) and reward the PC. This steers regular stencil and QCD loops to retain cache blocks, while pointer‐chasing and streaming PCs remain at long RRPV and naturally bypass, reducing pollution. The metadata overhead is ~33 KiB, well under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_ship_rrip_t04.cc,0.069391007,0.069391007,0%
974,mcf,SHiP_RRIP,"We replace the PC‐agnostic stream detector and set‐dueling DRRIP with a lightweight SHiP‐lite predictor driving the insertion RRPV in a pure SRRIP framework. A small PC‐signature table (2‐bit saturating counters) learns which PCs produce useful reuse: on a miss we consult the counter to pick a “short” (INIT_RRPV=2) or “long” (MAX_RRPV=3) insertion, then penalize the counter; on a hit we strongly promote the block (RRPV=0) and reward the PC. This steers regular stencil and QCD loops to retain cache blocks, while pointer‐chasing and streaming PCs remain at long RRPV and naturally bypass, reducing pollution. The metadata overhead is ~33 KiB, well under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_ship_rrip_t04.cc,0.474934344,0.474934344,0%
975,milc,SHiP_RRIP,"We replace the PC‐agnostic stream detector and set‐dueling DRRIP with a lightweight SHiP‐lite predictor driving the insertion RRPV in a pure SRRIP framework. A small PC‐signature table (2‐bit saturating counters) learns which PCs produce useful reuse: on a miss we consult the counter to pick a “short” (INIT_RRPV=2) or “long” (MAX_RRPV=3) insertion, then penalize the counter; on a hit we strongly promote the block (RRPV=0) and reward the PC. This steers regular stencil and QCD loops to retain cache blocks, while pointer‐chasing and streaming PCs remain at long RRPV and naturally bypass, reducing pollution. The metadata overhead is ~33 KiB, well under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_ship_rrip_t04.cc,0.009755824,0.009755824,0%
976,omnetpp,SHiP_RRIP,"We replace the PC‐agnostic stream detector and set‐dueling DRRIP with a lightweight SHiP‐lite predictor driving the insertion RRPV in a pure SRRIP framework. A small PC‐signature table (2‐bit saturating counters) learns which PCs produce useful reuse: on a miss we consult the counter to pick a “short” (INIT_RRPV=2) or “long” (MAX_RRPV=3) insertion, then penalize the counter; on a hit we strongly promote the block (RRPV=0) and reward the PC. This steers regular stencil and QCD loops to retain cache blocks, while pointer‐chasing and streaming PCs remain at long RRPV and naturally bypass, reducing pollution. The metadata overhead is ~33 KiB, well under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_ship_rrip_t04.cc,0.007139917,0.007139917,0%
977,astar,SHiP-Lite,"SHiP-Lite uses a small 2-bit saturating counter table indexed by PC signatures to predict whether a newly fetched block will be reused. On a hit, the corresponding counter is incremented and the block is promoted to RRPV=0 (MRU). On a miss, the counter is decremented and the new block is inserted at RRPV=MAX_RRPV (LRU position), effectively bypassing pollution from non-reuse streams or pointer‐chasing code. Victim selection is plain SRRIP. This simple PC-based predictor replaces set-dueling and streaming detection, yielding fast adaptation for both high‐reuse stencil phases and low‐reuse irregular accesses within a 6 KB metadata budget.",,ChampSim_CRC2/new_policies/002_02_ship_lite_t07.cc,0.049653432,0.049653432,0%
978,lbm,SHiP-Lite,"SHiP-Lite uses a small 2-bit saturating counter table indexed by PC signatures to predict whether a newly fetched block will be reused. On a hit, the corresponding counter is incremented and the block is promoted to RRPV=0 (MRU). On a miss, the counter is decremented and the new block is inserted at RRPV=MAX_RRPV (LRU position), effectively bypassing pollution from non-reuse streams or pointer‐chasing code. Victim selection is plain SRRIP. This simple PC-based predictor replaces set-dueling and streaming detection, yielding fast adaptation for both high‐reuse stencil phases and low‐reuse irregular accesses within a 6 KB metadata budget.",,ChampSim_CRC2/new_policies/002_02_ship_lite_t07.cc,0.061306641,0.061306641,0%
979,mcf,SHiP-Lite,"SHiP-Lite uses a small 2-bit saturating counter table indexed by PC signatures to predict whether a newly fetched block will be reused. On a hit, the corresponding counter is incremented and the block is promoted to RRPV=0 (MRU). On a miss, the counter is decremented and the new block is inserted at RRPV=MAX_RRPV (LRU position), effectively bypassing pollution from non-reuse streams or pointer‐chasing code. Victim selection is plain SRRIP. This simple PC-based predictor replaces set-dueling and streaming detection, yielding fast adaptation for both high‐reuse stencil phases and low‐reuse irregular accesses within a 6 KB metadata budget.",,ChampSim_CRC2/new_policies/002_02_ship_lite_t07.cc,0.423799803,0.423799803,0%
980,milc,SHiP-Lite,"SHiP-Lite uses a small 2-bit saturating counter table indexed by PC signatures to predict whether a newly fetched block will be reused. On a hit, the corresponding counter is incremented and the block is promoted to RRPV=0 (MRU). On a miss, the counter is decremented and the new block is inserted at RRPV=MAX_RRPV (LRU position), effectively bypassing pollution from non-reuse streams or pointer‐chasing code. Victim selection is plain SRRIP. This simple PC-based predictor replaces set-dueling and streaming detection, yielding fast adaptation for both high‐reuse stencil phases and low‐reuse irregular accesses within a 6 KB metadata budget.",,ChampSim_CRC2/new_policies/002_02_ship_lite_t07.cc,0.00962186,0.00962186,0%
981,omnetpp,SHiP-Lite,"SHiP-Lite uses a small 2-bit saturating counter table indexed by PC signatures to predict whether a newly fetched block will be reused. On a hit, the corresponding counter is incremented and the block is promoted to RRPV=0 (MRU). On a miss, the counter is decremented and the new block is inserted at RRPV=MAX_RRPV (LRU position), effectively bypassing pollution from non-reuse streams or pointer‐chasing code. Victim selection is plain SRRIP. This simple PC-based predictor replaces set-dueling and streaming detection, yielding fast adaptation for both high‐reuse stencil phases and low‐reuse irregular accesses within a 6 KB metadata budget.",,ChampSim_CRC2/new_policies/002_02_ship_lite_t07.cc,0.001169109,0.001169109,0%
982,all,StrideSHiP-BIP,"StrideSHiP-BIP combines a lightweight PC‐based reuse predictor (SHiP-lite) with a tiny stride detector and a bimodal insertion policy (BIP). We maintain a small SHCT table of 2-bit counters indexed by PC hashes to learn which PCs produce high reuse—those inserts get strong SRRIP treatment (RRPV=INIT_RRPV). A compact stride table tracks per-PC address deltas; repeated identical strides signal streaming scans that are bypassed (inserted at RRPV=MAX_RRPV) to avoid pollution. All other “cold” PCs follow a BIP policy: with low probability (1/32) they get INIT_RRPV, otherwise MAX_RRPV. Hits always reset the block’s RRPV to 0 and train the SHCT. This triage—streaming bypass, SRRIP for heavy reuse, occasional fill for cold—targets high spatial‐reuse stencils (LBM/MILC), irregular pointer chains (MCF/Omnet++), and control-intensive codes (astar) with <16 KiB extra metadata.",,ChampSim_CRC2/new_policies/002_00_strideship_bip_t02.cc,0.311004247,0.311004247,31%
983,astar,DRRIP-SHiP-Stream,"DRRIP-SHiP-Stream combines dynamic repl­acement (DRRIP) with lightweight PC-based reuse prediction (SHiP-lite) and a simple streaming bypass detector. 64 “leader” sets (32 for SRRIP, 32 for BRRIP) adaptively tune a 10-bit PSEL counter to choose between SRRIP (favoring blocks with moderate RRPV) and BRRIP (bimodal insertion). 2K-entry SHCT tables track which PCs produce true reuse—those inserts get aggressive RRPV=0 to capture frequent reuse in stencils (LBM/MILC) and scientific loops (MILC), while SCAN-like streams detected by stride matching are bypassed at RRPV=MAX to avoid LLC pollution. 16-way 2-bit RRPVs per line cost ~8 KB; SHCT 2 bits×2 K=512 B; stride detector ~4.5 KB; PSEL + leader flags ~1 KB—well under 64 KB.  This hybrid adapts both to phase changes (via DRRIP), PC reuse biasing (via SHiP), and scans, boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_00_drrip_ship_stream_t02.cc,0.448090157,0.448090157,0%
984,lbm,DRRIP-SHiP-Stream,"DRRIP-SHiP-Stream combines dynamic repl­acement (DRRIP) with lightweight PC-based reuse prediction (SHiP-lite) and a simple streaming bypass detector. 64 “leader” sets (32 for SRRIP, 32 for BRRIP) adaptively tune a 10-bit PSEL counter to choose between SRRIP (favoring blocks with moderate RRPV) and BRRIP (bimodal insertion). 2K-entry SHCT tables track which PCs produce true reuse—those inserts get aggressive RRPV=0 to capture frequent reuse in stencils (LBM/MILC) and scientific loops (MILC), while SCAN-like streams detected by stride matching are bypassed at RRPV=MAX to avoid LLC pollution. 16-way 2-bit RRPVs per line cost ~8 KB; SHCT 2 bits×2 K=512 B; stride detector ~4.5 KB; PSEL + leader flags ~1 KB—well under 64 KB.  This hybrid adapts both to phase changes (via DRRIP), PC reuse biasing (via SHiP), and scans, boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_00_drrip_ship_stream_t02.cc,0.316245172,0.316245172,0%
985,mcf,DRRIP-SHiP-Stream,"DRRIP-SHiP-Stream combines dynamic repl­acement (DRRIP) with lightweight PC-based reuse prediction (SHiP-lite) and a simple streaming bypass detector. 64 “leader” sets (32 for SRRIP, 32 for BRRIP) adaptively tune a 10-bit PSEL counter to choose between SRRIP (favoring blocks with moderate RRPV) and BRRIP (bimodal insertion). 2K-entry SHCT tables track which PCs produce true reuse—those inserts get aggressive RRPV=0 to capture frequent reuse in stencils (LBM/MILC) and scientific loops (MILC), while SCAN-like streams detected by stride matching are bypassed at RRPV=MAX to avoid LLC pollution. 16-way 2-bit RRPVs per line cost ~8 KB; SHCT 2 bits×2 K=512 B; stride detector ~4.5 KB; PSEL + leader flags ~1 KB—well under 64 KB.  This hybrid adapts both to phase changes (via DRRIP), PC reuse biasing (via SHiP), and scans, boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_00_drrip_ship_stream_t02.cc,0.40527757,0.40527757,0%
986,milc,DRRIP-SHiP-Stream,"DRRIP-SHiP-Stream combines dynamic repl­acement (DRRIP) with lightweight PC-based reuse prediction (SHiP-lite) and a simple streaming bypass detector. 64 “leader” sets (32 for SRRIP, 32 for BRRIP) adaptively tune a 10-bit PSEL counter to choose between SRRIP (favoring blocks with moderate RRPV) and BRRIP (bimodal insertion). 2K-entry SHCT tables track which PCs produce true reuse—those inserts get aggressive RRPV=0 to capture frequent reuse in stencils (LBM/MILC) and scientific loops (MILC), while SCAN-like streams detected by stride matching are bypassed at RRPV=MAX to avoid LLC pollution. 16-way 2-bit RRPVs per line cost ~8 KB; SHCT 2 bits×2 K=512 B; stride detector ~4.5 KB; PSEL + leader flags ~1 KB—well under 64 KB.  This hybrid adapts both to phase changes (via DRRIP), PC reuse biasing (via SHiP), and scans, boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_00_drrip_ship_stream_t02.cc,0.117118764,0.117118764,0%
987,omnetpp,DRRIP-SHiP-Stream,"DRRIP-SHiP-Stream combines dynamic repl­acement (DRRIP) with lightweight PC-based reuse prediction (SHiP-lite) and a simple streaming bypass detector. 64 “leader” sets (32 for SRRIP, 32 for BRRIP) adaptively tune a 10-bit PSEL counter to choose between SRRIP (favoring blocks with moderate RRPV) and BRRIP (bimodal insertion). 2K-entry SHCT tables track which PCs produce true reuse—those inserts get aggressive RRPV=0 to capture frequent reuse in stencils (LBM/MILC) and scientific loops (MILC), while SCAN-like streams detected by stride matching are bypassed at RRPV=MAX to avoid LLC pollution. 16-way 2-bit RRPVs per line cost ~8 KB; SHCT 2 bits×2 K=512 B; stride detector ~4.5 KB; PSEL + leader flags ~1 KB—well under 64 KB.  This hybrid adapts both to phase changes (via DRRIP), PC reuse biasing (via SHiP), and scans, boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_00_drrip_ship_stream_t02.cc,0.553250503,0.553250503,0%
988,astar,DRRIP-DIP-SHiP-DBP,"This policy combines dynamic RRIP set‐dueling (DRRIP) to choose between SRRIP and BRRIP for “cold” PCs, a lightweight SHiP‐lite predictor to detect “hot” PCs (inserting them with a strong SRRIP depth), and a 2‐bit per‐line dead‐block predictor (DBP) to bypass lines that have not shown reuse.  Hot PCs (high SHiP counters) always get strong SRRIP insertion, cold PCs use DRRIP’s SRRIP/BRRIP duel, and blocks predicted dead are inserted at the longest RRPV (bypassed).  Hits promote to RRPV=0, train both SHiP and DB counters.  This combination adapts to streaming or pointer chasing (DBP), control‐intensive or reuse‐heavy phases (SHiP), and effectively tunes insertion depth globally via DRRIP.",,ChampSim_CRC2/new_policies/003_01_drrip_dip_ship_dbp_t04.cc,0.045124665,0.045124665,0%
989,lbm,DRRIP-DIP-SHiP-DBP,"This policy combines dynamic RRIP set‐dueling (DRRIP) to choose between SRRIP and BRRIP for “cold” PCs, a lightweight SHiP‐lite predictor to detect “hot” PCs (inserting them with a strong SRRIP depth), and a 2‐bit per‐line dead‐block predictor (DBP) to bypass lines that have not shown reuse.  Hot PCs (high SHiP counters) always get strong SRRIP insertion, cold PCs use DRRIP’s SRRIP/BRRIP duel, and blocks predicted dead are inserted at the longest RRPV (bypassed).  Hits promote to RRPV=0, train both SHiP and DB counters.  This combination adapts to streaming or pointer chasing (DBP), control‐intensive or reuse‐heavy phases (SHiP), and effectively tunes insertion depth globally via DRRIP.",,ChampSim_CRC2/new_policies/003_01_drrip_dip_ship_dbp_t04.cc,0.058753172,0.058753172,0%
990,mcf,DRRIP-DIP-SHiP-DBP,"This policy combines dynamic RRIP set‐dueling (DRRIP) to choose between SRRIP and BRRIP for “cold” PCs, a lightweight SHiP‐lite predictor to detect “hot” PCs (inserting them with a strong SRRIP depth), and a 2‐bit per‐line dead‐block predictor (DBP) to bypass lines that have not shown reuse.  Hot PCs (high SHiP counters) always get strong SRRIP insertion, cold PCs use DRRIP’s SRRIP/BRRIP duel, and blocks predicted dead are inserted at the longest RRPV (bypassed).  Hits promote to RRPV=0, train both SHiP and DB counters.  This combination adapts to streaming or pointer chasing (DBP), control‐intensive or reuse‐heavy phases (SHiP), and effectively tunes insertion depth globally via DRRIP.",,ChampSim_CRC2/new_policies/003_01_drrip_dip_ship_dbp_t04.cc,0.214312084,0.214312084,0%
991,milc,DRRIP-DIP-SHiP-DBP,"This policy combines dynamic RRIP set‐dueling (DRRIP) to choose between SRRIP and BRRIP for “cold” PCs, a lightweight SHiP‐lite predictor to detect “hot” PCs (inserting them with a strong SRRIP depth), and a 2‐bit per‐line dead‐block predictor (DBP) to bypass lines that have not shown reuse.  Hot PCs (high SHiP counters) always get strong SRRIP insertion, cold PCs use DRRIP’s SRRIP/BRRIP duel, and blocks predicted dead are inserted at the longest RRPV (bypassed).  Hits promote to RRPV=0, train both SHiP and DB counters.  This combination adapts to streaming or pointer chasing (DBP), control‐intensive or reuse‐heavy phases (SHiP), and effectively tunes insertion depth globally via DRRIP.",,ChampSim_CRC2/new_policies/003_01_drrip_dip_ship_dbp_t04.cc,0.009520482,0.009520482,0%
992,omnetpp,DRRIP-DIP-SHiP-DBP,"This policy combines dynamic RRIP set‐dueling (DRRIP) to choose between SRRIP and BRRIP for “cold” PCs, a lightweight SHiP‐lite predictor to detect “hot” PCs (inserting them with a strong SRRIP depth), and a 2‐bit per‐line dead‐block predictor (DBP) to bypass lines that have not shown reuse.  Hot PCs (high SHiP counters) always get strong SRRIP insertion, cold PCs use DRRIP’s SRRIP/BRRIP duel, and blocks predicted dead are inserted at the longest RRPV (bypassed).  Hits promote to RRPV=0, train both SHiP and DB counters.  This combination adapts to streaming or pointer chasing (DBP), control‐intensive or reuse‐heavy phases (SHiP), and effectively tunes insertion depth globally via DRRIP.",,ChampSim_CRC2/new_policies/003_01_drrip_dip_ship_dbp_t04.cc,0.001151215,0.001151215,0%
993,astar,DRRIP-DBP,"DRRIP-DBP pairs dynamic RRIP (DRRIP) set-dueling with a tiny dead-block predictor (DBP) to adapt insertion depth per workload while preventing pollution from lines unlikely to be reused. Two small groups of leader sets test SRRIP (shallow inserts) versus BRRIP (bimodal deep inserts) and drive a 10-bit PSEL counter that steers follower sets. A 1 KB DBP table tracks per-PC reuse counts; blocks with zero reuses are identified as dead and inserted with maximum RRPV to bypass the cache. This design dynamically balances spatial vs. temporal locality (benefiting LBM/astar/MILC) and suppresses one-time or streaming blocks (benefiting MCF/omnetpp), boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_02_drrip_dbp_t07.cc,0.250244511,0.250244511,0%
994,lbm,DRRIP-DBP,"DRRIP-DBP pairs dynamic RRIP (DRRIP) set-dueling with a tiny dead-block predictor (DBP) to adapt insertion depth per workload while preventing pollution from lines unlikely to be reused. Two small groups of leader sets test SRRIP (shallow inserts) versus BRRIP (bimodal deep inserts) and drive a 10-bit PSEL counter that steers follower sets. A 1 KB DBP table tracks per-PC reuse counts; blocks with zero reuses are identified as dead and inserted with maximum RRPV to bypass the cache. This design dynamically balances spatial vs. temporal locality (benefiting LBM/astar/MILC) and suppresses one-time or streaming blocks (benefiting MCF/omnetpp), boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_02_drrip_dbp_t07.cc,0.166683699,0.166683699,0%
995,mcf,DRRIP-DBP,"DRRIP-DBP pairs dynamic RRIP (DRRIP) set-dueling with a tiny dead-block predictor (DBP) to adapt insertion depth per workload while preventing pollution from lines unlikely to be reused. Two small groups of leader sets test SRRIP (shallow inserts) versus BRRIP (bimodal deep inserts) and drive a 10-bit PSEL counter that steers follower sets. A 1 KB DBP table tracks per-PC reuse counts; blocks with zero reuses are identified as dead and inserted with maximum RRPV to bypass the cache. This design dynamically balances spatial vs. temporal locality (benefiting LBM/astar/MILC) and suppresses one-time or streaming blocks (benefiting MCF/omnetpp), boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_02_drrip_dbp_t07.cc,0.414457291,0.414457291,0%
996,milc,DRRIP-DBP,"DRRIP-DBP pairs dynamic RRIP (DRRIP) set-dueling with a tiny dead-block predictor (DBP) to adapt insertion depth per workload while preventing pollution from lines unlikely to be reused. Two small groups of leader sets test SRRIP (shallow inserts) versus BRRIP (bimodal deep inserts) and drive a 10-bit PSEL counter that steers follower sets. A 1 KB DBP table tracks per-PC reuse counts; blocks with zero reuses are identified as dead and inserted with maximum RRPV to bypass the cache. This design dynamically balances spatial vs. temporal locality (benefiting LBM/astar/MILC) and suppresses one-time or streaming blocks (benefiting MCF/omnetpp), boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_02_drrip_dbp_t07.cc,0.012060363,0.012060363,0%
997,omnetpp,DRRIP-DBP,"DRRIP-DBP pairs dynamic RRIP (DRRIP) set-dueling with a tiny dead-block predictor (DBP) to adapt insertion depth per workload while preventing pollution from lines unlikely to be reused. Two small groups of leader sets test SRRIP (shallow inserts) versus BRRIP (bimodal deep inserts) and drive a 10-bit PSEL counter that steers follower sets. A 1 KB DBP table tracks per-PC reuse counts; blocks with zero reuses are identified as dead and inserted with maximum RRPV to bypass the cache. This design dynamically balances spatial vs. temporal locality (benefiting LBM/astar/MILC) and suppresses one-time or streaming blocks (benefiting MCF/omnetpp), boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_02_drrip_dbp_t07.cc,0.004151531,0.004151531,0%
998,all,DRRIP-SHiP-Stream,"DRRIP-SHiP-Stream combines dynamic repl­acement (DRRIP) with lightweight PC-based reuse prediction (SHiP-lite) and a simple streaming bypass detector. 64 “leader” sets (32 for SRRIP, 32 for BRRIP) adaptively tune a 10-bit PSEL counter to choose between SRRIP (favoring blocks with moderate RRPV) and BRRIP (bimodal insertion). 2K-entry SHCT tables track which PCs produce true reuse—those inserts get aggressive RRPV=0 to capture frequent reuse in stencils (LBM/MILC) and scientific loops (MILC), while SCAN-like streams detected by stride matching are bypassed at RRPV=MAX to avoid LLC pollution. 16-way 2-bit RRPVs per line cost ~8 KB; SHCT 2 bits×2 K=512 B; stride detector ~4.5 KB; PSEL + leader flags ~1 KB—well under 64 KB.  This hybrid adapts both to phase changes (via DRRIP), PC reuse biasing (via SHiP), and scans, boosting hit rates across all workloads.",,ChampSim_CRC2/new_policies/003_00_drrip_ship_stream_t02.cc,0.367996433,0.367996433,37%
999,astar,DIP-DBP-Stream,"This policy combines a dead-block prediction (DBP) table with a Dynamic Insertion Policy (DIP) that duels between Bimodal Insertion (BIP) and Low Insertion Priority (LIP), plus a lightweight streaming detector. We replace the PC-reuse SHiP table with a 4K-entry 2-bit dead-block predictor to classify lines as “hot” (insert at RRPV=0) or “cold.” For the rest, a 10-bit PSEL counter steers between BIP and LIP via 64 leader sets. An on-the-fly stride detector spots streaming scans and relegates those lines to the long RRPV for bypass. This mix aggressively captures repeated reuse, avoids pollution from streams, and dynamically adapts insertion depth to workload characteristics—yielding higher hit rates on pointer-heavy, stencil, and control-bound phases alike, all within a ~24 KiB metadata budget.",,ChampSim_CRC2/new_policies/004_00_dip_dbp_stream_t02.cc,0.459788587,0.459788587,0%
1000,lbm,DIP-DBP-Stream,"This policy combines a dead-block prediction (DBP) table with a Dynamic Insertion Policy (DIP) that duels between Bimodal Insertion (BIP) and Low Insertion Priority (LIP), plus a lightweight streaming detector. We replace the PC-reuse SHiP table with a 4K-entry 2-bit dead-block predictor to classify lines as “hot” (insert at RRPV=0) or “cold.” For the rest, a 10-bit PSEL counter steers between BIP and LIP via 64 leader sets. An on-the-fly stride detector spots streaming scans and relegates those lines to the long RRPV for bypass. This mix aggressively captures repeated reuse, avoids pollution from streams, and dynamically adapts insertion depth to workload characteristics—yielding higher hit rates on pointer-heavy, stencil, and control-bound phases alike, all within a ~24 KiB metadata budget.",,ChampSim_CRC2/new_policies/004_00_dip_dbp_stream_t02.cc,0.19825586,0.19825586,0%
1001,mcf,DIP-DBP-Stream,"This policy combines a dead-block prediction (DBP) table with a Dynamic Insertion Policy (DIP) that duels between Bimodal Insertion (BIP) and Low Insertion Priority (LIP), plus a lightweight streaming detector. We replace the PC-reuse SHiP table with a 4K-entry 2-bit dead-block predictor to classify lines as “hot” (insert at RRPV=0) or “cold.” For the rest, a 10-bit PSEL counter steers between BIP and LIP via 64 leader sets. An on-the-fly stride detector spots streaming scans and relegates those lines to the long RRPV for bypass. This mix aggressively captures repeated reuse, avoids pollution from streams, and dynamically adapts insertion depth to workload characteristics—yielding higher hit rates on pointer-heavy, stencil, and control-bound phases alike, all within a ~24 KiB metadata budget.",,ChampSim_CRC2/new_policies/004_00_dip_dbp_stream_t02.cc,0.403773947,0.403773947,0%
1002,milc,DIP-DBP-Stream,"This policy combines a dead-block prediction (DBP) table with a Dynamic Insertion Policy (DIP) that duels between Bimodal Insertion (BIP) and Low Insertion Priority (LIP), plus a lightweight streaming detector. We replace the PC-reuse SHiP table with a 4K-entry 2-bit dead-block predictor to classify lines as “hot” (insert at RRPV=0) or “cold.” For the rest, a 10-bit PSEL counter steers between BIP and LIP via 64 leader sets. An on-the-fly stride detector spots streaming scans and relegates those lines to the long RRPV for bypass. This mix aggressively captures repeated reuse, avoids pollution from streams, and dynamically adapts insertion depth to workload characteristics—yielding higher hit rates on pointer-heavy, stencil, and control-bound phases alike, all within a ~24 KiB metadata budget.",,ChampSim_CRC2/new_policies/004_00_dip_dbp_stream_t02.cc,0.016050312,0.016050312,0%
1003,omnetpp,DIP-DBP-Stream,"This policy combines a dead-block prediction (DBP) table with a Dynamic Insertion Policy (DIP) that duels between Bimodal Insertion (BIP) and Low Insertion Priority (LIP), plus a lightweight streaming detector. We replace the PC-reuse SHiP table with a 4K-entry 2-bit dead-block predictor to classify lines as “hot” (insert at RRPV=0) or “cold.” For the rest, a 10-bit PSEL counter steers between BIP and LIP via 64 leader sets. An on-the-fly stride detector spots streaming scans and relegates those lines to the long RRPV for bypass. This mix aggressively captures repeated reuse, avoids pollution from streams, and dynamically adapts insertion depth to workload characteristics—yielding higher hit rates on pointer-heavy, stencil, and control-bound phases alike, all within a ~24 KiB metadata budget.",,ChampSim_CRC2/new_policies/004_00_dip_dbp_stream_t02.cc,0.402743812,0.402743812,0%
1004,astar,DIP-SHiP-DBP,"DIP-SHiP-DBP combines Dynamic Insertion Policy (DIP) with PC-based reuse prediction (SHiP) and a lightweight dead-block approximation (DBP). We allocate 64 leader sets to choose between Bimodal Insertion (BIP) and Long Insertion (LIP) via a small PSEL counter, adapting to workload phase changes. A 4K-entry SHCT table tracks PC reuse and promotes strong reinsertion (RRPV=0) for high-reuse PCs. Each cache line carries a 2-bit dead-block counter that decays on each miss; during victim selection, lines whose dead-block counter has expired (zero) are preferred for eviction, quickly removing non-reused blocks. This design replaces stride-based streaming bypass with actual dead-block detection, improving adaptability across both regular (LBM, MILC) and irregular (astar, mcf, omnetpp) workloads while staying under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/004_01_dip_ship_dbp_t04.cc,0.460056131,0.460056131,0%
1005,lbm,DIP-SHiP-DBP,"DIP-SHiP-DBP combines Dynamic Insertion Policy (DIP) with PC-based reuse prediction (SHiP) and a lightweight dead-block approximation (DBP). We allocate 64 leader sets to choose between Bimodal Insertion (BIP) and Long Insertion (LIP) via a small PSEL counter, adapting to workload phase changes. A 4K-entry SHCT table tracks PC reuse and promotes strong reinsertion (RRPV=0) for high-reuse PCs. Each cache line carries a 2-bit dead-block counter that decays on each miss; during victim selection, lines whose dead-block counter has expired (zero) are preferred for eviction, quickly removing non-reused blocks. This design replaces stride-based streaming bypass with actual dead-block detection, improving adaptability across both regular (LBM, MILC) and irregular (astar, mcf, omnetpp) workloads while staying under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/004_01_dip_ship_dbp_t04.cc,0.199450413,0.199450413,0%
1006,mcf,DIP-SHiP-DBP,"DIP-SHiP-DBP combines Dynamic Insertion Policy (DIP) with PC-based reuse prediction (SHiP) and a lightweight dead-block approximation (DBP). We allocate 64 leader sets to choose between Bimodal Insertion (BIP) and Long Insertion (LIP) via a small PSEL counter, adapting to workload phase changes. A 4K-entry SHCT table tracks PC reuse and promotes strong reinsertion (RRPV=0) for high-reuse PCs. Each cache line carries a 2-bit dead-block counter that decays on each miss; during victim selection, lines whose dead-block counter has expired (zero) are preferred for eviction, quickly removing non-reused blocks. This design replaces stride-based streaming bypass with actual dead-block detection, improving adaptability across both regular (LBM, MILC) and irregular (astar, mcf, omnetpp) workloads while staying under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/004_01_dip_ship_dbp_t04.cc,0.404278183,0.404278183,0%
1007,milc,DIP-SHiP-DBP,"DIP-SHiP-DBP combines Dynamic Insertion Policy (DIP) with PC-based reuse prediction (SHiP) and a lightweight dead-block approximation (DBP). We allocate 64 leader sets to choose between Bimodal Insertion (BIP) and Long Insertion (LIP) via a small PSEL counter, adapting to workload phase changes. A 4K-entry SHCT table tracks PC reuse and promotes strong reinsertion (RRPV=0) for high-reuse PCs. Each cache line carries a 2-bit dead-block counter that decays on each miss; during victim selection, lines whose dead-block counter has expired (zero) are preferred for eviction, quickly removing non-reused blocks. This design replaces stride-based streaming bypass with actual dead-block detection, improving adaptability across both regular (LBM, MILC) and irregular (astar, mcf, omnetpp) workloads while staying under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/004_01_dip_ship_dbp_t04.cc,0.017719429,0.017719429,0%
1008,omnetpp,DIP-SHiP-DBP,"DIP-SHiP-DBP combines Dynamic Insertion Policy (DIP) with PC-based reuse prediction (SHiP) and a lightweight dead-block approximation (DBP). We allocate 64 leader sets to choose between Bimodal Insertion (BIP) and Long Insertion (LIP) via a small PSEL counter, adapting to workload phase changes. A 4K-entry SHCT table tracks PC reuse and promotes strong reinsertion (RRPV=0) for high-reuse PCs. Each cache line carries a 2-bit dead-block counter that decays on each miss; during victim selection, lines whose dead-block counter has expired (zero) are preferred for eviction, quickly removing non-reused blocks. This design replaces stride-based streaming bypass with actual dead-block detection, improving adaptability across both regular (LBM, MILC) and irregular (astar, mcf, omnetpp) workloads while staying under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/004_01_dip_ship_dbp_t04.cc,0.38466815,0.38466815,0%
1009,astar,DIP-SHiP-DeadBlock,"DIP-SHiP-DeadBlock combines dynamic insertion policy (DIP) with PC-based reuse bias (SHiP-lite), simple dead-block approximation, and a stride-based streaming bypass. We replace SRRIP/BRRIP set-dueling with 64 DIP leader sets to choose between LIP and BIP, letting the policy adapt to both high-spatial workloads (e.g., LBM) and highly irregular pointer-chasing (e.g., MCF). A 2K-entry SHCT table identifies PCs with strong reuse and forces low RRPV on their inserts, while per-line 2-bit “dead” counters detect cold or single‐touch blocks and place them near eviction. Finally, a lightweight stride detector bypasses true scans. This hybrid aggressively captures hot data, quickly evicts dead lines, and dynamically shifts insertion behavior across phases, boosting overall hit rate.",,ChampSim_CRC2/new_policies/004_02_dip_ship_deadblock_t07.cc,0.008052028,0.008052028,0%
1010,lbm,DIP-SHiP-DeadBlock,"DIP-SHiP-DeadBlock combines dynamic insertion policy (DIP) with PC-based reuse bias (SHiP-lite), simple dead-block approximation, and a stride-based streaming bypass. We replace SRRIP/BRRIP set-dueling with 64 DIP leader sets to choose between LIP and BIP, letting the policy adapt to both high-spatial workloads (e.g., LBM) and highly irregular pointer-chasing (e.g., MCF). A 2K-entry SHCT table identifies PCs with strong reuse and forces low RRPV on their inserts, while per-line 2-bit “dead” counters detect cold or single‐touch blocks and place them near eviction. Finally, a lightweight stride detector bypasses true scans. This hybrid aggressively captures hot data, quickly evicts dead lines, and dynamically shifts insertion behavior across phases, boosting overall hit rate.",,ChampSim_CRC2/new_policies/004_02_dip_ship_deadblock_t07.cc,0.018892991,0.018892991,0%
1011,mcf,DIP-SHiP-DeadBlock,"DIP-SHiP-DeadBlock combines dynamic insertion policy (DIP) with PC-based reuse bias (SHiP-lite), simple dead-block approximation, and a stride-based streaming bypass. We replace SRRIP/BRRIP set-dueling with 64 DIP leader sets to choose between LIP and BIP, letting the policy adapt to both high-spatial workloads (e.g., LBM) and highly irregular pointer-chasing (e.g., MCF). A 2K-entry SHCT table identifies PCs with strong reuse and forces low RRPV on their inserts, while per-line 2-bit “dead” counters detect cold or single‐touch blocks and place them near eviction. Finally, a lightweight stride detector bypasses true scans. This hybrid aggressively captures hot data, quickly evicts dead lines, and dynamically shifts insertion behavior across phases, boosting overall hit rate.",,ChampSim_CRC2/new_policies/004_02_dip_ship_deadblock_t07.cc,0.010292393,0.010292393,0%
1012,milc,DIP-SHiP-DeadBlock,"DIP-SHiP-DeadBlock combines dynamic insertion policy (DIP) with PC-based reuse bias (SHiP-lite), simple dead-block approximation, and a stride-based streaming bypass. We replace SRRIP/BRRIP set-dueling with 64 DIP leader sets to choose between LIP and BIP, letting the policy adapt to both high-spatial workloads (e.g., LBM) and highly irregular pointer-chasing (e.g., MCF). A 2K-entry SHCT table identifies PCs with strong reuse and forces low RRPV on their inserts, while per-line 2-bit “dead” counters detect cold or single‐touch blocks and place them near eviction. Finally, a lightweight stride detector bypasses true scans. This hybrid aggressively captures hot data, quickly evicts dead lines, and dynamically shifts insertion behavior across phases, boosting overall hit rate.",,ChampSim_CRC2/new_policies/004_02_dip_ship_deadblock_t07.cc,0.008928507,0.008928507,0%
1013,omnetpp,DIP-SHiP-DeadBlock,"DIP-SHiP-DeadBlock combines dynamic insertion policy (DIP) with PC-based reuse bias (SHiP-lite), simple dead-block approximation, and a stride-based streaming bypass. We replace SRRIP/BRRIP set-dueling with 64 DIP leader sets to choose between LIP and BIP, letting the policy adapt to both high-spatial workloads (e.g., LBM) and highly irregular pointer-chasing (e.g., MCF). A 2K-entry SHCT table identifies PCs with strong reuse and forces low RRPV on their inserts, while per-line 2-bit “dead” counters detect cold or single‐touch blocks and place them near eviction. Finally, a lightweight stride detector bypasses true scans. This hybrid aggressively captures hot data, quickly evicts dead lines, and dynamically shifts insertion behavior across phases, boosting overall hit rate.",,ChampSim_CRC2/new_policies/004_02_dip_ship_deadblock_t07.cc,0.000721746,0.000721746,0%
1014,all,DIP-DBP-Stream,"This policy combines a dead-block prediction (DBP) table with a Dynamic Insertion Policy (DIP) that duels between Bimodal Insertion (BIP) and Low Insertion Priority (LIP), plus a lightweight streaming detector. We replace the PC-reuse SHiP table with a 4K-entry 2-bit dead-block predictor to classify lines as “hot” (insert at RRPV=0) or “cold.” For the rest, a 10-bit PSEL counter steers between BIP and LIP via 64 leader sets. An on-the-fly stride detector spots streaming scans and relegates those lines to the long RRPV for bypass. This mix aggressively captures repeated reuse, avoids pollution from streams, and dynamically adapts insertion depth to workload characteristics—yielding higher hit rates on pointer-heavy, stencil, and control-bound phases alike, all within a ~24 KiB metadata budget.",,ChampSim_CRC2/new_policies/004_00_dip_dbp_stream_t02.cc,0.296122504,0.296122504,30%
1015,astar,SHiP-DRRIP,"SHiP-DRRIP combines PC-based SHiP-lite reuse prediction with Dynamic RRIP (DRRIP) dueling to adaptively pick between SRRIP and BRRIP, all within a small metadata budget. A 4K-entry signature table uses 3-bit counters to classify incoming lines as “hot” (frequently reused) or “cold” (unlikely to be reused) and directly overrides RRPV insertion depth (0 for hot, MAX for cold). For ambiguous signatures, DRRIP’s 10-bit PSEL steers between SRRIP (RRPV=MAX-1) and BRRIP (mostly RRPV=MAX with occasional MAX-1) via two leader sets. On hits, lines are promoted to RRPV=0 and their signature counters incremented, while leader sets update PSEL to favor the stronger policy. This design captures recurring reuse in pointer-chasing and control-heavy phases, adapts to streaming/stencil regularity through DRRIP, and caps total metadata under 12 KiB for scalability across all workloads.",,ChampSim_CRC2/new_policies/005_00_ship_drrip_t02.cc,0.459394357,0.459394357,0%
1016,lbm,SHiP-DRRIP,"SHiP-DRRIP combines PC-based SHiP-lite reuse prediction with Dynamic RRIP (DRRIP) dueling to adaptively pick between SRRIP and BRRIP, all within a small metadata budget. A 4K-entry signature table uses 3-bit counters to classify incoming lines as “hot” (frequently reused) or “cold” (unlikely to be reused) and directly overrides RRPV insertion depth (0 for hot, MAX for cold). For ambiguous signatures, DRRIP’s 10-bit PSEL steers between SRRIP (RRPV=MAX-1) and BRRIP (mostly RRPV=MAX with occasional MAX-1) via two leader sets. On hits, lines are promoted to RRPV=0 and their signature counters incremented, while leader sets update PSEL to favor the stronger policy. This design captures recurring reuse in pointer-chasing and control-heavy phases, adapts to streaming/stencil regularity through DRRIP, and caps total metadata under 12 KiB for scalability across all workloads.",,ChampSim_CRC2/new_policies/005_00_ship_drrip_t02.cc,0.411360819,0.411360819,0%
1017,mcf,SHiP-DRRIP,"SHiP-DRRIP combines PC-based SHiP-lite reuse prediction with Dynamic RRIP (DRRIP) dueling to adaptively pick between SRRIP and BRRIP, all within a small metadata budget. A 4K-entry signature table uses 3-bit counters to classify incoming lines as “hot” (frequently reused) or “cold” (unlikely to be reused) and directly overrides RRPV insertion depth (0 for hot, MAX for cold). For ambiguous signatures, DRRIP’s 10-bit PSEL steers between SRRIP (RRPV=MAX-1) and BRRIP (mostly RRPV=MAX with occasional MAX-1) via two leader sets. On hits, lines are promoted to RRPV=0 and their signature counters incremented, while leader sets update PSEL to favor the stronger policy. This design captures recurring reuse in pointer-chasing and control-heavy phases, adapts to streaming/stencil regularity through DRRIP, and caps total metadata under 12 KiB for scalability across all workloads.",,ChampSim_CRC2/new_policies/005_00_ship_drrip_t02.cc,0.404026712,0.404026712,0%
1018,milc,SHiP-DRRIP,"SHiP-DRRIP combines PC-based SHiP-lite reuse prediction with Dynamic RRIP (DRRIP) dueling to adaptively pick between SRRIP and BRRIP, all within a small metadata budget. A 4K-entry signature table uses 3-bit counters to classify incoming lines as “hot” (frequently reused) or “cold” (unlikely to be reused) and directly overrides RRPV insertion depth (0 for hot, MAX for cold). For ambiguous signatures, DRRIP’s 10-bit PSEL steers between SRRIP (RRPV=MAX-1) and BRRIP (mostly RRPV=MAX with occasional MAX-1) via two leader sets. On hits, lines are promoted to RRPV=0 and their signature counters incremented, while leader sets update PSEL to favor the stronger policy. This design captures recurring reuse in pointer-chasing and control-heavy phases, adapts to streaming/stencil regularity through DRRIP, and caps total metadata under 12 KiB for scalability across all workloads.",,ChampSim_CRC2/new_policies/005_00_ship_drrip_t02.cc,0.306554451,0.306554451,0%
1019,omnetpp,SHiP-DRRIP,"SHiP-DRRIP combines PC-based SHiP-lite reuse prediction with Dynamic RRIP (DRRIP) dueling to adaptively pick between SRRIP and BRRIP, all within a small metadata budget. A 4K-entry signature table uses 3-bit counters to classify incoming lines as “hot” (frequently reused) or “cold” (unlikely to be reused) and directly overrides RRPV insertion depth (0 for hot, MAX for cold). For ambiguous signatures, DRRIP’s 10-bit PSEL steers between SRRIP (RRPV=MAX-1) and BRRIP (mostly RRPV=MAX with occasional MAX-1) via two leader sets. On hits, lines are promoted to RRPV=0 and their signature counters incremented, while leader sets update PSEL to favor the stronger policy. This design captures recurring reuse in pointer-chasing and control-heavy phases, adapts to streaming/stencil regularity through DRRIP, and caps total metadata under 12 KiB for scalability across all workloads.",,ChampSim_CRC2/new_policies/005_00_ship_drrip_t02.cc,0.450608705,0.450608705,0%
1020,astar,Hybrid-SHiP-DRRIP,"Hybrid-SHiP-DRRIP combines a lightweight SHiP-Lite signature predictor with dynamic RRIP dueling (DRRIP) and a small streaming detector. SHiP-Lite uses a 4K-entry PC signature table to predict reuse and promote genuinely hot lines to RRPV=0, avoiding misclassifying cold pointer-chasing or infrequent branches. DRRIP steers between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter over 64 leader sets, automatically adapting to spatially regular stencils (LBM, MILC) and highly speculative control (ASTAR, OMNET++) phases. A 512-entry stride detector still bypasses monotonic streams. This design better preserves temporal reuse while minimizing pollution and meets the 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/005_01_hybrid_ship_drrip_t04.cc,0.452143191,0.452143191,0%
1021,lbm,Hybrid-SHiP-DRRIP,"Hybrid-SHiP-DRRIP combines a lightweight SHiP-Lite signature predictor with dynamic RRIP dueling (DRRIP) and a small streaming detector. SHiP-Lite uses a 4K-entry PC signature table to predict reuse and promote genuinely hot lines to RRPV=0, avoiding misclassifying cold pointer-chasing or infrequent branches. DRRIP steers between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter over 64 leader sets, automatically adapting to spatially regular stencils (LBM, MILC) and highly speculative control (ASTAR, OMNET++) phases. A 512-entry stride detector still bypasses monotonic streams. This design better preserves temporal reuse while minimizing pollution and meets the 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/005_01_hybrid_ship_drrip_t04.cc,0.309122325,0.309122325,0%
1022,mcf,Hybrid-SHiP-DRRIP,"Hybrid-SHiP-DRRIP combines a lightweight SHiP-Lite signature predictor with dynamic RRIP dueling (DRRIP) and a small streaming detector. SHiP-Lite uses a 4K-entry PC signature table to predict reuse and promote genuinely hot lines to RRPV=0, avoiding misclassifying cold pointer-chasing or infrequent branches. DRRIP steers between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter over 64 leader sets, automatically adapting to spatially regular stencils (LBM, MILC) and highly speculative control (ASTAR, OMNET++) phases. A 512-entry stride detector still bypasses monotonic streams. This design better preserves temporal reuse while minimizing pollution and meets the 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/005_01_hybrid_ship_drrip_t04.cc,0.404076732,0.404076732,0%
1023,milc,Hybrid-SHiP-DRRIP,"Hybrid-SHiP-DRRIP combines a lightweight SHiP-Lite signature predictor with dynamic RRIP dueling (DRRIP) and a small streaming detector. SHiP-Lite uses a 4K-entry PC signature table to predict reuse and promote genuinely hot lines to RRPV=0, avoiding misclassifying cold pointer-chasing or infrequent branches. DRRIP steers between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter over 64 leader sets, automatically adapting to spatially regular stencils (LBM, MILC) and highly speculative control (ASTAR, OMNET++) phases. A 512-entry stride detector still bypasses monotonic streams. This design better preserves temporal reuse while minimizing pollution and meets the 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/005_01_hybrid_ship_drrip_t04.cc,0.057939347,0.057939347,0%
1024,omnetpp,Hybrid-SHiP-DRRIP,"Hybrid-SHiP-DRRIP combines a lightweight SHiP-Lite signature predictor with dynamic RRIP dueling (DRRIP) and a small streaming detector. SHiP-Lite uses a 4K-entry PC signature table to predict reuse and promote genuinely hot lines to RRPV=0, avoiding misclassifying cold pointer-chasing or infrequent branches. DRRIP steers between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter over 64 leader sets, automatically adapting to spatially regular stencils (LBM, MILC) and highly speculative control (ASTAR, OMNET++) phases. A 512-entry stride detector still bypasses monotonic streams. This design better preserves temporal reuse while minimizing pollution and meets the 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/005_01_hybrid_ship_drrip_t04.cc,0.537217195,0.537217195,0%
1025,astar,SHiP-SRRIP,"SHiP-SRRIP integrates a small PC-signature table (SHiP) with Static Re-Reference Interval Prediction (SRRIP), using per-line 8-bit signatures and 1-bit reuse flags. On each miss, we update the evicted line’s signature counter in the SHiP table (increment if it saw a hit, decrement otherwise), then hash the current PC to pick an insertion RRPV: high-reuse PCs (counter ≥2) insert at RRPV=0, medium PCs (counter=1) at RRPV=INIT_RRPV, and low-reuse PCs (counter=0) bypass at MAX_RRPV. On hits, blocks are promoted to RRPV=0 and marked as “reused.” This lean design (~45 KiB metadata) adapts insertion aggressiveness to dynamic reuse behavior, reduces pollution from one-time and streaming accesses, and handles control-bound, streaming, pointer-chasing, and phase-changing workloads more uniformly.",,ChampSim_CRC2/new_policies/005_02_ship_srrip_t07.cc,0.045124665,0.045124665,0%
1026,lbm,SHiP-SRRIP,"SHiP-SRRIP integrates a small PC-signature table (SHiP) with Static Re-Reference Interval Prediction (SRRIP), using per-line 8-bit signatures and 1-bit reuse flags. On each miss, we update the evicted line’s signature counter in the SHiP table (increment if it saw a hit, decrement otherwise), then hash the current PC to pick an insertion RRPV: high-reuse PCs (counter ≥2) insert at RRPV=0, medium PCs (counter=1) at RRPV=INIT_RRPV, and low-reuse PCs (counter=0) bypass at MAX_RRPV. On hits, blocks are promoted to RRPV=0 and marked as “reused.” This lean design (~45 KiB metadata) adapts insertion aggressiveness to dynamic reuse behavior, reduces pollution from one-time and streaming accesses, and handles control-bound, streaming, pointer-chasing, and phase-changing workloads more uniformly.",,ChampSim_CRC2/new_policies/005_02_ship_srrip_t07.cc,0.058753172,0.058753172,0%
1027,mcf,SHiP-SRRIP,"SHiP-SRRIP integrates a small PC-signature table (SHiP) with Static Re-Reference Interval Prediction (SRRIP), using per-line 8-bit signatures and 1-bit reuse flags. On each miss, we update the evicted line’s signature counter in the SHiP table (increment if it saw a hit, decrement otherwise), then hash the current PC to pick an insertion RRPV: high-reuse PCs (counter ≥2) insert at RRPV=0, medium PCs (counter=1) at RRPV=INIT_RRPV, and low-reuse PCs (counter=0) bypass at MAX_RRPV. On hits, blocks are promoted to RRPV=0 and marked as “reused.” This lean design (~45 KiB metadata) adapts insertion aggressiveness to dynamic reuse behavior, reduces pollution from one-time and streaming accesses, and handles control-bound, streaming, pointer-chasing, and phase-changing workloads more uniformly.",,ChampSim_CRC2/new_policies/005_02_ship_srrip_t07.cc,0.214312084,0.214312084,0%
1028,milc,SHiP-SRRIP,"SHiP-SRRIP integrates a small PC-signature table (SHiP) with Static Re-Reference Interval Prediction (SRRIP), using per-line 8-bit signatures and 1-bit reuse flags. On each miss, we update the evicted line’s signature counter in the SHiP table (increment if it saw a hit, decrement otherwise), then hash the current PC to pick an insertion RRPV: high-reuse PCs (counter ≥2) insert at RRPV=0, medium PCs (counter=1) at RRPV=INIT_RRPV, and low-reuse PCs (counter=0) bypass at MAX_RRPV. On hits, blocks are promoted to RRPV=0 and marked as “reused.” This lean design (~45 KiB metadata) adapts insertion aggressiveness to dynamic reuse behavior, reduces pollution from one-time and streaming accesses, and handles control-bound, streaming, pointer-chasing, and phase-changing workloads more uniformly.",,ChampSim_CRC2/new_policies/005_02_ship_srrip_t07.cc,0.009520482,0.009520482,0%
1029,omnetpp,SHiP-SRRIP,"SHiP-SRRIP integrates a small PC-signature table (SHiP) with Static Re-Reference Interval Prediction (SRRIP), using per-line 8-bit signatures and 1-bit reuse flags. On each miss, we update the evicted line’s signature counter in the SHiP table (increment if it saw a hit, decrement otherwise), then hash the current PC to pick an insertion RRPV: high-reuse PCs (counter ≥2) insert at RRPV=0, medium PCs (counter=1) at RRPV=INIT_RRPV, and low-reuse PCs (counter=0) bypass at MAX_RRPV. On hits, blocks are promoted to RRPV=0 and marked as “reused.” This lean design (~45 KiB metadata) adapts insertion aggressiveness to dynamic reuse behavior, reduces pollution from one-time and streaming accesses, and handles control-bound, streaming, pointer-chasing, and phase-changing workloads more uniformly.",,ChampSim_CRC2/new_policies/005_02_ship_srrip_t07.cc,0.001151215,0.001151215,0%
1030,all,SHiP-DRRIP,"SHiP-DRRIP combines PC-based SHiP-lite reuse prediction with Dynamic RRIP (DRRIP) dueling to adaptively pick between SRRIP and BRRIP, all within a small metadata budget. A 4K-entry signature table uses 3-bit counters to classify incoming lines as “hot” (frequently reused) or “cold” (unlikely to be reused) and directly overrides RRPV insertion depth (0 for hot, MAX for cold). For ambiguous signatures, DRRIP’s 10-bit PSEL steers between SRRIP (RRPV=MAX-1) and BRRIP (mostly RRPV=MAX with occasional MAX-1) via two leader sets. On hits, lines are promoted to RRPV=0 and their signature counters incremented, while leader sets update PSEL to favor the stronger policy. This design captures recurring reuse in pointer-chasing and control-heavy phases, adapts to streaming/stencil regularity through DRRIP, and caps total metadata under 12 KiB for scalability across all workloads.",,ChampSim_CRC2/new_policies/005_00_ship_drrip_t02.cc,0.406389009,0.406389009,41%
1031,astar,SSDB (SHiP with Streaming Bypass),"SSDB leverages PC-based SHiP-lite signatures to classify lines as hot, cold, or neutral, but eschews complex dueling in favor of direct insertion depths: hot lines are granted RRPV=0, cold lines RRPV=MAX, and neutral lines RRPV=MAX–1. To prevent streaming/stencil traffic from polluting the LLC (e.g., LBM), SSDB includes a compact streaming detector that tracks per-PC address strides; once a stream is detected, fills from that PC are effectively bypassed by leaving their RRPV at MAX, ensuring they are the first candidates for eviction. This simple combination drastically reduces pollution from dense strides while preserving SHiP’s strengths on pointer-chasing and phase-changing workloads, all within a ~16 KiB metadata footprint.",,ChampSim_CRC2/new_policies/006_00_ssdb__ship_with_streaming_bypass_t02.cc,0.457944124,0.457944124,0%
1032,lbm,SSDB (SHiP with Streaming Bypass),"SSDB leverages PC-based SHiP-lite signatures to classify lines as hot, cold, or neutral, but eschews complex dueling in favor of direct insertion depths: hot lines are granted RRPV=0, cold lines RRPV=MAX, and neutral lines RRPV=MAX–1. To prevent streaming/stencil traffic from polluting the LLC (e.g., LBM), SSDB includes a compact streaming detector that tracks per-PC address strides; once a stream is detected, fills from that PC are effectively bypassed by leaving their RRPV at MAX, ensuring they are the first candidates for eviction. This simple combination drastically reduces pollution from dense strides while preserving SHiP’s strengths on pointer-chasing and phase-changing workloads, all within a ~16 KiB metadata footprint.",,ChampSim_CRC2/new_policies/006_00_ssdb__ship_with_streaming_bypass_t02.cc,0.326280529,0.326280529,0%
1033,mcf,SSDB (SHiP with Streaming Bypass),"SSDB leverages PC-based SHiP-lite signatures to classify lines as hot, cold, or neutral, but eschews complex dueling in favor of direct insertion depths: hot lines are granted RRPV=0, cold lines RRPV=MAX, and neutral lines RRPV=MAX–1. To prevent streaming/stencil traffic from polluting the LLC (e.g., LBM), SSDB includes a compact streaming detector that tracks per-PC address strides; once a stream is detected, fills from that PC are effectively bypassed by leaving their RRPV at MAX, ensuring they are the first candidates for eviction. This simple combination drastically reduces pollution from dense strides while preserving SHiP’s strengths on pointer-chasing and phase-changing workloads, all within a ~16 KiB metadata footprint.",,ChampSim_CRC2/new_policies/006_00_ssdb__ship_with_streaming_bypass_t02.cc,0.404064406,0.404064406,0%
1034,milc,SSDB (SHiP with Streaming Bypass),"SSDB leverages PC-based SHiP-lite signatures to classify lines as hot, cold, or neutral, but eschews complex dueling in favor of direct insertion depths: hot lines are granted RRPV=0, cold lines RRPV=MAX, and neutral lines RRPV=MAX–1. To prevent streaming/stencil traffic from polluting the LLC (e.g., LBM), SSDB includes a compact streaming detector that tracks per-PC address strides; once a stream is detected, fills from that PC are effectively bypassed by leaving their RRPV at MAX, ensuring they are the first candidates for eviction. This simple combination drastically reduces pollution from dense strides while preserving SHiP’s strengths on pointer-chasing and phase-changing workloads, all within a ~16 KiB metadata footprint.",,ChampSim_CRC2/new_policies/006_00_ssdb__ship_with_streaming_bypass_t02.cc,0.140776049,0.140776049,0%
1035,omnetpp,SSDB (SHiP with Streaming Bypass),"SSDB leverages PC-based SHiP-lite signatures to classify lines as hot, cold, or neutral, but eschews complex dueling in favor of direct insertion depths: hot lines are granted RRPV=0, cold lines RRPV=MAX, and neutral lines RRPV=MAX–1. To prevent streaming/stencil traffic from polluting the LLC (e.g., LBM), SSDB includes a compact streaming detector that tracks per-PC address strides; once a stream is detected, fills from that PC are effectively bypassed by leaving their RRPV at MAX, ensuring they are the first candidates for eviction. This simple combination drastically reduces pollution from dense strides while preserving SHiP’s strengths on pointer-chasing and phase-changing workloads, all within a ~16 KiB metadata footprint.",,ChampSim_CRC2/new_policies/006_00_ssdb__ship_with_streaming_bypass_t02.cc,0.550816876,0.550816876,0%
1036,astar,SHiP-Stream,"SHiP-Stream augments PC-signature reuse prediction (SHiP-lite) with a lightweight streaming detector to bypass cache pollution from monotonic address streams. On a miss, if we observe the same address delta twice in a row, the new block is deemed streaming and inserted with the highest RRPV (effectively bypassed). Otherwise, we consult a 12-bit PC signature table: “hot” signatures get RRPV=0 for immediate retention; all others are filled at RRPV=MAX, so they only stay if reused. Hits always promote to RRPV=0 and reinforce the signature. By combining accurate PC-based hot/cold classification with simple streaming bypass logic and dropping DRRIP dueling, SHiP-Stream keeps metadata under 2 KiB and adapts efficiently to both regular stencils and irregular, streaming workloads.",,ChampSim_CRC2/new_policies/006_01_ship_stream_t04.cc,0.451341444,0.451341444,0%
1037,lbm,SHiP-Stream,"SHiP-Stream augments PC-signature reuse prediction (SHiP-lite) with a lightweight streaming detector to bypass cache pollution from monotonic address streams. On a miss, if we observe the same address delta twice in a row, the new block is deemed streaming and inserted with the highest RRPV (effectively bypassed). Otherwise, we consult a 12-bit PC signature table: “hot” signatures get RRPV=0 for immediate retention; all others are filled at RRPV=MAX, so they only stay if reused. Hits always promote to RRPV=0 and reinforce the signature. By combining accurate PC-based hot/cold classification with simple streaming bypass logic and dropping DRRIP dueling, SHiP-Stream keeps metadata under 2 KiB and adapts efficiently to both regular stencils and irregular, streaming workloads.",,ChampSim_CRC2/new_policies/006_01_ship_stream_t04.cc,0.196151757,0.196151757,0%
1038,mcf,SHiP-Stream,"SHiP-Stream augments PC-signature reuse prediction (SHiP-lite) with a lightweight streaming detector to bypass cache pollution from monotonic address streams. On a miss, if we observe the same address delta twice in a row, the new block is deemed streaming and inserted with the highest RRPV (effectively bypassed). Otherwise, we consult a 12-bit PC signature table: “hot” signatures get RRPV=0 for immediate retention; all others are filled at RRPV=MAX, so they only stay if reused. Hits always promote to RRPV=0 and reinforce the signature. By combining accurate PC-based hot/cold classification with simple streaming bypass logic and dropping DRRIP dueling, SHiP-Stream keeps metadata under 2 KiB and adapts efficiently to both regular stencils and irregular, streaming workloads.",,ChampSim_CRC2/new_policies/006_01_ship_stream_t04.cc,0.403660046,0.403660046,0%
1039,milc,SHiP-Stream,"SHiP-Stream augments PC-signature reuse prediction (SHiP-lite) with a lightweight streaming detector to bypass cache pollution from monotonic address streams. On a miss, if we observe the same address delta twice in a row, the new block is deemed streaming and inserted with the highest RRPV (effectively bypassed). Otherwise, we consult a 12-bit PC signature table: “hot” signatures get RRPV=0 for immediate retention; all others are filled at RRPV=MAX, so they only stay if reused. Hits always promote to RRPV=0 and reinforce the signature. By combining accurate PC-based hot/cold classification with simple streaming bypass logic and dropping DRRIP dueling, SHiP-Stream keeps metadata under 2 KiB and adapts efficiently to both regular stencils and irregular, streaming workloads.",,ChampSim_CRC2/new_policies/006_01_ship_stream_t04.cc,0.013573792,0.013573792,0%
1040,omnetpp,SHiP-Stream,"SHiP-Stream augments PC-signature reuse prediction (SHiP-lite) with a lightweight streaming detector to bypass cache pollution from monotonic address streams. On a miss, if we observe the same address delta twice in a row, the new block is deemed streaming and inserted with the highest RRPV (effectively bypassed). Otherwise, we consult a 12-bit PC signature table: “hot” signatures get RRPV=0 for immediate retention; all others are filled at RRPV=MAX, so they only stay if reused. Hits always promote to RRPV=0 and reinforce the signature. By combining accurate PC-based hot/cold classification with simple streaming bypass logic and dropping DRRIP dueling, SHiP-Stream keeps metadata under 2 KiB and adapts efficiently to both regular stencils and irregular, streaming workloads.",,ChampSim_CRC2/new_policies/006_01_ship_stream_t04.cc,0.121122106,0.121122106,0%
1041,astar,StreamShip-DIP,"StreamShip-DIP combines PC‐based SHiP-lite reuse prediction with a lightweight streaming detector and a DIP‐style dueling mechanism to dynamically choose between LIP (long insertion, i.e., strong promotion) and BIP (bimodal insertion) for non‐hot, non‐streaming lines. Hot lines (high SHiP counter) are inserted at RRPV=0, streaming lines are treated as cold (RRPV=MAX) to avoid polluting reuseful data, and the remaining lines follow the policy favored by a 10-bit PSEL counter guided by 64 leader sets. Hits always reset RRPV to 0 and train both the SHiP counters and PSEL in leader sets. This design captures pointer‐chasing and control‐heavy reuse with SHiP, isolates streaming/stencil traffic, and adapts insertion depth per workload phase, all within ~20 KiB metadata.",,ChampSim_CRC2/new_policies/006_02_streamship_dip_t07.cc,0.459657472,0.459657472,0%
1042,lbm,StreamShip-DIP,"StreamShip-DIP combines PC‐based SHiP-lite reuse prediction with a lightweight streaming detector and a DIP‐style dueling mechanism to dynamically choose between LIP (long insertion, i.e., strong promotion) and BIP (bimodal insertion) for non‐hot, non‐streaming lines. Hot lines (high SHiP counter) are inserted at RRPV=0, streaming lines are treated as cold (RRPV=MAX) to avoid polluting reuseful data, and the remaining lines follow the policy favored by a 10-bit PSEL counter guided by 64 leader sets. Hits always reset RRPV to 0 and train both the SHiP counters and PSEL in leader sets. This design captures pointer‐chasing and control‐heavy reuse with SHiP, isolates streaming/stencil traffic, and adapts insertion depth per workload phase, all within ~20 KiB metadata.",,ChampSim_CRC2/new_policies/006_02_streamship_dip_t07.cc,0.208040545,0.208040545,0%
1043,mcf,StreamShip-DIP,"StreamShip-DIP combines PC‐based SHiP-lite reuse prediction with a lightweight streaming detector and a DIP‐style dueling mechanism to dynamically choose between LIP (long insertion, i.e., strong promotion) and BIP (bimodal insertion) for non‐hot, non‐streaming lines. Hot lines (high SHiP counter) are inserted at RRPV=0, streaming lines are treated as cold (RRPV=MAX) to avoid polluting reuseful data, and the remaining lines follow the policy favored by a 10-bit PSEL counter guided by 64 leader sets. Hits always reset RRPV to 0 and train both the SHiP counters and PSEL in leader sets. This design captures pointer‐chasing and control‐heavy reuse with SHiP, isolates streaming/stencil traffic, and adapts insertion depth per workload phase, all within ~20 KiB metadata.",,ChampSim_CRC2/new_policies/006_02_streamship_dip_t07.cc,0.403277012,0.403277012,0%
1044,milc,StreamShip-DIP,"StreamShip-DIP combines PC‐based SHiP-lite reuse prediction with a lightweight streaming detector and a DIP‐style dueling mechanism to dynamically choose between LIP (long insertion, i.e., strong promotion) and BIP (bimodal insertion) for non‐hot, non‐streaming lines. Hot lines (high SHiP counter) are inserted at RRPV=0, streaming lines are treated as cold (RRPV=MAX) to avoid polluting reuseful data, and the remaining lines follow the policy favored by a 10-bit PSEL counter guided by 64 leader sets. Hits always reset RRPV to 0 and train both the SHiP counters and PSEL in leader sets. This design captures pointer‐chasing and control‐heavy reuse with SHiP, isolates streaming/stencil traffic, and adapts insertion depth per workload phase, all within ~20 KiB metadata.",,ChampSim_CRC2/new_policies/006_02_streamship_dip_t07.cc,0.025020457,0.025020457,0%
1045,omnetpp,StreamShip-DIP,"StreamShip-DIP combines PC‐based SHiP-lite reuse prediction with a lightweight streaming detector and a DIP‐style dueling mechanism to dynamically choose between LIP (long insertion, i.e., strong promotion) and BIP (bimodal insertion) for non‐hot, non‐streaming lines. Hot lines (high SHiP counter) are inserted at RRPV=0, streaming lines are treated as cold (RRPV=MAX) to avoid polluting reuseful data, and the remaining lines follow the policy favored by a 10-bit PSEL counter guided by 64 leader sets. Hits always reset RRPV to 0 and train both the SHiP counters and PSEL in leader sets. This design captures pointer‐chasing and control‐heavy reuse with SHiP, isolates streaming/stencil traffic, and adapts insertion depth per workload phase, all within ~20 KiB metadata.",,ChampSim_CRC2/new_policies/006_02_streamship_dip_t07.cc,0.38910594,0.38910594,0%
1046,all,SSDB (SHiP with Streaming Bypass),"SSDB leverages PC-based SHiP-lite signatures to classify lines as hot, cold, or neutral, but eschews complex dueling in favor of direct insertion depths: hot lines are granted RRPV=0, cold lines RRPV=MAX, and neutral lines RRPV=MAX–1. To prevent streaming/stencil traffic from polluting the LLC (e.g., LBM), SSDB includes a compact streaming detector that tracks per-PC address strides; once a stream is detected, fills from that PC are effectively bypassed by leaving their RRPV at MAX, ensuring they are the first candidates for eviction. This simple combination drastically reduces pollution from dense strides while preserving SHiP’s strengths on pointer-chasing and phase-changing workloads, all within a ~16 KiB metadata footprint.",,ChampSim_CRC2/new_policies/006_00_ssdb__ship_with_streaming_bypass_t02.cc,0.375976397,0.375976397,38%
1047,astar,DRRIP-SHIP-BY (Dueling RRIP + SHiP + Bypass),"DRRIP-SHIP-BY augments SSDB with a DRRIP-style set dueling mechanism to automatically choose at runtime between SHiP-lite’s PC-based insertion depths and standard SRRIP’s neutral insertion. We partition 2048 LLC sets into 32 SRRIP leader sets, 32 SHiP leader sets, and 1984 follower sets. A 10-bit PSEL counter is incremented on hits in SHiP leaders and decremented on hits in SRRIP leaders. Follower sets then follow whichever policy PSEL prefers. The original streaming detector is preserved to bypass long strided accesses. This dynamic selection lets the cache lean on SHiP when pointer-chasing or phase-changing workloads predominate, or fall back to SRRIP on heavy streaming or stencil patterns, improving overall hit rate.",,ChampSim_CRC2/new_policies/007_00_drrip_ship_by__dueling_rrip___ship___bypass_t02.cc,0.443688075,0.443688075,0%
1048,lbm,DRRIP-SHIP-BY (Dueling RRIP + SHiP + Bypass),"DRRIP-SHIP-BY augments SSDB with a DRRIP-style set dueling mechanism to automatically choose at runtime between SHiP-lite’s PC-based insertion depths and standard SRRIP’s neutral insertion. We partition 2048 LLC sets into 32 SRRIP leader sets, 32 SHiP leader sets, and 1984 follower sets. A 10-bit PSEL counter is incremented on hits in SHiP leaders and decremented on hits in SRRIP leaders. Follower sets then follow whichever policy PSEL prefers. The original streaming detector is preserved to bypass long strided accesses. This dynamic selection lets the cache lean on SHiP when pointer-chasing or phase-changing workloads predominate, or fall back to SRRIP on heavy streaming or stencil patterns, improving overall hit rate.",,ChampSim_CRC2/new_policies/007_00_drrip_ship_by__dueling_rrip___ship___bypass_t02.cc,0.333001512,0.333001512,0%
1049,mcf,DRRIP-SHIP-BY (Dueling RRIP + SHiP + Bypass),"DRRIP-SHIP-BY augments SSDB with a DRRIP-style set dueling mechanism to automatically choose at runtime between SHiP-lite’s PC-based insertion depths and standard SRRIP’s neutral insertion. We partition 2048 LLC sets into 32 SRRIP leader sets, 32 SHiP leader sets, and 1984 follower sets. A 10-bit PSEL counter is incremented on hits in SHiP leaders and decremented on hits in SRRIP leaders. Follower sets then follow whichever policy PSEL prefers. The original streaming detector is preserved to bypass long strided accesses. This dynamic selection lets the cache lean on SHiP when pointer-chasing or phase-changing workloads predominate, or fall back to SRRIP on heavy streaming or stencil patterns, improving overall hit rate.",,ChampSim_CRC2/new_policies/007_00_drrip_ship_by__dueling_rrip___ship___bypass_t02.cc,0.432365202,0.432365202,0%
1050,milc,DRRIP-SHIP-BY (Dueling RRIP + SHiP + Bypass),"DRRIP-SHIP-BY augments SSDB with a DRRIP-style set dueling mechanism to automatically choose at runtime between SHiP-lite’s PC-based insertion depths and standard SRRIP’s neutral insertion. We partition 2048 LLC sets into 32 SRRIP leader sets, 32 SHiP leader sets, and 1984 follower sets. A 10-bit PSEL counter is incremented on hits in SHiP leaders and decremented on hits in SRRIP leaders. Follower sets then follow whichever policy PSEL prefers. The original streaming detector is preserved to bypass long strided accesses. This dynamic selection lets the cache lean on SHiP when pointer-chasing or phase-changing workloads predominate, or fall back to SRRIP on heavy streaming or stencil patterns, improving overall hit rate.",,ChampSim_CRC2/new_policies/007_00_drrip_ship_by__dueling_rrip___ship___bypass_t02.cc,0.139789423,0.139789423,0%
1051,omnetpp,DRRIP-SHIP-BY (Dueling RRIP + SHiP + Bypass),"DRRIP-SHIP-BY augments SSDB with a DRRIP-style set dueling mechanism to automatically choose at runtime between SHiP-lite’s PC-based insertion depths and standard SRRIP’s neutral insertion. We partition 2048 LLC sets into 32 SRRIP leader sets, 32 SHiP leader sets, and 1984 follower sets. A 10-bit PSEL counter is incremented on hits in SHiP leaders and decremented on hits in SRRIP leaders. Follower sets then follow whichever policy PSEL prefers. The original streaming detector is preserved to bypass long strided accesses. This dynamic selection lets the cache lean on SHiP when pointer-chasing or phase-changing workloads predominate, or fall back to SRRIP on heavy streaming or stencil patterns, improving overall hit rate.",,ChampSim_CRC2/new_policies/007_00_drrip_ship_by__dueling_rrip___ship___bypass_t02.cc,0.550775122,0.550775122,0%
1052,astar,DSB: DRRIP with SHiP-lite and Streaming Bypass,"DSB combines dynamic RRIP (DRRIP) to balance between SRRIP and BRRIP insertion depths, SHiP-lite PC signatures to promote true “hot” pointer-chasing lines, and a compact streaming detector to bypass heavy‐stride fills. Leader sets sample SRRIP vs. BRRIP via a small PSEL counter, while each PC has a 3-bit signature tracking hit rates; truly hot PCs always insert at RRPV=0, streams always at RRPV=MAX, and the rest follow the current RRIP policy. This triad lets DSB quickly adapt to phase changes (MILC), capture pointer-chasing (MCF/ASTAR/OMNETPP), and avoid pollution from stencils (LBM) with only ~32 KiB metadata.",,ChampSim_CRC2/new_policies/007_01_dsb__drrip_with_ship_lite_and_streaming_bypass_t04.cc,0.458181548,0.458181548,0%
1053,lbm,DSB: DRRIP with SHiP-lite and Streaming Bypass,"DSB combines dynamic RRIP (DRRIP) to balance between SRRIP and BRRIP insertion depths, SHiP-lite PC signatures to promote true “hot” pointer-chasing lines, and a compact streaming detector to bypass heavy‐stride fills. Leader sets sample SRRIP vs. BRRIP via a small PSEL counter, while each PC has a 3-bit signature tracking hit rates; truly hot PCs always insert at RRPV=0, streams always at RRPV=MAX, and the rest follow the current RRIP policy. This triad lets DSB quickly adapt to phase changes (MILC), capture pointer-chasing (MCF/ASTAR/OMNETPP), and avoid pollution from stencils (LBM) with only ~32 KiB metadata.",,ChampSim_CRC2/new_policies/007_01_dsb__drrip_with_ship_lite_and_streaming_bypass_t04.cc,0.198661986,0.198661986,0%
1054,mcf,DSB: DRRIP with SHiP-lite and Streaming Bypass,"DSB combines dynamic RRIP (DRRIP) to balance between SRRIP and BRRIP insertion depths, SHiP-lite PC signatures to promote true “hot” pointer-chasing lines, and a compact streaming detector to bypass heavy‐stride fills. Leader sets sample SRRIP vs. BRRIP via a small PSEL counter, while each PC has a 3-bit signature tracking hit rates; truly hot PCs always insert at RRPV=0, streams always at RRPV=MAX, and the rest follow the current RRIP policy. This triad lets DSB quickly adapt to phase changes (MILC), capture pointer-chasing (MCF/ASTAR/OMNETPP), and avoid pollution from stencils (LBM) with only ~32 KiB metadata.",,ChampSim_CRC2/new_policies/007_01_dsb__drrip_with_ship_lite_and_streaming_bypass_t04.cc,0.403711479,0.403711479,0%
1055,milc,DSB: DRRIP with SHiP-lite and Streaming Bypass,"DSB combines dynamic RRIP (DRRIP) to balance between SRRIP and BRRIP insertion depths, SHiP-lite PC signatures to promote true “hot” pointer-chasing lines, and a compact streaming detector to bypass heavy‐stride fills. Leader sets sample SRRIP vs. BRRIP via a small PSEL counter, while each PC has a 3-bit signature tracking hit rates; truly hot PCs always insert at RRPV=0, streams always at RRPV=MAX, and the rest follow the current RRIP policy. This triad lets DSB quickly adapt to phase changes (MILC), capture pointer-chasing (MCF/ASTAR/OMNETPP), and avoid pollution from stencils (LBM) with only ~32 KiB metadata.",,ChampSim_CRC2/new_policies/007_01_dsb__drrip_with_ship_lite_and_streaming_bypass_t04.cc,0.077691767,0.077691767,0%
1056,omnetpp,DSB: DRRIP with SHiP-lite and Streaming Bypass,"DSB combines dynamic RRIP (DRRIP) to balance between SRRIP and BRRIP insertion depths, SHiP-lite PC signatures to promote true “hot” pointer-chasing lines, and a compact streaming detector to bypass heavy‐stride fills. Leader sets sample SRRIP vs. BRRIP via a small PSEL counter, while each PC has a 3-bit signature tracking hit rates; truly hot PCs always insert at RRPV=0, streams always at RRPV=MAX, and the rest follow the current RRIP policy. This triad lets DSB quickly adapt to phase changes (MILC), capture pointer-chasing (MCF/ASTAR/OMNETPP), and avoid pollution from stencils (LBM) with only ~32 KiB metadata.",,ChampSim_CRC2/new_policies/007_01_dsb__drrip_with_ship_lite_and_streaming_bypass_t04.cc,0.384250616,0.384250616,0%
1057,astar,DBRIP-SHiP,"DBRIP-SHiP fuses PC-based SHiP-lite for phase and pointer‐chasing adaptation with a DRRIP–style set‐dueling between SRRIP and BIP for neutral lines, plus a lightweight streaming bypass. Hits always reset RRPV to 0 and train the 4-bit PC signature. On misses, truly streaming PCs bypass the cache (RRPV=MAX), and “hot” PCs (high signature) also get RRPV=0 while “cold” PCs get RRPV=MAX. For signature‐neutral PCs, we dynamically switch between SRRIP (RRPV=2) and BIP (1/32 chance of RRPV=2, else RRPV=3) using 32 leader sets for each policy to update an 8-bit PSEL counter. This lets the policy adapt insertion depth to workload reuse patterns, retains SHiP’s phase sensitivity, avoids pollution from streams, and keeps total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/007_02_dbrip_ship_t07.cc,0.457782888,0.457782888,0%
1058,lbm,DBRIP-SHiP,"DBRIP-SHiP fuses PC-based SHiP-lite for phase and pointer‐chasing adaptation with a DRRIP–style set‐dueling between SRRIP and BIP for neutral lines, plus a lightweight streaming bypass. Hits always reset RRPV to 0 and train the 4-bit PC signature. On misses, truly streaming PCs bypass the cache (RRPV=MAX), and “hot” PCs (high signature) also get RRPV=0 while “cold” PCs get RRPV=MAX. For signature‐neutral PCs, we dynamically switch between SRRIP (RRPV=2) and BIP (1/32 chance of RRPV=2, else RRPV=3) using 32 leader sets for each policy to update an 8-bit PSEL counter. This lets the policy adapt insertion depth to workload reuse patterns, retains SHiP’s phase sensitivity, avoids pollution from streams, and keeps total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/007_02_dbrip_ship_t07.cc,0.340418284,0.340418284,0%
1059,mcf,DBRIP-SHiP,"DBRIP-SHiP fuses PC-based SHiP-lite for phase and pointer‐chasing adaptation with a DRRIP–style set‐dueling between SRRIP and BIP for neutral lines, plus a lightweight streaming bypass. Hits always reset RRPV to 0 and train the 4-bit PC signature. On misses, truly streaming PCs bypass the cache (RRPV=MAX), and “hot” PCs (high signature) also get RRPV=0 while “cold” PCs get RRPV=MAX. For signature‐neutral PCs, we dynamically switch between SRRIP (RRPV=2) and BIP (1/32 chance of RRPV=2, else RRPV=3) using 32 leader sets for each policy to update an 8-bit PSEL counter. This lets the policy adapt insertion depth to workload reuse patterns, retains SHiP’s phase sensitivity, avoids pollution from streams, and keeps total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/007_02_dbrip_ship_t07.cc,0.403697456,0.403697456,0%
1060,milc,DBRIP-SHiP,"DBRIP-SHiP fuses PC-based SHiP-lite for phase and pointer‐chasing adaptation with a DRRIP–style set‐dueling between SRRIP and BIP for neutral lines, plus a lightweight streaming bypass. Hits always reset RRPV to 0 and train the 4-bit PC signature. On misses, truly streaming PCs bypass the cache (RRPV=MAX), and “hot” PCs (high signature) also get RRPV=0 while “cold” PCs get RRPV=MAX. For signature‐neutral PCs, we dynamically switch between SRRIP (RRPV=2) and BIP (1/32 chance of RRPV=2, else RRPV=3) using 32 leader sets for each policy to update an 8-bit PSEL counter. This lets the policy adapt insertion depth to workload reuse patterns, retains SHiP’s phase sensitivity, avoids pollution from streams, and keeps total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/007_02_dbrip_ship_t07.cc,0.138694179,0.138694179,0%
1061,omnetpp,DBRIP-SHiP,"DBRIP-SHiP fuses PC-based SHiP-lite for phase and pointer‐chasing adaptation with a DRRIP–style set‐dueling between SRRIP and BIP for neutral lines, plus a lightweight streaming bypass. Hits always reset RRPV to 0 and train the 4-bit PC signature. On misses, truly streaming PCs bypass the cache (RRPV=MAX), and “hot” PCs (high signature) also get RRPV=0 while “cold” PCs get RRPV=MAX. For signature‐neutral PCs, we dynamically switch between SRRIP (RRPV=2) and BIP (1/32 chance of RRPV=2, else RRPV=3) using 32 leader sets for each policy to update an 8-bit PSEL counter. This lets the policy adapt insertion depth to workload reuse patterns, retains SHiP’s phase sensitivity, avoids pollution from streams, and keeps total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/007_02_dbrip_ship_t07.cc,0.549164634,0.549164634,0%
1062,all,DRRIP-SHIP-BY (Dueling RRIP + SHiP + Bypass),"DRRIP-SHIP-BY augments SSDB with a DRRIP-style set dueling mechanism to automatically choose at runtime between SHiP-lite’s PC-based insertion depths and standard SRRIP’s neutral insertion. We partition 2048 LLC sets into 32 SRRIP leader sets, 32 SHiP leader sets, and 1984 follower sets. A 10-bit PSEL counter is incremented on hits in SHiP leaders and decremented on hits in SRRIP leaders. Follower sets then follow whichever policy PSEL prefers. The original streaming detector is preserved to bypass long strided accesses. This dynamic selection lets the cache lean on SHiP when pointer-chasing or phase-changing workloads predominate, or fall back to SRRIP on heavy streaming or stencil patterns, improving overall hit rate.",,ChampSim_CRC2/new_policies/007_00_drrip_ship_by__dueling_rrip___ship___bypass_t02.cc,0.379923867,0.379923867,38%
1063,astar,DIP-SHiP-BY,"DIP-SHiP-BY uses a small set-dueling (DIP) to switch online between bimodal insertion (BIP) for streaming/stencil workloads and PC-signature guided SHiP-lite insertion for pointer-chasing and phase-changing workloads. A 10-bit PSEL counter steers 32 BIP-leader sets versus 32 SHiP-leader sets, while the remaining 1,984 follower sets pick whichever side PSEL prefers. We augment this with the same lightweight stride-based streaming detector to bypass long predictable streams. Compared to DRRIP-SHIP, replacing SRRIP with BIP greatly reduces pollution on regular stride patterns, while SHiP-lite continues to capture temporal reuse on hard pointer workloads—yielding consistently higher hit rates across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/008_00_dip_ship_by_t02.cc,0.282917724,0.282917724,0%
1064,lbm,DIP-SHiP-BY,"DIP-SHiP-BY uses a small set-dueling (DIP) to switch online between bimodal insertion (BIP) for streaming/stencil workloads and PC-signature guided SHiP-lite insertion for pointer-chasing and phase-changing workloads. A 10-bit PSEL counter steers 32 BIP-leader sets versus 32 SHiP-leader sets, while the remaining 1,984 follower sets pick whichever side PSEL prefers. We augment this with the same lightweight stride-based streaming detector to bypass long predictable streams. Compared to DRRIP-SHIP, replacing SRRIP with BIP greatly reduces pollution on regular stride patterns, while SHiP-lite continues to capture temporal reuse on hard pointer workloads—yielding consistently higher hit rates across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/008_00_dip_ship_by_t02.cc,0.192692237,0.192692237,0%
1065,mcf,DIP-SHiP-BY,"DIP-SHiP-BY uses a small set-dueling (DIP) to switch online between bimodal insertion (BIP) for streaming/stencil workloads and PC-signature guided SHiP-lite insertion for pointer-chasing and phase-changing workloads. A 10-bit PSEL counter steers 32 BIP-leader sets versus 32 SHiP-leader sets, while the remaining 1,984 follower sets pick whichever side PSEL prefers. We augment this with the same lightweight stride-based streaming detector to bypass long predictable streams. Compared to DRRIP-SHIP, replacing SRRIP with BIP greatly reduces pollution on regular stride patterns, while SHiP-lite continues to capture temporal reuse on hard pointer workloads—yielding consistently higher hit rates across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/008_00_dip_ship_by_t02.cc,0.408329218,0.408329218,0%
1066,milc,DIP-SHiP-BY,"DIP-SHiP-BY uses a small set-dueling (DIP) to switch online between bimodal insertion (BIP) for streaming/stencil workloads and PC-signature guided SHiP-lite insertion for pointer-chasing and phase-changing workloads. A 10-bit PSEL counter steers 32 BIP-leader sets versus 32 SHiP-leader sets, while the remaining 1,984 follower sets pick whichever side PSEL prefers. We augment this with the same lightweight stride-based streaming detector to bypass long predictable streams. Compared to DRRIP-SHIP, replacing SRRIP with BIP greatly reduces pollution on regular stride patterns, while SHiP-lite continues to capture temporal reuse on hard pointer workloads—yielding consistently higher hit rates across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/008_00_dip_ship_by_t02.cc,0.079820706,0.079820706,0%
1067,omnetpp,DIP-SHiP-BY,"DIP-SHiP-BY uses a small set-dueling (DIP) to switch online between bimodal insertion (BIP) for streaming/stencil workloads and PC-signature guided SHiP-lite insertion for pointer-chasing and phase-changing workloads. A 10-bit PSEL counter steers 32 BIP-leader sets versus 32 SHiP-leader sets, while the remaining 1,984 follower sets pick whichever side PSEL prefers. We augment this with the same lightweight stride-based streaming detector to bypass long predictable streams. Compared to DRRIP-SHIP, replacing SRRIP with BIP greatly reduces pollution on regular stride patterns, while SHiP-lite continues to capture temporal reuse on hard pointer workloads—yielding consistently higher hit rates across astar, lbm, mcf, milc, and omnetpp.",,ChampSim_CRC2/new_policies/008_00_dip_ship_by_t02.cc,0.285897489,0.285897489,0%
1068,astar,DBIP-SHiP-DB,"DBIP-SHiP-DB combines set-dueling DIP (choosing between Bimodal Insertion Policy (BIP) and LRU) with per-PC SHiP signatures to bias hot blocks toward early promotion, and adds a 2-bit “dead-block” counter per line to accelerate the eviction of truly dead blocks. We partition 2048 sets into 32 BIP leaders, 32 LRU leaders, and 1984 followers, using a 10-bit PSEL to steer followers toward the better insertion style at runtime. On each miss we first consult SHiP: any PC with a strong “hot” signature is inserted at RRPV=0 regardless of DIP, otherwise we follow the DIP decision (mostly cold BIP with 1/32 chance of hot, or always hot for LRU). Hits update SHiP and reset the dead-block counter; miss evictions choose lines with RRPV=MAX and dead counter=0 first. This design adapts to both irregular pointer-chasing (via SHiP and dead-block) and streaming/stencil (via DIP) behaviors, improving overall hit rate.",,ChampSim_CRC2/new_policies/008_01_dbip_ship_db_t04.cc,0.454877993,0.454877993,0%
1069,lbm,DBIP-SHiP-DB,"DBIP-SHiP-DB combines set-dueling DIP (choosing between Bimodal Insertion Policy (BIP) and LRU) with per-PC SHiP signatures to bias hot blocks toward early promotion, and adds a 2-bit “dead-block” counter per line to accelerate the eviction of truly dead blocks. We partition 2048 sets into 32 BIP leaders, 32 LRU leaders, and 1984 followers, using a 10-bit PSEL to steer followers toward the better insertion style at runtime. On each miss we first consult SHiP: any PC with a strong “hot” signature is inserted at RRPV=0 regardless of DIP, otherwise we follow the DIP decision (mostly cold BIP with 1/32 chance of hot, or always hot for LRU). Hits update SHiP and reset the dead-block counter; miss evictions choose lines with RRPV=MAX and dead counter=0 first. This design adapts to both irregular pointer-chasing (via SHiP and dead-block) and streaming/stencil (via DIP) behaviors, improving overall hit rate.",,ChampSim_CRC2/new_policies/008_01_dbip_ship_db_t04.cc,0.345425882,0.345425882,0%
1070,mcf,DBIP-SHiP-DB,"DBIP-SHiP-DB combines set-dueling DIP (choosing between Bimodal Insertion Policy (BIP) and LRU) with per-PC SHiP signatures to bias hot blocks toward early promotion, and adds a 2-bit “dead-block” counter per line to accelerate the eviction of truly dead blocks. We partition 2048 sets into 32 BIP leaders, 32 LRU leaders, and 1984 followers, using a 10-bit PSEL to steer followers toward the better insertion style at runtime. On each miss we first consult SHiP: any PC with a strong “hot” signature is inserted at RRPV=0 regardless of DIP, otherwise we follow the DIP decision (mostly cold BIP with 1/32 chance of hot, or always hot for LRU). Hits update SHiP and reset the dead-block counter; miss evictions choose lines with RRPV=MAX and dead counter=0 first. This design adapts to both irregular pointer-chasing (via SHiP and dead-block) and streaming/stencil (via DIP) behaviors, improving overall hit rate.",,ChampSim_CRC2/new_policies/008_01_dbip_ship_db_t04.cc,0.403012353,0.403012353,0%
1071,milc,DBIP-SHiP-DB,"DBIP-SHiP-DB combines set-dueling DIP (choosing between Bimodal Insertion Policy (BIP) and LRU) with per-PC SHiP signatures to bias hot blocks toward early promotion, and adds a 2-bit “dead-block” counter per line to accelerate the eviction of truly dead blocks. We partition 2048 sets into 32 BIP leaders, 32 LRU leaders, and 1984 followers, using a 10-bit PSEL to steer followers toward the better insertion style at runtime. On each miss we first consult SHiP: any PC with a strong “hot” signature is inserted at RRPV=0 regardless of DIP, otherwise we follow the DIP decision (mostly cold BIP with 1/32 chance of hot, or always hot for LRU). Hits update SHiP and reset the dead-block counter; miss evictions choose lines with RRPV=MAX and dead counter=0 first. This design adapts to both irregular pointer-chasing (via SHiP and dead-block) and streaming/stencil (via DIP) behaviors, improving overall hit rate.",,ChampSim_CRC2/new_policies/008_01_dbip_ship_db_t04.cc,0.178809098,0.178809098,0%
1072,omnetpp,DBIP-SHiP-DB,"DBIP-SHiP-DB combines set-dueling DIP (choosing between Bimodal Insertion Policy (BIP) and LRU) with per-PC SHiP signatures to bias hot blocks toward early promotion, and adds a 2-bit “dead-block” counter per line to accelerate the eviction of truly dead blocks. We partition 2048 sets into 32 BIP leaders, 32 LRU leaders, and 1984 followers, using a 10-bit PSEL to steer followers toward the better insertion style at runtime. On each miss we first consult SHiP: any PC with a strong “hot” signature is inserted at RRPV=0 regardless of DIP, otherwise we follow the DIP decision (mostly cold BIP with 1/32 chance of hot, or always hot for LRU). Hits update SHiP and reset the dead-block counter; miss evictions choose lines with RRPV=MAX and dead counter=0 first. This design adapts to both irregular pointer-chasing (via SHiP and dead-block) and streaming/stencil (via DIP) behaviors, improving overall hit rate.",,ChampSim_CRC2/new_policies/008_01_dbip_ship_db_t04.cc,0.500903663,0.500903663,0%
1073,astar,DIP-RRIP-SB,"We replace DRRIP’s choice of SRRIP vs. SHiP with a traditional DIP-style dueling between BIP (Bimodal Insertion Policy) and LIP (Low Insertion Priority) built on 2-bit RRIP, and retain a lightweight streaming detector to bypass long strides. 32 leader sets favor BIP (infrequently insert at MRU), 32 favor LIP (always insert at LRU), and 1984 followers pick via a 10-bit PSEL vote.  On hits we promote to RRPV=0 and update PSEL in leaders; on misses we first check for a detected stream and bypass (insert at RRPV=MAX), otherwise apply BIP/LIP.  This change in insertion‐depth policy plus explicit bypassing yields robust gains on both irregular, pointer-chasing workloads and dense stencil or streaming patterns without exceeding 64 KiB of metadata.",,ChampSim_CRC2/new_policies/008_02_dip_rrip_sb_t07.cc,0.075023211,0.075023211,0%
1074,lbm,DIP-RRIP-SB,"We replace DRRIP’s choice of SRRIP vs. SHiP with a traditional DIP-style dueling between BIP (Bimodal Insertion Policy) and LIP (Low Insertion Priority) built on 2-bit RRIP, and retain a lightweight streaming detector to bypass long strides. 32 leader sets favor BIP (infrequently insert at MRU), 32 favor LIP (always insert at LRU), and 1984 followers pick via a 10-bit PSEL vote.  On hits we promote to RRPV=0 and update PSEL in leaders; on misses we first check for a detected stream and bypass (insert at RRPV=MAX), otherwise apply BIP/LIP.  This change in insertion‐depth policy plus explicit bypassing yields robust gains on both irregular, pointer-chasing workloads and dense stencil or streaming patterns without exceeding 64 KiB of metadata.",,ChampSim_CRC2/new_policies/008_02_dip_rrip_sb_t07.cc,0.052364235,0.052364235,0%
1075,mcf,DIP-RRIP-SB,"We replace DRRIP’s choice of SRRIP vs. SHiP with a traditional DIP-style dueling between BIP (Bimodal Insertion Policy) and LIP (Low Insertion Priority) built on 2-bit RRIP, and retain a lightweight streaming detector to bypass long strides. 32 leader sets favor BIP (infrequently insert at MRU), 32 favor LIP (always insert at LRU), and 1984 followers pick via a 10-bit PSEL vote.  On hits we promote to RRPV=0 and update PSEL in leaders; on misses we first check for a detected stream and bypass (insert at RRPV=MAX), otherwise apply BIP/LIP.  This change in insertion‐depth policy plus explicit bypassing yields robust gains on both irregular, pointer-chasing workloads and dense stencil or streaming patterns without exceeding 64 KiB of metadata.",,ChampSim_CRC2/new_policies/008_02_dip_rrip_sb_t07.cc,0.316621996,0.316621996,0%
1076,milc,DIP-RRIP-SB,"We replace DRRIP’s choice of SRRIP vs. SHiP with a traditional DIP-style dueling between BIP (Bimodal Insertion Policy) and LIP (Low Insertion Priority) built on 2-bit RRIP, and retain a lightweight streaming detector to bypass long strides. 32 leader sets favor BIP (infrequently insert at MRU), 32 favor LIP (always insert at LRU), and 1984 followers pick via a 10-bit PSEL vote.  On hits we promote to RRPV=0 and update PSEL in leaders; on misses we first check for a detected stream and bypass (insert at RRPV=MAX), otherwise apply BIP/LIP.  This change in insertion‐depth policy plus explicit bypassing yields robust gains on both irregular, pointer-chasing workloads and dense stencil or streaming patterns without exceeding 64 KiB of metadata.",,ChampSim_CRC2/new_policies/008_02_dip_rrip_sb_t07.cc,0.011716402,0.011716402,0%
1077,omnetpp,DIP-RRIP-SB,"We replace DRRIP’s choice of SRRIP vs. SHiP with a traditional DIP-style dueling between BIP (Bimodal Insertion Policy) and LIP (Low Insertion Priority) built on 2-bit RRIP, and retain a lightweight streaming detector to bypass long strides. 32 leader sets favor BIP (infrequently insert at MRU), 32 favor LIP (always insert at LRU), and 1984 followers pick via a 10-bit PSEL vote.  On hits we promote to RRPV=0 and update PSEL in leaders; on misses we first check for a detected stream and bypass (insert at RRPV=MAX), otherwise apply BIP/LIP.  This change in insertion‐depth policy plus explicit bypassing yields robust gains on both irregular, pointer-chasing workloads and dense stencil or streaming patterns without exceeding 64 KiB of metadata.",,ChampSim_CRC2/new_policies/008_02_dip_rrip_sb_t07.cc,0.002892949,0.002892949,0%
1078,all,DBIP-SHiP-DB,"DBIP-SHiP-DB combines set-dueling DIP (choosing between Bimodal Insertion Policy (BIP) and LRU) with per-PC SHiP signatures to bias hot blocks toward early promotion, and adds a 2-bit “dead-block” counter per line to accelerate the eviction of truly dead blocks. We partition 2048 sets into 32 BIP leaders, 32 LRU leaders, and 1984 followers, using a 10-bit PSEL to steer followers toward the better insertion style at runtime. On each miss we first consult SHiP: any PC with a strong “hot” signature is inserted at RRPV=0 regardless of DIP, otherwise we follow the DIP decision (mostly cold BIP with 1/32 chance of hot, or always hot for LRU). Hits update SHiP and reset the dead-block counter; miss evictions choose lines with RRPV=MAX and dead counter=0 first. This design adapts to both irregular pointer-chasing (via SHiP and dead-block) and streaming/stencil (via DIP) behaviors, improving overall hit rate.",,ChampSim_CRC2/new_policies/008_01_dbip_ship_db_t04.cc,0.376605798,0.376605798,38%
1079,astar,DRRIP-StreamGuard,"DRRIP-StreamGuard uses Dynamic RRIP (DRRIP) to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) for insertion depth via a 10-bit PSEL-driven set dueling. On top of that, we maintain a small per-PC 2-bit reuse counter to detect low-reuse (streaming) PCs: cold PCs are inserted with the maximum RRPV (effectively bypassed) to avoid cache pollution. Hits reinforce both reuse counters and keep blocks hot (RRPV=0), while misses on streaming PCs decay their counter and insert cold. This combination harnesses DRRIP’s sensitivity to access regularity and the reuse predictor’s ability to quarantine one-time streams, boosting performance across pointer-chasing, stencil, and streaming workloads with under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/009_00_drrip_streamguard_t02.cc,0.098206566,0.098206566,0%
1080,lbm,DRRIP-StreamGuard,"DRRIP-StreamGuard uses Dynamic RRIP (DRRIP) to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) for insertion depth via a 10-bit PSEL-driven set dueling. On top of that, we maintain a small per-PC 2-bit reuse counter to detect low-reuse (streaming) PCs: cold PCs are inserted with the maximum RRPV (effectively bypassed) to avoid cache pollution. Hits reinforce both reuse counters and keep blocks hot (RRPV=0), while misses on streaming PCs decay their counter and insert cold. This combination harnesses DRRIP’s sensitivity to access regularity and the reuse predictor’s ability to quarantine one-time streams, boosting performance across pointer-chasing, stencil, and streaming workloads with under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/009_00_drrip_streamguard_t02.cc,0.06751982,0.06751982,0%
1081,mcf,DRRIP-StreamGuard,"DRRIP-StreamGuard uses Dynamic RRIP (DRRIP) to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) for insertion depth via a 10-bit PSEL-driven set dueling. On top of that, we maintain a small per-PC 2-bit reuse counter to detect low-reuse (streaming) PCs: cold PCs are inserted with the maximum RRPV (effectively bypassed) to avoid cache pollution. Hits reinforce both reuse counters and keep blocks hot (RRPV=0), while misses on streaming PCs decay their counter and insert cold. This combination harnesses DRRIP’s sensitivity to access regularity and the reuse predictor’s ability to quarantine one-time streams, boosting performance across pointer-chasing, stencil, and streaming workloads with under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/009_00_drrip_streamguard_t02.cc,0.390228303,0.390228303,0%
1082,milc,DRRIP-StreamGuard,"DRRIP-StreamGuard uses Dynamic RRIP (DRRIP) to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) for insertion depth via a 10-bit PSEL-driven set dueling. On top of that, we maintain a small per-PC 2-bit reuse counter to detect low-reuse (streaming) PCs: cold PCs are inserted with the maximum RRPV (effectively bypassed) to avoid cache pollution. Hits reinforce both reuse counters and keep blocks hot (RRPV=0), while misses on streaming PCs decay their counter and insert cold. This combination harnesses DRRIP’s sensitivity to access regularity and the reuse predictor’s ability to quarantine one-time streams, boosting performance across pointer-chasing, stencil, and streaming workloads with under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/009_00_drrip_streamguard_t02.cc,0.009726859,0.009726859,0%
1083,omnetpp,DRRIP-StreamGuard,"DRRIP-StreamGuard uses Dynamic RRIP (DRRIP) to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) for insertion depth via a 10-bit PSEL-driven set dueling. On top of that, we maintain a small per-PC 2-bit reuse counter to detect low-reuse (streaming) PCs: cold PCs are inserted with the maximum RRPV (effectively bypassed) to avoid cache pollution. Hits reinforce both reuse counters and keep blocks hot (RRPV=0), while misses on streaming PCs decay their counter and insert cold. This combination harnesses DRRIP’s sensitivity to access regularity and the reuse predictor’s ability to quarantine one-time streams, boosting performance across pointer-chasing, stencil, and streaming workloads with under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/009_00_drrip_streamguard_t02.cc,0.001288406,0.001288406,0%
1084,astar,SDDRIP,"SDDRIP augments the well‐known signature‐guided SHiP mechanism with a tiny per‐PC streaming detector to bypass near‐monotonic “one‐time” streams, and wraps it all in DRRIP’s set‐dueling of SRRIP vs. BIP insertion.  On each miss we first update a global last‐miss stride and a 2-bit stream counter per PC; if a PC’s stream counter is high, new blocks from that PC are cold‐inserted (RRPV=max) to avoid pollution.  Otherwise, if the PC’s SHiP signature predicts reuse, we insert at MRU (RRPV=0).  All other blocks follow the current DRRIP policy (SRRIP always inserts at RRPV=MAX-1; BIP inserts at RRPV=MAX except one‐in‐64 times at 0).  DRRIP’s 64 leader sets keep a 10-bit PSEL counter to adaptively pick between SRRIP and BIP.  On hits, we train the SHiP table.  This combination efficiently handles streaming (lbm), irregular pointer‐chases (mcf/omnetpp), and mixed‐reuse phases (milc/astar) at very low metadata cost.",,ChampSim_CRC2/new_policies/009_01_sddrip_t04.cc,0.454986074,0.454986074,0%
1085,lbm,SDDRIP,"SDDRIP augments the well‐known signature‐guided SHiP mechanism with a tiny per‐PC streaming detector to bypass near‐monotonic “one‐time” streams, and wraps it all in DRRIP’s set‐dueling of SRRIP vs. BIP insertion.  On each miss we first update a global last‐miss stride and a 2-bit stream counter per PC; if a PC’s stream counter is high, new blocks from that PC are cold‐inserted (RRPV=max) to avoid pollution.  Otherwise, if the PC’s SHiP signature predicts reuse, we insert at MRU (RRPV=0).  All other blocks follow the current DRRIP policy (SRRIP always inserts at RRPV=MAX-1; BIP inserts at RRPV=MAX except one‐in‐64 times at 0).  DRRIP’s 64 leader sets keep a 10-bit PSEL counter to adaptively pick between SRRIP and BIP.  On hits, we train the SHiP table.  This combination efficiently handles streaming (lbm), irregular pointer‐chases (mcf/omnetpp), and mixed‐reuse phases (milc/astar) at very low metadata cost.",,ChampSim_CRC2/new_policies/009_01_sddrip_t04.cc,0.309410574,0.309410574,0%
1086,mcf,SDDRIP,"SDDRIP augments the well‐known signature‐guided SHiP mechanism with a tiny per‐PC streaming detector to bypass near‐monotonic “one‐time” streams, and wraps it all in DRRIP’s set‐dueling of SRRIP vs. BIP insertion.  On each miss we first update a global last‐miss stride and a 2-bit stream counter per PC; if a PC’s stream counter is high, new blocks from that PC are cold‐inserted (RRPV=max) to avoid pollution.  Otherwise, if the PC’s SHiP signature predicts reuse, we insert at MRU (RRPV=0).  All other blocks follow the current DRRIP policy (SRRIP always inserts at RRPV=MAX-1; BIP inserts at RRPV=MAX except one‐in‐64 times at 0).  DRRIP’s 64 leader sets keep a 10-bit PSEL counter to adaptively pick between SRRIP and BIP.  On hits, we train the SHiP table.  This combination efficiently handles streaming (lbm), irregular pointer‐chases (mcf/omnetpp), and mixed‐reuse phases (milc/astar) at very low metadata cost.",,ChampSim_CRC2/new_policies/009_01_sddrip_t04.cc,0.403676171,0.403676171,0%
1087,milc,SDDRIP,"SDDRIP augments the well‐known signature‐guided SHiP mechanism with a tiny per‐PC streaming detector to bypass near‐monotonic “one‐time” streams, and wraps it all in DRRIP’s set‐dueling of SRRIP vs. BIP insertion.  On each miss we first update a global last‐miss stride and a 2-bit stream counter per PC; if a PC’s stream counter is high, new blocks from that PC are cold‐inserted (RRPV=max) to avoid pollution.  Otherwise, if the PC’s SHiP signature predicts reuse, we insert at MRU (RRPV=0).  All other blocks follow the current DRRIP policy (SRRIP always inserts at RRPV=MAX-1; BIP inserts at RRPV=MAX except one‐in‐64 times at 0).  DRRIP’s 64 leader sets keep a 10-bit PSEL counter to adaptively pick between SRRIP and BIP.  On hits, we train the SHiP table.  This combination efficiently handles streaming (lbm), irregular pointer‐chases (mcf/omnetpp), and mixed‐reuse phases (milc/astar) at very low metadata cost.",,ChampSim_CRC2/new_policies/009_01_sddrip_t04.cc,0.159773565,0.159773565,0%
1088,omnetpp,SDDRIP,"SDDRIP augments the well‐known signature‐guided SHiP mechanism with a tiny per‐PC streaming detector to bypass near‐monotonic “one‐time” streams, and wraps it all in DRRIP’s set‐dueling of SRRIP vs. BIP insertion.  On each miss we first update a global last‐miss stride and a 2-bit stream counter per PC; if a PC’s stream counter is high, new blocks from that PC are cold‐inserted (RRPV=max) to avoid pollution.  Otherwise, if the PC’s SHiP signature predicts reuse, we insert at MRU (RRPV=0).  All other blocks follow the current DRRIP policy (SRRIP always inserts at RRPV=MAX-1; BIP inserts at RRPV=MAX except one‐in‐64 times at 0).  DRRIP’s 64 leader sets keep a 10-bit PSEL counter to adaptively pick between SRRIP and BIP.  On hits, we train the SHiP table.  This combination efficiently handles streaming (lbm), irregular pointer‐chases (mcf/omnetpp), and mixed‐reuse phases (milc/astar) at very low metadata cost.",,ChampSim_CRC2/new_policies/009_01_sddrip_t04.cc,0.417563868,0.417563868,0%
1089,astar,SDBRIP,"SDBRIP combines Dynamic RRIP (DRRIP) with SHiP-lite hot‐PC signatures, a streaming detector/bypass, and per‐line dead‐block counters. A set-dueling PSEL steers followers between SRRIP (all insertions at RRPV=2) and BRRIP (mostly RRPV=3 with a small chance of RRPV=2). On each access, we first update a tiny per-PC streaming table: once two consecutive 1-line strides are seen, future blocks from that PC are bypassed (inserted at RRPV=MAX and marked dead) to avoid pollution from pure streams. Otherwise, misses use DRRIP’s SRRIP/BRRIP choice, but SHiP-lite “hot” PCs always insert at RRPV=0. Hits promote to RRPV=0, train the SHiP signature, and reset the dead‐block counter. Victim selection prefers dead lines with RRPV=MAX, else any RRPV=MAX. This design eliminates DIP vs. LRU complexity, effectively handles streaming/stencil phases, pointer-chasing, and phase shifts, and keeps metadata under 16 KB.",,ChampSim_CRC2/new_policies/009_02_sdbrip_t07.cc,0.457873251,0.457873251,0%
1090,lbm,SDBRIP,"SDBRIP combines Dynamic RRIP (DRRIP) with SHiP-lite hot‐PC signatures, a streaming detector/bypass, and per‐line dead‐block counters. A set-dueling PSEL steers followers between SRRIP (all insertions at RRPV=2) and BRRIP (mostly RRPV=3 with a small chance of RRPV=2). On each access, we first update a tiny per-PC streaming table: once two consecutive 1-line strides are seen, future blocks from that PC are bypassed (inserted at RRPV=MAX and marked dead) to avoid pollution from pure streams. Otherwise, misses use DRRIP’s SRRIP/BRRIP choice, but SHiP-lite “hot” PCs always insert at RRPV=0. Hits promote to RRPV=0, train the SHiP signature, and reset the dead‐block counter. Victim selection prefers dead lines with RRPV=MAX, else any RRPV=MAX. This design eliminates DIP vs. LRU complexity, effectively handles streaming/stencil phases, pointer-chasing, and phase shifts, and keeps metadata under 16 KB.",,ChampSim_CRC2/new_policies/009_02_sdbrip_t07.cc,0.331064828,0.331064828,0%
1091,mcf,SDBRIP,"SDBRIP combines Dynamic RRIP (DRRIP) with SHiP-lite hot‐PC signatures, a streaming detector/bypass, and per‐line dead‐block counters. A set-dueling PSEL steers followers between SRRIP (all insertions at RRPV=2) and BRRIP (mostly RRPV=3 with a small chance of RRPV=2). On each access, we first update a tiny per-PC streaming table: once two consecutive 1-line strides are seen, future blocks from that PC are bypassed (inserted at RRPV=MAX and marked dead) to avoid pollution from pure streams. Otherwise, misses use DRRIP’s SRRIP/BRRIP choice, but SHiP-lite “hot” PCs always insert at RRPV=0. Hits promote to RRPV=0, train the SHiP signature, and reset the dead‐block counter. Victim selection prefers dead lines with RRPV=MAX, else any RRPV=MAX. This design eliminates DIP vs. LRU complexity, effectively handles streaming/stencil phases, pointer-chasing, and phase shifts, and keeps metadata under 16 KB.",,ChampSim_CRC2/new_policies/009_02_sdbrip_t07.cc,0.403704191,0.403704191,0%
1092,milc,SDBRIP,"SDBRIP combines Dynamic RRIP (DRRIP) with SHiP-lite hot‐PC signatures, a streaming detector/bypass, and per‐line dead‐block counters. A set-dueling PSEL steers followers between SRRIP (all insertions at RRPV=2) and BRRIP (mostly RRPV=3 with a small chance of RRPV=2). On each access, we first update a tiny per-PC streaming table: once two consecutive 1-line strides are seen, future blocks from that PC are bypassed (inserted at RRPV=MAX and marked dead) to avoid pollution from pure streams. Otherwise, misses use DRRIP’s SRRIP/BRRIP choice, but SHiP-lite “hot” PCs always insert at RRPV=0. Hits promote to RRPV=0, train the SHiP signature, and reset the dead‐block counter. Victim selection prefers dead lines with RRPV=MAX, else any RRPV=MAX. This design eliminates DIP vs. LRU complexity, effectively handles streaming/stencil phases, pointer-chasing, and phase shifts, and keeps metadata under 16 KB.",,ChampSim_CRC2/new_policies/009_02_sdbrip_t07.cc,0.155993613,0.155993613,0%
1093,omnetpp,SDBRIP,"SDBRIP combines Dynamic RRIP (DRRIP) with SHiP-lite hot‐PC signatures, a streaming detector/bypass, and per‐line dead‐block counters. A set-dueling PSEL steers followers between SRRIP (all insertions at RRPV=2) and BRRIP (mostly RRPV=3 with a small chance of RRPV=2). On each access, we first update a tiny per-PC streaming table: once two consecutive 1-line strides are seen, future blocks from that PC are bypassed (inserted at RRPV=MAX and marked dead) to avoid pollution from pure streams. Otherwise, misses use DRRIP’s SRRIP/BRRIP choice, but SHiP-lite “hot” PCs always insert at RRPV=0. Hits promote to RRPV=0, train the SHiP signature, and reset the dead‐block counter. Victim selection prefers dead lines with RRPV=MAX, else any RRPV=MAX. This design eliminates DIP vs. LRU complexity, effectively handles streaming/stencil phases, pointer-chasing, and phase shifts, and keeps metadata under 16 KB.",,ChampSim_CRC2/new_policies/009_02_sdbrip_t07.cc,0.560396299,0.560396299,0%
1094,all,SDBRIP,"SDBRIP combines Dynamic RRIP (DRRIP) with SHiP-lite hot‐PC signatures, a streaming detector/bypass, and per‐line dead‐block counters. A set-dueling PSEL steers followers between SRRIP (all insertions at RRPV=2) and BRRIP (mostly RRPV=3 with a small chance of RRPV=2). On each access, we first update a tiny per-PC streaming table: once two consecutive 1-line strides are seen, future blocks from that PC are bypassed (inserted at RRPV=MAX and marked dead) to avoid pollution from pure streams. Otherwise, misses use DRRIP’s SRRIP/BRRIP choice, but SHiP-lite “hot” PCs always insert at RRPV=0. Hits promote to RRPV=0, train the SHiP signature, and reset the dead‐block counter. Victim selection prefers dead lines with RRPV=MAX, else any RRPV=MAX. This design eliminates DIP vs. LRU complexity, effectively handles streaming/stencil phases, pointer-chasing, and phase shifts, and keeps metadata under 16 KB.",,ChampSim_CRC2/new_policies/009_02_sdbrip_t07.cc,0.381806437,0.381806437,38%
1095,astar,PF-DIP (PC‐Guided Frequency Dual Insertion Policy),"PF-DIP combines a small per‐PC saturating reuse counter with a classic DIP chooser and per‐line “use” bits to adaptively insert and evict blocks. A 3-bit PC‐signature table classifies PCs into streaming (0–1), medium (2–4), or recurrent (5–7) phases. On a miss from a streaming PC, the block is bypassed (inserted with RRPV=MAX); from a recurrent PC, it is promoted (RRPV=0); from a medium PC, we run DIP between LRU‐style (always RRPV=0) and BIP‐style (mostly RRPV=MAX with occasional RRPV=2) insertion, steered by 64 leader sets and a 10-bit PSEL. On hits, RRPV is reset and a per‐line “use” bit is set. Victim selection prefers RRPV=MAX lines with use==0 first, then any RRPV=MAX, aging otherwise. This mix bypasses pure streams, retains hot/recurrent data aggressively, and dynamically chooses between recency and conservatism for ambiguous phases. The small PC table (2 K entries, 3 bits each), a 10-bit PSEL, per‐set leader flags, per‐line 2-bit RRPVs, and 1-bit use flags stay under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_pf_dip__pc_guided_frequency_dual_insertion_policy_t02.cc,0.050013111,0.050013111,0%
1096,lbm,PF-DIP (PC‐Guided Frequency Dual Insertion Policy),"PF-DIP combines a small per‐PC saturating reuse counter with a classic DIP chooser and per‐line “use” bits to adaptively insert and evict blocks. A 3-bit PC‐signature table classifies PCs into streaming (0–1), medium (2–4), or recurrent (5–7) phases. On a miss from a streaming PC, the block is bypassed (inserted with RRPV=MAX); from a recurrent PC, it is promoted (RRPV=0); from a medium PC, we run DIP between LRU‐style (always RRPV=0) and BIP‐style (mostly RRPV=MAX with occasional RRPV=2) insertion, steered by 64 leader sets and a 10-bit PSEL. On hits, RRPV is reset and a per‐line “use” bit is set. Victim selection prefers RRPV=MAX lines with use==0 first, then any RRPV=MAX, aging otherwise. This mix bypasses pure streams, retains hot/recurrent data aggressively, and dynamically chooses between recency and conservatism for ambiguous phases. The small PC table (2 K entries, 3 bits each), a 10-bit PSEL, per‐set leader flags, per‐line 2-bit RRPVs, and 1-bit use flags stay under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_pf_dip__pc_guided_frequency_dual_insertion_policy_t02.cc,0.065329667,0.065329667,0%
1097,mcf,PF-DIP (PC‐Guided Frequency Dual Insertion Policy),"PF-DIP combines a small per‐PC saturating reuse counter with a classic DIP chooser and per‐line “use” bits to adaptively insert and evict blocks. A 3-bit PC‐signature table classifies PCs into streaming (0–1), medium (2–4), or recurrent (5–7) phases. On a miss from a streaming PC, the block is bypassed (inserted with RRPV=MAX); from a recurrent PC, it is promoted (RRPV=0); from a medium PC, we run DIP between LRU‐style (always RRPV=0) and BIP‐style (mostly RRPV=MAX with occasional RRPV=2) insertion, steered by 64 leader sets and a 10-bit PSEL. On hits, RRPV is reset and a per‐line “use” bit is set. Victim selection prefers RRPV=MAX lines with use==0 first, then any RRPV=MAX, aging otherwise. This mix bypasses pure streams, retains hot/recurrent data aggressively, and dynamically chooses between recency and conservatism for ambiguous phases. The small PC table (2 K entries, 3 bits each), a 10-bit PSEL, per‐set leader flags, per‐line 2-bit RRPVs, and 1-bit use flags stay under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_pf_dip__pc_guided_frequency_dual_insertion_policy_t02.cc,0.425547565,0.425547565,0%
1098,milc,PF-DIP (PC‐Guided Frequency Dual Insertion Policy),"PF-DIP combines a small per‐PC saturating reuse counter with a classic DIP chooser and per‐line “use” bits to adaptively insert and evict blocks. A 3-bit PC‐signature table classifies PCs into streaming (0–1), medium (2–4), or recurrent (5–7) phases. On a miss from a streaming PC, the block is bypassed (inserted with RRPV=MAX); from a recurrent PC, it is promoted (RRPV=0); from a medium PC, we run DIP between LRU‐style (always RRPV=0) and BIP‐style (mostly RRPV=MAX with occasional RRPV=2) insertion, steered by 64 leader sets and a 10-bit PSEL. On hits, RRPV is reset and a per‐line “use” bit is set. Victim selection prefers RRPV=MAX lines with use==0 first, then any RRPV=MAX, aging otherwise. This mix bypasses pure streams, retains hot/recurrent data aggressively, and dynamically chooses between recency and conservatism for ambiguous phases. The small PC table (2 K entries, 3 bits each), a 10-bit PSEL, per‐set leader flags, per‐line 2-bit RRPVs, and 1-bit use flags stay under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_pf_dip__pc_guided_frequency_dual_insertion_policy_t02.cc,0.009754013,0.009754013,0%
1099,omnetpp,PF-DIP (PC‐Guided Frequency Dual Insertion Policy),"PF-DIP combines a small per‐PC saturating reuse counter with a classic DIP chooser and per‐line “use” bits to adaptively insert and evict blocks. A 3-bit PC‐signature table classifies PCs into streaming (0–1), medium (2–4), or recurrent (5–7) phases. On a miss from a streaming PC, the block is bypassed (inserted with RRPV=MAX); from a recurrent PC, it is promoted (RRPV=0); from a medium PC, we run DIP between LRU‐style (always RRPV=0) and BIP‐style (mostly RRPV=MAX with occasional RRPV=2) insertion, steered by 64 leader sets and a 10-bit PSEL. On hits, RRPV is reset and a per‐line “use” bit is set. Victim selection prefers RRPV=MAX lines with use==0 first, then any RRPV=MAX, aging otherwise. This mix bypasses pure streams, retains hot/recurrent data aggressively, and dynamically chooses between recency and conservatism for ambiguous phases. The small PC table (2 K entries, 3 bits each), a 10-bit PSEL, per‐set leader flags, per‐line 2-bit RRPVs, and 1-bit use flags stay under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_pf_dip__pc_guided_frequency_dual_insertion_policy_t02.cc,0.004241004,0.004241004,0%
1100,astar,DIP-SHiP,"DIP-SHiP dynamically steers between an LRU insertion policy and a BIP (bimodal) policy via set-dueling, augmented with SHiP-lite PC signatures to immediately promote “hot” streams, and lightweight per-line dead-block counters to evict non-reused lines early. By removing the explicit stride detector and replacing DRRIP with DIP, we adapt naturally to streaming workloads (via BIP) and irregular, pointer-chasing workloads (via LRU), while the SHiP override quickly captures high-locality loops (milc, astar) and dead-block counters reduce pollution from one-time blocks. The entire design fits well under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/010_01_dip_ship_t04.cc,0.454691066,0.454691066,0%
1101,lbm,DIP-SHiP,"DIP-SHiP dynamically steers between an LRU insertion policy and a BIP (bimodal) policy via set-dueling, augmented with SHiP-lite PC signatures to immediately promote “hot” streams, and lightweight per-line dead-block counters to evict non-reused lines early. By removing the explicit stride detector and replacing DRRIP with DIP, we adapt naturally to streaming workloads (via BIP) and irregular, pointer-chasing workloads (via LRU), while the SHiP override quickly captures high-locality loops (milc, astar) and dead-block counters reduce pollution from one-time blocks. The entire design fits well under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/010_01_dip_ship_t04.cc,0.439915442,0.439915442,0%
1102,mcf,DIP-SHiP,"DIP-SHiP dynamically steers between an LRU insertion policy and a BIP (bimodal) policy via set-dueling, augmented with SHiP-lite PC signatures to immediately promote “hot” streams, and lightweight per-line dead-block counters to evict non-reused lines early. By removing the explicit stride detector and replacing DRRIP with DIP, we adapt naturally to streaming workloads (via BIP) and irregular, pointer-chasing workloads (via LRU), while the SHiP override quickly captures high-locality loops (milc, astar) and dead-block counters reduce pollution from one-time blocks. The entire design fits well under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/010_01_dip_ship_t04.cc,0.403069095,0.403069095,0%
1103,milc,DIP-SHiP,"DIP-SHiP dynamically steers between an LRU insertion policy and a BIP (bimodal) policy via set-dueling, augmented with SHiP-lite PC signatures to immediately promote “hot” streams, and lightweight per-line dead-block counters to evict non-reused lines early. By removing the explicit stride detector and replacing DRRIP with DIP, we adapt naturally to streaming workloads (via BIP) and irregular, pointer-chasing workloads (via LRU), while the SHiP override quickly captures high-locality loops (milc, astar) and dead-block counters reduce pollution from one-time blocks. The entire design fits well under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/010_01_dip_ship_t04.cc,0.243158794,0.243158794,0%
1104,omnetpp,DIP-SHiP,"DIP-SHiP dynamically steers between an LRU insertion policy and a BIP (bimodal) policy via set-dueling, augmented with SHiP-lite PC signatures to immediately promote “hot” streams, and lightweight per-line dead-block counters to evict non-reused lines early. By removing the explicit stride detector and replacing DRRIP with DIP, we adapt naturally to streaming workloads (via BIP) and irregular, pointer-chasing workloads (via LRU), while the SHiP override quickly captures high-locality loops (milc, astar) and dead-block counters reduce pollution from one-time blocks. The entire design fits well under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/010_01_dip_ship_t04.cc,0.484250019,0.484250019,0%
1105,astar,SHiDIP,"SHiDIP (Signature-guided Hybrid DIP) combines SHiP-based PC signatures with a set-dueling DIP mechanism and a simple streaming detector to adapt insertion depth per stream, hot PC, and phase. Hot PCs (identified by saturating signature counters) always insert at MRU to capture reuse-driven phases (e.g., pointer chasing), while cold PCs follow a dynamic choice between LIP and BIP driven by a small PSEL counter. Sequential streams (detected by PC-indexed deltas) bypass the cache by inserting at LRU, preventing pollution from pure streams and stencils. Victim selection uses 2-bit RRPVs with usual aging. This hybrid design targets irregular workloads (mcf, omnetpp) with aggressive insertion on hot PCs, regular stencils (lbm) with bypass logic, and dynamic phase shifts (milc, astar) via DIP set dueling, all in <32 KB metadata.",,ChampSim_CRC2/new_policies/010_02_shidip_t07.cc,0.457576472,0.457576472,0%
1106,lbm,SHiDIP,"SHiDIP (Signature-guided Hybrid DIP) combines SHiP-based PC signatures with a set-dueling DIP mechanism and a simple streaming detector to adapt insertion depth per stream, hot PC, and phase. Hot PCs (identified by saturating signature counters) always insert at MRU to capture reuse-driven phases (e.g., pointer chasing), while cold PCs follow a dynamic choice between LIP and BIP driven by a small PSEL counter. Sequential streams (detected by PC-indexed deltas) bypass the cache by inserting at LRU, preventing pollution from pure streams and stencils. Victim selection uses 2-bit RRPVs with usual aging. This hybrid design targets irregular workloads (mcf, omnetpp) with aggressive insertion on hot PCs, regular stencils (lbm) with bypass logic, and dynamic phase shifts (milc, astar) via DIP set dueling, all in <32 KB metadata.",,ChampSim_CRC2/new_policies/010_02_shidip_t07.cc,0.059845154,0.059845154,0%
1107,mcf,SHiDIP,"SHiDIP (Signature-guided Hybrid DIP) combines SHiP-based PC signatures with a set-dueling DIP mechanism and a simple streaming detector to adapt insertion depth per stream, hot PC, and phase. Hot PCs (identified by saturating signature counters) always insert at MRU to capture reuse-driven phases (e.g., pointer chasing), while cold PCs follow a dynamic choice between LIP and BIP driven by a small PSEL counter. Sequential streams (detected by PC-indexed deltas) bypass the cache by inserting at LRU, preventing pollution from pure streams and stencils. Victim selection uses 2-bit RRPVs with usual aging. This hybrid design targets irregular workloads (mcf, omnetpp) with aggressive insertion on hot PCs, regular stencils (lbm) with bypass logic, and dynamic phase shifts (milc, astar) via DIP set dueling, all in <32 KB metadata.",,ChampSim_CRC2/new_policies/010_02_shidip_t07.cc,0.401038587,0.401038587,0%
1108,milc,SHiDIP,"SHiDIP (Signature-guided Hybrid DIP) combines SHiP-based PC signatures with a set-dueling DIP mechanism and a simple streaming detector to adapt insertion depth per stream, hot PC, and phase. Hot PCs (identified by saturating signature counters) always insert at MRU to capture reuse-driven phases (e.g., pointer chasing), while cold PCs follow a dynamic choice between LIP and BIP driven by a small PSEL counter. Sequential streams (detected by PC-indexed deltas) bypass the cache by inserting at LRU, preventing pollution from pure streams and stencils. Victim selection uses 2-bit RRPVs with usual aging. This hybrid design targets irregular workloads (mcf, omnetpp) with aggressive insertion on hot PCs, regular stencils (lbm) with bypass logic, and dynamic phase shifts (milc, astar) via DIP set dueling, all in <32 KB metadata.",,ChampSim_CRC2/new_policies/010_02_shidip_t07.cc,0.30013505,0.30013505,0%
1109,omnetpp,SHiDIP,"SHiDIP (Signature-guided Hybrid DIP) combines SHiP-based PC signatures with a set-dueling DIP mechanism and a simple streaming detector to adapt insertion depth per stream, hot PC, and phase. Hot PCs (identified by saturating signature counters) always insert at MRU to capture reuse-driven phases (e.g., pointer chasing), while cold PCs follow a dynamic choice between LIP and BIP driven by a small PSEL counter. Sequential streams (detected by PC-indexed deltas) bypass the cache by inserting at LRU, preventing pollution from pure streams and stencils. Victim selection uses 2-bit RRPVs with usual aging. This hybrid design targets irregular workloads (mcf, omnetpp) with aggressive insertion on hot PCs, regular stencils (lbm) with bypass logic, and dynamic phase shifts (milc, astar) via DIP set dueling, all in <32 KB metadata.",,ChampSim_CRC2/new_policies/010_02_shidip_t07.cc,0.282149014,0.282149014,0%
1110,all,DIP-SHiP,"DIP-SHiP dynamically steers between an LRU insertion policy and a BIP (bimodal) policy via set-dueling, augmented with SHiP-lite PC signatures to immediately promote “hot” streams, and lightweight per-line dead-block counters to evict non-reused lines early. By removing the explicit stride detector and replacing DRRIP with DIP, we adapt naturally to streaming workloads (via BIP) and irregular, pointer-chasing workloads (via LRU), while the SHiP override quickly captures high-locality loops (milc, astar) and dead-block counters reduce pollution from one-time blocks. The entire design fits well under 64 KiB of metadata.",,ChampSim_CRC2/new_policies/010_01_dip_ship_t04.cc,0.405016883,0.405016883,41%
1111,astar,StreamSHiP-RRIP,"StreamSHiP-RRIP combines dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC signatures, a tiny streaming detector, and per-line dead-block counters to cover the spectrum of our workloads. DRRIP automatically steers between SRRIP (good for random/pointer-chasing) and BRRIP (good for streaming) via a 10-bit PSEL and 64 leader sets. A 2-bit SHiP-lite signature counter immediately promotes high-reuse PCs into MRU on insert and hit, accelerating capture of loop phases (astar, milc). A per-set stride tracker detects near-monotonic streams (e.g., LBM) and bypasses them by inserting at max RRPV with zero dead-block budget, avoiding pollution. Finally, 2-bit dead-block counters evict one-timers early. This synergy reduces pollution across all patterns within 36 KiB metadata, outperforming DIP-SHiP on both streaming and irregular access.",,ChampSim_CRC2/new_policies/011_01_streamship_rrip_t04.cc,0.456270642,0.456270642,0%
1112,lbm,StreamSHiP-RRIP,"StreamSHiP-RRIP combines dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC signatures, a tiny streaming detector, and per-line dead-block counters to cover the spectrum of our workloads. DRRIP automatically steers between SRRIP (good for random/pointer-chasing) and BRRIP (good for streaming) via a 10-bit PSEL and 64 leader sets. A 2-bit SHiP-lite signature counter immediately promotes high-reuse PCs into MRU on insert and hit, accelerating capture of loop phases (astar, milc). A per-set stride tracker detects near-monotonic streams (e.g., LBM) and bypasses them by inserting at max RRPV with zero dead-block budget, avoiding pollution. Finally, 2-bit dead-block counters evict one-timers early. This synergy reduces pollution across all patterns within 36 KiB metadata, outperforming DIP-SHiP on both streaming and irregular access.",,ChampSim_CRC2/new_policies/011_01_streamship_rrip_t04.cc,0.265027498,0.265027498,0%
1113,mcf,StreamSHiP-RRIP,"StreamSHiP-RRIP combines dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC signatures, a tiny streaming detector, and per-line dead-block counters to cover the spectrum of our workloads. DRRIP automatically steers between SRRIP (good for random/pointer-chasing) and BRRIP (good for streaming) via a 10-bit PSEL and 64 leader sets. A 2-bit SHiP-lite signature counter immediately promotes high-reuse PCs into MRU on insert and hit, accelerating capture of loop phases (astar, milc). A per-set stride tracker detects near-monotonic streams (e.g., LBM) and bypasses them by inserting at max RRPV with zero dead-block budget, avoiding pollution. Finally, 2-bit dead-block counters evict one-timers early. This synergy reduces pollution across all patterns within 36 KiB metadata, outperforming DIP-SHiP on both streaming and irregular access.",,ChampSim_CRC2/new_policies/011_01_streamship_rrip_t04.cc,0.404149019,0.404149019,0%
1114,milc,StreamSHiP-RRIP,"StreamSHiP-RRIP combines dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC signatures, a tiny streaming detector, and per-line dead-block counters to cover the spectrum of our workloads. DRRIP automatically steers between SRRIP (good for random/pointer-chasing) and BRRIP (good for streaming) via a 10-bit PSEL and 64 leader sets. A 2-bit SHiP-lite signature counter immediately promotes high-reuse PCs into MRU on insert and hit, accelerating capture of loop phases (astar, milc). A per-set stride tracker detects near-monotonic streams (e.g., LBM) and bypasses them by inserting at max RRPV with zero dead-block budget, avoiding pollution. Finally, 2-bit dead-block counters evict one-timers early. This synergy reduces pollution across all patterns within 36 KiB metadata, outperforming DIP-SHiP on both streaming and irregular access.",,ChampSim_CRC2/new_policies/011_01_streamship_rrip_t04.cc,0.288241236,0.288241236,0%
1115,omnetpp,StreamSHiP-RRIP,"StreamSHiP-RRIP combines dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC signatures, a tiny streaming detector, and per-line dead-block counters to cover the spectrum of our workloads. DRRIP automatically steers between SRRIP (good for random/pointer-chasing) and BRRIP (good for streaming) via a 10-bit PSEL and 64 leader sets. A 2-bit SHiP-lite signature counter immediately promotes high-reuse PCs into MRU on insert and hit, accelerating capture of loop phases (astar, milc). A per-set stride tracker detects near-monotonic streams (e.g., LBM) and bypasses them by inserting at max RRPV with zero dead-block budget, avoiding pollution. Finally, 2-bit dead-block counters evict one-timers early. This synergy reduces pollution across all patterns within 36 KiB metadata, outperforming DIP-SHiP on both streaming and irregular access.",,ChampSim_CRC2/new_policies/011_01_streamship_rrip_t04.cc,0.475994775,0.475994775,0%
1116,astar,SASRIP (Streaming-Aware Signature-based RRIP),"SASRIP augments standard Static RRIP with two compact predictors: a PC‐indexed signature table (SHiP‐style) to detect high‐reuse “hot” streams, and a small PC‐indexed streaming detector to identify and bypass true streaming accesses. On a miss, if the streaming detector for this PC has converged, the new block is inserted with maximal RRPV (bypassed) to avoid pollution (improving LBM). Otherwise, we consult the signature counter: strong‐reuse PCs get MRU insertion, while others use SRRIP default insertion (RRPV=2). Hits always refresh to MRU and train both predictors. This design fits under 40 KiB of metadata and boosts performance on regular (LBM), irregular (mcf, omnetpp), and loop‐heavy (milc, astar) workloads by specializing for streaming vs. reusable data.",,ChampSim_CRC2/new_policies/011_02_sasrip__streaming_aware_signature_based_rrip_t07.cc,0.458077896,0.458077896,0%
1117,lbm,SASRIP (Streaming-Aware Signature-based RRIP),"SASRIP augments standard Static RRIP with two compact predictors: a PC‐indexed signature table (SHiP‐style) to detect high‐reuse “hot” streams, and a small PC‐indexed streaming detector to identify and bypass true streaming accesses. On a miss, if the streaming detector for this PC has converged, the new block is inserted with maximal RRPV (bypassed) to avoid pollution (improving LBM). Otherwise, we consult the signature counter: strong‐reuse PCs get MRU insertion, while others use SRRIP default insertion (RRPV=2). Hits always refresh to MRU and train both predictors. This design fits under 40 KiB of metadata and boosts performance on regular (LBM), irregular (mcf, omnetpp), and loop‐heavy (milc, astar) workloads by specializing for streaming vs. reusable data.",,ChampSim_CRC2/new_policies/011_02_sasrip__streaming_aware_signature_based_rrip_t07.cc,0.296595735,0.296595735,0%
1118,mcf,SASRIP (Streaming-Aware Signature-based RRIP),"SASRIP augments standard Static RRIP with two compact predictors: a PC‐indexed signature table (SHiP‐style) to detect high‐reuse “hot” streams, and a small PC‐indexed streaming detector to identify and bypass true streaming accesses. On a miss, if the streaming detector for this PC has converged, the new block is inserted with maximal RRPV (bypassed) to avoid pollution (improving LBM). Otherwise, we consult the signature counter: strong‐reuse PCs get MRU insertion, while others use SRRIP default insertion (RRPV=2). Hits always refresh to MRU and train both predictors. This design fits under 40 KiB of metadata and boosts performance on regular (LBM), irregular (mcf, omnetpp), and loop‐heavy (milc, astar) workloads by specializing for streaming vs. reusable data.",,ChampSim_CRC2/new_policies/011_02_sasrip__streaming_aware_signature_based_rrip_t07.cc,0.410089974,0.410089974,0%
1119,milc,SASRIP (Streaming-Aware Signature-based RRIP),"SASRIP augments standard Static RRIP with two compact predictors: a PC‐indexed signature table (SHiP‐style) to detect high‐reuse “hot” streams, and a small PC‐indexed streaming detector to identify and bypass true streaming accesses. On a miss, if the streaming detector for this PC has converged, the new block is inserted with maximal RRPV (bypassed) to avoid pollution (improving LBM). Otherwise, we consult the signature counter: strong‐reuse PCs get MRU insertion, while others use SRRIP default insertion (RRPV=2). Hits always refresh to MRU and train both predictors. This design fits under 40 KiB of metadata and boosts performance on regular (LBM), irregular (mcf, omnetpp), and loop‐heavy (milc, astar) workloads by specializing for streaming vs. reusable data.",,ChampSim_CRC2/new_policies/011_02_sasrip__streaming_aware_signature_based_rrip_t07.cc,0.103441784,0.103441784,0%
1120,omnetpp,SASRIP (Streaming-Aware Signature-based RRIP),"SASRIP augments standard Static RRIP with two compact predictors: a PC‐indexed signature table (SHiP‐style) to detect high‐reuse “hot” streams, and a small PC‐indexed streaming detector to identify and bypass true streaming accesses. On a miss, if the streaming detector for this PC has converged, the new block is inserted with maximal RRPV (bypassed) to avoid pollution (improving LBM). Otherwise, we consult the signature counter: strong‐reuse PCs get MRU insertion, while others use SRRIP default insertion (RRPV=2). Hits always refresh to MRU and train both predictors. This design fits under 40 KiB of metadata and boosts performance on regular (LBM), irregular (mcf, omnetpp), and loop‐heavy (milc, astar) workloads by specializing for streaming vs. reusable data.",,ChampSim_CRC2/new_policies/011_02_sasrip__streaming_aware_signature_based_rrip_t07.cc,0.543402664,0.543402664,0%
1121,all,StreamSHiP-RRIP,"StreamSHiP-RRIP combines dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC signatures, a tiny streaming detector, and per-line dead-block counters to cover the spectrum of our workloads. DRRIP automatically steers between SRRIP (good for random/pointer-chasing) and BRRIP (good for streaming) via a 10-bit PSEL and 64 leader sets. A 2-bit SHiP-lite signature counter immediately promotes high-reuse PCs into MRU on insert and hit, accelerating capture of loop phases (astar, milc). A per-set stride tracker detects near-monotonic streams (e.g., LBM) and bypasses them by inserting at max RRPV with zero dead-block budget, avoiding pollution. Finally, 2-bit dead-block counters evict one-timers early. This synergy reduces pollution across all patterns within 36 KiB metadata, outperforming DIP-SHiP on both streaming and irregular access.",,ChampSim_CRC2/new_policies/011_01_streamship_rrip_t04.cc,0.377936634,0.377936634,38%
1122,astar,Phase‐Adaptive SHiP (PA-SHiP),"PA-SHiP uses a 4-bit per‐PC signature table (4 K entries) to classify each load PC into cold, warm, or hot, and maps these classes to three distinct RRIP insertion depths (bypass, near-MRU, MRU). A per-set streaming detector now requires four consecutive identical address deltas before bypassing a line, avoiding the over-eager bypass that hurts stencil kernels. By removing set-dueling and dead‐block counters and reallocating that budget to a larger signature table, PA-SHiP gains finer PC profiling and phase‐adaptivity, improving reuse capture on ASTAR/MILC while still suppressing true streaming pollution in LBM/MCF/OMNETPP.",,ChampSim_CRC2/new_policies/012_00_phase_adaptive_ship__pa_ship_t02.cc,0.455442317,0.455442317,0%
1123,lbm,Phase‐Adaptive SHiP (PA-SHiP),"PA-SHiP uses a 4-bit per‐PC signature table (4 K entries) to classify each load PC into cold, warm, or hot, and maps these classes to three distinct RRIP insertion depths (bypass, near-MRU, MRU). A per-set streaming detector now requires four consecutive identical address deltas before bypassing a line, avoiding the over-eager bypass that hurts stencil kernels. By removing set-dueling and dead‐block counters and reallocating that budget to a larger signature table, PA-SHiP gains finer PC profiling and phase‐adaptivity, improving reuse capture on ASTAR/MILC while still suppressing true streaming pollution in LBM/MCF/OMNETPP.",,ChampSim_CRC2/new_policies/012_00_phase_adaptive_ship__pa_ship_t02.cc,0.438423906,0.438423906,0%
1124,mcf,Phase‐Adaptive SHiP (PA-SHiP),"PA-SHiP uses a 4-bit per‐PC signature table (4 K entries) to classify each load PC into cold, warm, or hot, and maps these classes to three distinct RRIP insertion depths (bypass, near-MRU, MRU). A per-set streaming detector now requires four consecutive identical address deltas before bypassing a line, avoiding the over-eager bypass that hurts stencil kernels. By removing set-dueling and dead‐block counters and reallocating that budget to a larger signature table, PA-SHiP gains finer PC profiling and phase‐adaptivity, improving reuse capture on ASTAR/MILC while still suppressing true streaming pollution in LBM/MCF/OMNETPP.",,ChampSim_CRC2/new_policies/012_00_phase_adaptive_ship__pa_ship_t02.cc,0.435444597,0.435444597,0%
1125,milc,Phase‐Adaptive SHiP (PA-SHiP),"PA-SHiP uses a 4-bit per‐PC signature table (4 K entries) to classify each load PC into cold, warm, or hot, and maps these classes to three distinct RRIP insertion depths (bypass, near-MRU, MRU). A per-set streaming detector now requires four consecutive identical address deltas before bypassing a line, avoiding the over-eager bypass that hurts stencil kernels. By removing set-dueling and dead‐block counters and reallocating that budget to a larger signature table, PA-SHiP gains finer PC profiling and phase‐adaptivity, improving reuse capture on ASTAR/MILC while still suppressing true streaming pollution in LBM/MCF/OMNETPP.",,ChampSim_CRC2/new_policies/012_00_phase_adaptive_ship__pa_ship_t02.cc,0.322201062,0.322201062,0%
1126,omnetpp,Phase‐Adaptive SHiP (PA-SHiP),"PA-SHiP uses a 4-bit per‐PC signature table (4 K entries) to classify each load PC into cold, warm, or hot, and maps these classes to three distinct RRIP insertion depths (bypass, near-MRU, MRU). A per-set streaming detector now requires four consecutive identical address deltas before bypassing a line, avoiding the over-eager bypass that hurts stencil kernels. By removing set-dueling and dead‐block counters and reallocating that budget to a larger signature table, PA-SHiP gains finer PC profiling and phase‐adaptivity, improving reuse capture on ASTAR/MILC while still suppressing true streaming pollution in LBM/MCF/OMNETPP.",,ChampSim_CRC2/new_policies/012_00_phase_adaptive_ship__pa_ship_t02.cc,0.461816512,0.461816512,0%
1127,astar,PC-BiSRRIP,"PC-BiSRRIP employs per‐PC signatures to drive multi‐depth RRIP insertions and a lightweight per‐PC streaming detector to evict pure streams. On each miss we index a small PC‐signature table (4K×2-bit) that tracks past reuse: high‐entropy PCs (sig≥6) insert at MRU, medium (3≤sig<6) at SRRIP depth, and cold PCs (sig<3) use a 1/32 “bimodal” promotion (BIP) to SRRIP while otherwise bypassing. Hits always promote to MRU and increment the signature; misses decrement it, biasing future insertions. Parallel to this is a 1K‐entry per‐PC stride detector, which counts repeated, identical block‐stride deltas and then treats such sequences as streaming, inserting them at max-RRPV (bypassed). By moving streaming logic and signature granularity to the PC axis, we avoid polluting cache sets with regular streams (LBM) and better distinguish pointer-chasing or phase-changing PCs (MCF, MILC, ASTAR, OMNETPP), all within ≈46 KiB of metadata.",,ChampSim_CRC2/new_policies/012_01_pc_bisrrip_t04.cc,0.185049575,0.185049575,0%
1128,lbm,PC-BiSRRIP,"PC-BiSRRIP employs per‐PC signatures to drive multi‐depth RRIP insertions and a lightweight per‐PC streaming detector to evict pure streams. On each miss we index a small PC‐signature table (4K×2-bit) that tracks past reuse: high‐entropy PCs (sig≥6) insert at MRU, medium (3≤sig<6) at SRRIP depth, and cold PCs (sig<3) use a 1/32 “bimodal” promotion (BIP) to SRRIP while otherwise bypassing. Hits always promote to MRU and increment the signature; misses decrement it, biasing future insertions. Parallel to this is a 1K‐entry per‐PC stride detector, which counts repeated, identical block‐stride deltas and then treats such sequences as streaming, inserting them at max-RRPV (bypassed). By moving streaming logic and signature granularity to the PC axis, we avoid polluting cache sets with regular streams (LBM) and better distinguish pointer-chasing or phase-changing PCs (MCF, MILC, ASTAR, OMNETPP), all within ≈46 KiB of metadata.",,ChampSim_CRC2/new_policies/012_01_pc_bisrrip_t04.cc,0.058808278,0.058808278,0%
1129,mcf,PC-BiSRRIP,"PC-BiSRRIP employs per‐PC signatures to drive multi‐depth RRIP insertions and a lightweight per‐PC streaming detector to evict pure streams. On each miss we index a small PC‐signature table (4K×2-bit) that tracks past reuse: high‐entropy PCs (sig≥6) insert at MRU, medium (3≤sig<6) at SRRIP depth, and cold PCs (sig<3) use a 1/32 “bimodal” promotion (BIP) to SRRIP while otherwise bypassing. Hits always promote to MRU and increment the signature; misses decrement it, biasing future insertions. Parallel to this is a 1K‐entry per‐PC stride detector, which counts repeated, identical block‐stride deltas and then treats such sequences as streaming, inserting them at max-RRPV (bypassed). By moving streaming logic and signature granularity to the PC axis, we avoid polluting cache sets with regular streams (LBM) and better distinguish pointer-chasing or phase-changing PCs (MCF, MILC, ASTAR, OMNETPP), all within ≈46 KiB of metadata.",,ChampSim_CRC2/new_policies/012_01_pc_bisrrip_t04.cc,0.515719953,0.515719953,0%
1130,milc,PC-BiSRRIP,"PC-BiSRRIP employs per‐PC signatures to drive multi‐depth RRIP insertions and a lightweight per‐PC streaming detector to evict pure streams. On each miss we index a small PC‐signature table (4K×2-bit) that tracks past reuse: high‐entropy PCs (sig≥6) insert at MRU, medium (3≤sig<6) at SRRIP depth, and cold PCs (sig<3) use a 1/32 “bimodal” promotion (BIP) to SRRIP while otherwise bypassing. Hits always promote to MRU and increment the signature; misses decrement it, biasing future insertions. Parallel to this is a 1K‐entry per‐PC stride detector, which counts repeated, identical block‐stride deltas and then treats such sequences as streaming, inserting them at max-RRPV (bypassed). By moving streaming logic and signature granularity to the PC axis, we avoid polluting cache sets with regular streams (LBM) and better distinguish pointer-chasing or phase-changing PCs (MCF, MILC, ASTAR, OMNETPP), all within ≈46 KiB of metadata.",,ChampSim_CRC2/new_policies/012_01_pc_bisrrip_t04.cc,0.04760422,0.04760422,0%
1131,omnetpp,PC-BiSRRIP,"PC-BiSRRIP employs per‐PC signatures to drive multi‐depth RRIP insertions and a lightweight per‐PC streaming detector to evict pure streams. On each miss we index a small PC‐signature table (4K×2-bit) that tracks past reuse: high‐entropy PCs (sig≥6) insert at MRU, medium (3≤sig<6) at SRRIP depth, and cold PCs (sig<3) use a 1/32 “bimodal” promotion (BIP) to SRRIP while otherwise bypassing. Hits always promote to MRU and increment the signature; misses decrement it, biasing future insertions. Parallel to this is a 1K‐entry per‐PC stride detector, which counts repeated, identical block‐stride deltas and then treats such sequences as streaming, inserting them at max-RRPV (bypassed). By moving streaming logic and signature granularity to the PC axis, we avoid polluting cache sets with regular streams (LBM) and better distinguish pointer-chasing or phase-changing PCs (MCF, MILC, ASTAR, OMNETPP), all within ≈46 KiB of metadata.",,ChampSim_CRC2/new_policies/012_01_pc_bisrrip_t04.cc,0.004694332,0.004694332,0%
1132,astar,SHiP-DIP,"SHiP-DIP classifies each new block by a compact PC-indexed signature into three reuse tiers—cold (bypass), warm (dual-policy insertion), and hot (MRU)—and dynamically steers between BIP (distant insert) and LRU (MRU insert) for the warm tier via a small DIP set-dueling PSEL. On a hit, SHiP-style counters boost the signature and pin the block at MRU. On a miss, signatures underflow imply streaming/one-timers and are bypassed, overflow imply high reuse and are MRU-inserted, while medium signatures follow PSEL’s BIP vs. LRU guidance. Tiny per-line dead-block counters accelerate eviction of single‐use lines. By replacing per‐set streaming detection with per‐PC reuse prediction and swapping DRRIP for lightweight DIP, SHiP-DIP better adapts to streaming (LBM), pointer‐chasing (MCF/Omnetpp), and loop‐intensive phases (ASTAR/MILC) within 20 KiB of metadata.",,ChampSim_CRC2/new_policies/012_02_ship_dip_t07.cc,0.150856143,0.150856143,0%
1133,lbm,SHiP-DIP,"SHiP-DIP classifies each new block by a compact PC-indexed signature into three reuse tiers—cold (bypass), warm (dual-policy insertion), and hot (MRU)—and dynamically steers between BIP (distant insert) and LRU (MRU insert) for the warm tier via a small DIP set-dueling PSEL. On a hit, SHiP-style counters boost the signature and pin the block at MRU. On a miss, signatures underflow imply streaming/one-timers and are bypassed, overflow imply high reuse and are MRU-inserted, while medium signatures follow PSEL’s BIP vs. LRU guidance. Tiny per-line dead-block counters accelerate eviction of single‐use lines. By replacing per‐set streaming detection with per‐PC reuse prediction and swapping DRRIP for lightweight DIP, SHiP-DIP better adapts to streaming (LBM), pointer‐chasing (MCF/Omnetpp), and loop‐intensive phases (ASTAR/MILC) within 20 KiB of metadata.",,ChampSim_CRC2/new_policies/012_02_ship_dip_t07.cc,0.069220681,0.069220681,0%
1134,mcf,SHiP-DIP,"SHiP-DIP classifies each new block by a compact PC-indexed signature into three reuse tiers—cold (bypass), warm (dual-policy insertion), and hot (MRU)—and dynamically steers between BIP (distant insert) and LRU (MRU insert) for the warm tier via a small DIP set-dueling PSEL. On a hit, SHiP-style counters boost the signature and pin the block at MRU. On a miss, signatures underflow imply streaming/one-timers and are bypassed, overflow imply high reuse and are MRU-inserted, while medium signatures follow PSEL’s BIP vs. LRU guidance. Tiny per-line dead-block counters accelerate eviction of single‐use lines. By replacing per‐set streaming detection with per‐PC reuse prediction and swapping DRRIP for lightweight DIP, SHiP-DIP better adapts to streaming (LBM), pointer‐chasing (MCF/Omnetpp), and loop‐intensive phases (ASTAR/MILC) within 20 KiB of metadata.",,ChampSim_CRC2/new_policies/012_02_ship_dip_t07.cc,0.469875188,0.469875188,0%
1135,milc,SHiP-DIP,"SHiP-DIP classifies each new block by a compact PC-indexed signature into three reuse tiers—cold (bypass), warm (dual-policy insertion), and hot (MRU)—and dynamically steers between BIP (distant insert) and LRU (MRU insert) for the warm tier via a small DIP set-dueling PSEL. On a hit, SHiP-style counters boost the signature and pin the block at MRU. On a miss, signatures underflow imply streaming/one-timers and are bypassed, overflow imply high reuse and are MRU-inserted, while medium signatures follow PSEL’s BIP vs. LRU guidance. Tiny per-line dead-block counters accelerate eviction of single‐use lines. By replacing per‐set streaming detection with per‐PC reuse prediction and swapping DRRIP for lightweight DIP, SHiP-DIP better adapts to streaming (LBM), pointer‐chasing (MCF/Omnetpp), and loop‐intensive phases (ASTAR/MILC) within 20 KiB of metadata.",,ChampSim_CRC2/new_policies/012_02_ship_dip_t07.cc,0.009726859,0.009726859,0%
1136,omnetpp,SHiP-DIP,"SHiP-DIP classifies each new block by a compact PC-indexed signature into three reuse tiers—cold (bypass), warm (dual-policy insertion), and hot (MRU)—and dynamically steers between BIP (distant insert) and LRU (MRU insert) for the warm tier via a small DIP set-dueling PSEL. On a hit, SHiP-style counters boost the signature and pin the block at MRU. On a miss, signatures underflow imply streaming/one-timers and are bypassed, overflow imply high reuse and are MRU-inserted, while medium signatures follow PSEL’s BIP vs. LRU guidance. Tiny per-line dead-block counters accelerate eviction of single‐use lines. By replacing per‐set streaming detection with per‐PC reuse prediction and swapping DRRIP for lightweight DIP, SHiP-DIP better adapts to streaming (LBM), pointer‐chasing (MCF/Omnetpp), and loop‐intensive phases (ASTAR/MILC) within 20 KiB of metadata.",,ChampSim_CRC2/new_policies/012_02_ship_dip_t07.cc,0.001300336,0.001300336,0%
1137,all,Phase‐Adaptive SHiP (PA-SHiP),"PA-SHiP uses a 4-bit per‐PC signature table (4 K entries) to classify each load PC into cold, warm, or hot, and maps these classes to three distinct RRIP insertion depths (bypass, near-MRU, MRU). A per-set streaming detector now requires four consecutive identical address deltas before bypassing a line, avoiding the over-eager bypass that hurts stencil kernels. By removing set-dueling and dead‐block counters and reallocating that budget to a larger signature table, PA-SHiP gains finer PC profiling and phase‐adaptivity, improving reuse capture on ASTAR/MILC while still suppressing true streaming pollution in LBM/MCF/OMNETPP.",,ChampSim_CRC2/new_policies/012_00_phase_adaptive_ship__pa_ship_t02.cc,0.422665679,0.422665679,42%
1138,astar,DB-SRRIP (Dead‐block Aware SRRIP),"DB‐SRRIP augments the well‐known Static RRIP (SRRIP) policy with a small dead‐block predictor to suppress one‐shot, non‐reused lines (e.g., streaming or pointer‐chasing pollution) while still capturing temporal reuse on hot lines. On a miss, the dead‐block predictor (indexed by coarse address hash) is first updated to mark the just‐evicted line’s region as “dead.” When the new block is inserted, if its region is marked dead, we bypass by inserting at the maximum RRPV; otherwise we insert near‐MRU as in SRRIP. On a hit, we promote the line to MRU and clear its region’s dead bit. This simple change (36 KB of metadata) dynamically prunes useless lines for LBM/MCF/OMNETPP while retaining high reuse capture on ASTAR/MILC.",,ChampSim_CRC2/new_policies/013_00_db_srrip__dead_block_aware_srrip_t02.cc,0.340867695,0.340867695,0%
1139,lbm,DB-SRRIP (Dead‐block Aware SRRIP),"DB‐SRRIP augments the well‐known Static RRIP (SRRIP) policy with a small dead‐block predictor to suppress one‐shot, non‐reused lines (e.g., streaming or pointer‐chasing pollution) while still capturing temporal reuse on hot lines. On a miss, the dead‐block predictor (indexed by coarse address hash) is first updated to mark the just‐evicted line’s region as “dead.” When the new block is inserted, if its region is marked dead, we bypass by inserting at the maximum RRPV; otherwise we insert near‐MRU as in SRRIP. On a hit, we promote the line to MRU and clear its region’s dead bit. This simple change (36 KB of metadata) dynamically prunes useless lines for LBM/MCF/OMNETPP while retaining high reuse capture on ASTAR/MILC.",,ChampSim_CRC2/new_policies/013_00_db_srrip__dead_block_aware_srrip_t02.cc,0.214032252,0.214032252,0%
1140,mcf,DB-SRRIP (Dead‐block Aware SRRIP),"DB‐SRRIP augments the well‐known Static RRIP (SRRIP) policy with a small dead‐block predictor to suppress one‐shot, non‐reused lines (e.g., streaming or pointer‐chasing pollution) while still capturing temporal reuse on hot lines. On a miss, the dead‐block predictor (indexed by coarse address hash) is first updated to mark the just‐evicted line’s region as “dead.” When the new block is inserted, if its region is marked dead, we bypass by inserting at the maximum RRPV; otherwise we insert near‐MRU as in SRRIP. On a hit, we promote the line to MRU and clear its region’s dead bit. This simple change (36 KB of metadata) dynamically prunes useless lines for LBM/MCF/OMNETPP while retaining high reuse capture on ASTAR/MILC.",,ChampSim_CRC2/new_policies/013_00_db_srrip__dead_block_aware_srrip_t02.cc,0.465860747,0.465860747,0%
1141,milc,DB-SRRIP (Dead‐block Aware SRRIP),"DB‐SRRIP augments the well‐known Static RRIP (SRRIP) policy with a small dead‐block predictor to suppress one‐shot, non‐reused lines (e.g., streaming or pointer‐chasing pollution) while still capturing temporal reuse on hot lines. On a miss, the dead‐block predictor (indexed by coarse address hash) is first updated to mark the just‐evicted line’s region as “dead.” When the new block is inserted, if its region is marked dead, we bypass by inserting at the maximum RRPV; otherwise we insert near‐MRU as in SRRIP. On a hit, we promote the line to MRU and clear its region’s dead bit. This simple change (36 KB of metadata) dynamically prunes useless lines for LBM/MCF/OMNETPP while retaining high reuse capture on ASTAR/MILC.",,ChampSim_CRC2/new_policies/013_00_db_srrip__dead_block_aware_srrip_t02.cc,0.072693469,0.072693469,0%
1142,omnetpp,DB-SRRIP (Dead‐block Aware SRRIP),"DB‐SRRIP augments the well‐known Static RRIP (SRRIP) policy with a small dead‐block predictor to suppress one‐shot, non‐reused lines (e.g., streaming or pointer‐chasing pollution) while still capturing temporal reuse on hot lines. On a miss, the dead‐block predictor (indexed by coarse address hash) is first updated to mark the just‐evicted line’s region as “dead.” When the new block is inserted, if its region is marked dead, we bypass by inserting at the maximum RRPV; otherwise we insert near‐MRU as in SRRIP. On a hit, we promote the line to MRU and clear its region’s dead bit. This simple change (36 KB of metadata) dynamically prunes useless lines for LBM/MCF/OMNETPP while retaining high reuse capture on ASTAR/MILC.",,ChampSim_CRC2/new_policies/013_00_db_srrip__dead_block_aware_srrip_t02.cc,0.853672212,0.853672212,0%
1143,astar,SPDIP (Streaming-aware PC-Driven Insertion Policy),"SPDIP combines Dynamic RRIP (DRRIP) via set-dueling with a lightweight PC-based signature table that drives fine-grained insertion decisions and a per-PC stride stream detector to bypass long monotonic streams. We dedicate 64 leader sets to SRRIP and 64 to BRRIP, updating a 10-bit PSEL on misses to choose between SRRIP/BRRIP in follower sets. In all sets, on each miss we index a 4-bit saturating counter plus a small stride history per PC: if the counter is high (hot PC) we override to MRU, if low (cold PC) we insert at RRPV=MAX, and if a repeated stride stream is detected we force bypass. On hits we strengthen the PC counter and promote the block to MRU. This hybrid approach adapts globally via DRRIP while capturing PC-level reuse and suppressing streams, improving both ASTAR/MILC reuse and LBM/MCF/OMNETPP pollution, with total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/013_01_spdip__streaming_aware_pc_driven_insertion_policy_t04.cc,0.422863896,0.422863896,0%
1144,lbm,SPDIP (Streaming-aware PC-Driven Insertion Policy),"SPDIP combines Dynamic RRIP (DRRIP) via set-dueling with a lightweight PC-based signature table that drives fine-grained insertion decisions and a per-PC stride stream detector to bypass long monotonic streams. We dedicate 64 leader sets to SRRIP and 64 to BRRIP, updating a 10-bit PSEL on misses to choose between SRRIP/BRRIP in follower sets. In all sets, on each miss we index a 4-bit saturating counter plus a small stride history per PC: if the counter is high (hot PC) we override to MRU, if low (cold PC) we insert at RRPV=MAX, and if a repeated stride stream is detected we force bypass. On hits we strengthen the PC counter and promote the block to MRU. This hybrid approach adapts globally via DRRIP while capturing PC-level reuse and suppressing streams, improving both ASTAR/MILC reuse and LBM/MCF/OMNETPP pollution, with total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/013_01_spdip__streaming_aware_pc_driven_insertion_policy_t04.cc,0.179389739,0.179389739,0%
1145,mcf,SPDIP (Streaming-aware PC-Driven Insertion Policy),"SPDIP combines Dynamic RRIP (DRRIP) via set-dueling with a lightweight PC-based signature table that drives fine-grained insertion decisions and a per-PC stride stream detector to bypass long monotonic streams. We dedicate 64 leader sets to SRRIP and 64 to BRRIP, updating a 10-bit PSEL on misses to choose between SRRIP/BRRIP in follower sets. In all sets, on each miss we index a 4-bit saturating counter plus a small stride history per PC: if the counter is high (hot PC) we override to MRU, if low (cold PC) we insert at RRPV=MAX, and if a repeated stride stream is detected we force bypass. On hits we strengthen the PC counter and promote the block to MRU. This hybrid approach adapts globally via DRRIP while capturing PC-level reuse and suppressing streams, improving both ASTAR/MILC reuse and LBM/MCF/OMNETPP pollution, with total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/013_01_spdip__streaming_aware_pc_driven_insertion_policy_t04.cc,0.504421623,0.504421623,0%
1146,milc,SPDIP (Streaming-aware PC-Driven Insertion Policy),"SPDIP combines Dynamic RRIP (DRRIP) via set-dueling with a lightweight PC-based signature table that drives fine-grained insertion decisions and a per-PC stride stream detector to bypass long monotonic streams. We dedicate 64 leader sets to SRRIP and 64 to BRRIP, updating a 10-bit PSEL on misses to choose between SRRIP/BRRIP in follower sets. In all sets, on each miss we index a 4-bit saturating counter plus a small stride history per PC: if the counter is high (hot PC) we override to MRU, if low (cold PC) we insert at RRPV=MAX, and if a repeated stride stream is detected we force bypass. On hits we strengthen the PC counter and promote the block to MRU. This hybrid approach adapts globally via DRRIP while capturing PC-level reuse and suppressing streams, improving both ASTAR/MILC reuse and LBM/MCF/OMNETPP pollution, with total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/013_01_spdip__streaming_aware_pc_driven_insertion_policy_t04.cc,0.219961332,0.219961332,0%
1147,omnetpp,SPDIP (Streaming-aware PC-Driven Insertion Policy),"SPDIP combines Dynamic RRIP (DRRIP) via set-dueling with a lightweight PC-based signature table that drives fine-grained insertion decisions and a per-PC stride stream detector to bypass long monotonic streams. We dedicate 64 leader sets to SRRIP and 64 to BRRIP, updating a 10-bit PSEL on misses to choose between SRRIP/BRRIP in follower sets. In all sets, on each miss we index a 4-bit saturating counter plus a small stride history per PC: if the counter is high (hot PC) we override to MRU, if low (cold PC) we insert at RRPV=MAX, and if a repeated stride stream is detected we force bypass. On hits we strengthen the PC counter and promote the block to MRU. This hybrid approach adapts globally via DRRIP while capturing PC-level reuse and suppressing streams, improving both ASTAR/MILC reuse and LBM/MCF/OMNETPP pollution, with total metadata under 64 KiB.",,ChampSim_CRC2/new_policies/013_01_spdip__streaming_aware_pc_driven_insertion_policy_t04.cc,0.467620235,0.467620235,0%
1148,astar,Stream-DIP,"Stream-DIP combines dynamic insertion decision (DIP) between Bimodal Insertion Policy (BIP) and Static RRIP (SRRIP) via set dueling, with a lightweight per-set streaming detector to bypass long streams. We assign 32 leader sets to BIP and 32 to SRRIP to update a 10-bit PSEL counter based on misses, steering all follower sets toward the better policy. The streaming logic tracks four identical deltas before bypassing new blocks. This approach captures high reuse in irregular workloads (ASTAR, MILC) via SRRIP, limits pollution in streaming/stencil workloads (LBM, MCF, OMNETPP) via BIP or bypass, and adapts dynamically with minimal metadata.",,ChampSim_CRC2/new_policies/013_02_stream_dip_t07.cc,0.427203079,0.427203079,0%
1149,lbm,Stream-DIP,"Stream-DIP combines dynamic insertion decision (DIP) between Bimodal Insertion Policy (BIP) and Static RRIP (SRRIP) via set dueling, with a lightweight per-set streaming detector to bypass long streams. We assign 32 leader sets to BIP and 32 to SRRIP to update a 10-bit PSEL counter based on misses, steering all follower sets toward the better policy. The streaming logic tracks four identical deltas before bypassing new blocks. This approach captures high reuse in irregular workloads (ASTAR, MILC) via SRRIP, limits pollution in streaming/stencil workloads (LBM, MCF, OMNETPP) via BIP or bypass, and adapts dynamically with minimal metadata.",,ChampSim_CRC2/new_policies/013_02_stream_dip_t07.cc,0.406918648,0.406918648,0%
1150,mcf,Stream-DIP,"Stream-DIP combines dynamic insertion decision (DIP) between Bimodal Insertion Policy (BIP) and Static RRIP (SRRIP) via set dueling, with a lightweight per-set streaming detector to bypass long streams. We assign 32 leader sets to BIP and 32 to SRRIP to update a 10-bit PSEL counter based on misses, steering all follower sets toward the better policy. The streaming logic tracks four identical deltas before bypassing new blocks. This approach captures high reuse in irregular workloads (ASTAR, MILC) via SRRIP, limits pollution in streaming/stencil workloads (LBM, MCF, OMNETPP) via BIP or bypass, and adapts dynamically with minimal metadata.",,ChampSim_CRC2/new_policies/013_02_stream_dip_t07.cc,0.457641165,0.457641165,0%
1151,milc,Stream-DIP,"Stream-DIP combines dynamic insertion decision (DIP) between Bimodal Insertion Policy (BIP) and Static RRIP (SRRIP) via set dueling, with a lightweight per-set streaming detector to bypass long streams. We assign 32 leader sets to BIP and 32 to SRRIP to update a 10-bit PSEL counter based on misses, steering all follower sets toward the better policy. The streaming logic tracks four identical deltas before bypassing new blocks. This approach captures high reuse in irregular workloads (ASTAR, MILC) via SRRIP, limits pollution in streaming/stencil workloads (LBM, MCF, OMNETPP) via BIP or bypass, and adapts dynamically with minimal metadata.",,ChampSim_CRC2/new_policies/013_02_stream_dip_t07.cc,0.306485659,0.306485659,0%
1152,omnetpp,Stream-DIP,"Stream-DIP combines dynamic insertion decision (DIP) between Bimodal Insertion Policy (BIP) and Static RRIP (SRRIP) via set dueling, with a lightweight per-set streaming detector to bypass long streams. We assign 32 leader sets to BIP and 32 to SRRIP to update a 10-bit PSEL counter based on misses, steering all follower sets toward the better policy. The streaming logic tracks four identical deltas before bypassing new blocks. This approach captures high reuse in irregular workloads (ASTAR, MILC) via SRRIP, limits pollution in streaming/stencil workloads (LBM, MCF, OMNETPP) via BIP or bypass, and adapts dynamically with minimal metadata.",,ChampSim_CRC2/new_policies/013_02_stream_dip_t07.cc,0.517694496,0.517694496,0%
1153,all,Stream-DIP,"Stream-DIP combines dynamic insertion decision (DIP) between Bimodal Insertion Policy (BIP) and Static RRIP (SRRIP) via set dueling, with a lightweight per-set streaming detector to bypass long streams. We assign 32 leader sets to BIP and 32 to SRRIP to update a 10-bit PSEL counter based on misses, steering all follower sets toward the better policy. The streaming logic tracks four identical deltas before bypassing new blocks. This approach captures high reuse in irregular workloads (ASTAR, MILC) via SRRIP, limits pollution in streaming/stencil workloads (LBM, MCF, OMNETPP) via BIP or bypass, and adapts dynamically with minimal metadata.",,ChampSim_CRC2/new_policies/013_02_stream_dip_t07.cc,0.423188609,0.423188609,42%
1154,astar,SHIP-RRIP-DBP,"We combine a SHiP-lite style PC‐signature table with RRIP and an on‐demand dead‐block bypass to focus cache residency on genuinely reusable lines. Each load’s PC indexes a tiny 2-bit saturating counter that tracks reuse tendency: cold PCs (counter=0) bypass (insert at RRPV=MAX), mildly reused PCs (counter=1) receive shallow insertion, hot PCs (counter=2) use SRRIP insertion, and hottest PCs (counter=3) insert at MRU. We update the signature counters up on hits and down on misses, so the predictor adapts per‐PC reuse patterns. This shifts blocks from low‐reuse (ASTAR/MCF/OMNETPP) out quickly, while retaining high‐reuse blocks (LBM/MILC) at the front, improving overall hit rate with minimal metadata overhead (<24 KiB).",,ChampSim_CRC2/new_policies/014_00_ship_rrip_dbp_t02.cc,0.144876256,0.144876256,0%
1155,lbm,SHIP-RRIP-DBP,"We combine a SHiP-lite style PC‐signature table with RRIP and an on‐demand dead‐block bypass to focus cache residency on genuinely reusable lines. Each load’s PC indexes a tiny 2-bit saturating counter that tracks reuse tendency: cold PCs (counter=0) bypass (insert at RRPV=MAX), mildly reused PCs (counter=1) receive shallow insertion, hot PCs (counter=2) use SRRIP insertion, and hottest PCs (counter=3) insert at MRU. We update the signature counters up on hits and down on misses, so the predictor adapts per‐PC reuse patterns. This shifts blocks from low‐reuse (ASTAR/MCF/OMNETPP) out quickly, while retaining high‐reuse blocks (LBM/MILC) at the front, improving overall hit rate with minimal metadata overhead (<24 KiB).",,ChampSim_CRC2/new_policies/014_00_ship_rrip_dbp_t02.cc,0.069209326,0.069209326,0%
1156,mcf,SHIP-RRIP-DBP,"We combine a SHiP-lite style PC‐signature table with RRIP and an on‐demand dead‐block bypass to focus cache residency on genuinely reusable lines. Each load’s PC indexes a tiny 2-bit saturating counter that tracks reuse tendency: cold PCs (counter=0) bypass (insert at RRPV=MAX), mildly reused PCs (counter=1) receive shallow insertion, hot PCs (counter=2) use SRRIP insertion, and hottest PCs (counter=3) insert at MRU. We update the signature counters up on hits and down on misses, so the predictor adapts per‐PC reuse patterns. This shifts blocks from low‐reuse (ASTAR/MCF/OMNETPP) out quickly, while retaining high‐reuse blocks (LBM/MILC) at the front, improving overall hit rate with minimal metadata overhead (<24 KiB).",,ChampSim_CRC2/new_policies/014_00_ship_rrip_dbp_t02.cc,0.473534742,0.473534742,0%
1157,milc,SHIP-RRIP-DBP,"We combine a SHiP-lite style PC‐signature table with RRIP and an on‐demand dead‐block bypass to focus cache residency on genuinely reusable lines. Each load’s PC indexes a tiny 2-bit saturating counter that tracks reuse tendency: cold PCs (counter=0) bypass (insert at RRPV=MAX), mildly reused PCs (counter=1) receive shallow insertion, hot PCs (counter=2) use SRRIP insertion, and hottest PCs (counter=3) insert at MRU. We update the signature counters up on hits and down on misses, so the predictor adapts per‐PC reuse patterns. This shifts blocks from low‐reuse (ASTAR/MCF/OMNETPP) out quickly, while retaining high‐reuse blocks (LBM/MILC) at the front, improving overall hit rate with minimal metadata overhead (<24 KiB).",,ChampSim_CRC2/new_policies/014_00_ship_rrip_dbp_t02.cc,0.009715997,0.009715997,0%
1158,omnetpp,SHIP-RRIP-DBP,"We combine a SHiP-lite style PC‐signature table with RRIP and an on‐demand dead‐block bypass to focus cache residency on genuinely reusable lines. Each load’s PC indexes a tiny 2-bit saturating counter that tracks reuse tendency: cold PCs (counter=0) bypass (insert at RRPV=MAX), mildly reused PCs (counter=1) receive shallow insertion, hot PCs (counter=2) use SRRIP insertion, and hottest PCs (counter=3) insert at MRU. We update the signature counters up on hits and down on misses, so the predictor adapts per‐PC reuse patterns. This shifts blocks from low‐reuse (ASTAR/MCF/OMNETPP) out quickly, while retaining high‐reuse blocks (LBM/MILC) at the front, improving overall hit rate with minimal metadata overhead (<24 KiB).",,ChampSim_CRC2/new_policies/014_00_ship_rrip_dbp_t02.cc,0.001348055,0.001348055,0%
1159,astar,SHiP-RRIP,"SHiP-RRIP marries RRIP with a tiny PC‐signature history table (SHCT) to predict block reuse and dynamically pick insertion depth, while a per‐line “dead‐block” flag trains the SHCT on evictions. Blocks from PCs that have historically been reused are inserted as MRU (RRPV=0), those with moderate reuse get SRRIP near‐MRU (RRPV=2), and never‐reused blocks bypass (RRPV=3). Hits immediately promote to MRU and increment the SHCT; evictions of cold blocks decrement it. By moving the prediction source to PC history instead of global PSEL or streaming deltas, this policy adapts to both phase‐changing scientific kernels and pathological pointer‐chasing or streaming workloads, reducing pollution and boosting hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/014_01_ship_rrip_t04.cc,0.343958632,0.343958632,0%
1160,lbm,SHiP-RRIP,"SHiP-RRIP marries RRIP with a tiny PC‐signature history table (SHCT) to predict block reuse and dynamically pick insertion depth, while a per‐line “dead‐block” flag trains the SHCT on evictions. Blocks from PCs that have historically been reused are inserted as MRU (RRPV=0), those with moderate reuse get SRRIP near‐MRU (RRPV=2), and never‐reused blocks bypass (RRPV=3). Hits immediately promote to MRU and increment the SHCT; evictions of cold blocks decrement it. By moving the prediction source to PC history instead of global PSEL or streaming deltas, this policy adapts to both phase‐changing scientific kernels and pathological pointer‐chasing or streaming workloads, reducing pollution and boosting hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/014_01_ship_rrip_t04.cc,0.269441348,0.269441348,0%
1161,mcf,SHiP-RRIP,"SHiP-RRIP marries RRIP with a tiny PC‐signature history table (SHCT) to predict block reuse and dynamically pick insertion depth, while a per‐line “dead‐block” flag trains the SHCT on evictions. Blocks from PCs that have historically been reused are inserted as MRU (RRPV=0), those with moderate reuse get SRRIP near‐MRU (RRPV=2), and never‐reused blocks bypass (RRPV=3). Hits immediately promote to MRU and increment the SHCT; evictions of cold blocks decrement it. By moving the prediction source to PC history instead of global PSEL or streaming deltas, this policy adapts to both phase‐changing scientific kernels and pathological pointer‐chasing or streaming workloads, reducing pollution and boosting hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/014_01_ship_rrip_t04.cc,0.498921896,0.498921896,0%
1162,milc,SHiP-RRIP,"SHiP-RRIP marries RRIP with a tiny PC‐signature history table (SHCT) to predict block reuse and dynamically pick insertion depth, while a per‐line “dead‐block” flag trains the SHCT on evictions. Blocks from PCs that have historically been reused are inserted as MRU (RRPV=0), those with moderate reuse get SRRIP near‐MRU (RRPV=2), and never‐reused blocks bypass (RRPV=3). Hits immediately promote to MRU and increment the SHCT; evictions of cold blocks decrement it. By moving the prediction source to PC history instead of global PSEL or streaming deltas, this policy adapts to both phase‐changing scientific kernels and pathological pointer‐chasing or streaming workloads, reducing pollution and boosting hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/014_01_ship_rrip_t04.cc,0.060672933,0.060672933,0%
1163,omnetpp,SHiP-RRIP,"SHiP-RRIP marries RRIP with a tiny PC‐signature history table (SHCT) to predict block reuse and dynamically pick insertion depth, while a per‐line “dead‐block” flag trains the SHCT on evictions. Blocks from PCs that have historically been reused are inserted as MRU (RRPV=0), those with moderate reuse get SRRIP near‐MRU (RRPV=2), and never‐reused blocks bypass (RRPV=3). Hits immediately promote to MRU and increment the SHCT; evictions of cold blocks decrement it. By moving the prediction source to PC history instead of global PSEL or streaming deltas, this policy adapts to both phase‐changing scientific kernels and pathological pointer‐chasing or streaming workloads, reducing pollution and boosting hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/014_01_ship_rrip_t04.cc,0.572391456,0.572391456,0%
1164,astar,PC-SHiP (Program Counter–based Static RRIP with SHiP-lite Insertion),"PC-SHiP adapts RRIP’s insertion depth per PC using a small SHiP-lite signature table to capture which instruction PCs tend to produce reusable blocks.  On each miss we index into a 2-bit saturating counter table by PC to decide whether to insert near-MRU (SRRIP_INS) or as a long-lived block (LIP) to avoid pollution.  On a hit, we reset RRPV to zero and increment the PC’s counter, learning over time which PCs exhibit high reuse.  This eliminates explicit streaming logic, yet naturally treats streaming or single-use patterns (LBM, MCF, OMNETPP) with LIP insertions and promotes high-reuse PCs (ASTAR, MILC) to MRU, yielding better overall performance.",,ChampSim_CRC2/new_policies/014_02_pc_ship__program_counter_based_static_rrip_with_ship_lite_insertion_t07.cc,0.425380764,0.425380764,0%
1165,lbm,PC-SHiP (Program Counter–based Static RRIP with SHiP-lite Insertion),"PC-SHiP adapts RRIP’s insertion depth per PC using a small SHiP-lite signature table to capture which instruction PCs tend to produce reusable blocks.  On each miss we index into a 2-bit saturating counter table by PC to decide whether to insert near-MRU (SRRIP_INS) or as a long-lived block (LIP) to avoid pollution.  On a hit, we reset RRPV to zero and increment the PC’s counter, learning over time which PCs exhibit high reuse.  This eliminates explicit streaming logic, yet naturally treats streaming or single-use patterns (LBM, MCF, OMNETPP) with LIP insertions and promotes high-reuse PCs (ASTAR, MILC) to MRU, yielding better overall performance.",,ChampSim_CRC2/new_policies/014_02_pc_ship__program_counter_based_static_rrip_with_ship_lite_insertion_t07.cc,0.27084319,0.27084319,0%
1166,mcf,PC-SHiP (Program Counter–based Static RRIP with SHiP-lite Insertion),"PC-SHiP adapts RRIP’s insertion depth per PC using a small SHiP-lite signature table to capture which instruction PCs tend to produce reusable blocks.  On each miss we index into a 2-bit saturating counter table by PC to decide whether to insert near-MRU (SRRIP_INS) or as a long-lived block (LIP) to avoid pollution.  On a hit, we reset RRPV to zero and increment the PC’s counter, learning over time which PCs exhibit high reuse.  This eliminates explicit streaming logic, yet naturally treats streaming or single-use patterns (LBM, MCF, OMNETPP) with LIP insertions and promotes high-reuse PCs (ASTAR, MILC) to MRU, yielding better overall performance.",,ChampSim_CRC2/new_policies/014_02_pc_ship__program_counter_based_static_rrip_with_ship_lite_insertion_t07.cc,0.461255615,0.461255615,0%
1167,milc,PC-SHiP (Program Counter–based Static RRIP with SHiP-lite Insertion),"PC-SHiP adapts RRIP’s insertion depth per PC using a small SHiP-lite signature table to capture which instruction PCs tend to produce reusable blocks.  On each miss we index into a 2-bit saturating counter table by PC to decide whether to insert near-MRU (SRRIP_INS) or as a long-lived block (LIP) to avoid pollution.  On a hit, we reset RRPV to zero and increment the PC’s counter, learning over time which PCs exhibit high reuse.  This eliminates explicit streaming logic, yet naturally treats streaming or single-use patterns (LBM, MCF, OMNETPP) with LIP insertions and promotes high-reuse PCs (ASTAR, MILC) to MRU, yielding better overall performance.",,ChampSim_CRC2/new_policies/014_02_pc_ship__program_counter_based_static_rrip_with_ship_lite_insertion_t07.cc,0.013329399,0.013329399,0%
1168,omnetpp,PC-SHiP (Program Counter–based Static RRIP with SHiP-lite Insertion),"PC-SHiP adapts RRIP’s insertion depth per PC using a small SHiP-lite signature table to capture which instruction PCs tend to produce reusable blocks.  On each miss we index into a 2-bit saturating counter table by PC to decide whether to insert near-MRU (SRRIP_INS) or as a long-lived block (LIP) to avoid pollution.  On a hit, we reset RRPV to zero and increment the PC’s counter, learning over time which PCs exhibit high reuse.  This eliminates explicit streaming logic, yet naturally treats streaming or single-use patterns (LBM, MCF, OMNETPP) with LIP insertions and promotes high-reuse PCs (ASTAR, MILC) to MRU, yielding better overall performance.",,ChampSim_CRC2/new_policies/014_02_pc_ship__program_counter_based_static_rrip_with_ship_lite_insertion_t07.cc,0.223077841,0.223077841,0%
1169,all,SHiP-RRIP,"SHiP-RRIP marries RRIP with a tiny PC‐signature history table (SHCT) to predict block reuse and dynamically pick insertion depth, while a per‐line “dead‐block” flag trains the SHCT on evictions. Blocks from PCs that have historically been reused are inserted as MRU (RRPV=0), those with moderate reuse get SRRIP near‐MRU (RRPV=2), and never‐reused blocks bypass (RRPV=3). Hits immediately promote to MRU and increment the SHCT; evictions of cold blocks decrement it. By moving the prediction source to PC history instead of global PSEL or streaming deltas, this policy adapts to both phase‐changing scientific kernels and pathological pointer‐chasing or streaming workloads, reducing pollution and boosting hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/014_01_ship_rrip_t04.cc,0.349077253,0.349077253,35%
1170,astar,DRRIP with Streaming Bypass (DRRIP-SB),"DRRIP-SB combines dynamic RRIP (DRRIP) to adaptively choose between SRRIP (insertion at RRPV=2) and BRRIP (bimodal insertion at RRPV=3 with rare RRPV=2) using a 10-bit PSEL and 64 leader sets, together with a tiny streaming detector that tracks the delta between successive miss addresses. When the detector identifies a monotonic streaming pattern, new blocks are bypassed (inserted at the far-RRIP priority) to avoid cache pollution. This design retains the strengths of RRIP against both high-reuse and low-reuse workloads, adapts globally to shifting phases, and prevents stencils or pointer-chasing from evicting stream data, improving hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/015_00_drrip_with_streaming_bypass__drrip_sb_t02.cc,0.322861593,0.322861593,0%
1171,lbm,DRRIP with Streaming Bypass (DRRIP-SB),"DRRIP-SB combines dynamic RRIP (DRRIP) to adaptively choose between SRRIP (insertion at RRPV=2) and BRRIP (bimodal insertion at RRPV=3 with rare RRPV=2) using a 10-bit PSEL and 64 leader sets, together with a tiny streaming detector that tracks the delta between successive miss addresses. When the detector identifies a monotonic streaming pattern, new blocks are bypassed (inserted at the far-RRIP priority) to avoid cache pollution. This design retains the strengths of RRIP against both high-reuse and low-reuse workloads, adapts globally to shifting phases, and prevents stencils or pointer-chasing from evicting stream data, improving hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/015_00_drrip_with_streaming_bypass__drrip_sb_t02.cc,0.259204796,0.259204796,0%
1172,mcf,DRRIP with Streaming Bypass (DRRIP-SB),"DRRIP-SB combines dynamic RRIP (DRRIP) to adaptively choose between SRRIP (insertion at RRPV=2) and BRRIP (bimodal insertion at RRPV=3 with rare RRPV=2) using a 10-bit PSEL and 64 leader sets, together with a tiny streaming detector that tracks the delta between successive miss addresses. When the detector identifies a monotonic streaming pattern, new blocks are bypassed (inserted at the far-RRIP priority) to avoid cache pollution. This design retains the strengths of RRIP against both high-reuse and low-reuse workloads, adapts globally to shifting phases, and prevents stencils or pointer-chasing from evicting stream data, improving hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/015_00_drrip_with_streaming_bypass__drrip_sb_t02.cc,0.410134646,0.410134646,0%
1173,milc,DRRIP with Streaming Bypass (DRRIP-SB),"DRRIP-SB combines dynamic RRIP (DRRIP) to adaptively choose between SRRIP (insertion at RRPV=2) and BRRIP (bimodal insertion at RRPV=3 with rare RRPV=2) using a 10-bit PSEL and 64 leader sets, together with a tiny streaming detector that tracks the delta between successive miss addresses. When the detector identifies a monotonic streaming pattern, new blocks are bypassed (inserted at the far-RRIP priority) to avoid cache pollution. This design retains the strengths of RRIP against both high-reuse and low-reuse workloads, adapts globally to shifting phases, and prevents stencils or pointer-chasing from evicting stream data, improving hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/015_00_drrip_with_streaming_bypass__drrip_sb_t02.cc,0.160439763,0.160439763,0%
1174,omnetpp,DRRIP with Streaming Bypass (DRRIP-SB),"DRRIP-SB combines dynamic RRIP (DRRIP) to adaptively choose between SRRIP (insertion at RRPV=2) and BRRIP (bimodal insertion at RRPV=3 with rare RRPV=2) using a 10-bit PSEL and 64 leader sets, together with a tiny streaming detector that tracks the delta between successive miss addresses. When the detector identifies a monotonic streaming pattern, new blocks are bypassed (inserted at the far-RRIP priority) to avoid cache pollution. This design retains the strengths of RRIP against both high-reuse and low-reuse workloads, adapts globally to shifting phases, and prevents stencils or pointer-chasing from evicting stream data, improving hit rates across all benchmarks.",,ChampSim_CRC2/new_policies/015_00_drrip_with_streaming_bypass__drrip_sb_t02.cc,0.264081504,0.264081504,0%
1175,astar,Hybrid-Stream-DRRIP-SHiP,"Hybrid-Stream-DRRIP-SHiP fuses three compact mechanisms to adapt to all target workloads. First, DRRIP set-dueling dynamically chooses between SRRIP and BIP insertion to adapt recency bias per phase. Second, SHiP-lite PC-signature history (2-bit counters indexed by OPC^ADDR) biases insertion depth per PC, rapidly learning pointer-chase or reuse-heavy patterns. Third, a per-core streaming detector tracks monotonic address strides and bypasses or de-prioritizes likely streaming blocks to avoid cache pollution. Together this design leverages global phase adaptation (DRRIP), fine-grained PC reuse prediction (SHiP), and explicit streaming bypass with under 64 KiB of extra metadata, boosting hit rates on A*’s speculation, MCF’s pointer-chasing, LBM’s spatial streams, MILC’s mixed phases, and OMNET++’s dynamic objects.",,ChampSim_CRC2/new_policies/015_01_hybrid_stream_drrip_ship_t04.cc,0.008052028,0.008052028,0%
1176,lbm,Hybrid-Stream-DRRIP-SHiP,"Hybrid-Stream-DRRIP-SHiP fuses three compact mechanisms to adapt to all target workloads. First, DRRIP set-dueling dynamically chooses between SRRIP and BIP insertion to adapt recency bias per phase. Second, SHiP-lite PC-signature history (2-bit counters indexed by OPC^ADDR) biases insertion depth per PC, rapidly learning pointer-chase or reuse-heavy patterns. Third, a per-core streaming detector tracks monotonic address strides and bypasses or de-prioritizes likely streaming blocks to avoid cache pollution. Together this design leverages global phase adaptation (DRRIP), fine-grained PC reuse prediction (SHiP), and explicit streaming bypass with under 64 KiB of extra metadata, boosting hit rates on A*’s speculation, MCF’s pointer-chasing, LBM’s spatial streams, MILC’s mixed phases, and OMNET++’s dynamic objects.",,ChampSim_CRC2/new_policies/015_01_hybrid_stream_drrip_ship_t04.cc,0.018892991,0.018892991,0%
1177,astar,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to maximize hit rate across diverse workloads: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth for irregular/pointer-chasing codes (MCF, Omnetpp, Astar); (2) a lightweight streaming detector that tracks per-set address deltas to identify monotonic scans and bypass streaming blocks (LBM, MILC); and (3) a recency-based dead-block approximation using 1-bit per-line reuse flags to protect recently reused blocks from premature eviction. On insertion, the policy consults the PC signature to select RRPV (MRU for ""hot"" PCs, distant for ""cold""), and if a stream is detected, forces bypass. On hits, lines are promoted to MRU and their reuse flag is set. This hybrid approach adapts to phase changes, captures irregular reuse, and avoids pollution from scans, outperforming prior policies with <32 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_hybrid_signature_recency_streaming__hsrs_t02.cc,0.332562297,0.332562297,0%
1178,lbm,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to maximize hit rate across diverse workloads: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth for irregular/pointer-chasing codes (MCF, Omnetpp, Astar); (2) a lightweight streaming detector that tracks per-set address deltas to identify monotonic scans and bypass streaming blocks (LBM, MILC); and (3) a recency-based dead-block approximation using 1-bit per-line reuse flags to protect recently reused blocks from premature eviction. On insertion, the policy consults the PC signature to select RRPV (MRU for ""hot"" PCs, distant for ""cold""), and if a stream is detected, forces bypass. On hits, lines are promoted to MRU and their reuse flag is set. This hybrid approach adapts to phase changes, captures irregular reuse, and avoids pollution from scans, outperforming prior policies with <32 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_hybrid_signature_recency_streaming__hsrs_t02.cc,0.137523751,0.137523751,0%
1179,mcf,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to maximize hit rate across diverse workloads: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth for irregular/pointer-chasing codes (MCF, Omnetpp, Astar); (2) a lightweight streaming detector that tracks per-set address deltas to identify monotonic scans and bypass streaming blocks (LBM, MILC); and (3) a recency-based dead-block approximation using 1-bit per-line reuse flags to protect recently reused blocks from premature eviction. On insertion, the policy consults the PC signature to select RRPV (MRU for ""hot"" PCs, distant for ""cold""), and if a stream is detected, forces bypass. On hits, lines are promoted to MRU and their reuse flag is set. This hybrid approach adapts to phase changes, captures irregular reuse, and avoids pollution from scans, outperforming prior policies with <32 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_hybrid_signature_recency_streaming__hsrs_t02.cc,0.488414157,0.488414157,0%
1180,milc,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to maximize hit rate across diverse workloads: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth for irregular/pointer-chasing codes (MCF, Omnetpp, Astar); (2) a lightweight streaming detector that tracks per-set address deltas to identify monotonic scans and bypass streaming blocks (LBM, MILC); and (3) a recency-based dead-block approximation using 1-bit per-line reuse flags to protect recently reused blocks from premature eviction. On insertion, the policy consults the PC signature to select RRPV (MRU for ""hot"" PCs, distant for ""cold""), and if a stream is detected, forces bypass. On hits, lines are promoted to MRU and their reuse flag is set. This hybrid approach adapts to phase changes, captures irregular reuse, and avoids pollution from scans, outperforming prior policies with <32 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_hybrid_signature_recency_streaming__hsrs_t02.cc,0.009945908,0.009945908,0%
1181,omnetpp,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to maximize hit rate across diverse workloads: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth for irregular/pointer-chasing codes (MCF, Omnetpp, Astar); (2) a lightweight streaming detector that tracks per-set address deltas to identify monotonic scans and bypass streaming blocks (LBM, MILC); and (3) a recency-based dead-block approximation using 1-bit per-line reuse flags to protect recently reused blocks from premature eviction. On insertion, the policy consults the PC signature to select RRPV (MRU for ""hot"" PCs, distant for ""cold""), and if a stream is detected, forces bypass. On hits, lines are promoted to MRU and their reuse flag is set. This hybrid approach adapts to phase changes, captures irregular reuse, and avoids pollution from scans, outperforming prior policies with <32 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_hybrid_signature_recency_streaming__hsrs_t02.cc,0.002946633,0.002946633,0%
1182,astar,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to robustly handle diverse workload behaviors: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth toward MRU for “hot” PCs and distant RRPV for “cold” PCs, (2) a lightweight streaming detector that tracks per-set monotonic address deltas to bypass pure scans, and (3) a recency-based dead-block predictor using tiny per-line saturating counters to approximate reuse. On insertion, HSRS consults both signature and streaming signals to select RRPV; on hits, it promotes blocks and boosts dead-block counters. This hybrid approach adapts to pointer-chasing (MCF, Omnet++), streaming/stencil (LBM, MILC), and speculative control-flow (Astar), capturing high reuse, suppressing pollution, and responding to phase changes. All metadata fits comfortably within 64 KiB, supporting scalable, phase-adaptive cache management.",,ChampSim_CRC2/new_policies/000_01_hybrid_signature_recency_streaming__hsrs_t04.cc,0.149448433,0.149448433,0%
1183,lbm,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to robustly handle diverse workload behaviors: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth toward MRU for “hot” PCs and distant RRPV for “cold” PCs, (2) a lightweight streaming detector that tracks per-set monotonic address deltas to bypass pure scans, and (3) a recency-based dead-block predictor using tiny per-line saturating counters to approximate reuse. On insertion, HSRS consults both signature and streaming signals to select RRPV; on hits, it promotes blocks and boosts dead-block counters. This hybrid approach adapts to pointer-chasing (MCF, Omnet++), streaming/stencil (LBM, MILC), and speculative control-flow (Astar), capturing high reuse, suppressing pollution, and responding to phase changes. All metadata fits comfortably within 64 KiB, supporting scalable, phase-adaptive cache management.",,ChampSim_CRC2/new_policies/000_01_hybrid_signature_recency_streaming__hsrs_t04.cc,0.069298274,0.069298274,0%
1184,mcf,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to robustly handle diverse workload behaviors: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth toward MRU for “hot” PCs and distant RRPV for “cold” PCs, (2) a lightweight streaming detector that tracks per-set monotonic address deltas to bypass pure scans, and (3) a recency-based dead-block predictor using tiny per-line saturating counters to approximate reuse. On insertion, HSRS consults both signature and streaming signals to select RRPV; on hits, it promotes blocks and boosts dead-block counters. This hybrid approach adapts to pointer-chasing (MCF, Omnet++), streaming/stencil (LBM, MILC), and speculative control-flow (Astar), capturing high reuse, suppressing pollution, and responding to phase changes. All metadata fits comfortably within 64 KiB, supporting scalable, phase-adaptive cache management.",,ChampSim_CRC2/new_policies/000_01_hybrid_signature_recency_streaming__hsrs_t04.cc,0.471519098,0.471519098,0%
1185,milc,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to robustly handle diverse workload behaviors: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth toward MRU for “hot” PCs and distant RRPV for “cold” PCs, (2) a lightweight streaming detector that tracks per-set monotonic address deltas to bypass pure scans, and (3) a recency-based dead-block predictor using tiny per-line saturating counters to approximate reuse. On insertion, HSRS consults both signature and streaming signals to select RRPV; on hits, it promotes blocks and boosts dead-block counters. This hybrid approach adapts to pointer-chasing (MCF, Omnet++), streaming/stencil (LBM, MILC), and speculative control-flow (Astar), capturing high reuse, suppressing pollution, and responding to phase changes. All metadata fits comfortably within 64 KiB, supporting scalable, phase-adaptive cache management.",,ChampSim_CRC2/new_policies/000_01_hybrid_signature_recency_streaming__hsrs_t04.cc,0.00973591,0.00973591,0%
1186,omnetpp,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to robustly handle diverse workload behaviors: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth toward MRU for “hot” PCs and distant RRPV for “cold” PCs, (2) a lightweight streaming detector that tracks per-set monotonic address deltas to bypass pure scans, and (3) a recency-based dead-block predictor using tiny per-line saturating counters to approximate reuse. On insertion, HSRS consults both signature and streaming signals to select RRPV; on hits, it promotes blocks and boosts dead-block counters. This hybrid approach adapts to pointer-chasing (MCF, Omnet++), streaming/stencil (LBM, MILC), and speculative control-flow (Astar), capturing high reuse, suppressing pollution, and responding to phase changes. All metadata fits comfortably within 64 KiB, supporting scalable, phase-adaptive cache management.",,ChampSim_CRC2/new_policies/000_01_hybrid_signature_recency_streaming__hsrs_t04.cc,0.001288406,0.001288406,0%
1187,all,Hybrid Signature-Recency Streaming (HSRS),"HSRS combines three compact mechanisms to maximize hit rate across diverse workloads: (1) a 4-bit per-PC signature table with 2-bit outcome counters (SHiP-lite) to bias insertion depth for irregular/pointer-chasing codes (MCF, Omnetpp, Astar); (2) a lightweight streaming detector that tracks per-set address deltas to identify monotonic scans and bypass streaming blocks (LBM, MILC); and (3) a recency-based dead-block approximation using 1-bit per-line reuse flags to protect recently reused blocks from premature eviction. On insertion, the policy consults the PC signature to select RRPV (MRU for ""hot"" PCs, distant for ""cold""), and if a stream is detected, forces bypass. On hits, lines are promoted to MRU and their reuse flag is set. This hybrid approach adapts to phase changes, captures irregular reuse, and avoids pollution from scans, outperforming prior policies with <32 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_hybrid_signature_recency_streaming__hsrs_t02.cc,0.194278549,0.194278549,19%
1188,astar,Adaptive DRRIP with Streaming Bypass (ADSB),"ADSB combines set-dueling DRRIP (Dynamic RRIP) with a lightweight streaming detector to adapt insertion depth and bypass logic for diverse workloads. DRRIP uses a 2-bit RRPV per line and a 10-bit PSEL counter to dynamically select between SRRIP (static insertion at distant RRPV) and BRRIP (mostly distant, occasionally MRU) based on leader set hit rates, improving performance for both recency- and thrash-sensitive codes. A compact per-set streaming detector tracks consecutive address deltas; when monotonic access is detected (e.g., in LBM/MILC), streaming blocks are bypassed (not inserted), preventing cache pollution. This design improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, Astar) via DRRIP adaptivity, while protecting against scan-induced pollution in streaming phases. All metadata fits within 64 KiB, and the policy is materially different from HSRS by changing both prediction source (set-dueling, not PC signatures) and streaming logic (true bypass, not just distant insertion).",,ChampSim_CRC2/new_policies/001_00_adaptive_drrip_with_streaming_bypass__adsb_t02.cc,0.166308169,0.166308169,0%
1189,lbm,Adaptive DRRIP with Streaming Bypass (ADSB),"ADSB combines set-dueling DRRIP (Dynamic RRIP) with a lightweight streaming detector to adapt insertion depth and bypass logic for diverse workloads. DRRIP uses a 2-bit RRPV per line and a 10-bit PSEL counter to dynamically select between SRRIP (static insertion at distant RRPV) and BRRIP (mostly distant, occasionally MRU) based on leader set hit rates, improving performance for both recency- and thrash-sensitive codes. A compact per-set streaming detector tracks consecutive address deltas; when monotonic access is detected (e.g., in LBM/MILC), streaming blocks are bypassed (not inserted), preventing cache pollution. This design improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, Astar) via DRRIP adaptivity, while protecting against scan-induced pollution in streaming phases. All metadata fits within 64 KiB, and the policy is materially different from HSRS by changing both prediction source (set-dueling, not PC signatures) and streaming logic (true bypass, not just distant insertion).",,ChampSim_CRC2/new_policies/001_00_adaptive_drrip_with_streaming_bypass__adsb_t02.cc,0.095643995,0.095643995,0%
1190,mcf,Adaptive DRRIP with Streaming Bypass (ADSB),"ADSB combines set-dueling DRRIP (Dynamic RRIP) with a lightweight streaming detector to adapt insertion depth and bypass logic for diverse workloads. DRRIP uses a 2-bit RRPV per line and a 10-bit PSEL counter to dynamically select between SRRIP (static insertion at distant RRPV) and BRRIP (mostly distant, occasionally MRU) based on leader set hit rates, improving performance for both recency- and thrash-sensitive codes. A compact per-set streaming detector tracks consecutive address deltas; when monotonic access is detected (e.g., in LBM/MILC), streaming blocks are bypassed (not inserted), preventing cache pollution. This design improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, Astar) via DRRIP adaptivity, while protecting against scan-induced pollution in streaming phases. All metadata fits within 64 KiB, and the policy is materially different from HSRS by changing both prediction source (set-dueling, not PC signatures) and streaming logic (true bypass, not just distant insertion).",,ChampSim_CRC2/new_policies/001_00_adaptive_drrip_with_streaming_bypass__adsb_t02.cc,0.342472154,0.342472154,0%
1191,milc,Adaptive DRRIP with Streaming Bypass (ADSB),"ADSB combines set-dueling DRRIP (Dynamic RRIP) with a lightweight streaming detector to adapt insertion depth and bypass logic for diverse workloads. DRRIP uses a 2-bit RRPV per line and a 10-bit PSEL counter to dynamically select between SRRIP (static insertion at distant RRPV) and BRRIP (mostly distant, occasionally MRU) based on leader set hit rates, improving performance for both recency- and thrash-sensitive codes. A compact per-set streaming detector tracks consecutive address deltas; when monotonic access is detected (e.g., in LBM/MILC), streaming blocks are bypassed (not inserted), preventing cache pollution. This design improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, Astar) via DRRIP adaptivity, while protecting against scan-induced pollution in streaming phases. All metadata fits within 64 KiB, and the policy is materially different from HSRS by changing both prediction source (set-dueling, not PC signatures) and streaming logic (true bypass, not just distant insertion).",,ChampSim_CRC2/new_policies/001_00_adaptive_drrip_with_streaming_bypass__adsb_t02.cc,0.02143964,0.02143964,0%
1192,omnetpp,Adaptive DRRIP with Streaming Bypass (ADSB),"ADSB combines set-dueling DRRIP (Dynamic RRIP) with a lightweight streaming detector to adapt insertion depth and bypass logic for diverse workloads. DRRIP uses a 2-bit RRPV per line and a 10-bit PSEL counter to dynamically select between SRRIP (static insertion at distant RRPV) and BRRIP (mostly distant, occasionally MRU) based on leader set hit rates, improving performance for both recency- and thrash-sensitive codes. A compact per-set streaming detector tracks consecutive address deltas; when monotonic access is detected (e.g., in LBM/MILC), streaming blocks are bypassed (not inserted), preventing cache pollution. This design improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, Astar) via DRRIP adaptivity, while protecting against scan-induced pollution in streaming phases. All metadata fits within 64 KiB, and the policy is materially different from HSRS by changing both prediction source (set-dueling, not PC signatures) and streaming logic (true bypass, not just distant insertion).",,ChampSim_CRC2/new_policies/001_00_adaptive_drrip_with_streaming_bypass__adsb_t02.cc,0.073618095,0.073618095,0%
1193,astar,Adaptive DIP-Streaming Hybrid (ADSH),"ADSH fuses DIP-style set-dueling insertion control with a streaming-aware bypass and lightweight dead-block tracking to adapt to both regular and irregular workloads. DIP divides the cache sets into leader sets, dynamically switching between LIP (always insert at LRU) and BIP (insert mostly at MRU, occasionally at LRU) based on a global PSEL counter, optimizing for recency or scan-heavy patterns. A compact streaming detector (per-set, 2-byte) identifies monotonic address strides and forces bypass or distant insertion for streaming blocks (LBM, MILC), reducing pollution. Each cache line also maintains a 1-bit reuse flag, periodically decayed, to protect recently reused blocks from eviction (helpful for MCF, Omnetpp, Astar). This hybrid policy leverages set-dueling to self-tune insertion depth, streaming detection to avoid scan pollution, and dead-block approximation for irregular reuse, delivering robust performance across diverse workloads within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/001_01_adaptive_dip_streaming_hybrid__adsh_t04.cc,0.129359673,0.129359673,0%
1194,lbm,Adaptive DIP-Streaming Hybrid (ADSH),"ADSH fuses DIP-style set-dueling insertion control with a streaming-aware bypass and lightweight dead-block tracking to adapt to both regular and irregular workloads. DIP divides the cache sets into leader sets, dynamically switching between LIP (always insert at LRU) and BIP (insert mostly at MRU, occasionally at LRU) based on a global PSEL counter, optimizing for recency or scan-heavy patterns. A compact streaming detector (per-set, 2-byte) identifies monotonic address strides and forces bypass or distant insertion for streaming blocks (LBM, MILC), reducing pollution. Each cache line also maintains a 1-bit reuse flag, periodically decayed, to protect recently reused blocks from eviction (helpful for MCF, Omnetpp, Astar). This hybrid policy leverages set-dueling to self-tune insertion depth, streaming detection to avoid scan pollution, and dead-block approximation for irregular reuse, delivering robust performance across diverse workloads within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/001_01_adaptive_dip_streaming_hybrid__adsh_t04.cc,0.080680173,0.080680173,0%
1195,mcf,Adaptive DIP-Streaming Hybrid (ADSH),"ADSH fuses DIP-style set-dueling insertion control with a streaming-aware bypass and lightweight dead-block tracking to adapt to both regular and irregular workloads. DIP divides the cache sets into leader sets, dynamically switching between LIP (always insert at LRU) and BIP (insert mostly at MRU, occasionally at LRU) based on a global PSEL counter, optimizing for recency or scan-heavy patterns. A compact streaming detector (per-set, 2-byte) identifies monotonic address strides and forces bypass or distant insertion for streaming blocks (LBM, MILC), reducing pollution. Each cache line also maintains a 1-bit reuse flag, periodically decayed, to protect recently reused blocks from eviction (helpful for MCF, Omnetpp, Astar). This hybrid policy leverages set-dueling to self-tune insertion depth, streaming detection to avoid scan pollution, and dead-block approximation for irregular reuse, delivering robust performance across diverse workloads within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/001_01_adaptive_dip_streaming_hybrid__adsh_t04.cc,0.269358481,0.269358481,0%
1196,milc,Adaptive DIP-Streaming Hybrid (ADSH),"ADSH fuses DIP-style set-dueling insertion control with a streaming-aware bypass and lightweight dead-block tracking to adapt to both regular and irregular workloads. DIP divides the cache sets into leader sets, dynamically switching between LIP (always insert at LRU) and BIP (insert mostly at MRU, occasionally at LRU) based on a global PSEL counter, optimizing for recency or scan-heavy patterns. A compact streaming detector (per-set, 2-byte) identifies monotonic address strides and forces bypass or distant insertion for streaming blocks (LBM, MILC), reducing pollution. Each cache line also maintains a 1-bit reuse flag, periodically decayed, to protect recently reused blocks from eviction (helpful for MCF, Omnetpp, Astar). This hybrid policy leverages set-dueling to self-tune insertion depth, streaming detection to avoid scan pollution, and dead-block approximation for irregular reuse, delivering robust performance across diverse workloads within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/001_01_adaptive_dip_streaming_hybrid__adsh_t04.cc,0.014984033,0.014984033,0%
1197,omnetpp,Adaptive DIP-Streaming Hybrid (ADSH),"ADSH fuses DIP-style set-dueling insertion control with a streaming-aware bypass and lightweight dead-block tracking to adapt to both regular and irregular workloads. DIP divides the cache sets into leader sets, dynamically switching between LIP (always insert at LRU) and BIP (insert mostly at MRU, occasionally at LRU) based on a global PSEL counter, optimizing for recency or scan-heavy patterns. A compact streaming detector (per-set, 2-byte) identifies monotonic address strides and forces bypass or distant insertion for streaming blocks (LBM, MILC), reducing pollution. Each cache line also maintains a 1-bit reuse flag, periodically decayed, to protect recently reused blocks from eviction (helpful for MCF, Omnetpp, Astar). This hybrid policy leverages set-dueling to self-tune insertion depth, streaming detection to avoid scan pollution, and dead-block approximation for irregular reuse, delivering robust performance across diverse workloads within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/001_01_adaptive_dip_streaming_hybrid__adsh_t04.cc,0.045350162,0.045350162,0%
1198,astar,Adaptive Dueling Insertion with Streaming Bypass (ADS-B),"ADS-B combines dynamic insertion depth control via DIP-style set dueling and a compact streaming detector to adapt to both irregular and streaming-dominated workloads. Leader sets choose between LIP (always insert at distant RRPV) and BIP (insert mostly distant, sometimes MRU), guided by a 10-bit PSEL counter; follower sets use the winning policy for insertion. This enables robust handling of pointer-chasing and irregular reuse (MCF, omnetpp, astar), while still exploiting recency when beneficial (milc, astar, omnetpp). For highly streaming phases (lbm, milc), a per-set streaming detector tracks monotonic address strides and forces bypass (insert at distant RRPV) when detected, preventing pollution. The approach requires only 32 leader sets, a 10-bit PSEL counter, and per-set streaming state, fitting comfortably within 64 KiB metadata. By combining dynamic policy selection and streaming bypass, ADS-B significantly improves hit rate across diverse workload phases compared to static or signature-based approaches.",,ChampSim_CRC2/new_policies/001_02_adaptive_dueling_insertion_with_streaming_bypass__ads_b_t07.cc,0.053614332,0.053614332,0%
1199,lbm,Adaptive Dueling Insertion with Streaming Bypass (ADS-B),"ADS-B combines dynamic insertion depth control via DIP-style set dueling and a compact streaming detector to adapt to both irregular and streaming-dominated workloads. Leader sets choose between LIP (always insert at distant RRPV) and BIP (insert mostly distant, sometimes MRU), guided by a 10-bit PSEL counter; follower sets use the winning policy for insertion. This enables robust handling of pointer-chasing and irregular reuse (MCF, omnetpp, astar), while still exploiting recency when beneficial (milc, astar, omnetpp). For highly streaming phases (lbm, milc), a per-set streaming detector tracks monotonic address strides and forces bypass (insert at distant RRPV) when detected, preventing pollution. The approach requires only 32 leader sets, a 10-bit PSEL counter, and per-set streaming state, fitting comfortably within 64 KiB metadata. By combining dynamic policy selection and streaming bypass, ADS-B significantly improves hit rate across diverse workload phases compared to static or signature-based approaches.",,ChampSim_CRC2/new_policies/001_02_adaptive_dueling_insertion_with_streaming_bypass__ads_b_t07.cc,0.059570739,0.059570739,0%
1200,mcf,Adaptive Dueling Insertion with Streaming Bypass (ADS-B),"ADS-B combines dynamic insertion depth control via DIP-style set dueling and a compact streaming detector to adapt to both irregular and streaming-dominated workloads. Leader sets choose between LIP (always insert at distant RRPV) and BIP (insert mostly distant, sometimes MRU), guided by a 10-bit PSEL counter; follower sets use the winning policy for insertion. This enables robust handling of pointer-chasing and irregular reuse (MCF, omnetpp, astar), while still exploiting recency when beneficial (milc, astar, omnetpp). For highly streaming phases (lbm, milc), a per-set streaming detector tracks monotonic address strides and forces bypass (insert at distant RRPV) when detected, preventing pollution. The approach requires only 32 leader sets, a 10-bit PSEL counter, and per-set streaming state, fitting comfortably within 64 KiB metadata. By combining dynamic policy selection and streaming bypass, ADS-B significantly improves hit rate across diverse workload phases compared to static or signature-based approaches.",,ChampSim_CRC2/new_policies/001_02_adaptive_dueling_insertion_with_streaming_bypass__ads_b_t07.cc,0.231356813,0.231356813,0%
1201,milc,Adaptive Dueling Insertion with Streaming Bypass (ADS-B),"ADS-B combines dynamic insertion depth control via DIP-style set dueling and a compact streaming detector to adapt to both irregular and streaming-dominated workloads. Leader sets choose between LIP (always insert at distant RRPV) and BIP (insert mostly distant, sometimes MRU), guided by a 10-bit PSEL counter; follower sets use the winning policy for insertion. This enables robust handling of pointer-chasing and irregular reuse (MCF, omnetpp, astar), while still exploiting recency when beneficial (milc, astar, omnetpp). For highly streaming phases (lbm, milc), a per-set streaming detector tracks monotonic address strides and forces bypass (insert at distant RRPV) when detected, preventing pollution. The approach requires only 32 leader sets, a 10-bit PSEL counter, and per-set streaming state, fitting comfortably within 64 KiB metadata. By combining dynamic policy selection and streaming bypass, ADS-B significantly improves hit rate across diverse workload phases compared to static or signature-based approaches.",,ChampSim_CRC2/new_policies/001_02_adaptive_dueling_insertion_with_streaming_bypass__ads_b_t07.cc,0.011153392,0.011153392,0%
1202,omnetpp,Adaptive Dueling Insertion with Streaming Bypass (ADS-B),"ADS-B combines dynamic insertion depth control via DIP-style set dueling and a compact streaming detector to adapt to both irregular and streaming-dominated workloads. Leader sets choose between LIP (always insert at distant RRPV) and BIP (insert mostly distant, sometimes MRU), guided by a 10-bit PSEL counter; follower sets use the winning policy for insertion. This enables robust handling of pointer-chasing and irregular reuse (MCF, omnetpp, astar), while still exploiting recency when beneficial (milc, astar, omnetpp). For highly streaming phases (lbm, milc), a per-set streaming detector tracks monotonic address strides and forces bypass (insert at distant RRPV) when detected, preventing pollution. The approach requires only 32 leader sets, a 10-bit PSEL counter, and per-set streaming state, fitting comfortably within 64 KiB metadata. By combining dynamic policy selection and streaming bypass, ADS-B significantly improves hit rate across diverse workload phases compared to static or signature-based approaches.",,ChampSim_CRC2/new_policies/001_02_adaptive_dueling_insertion_with_streaming_bypass__ads_b_t07.cc,0.03519854,0.03519854,0%
1203,all,Adaptive DRRIP with Streaming Bypass (ADSB),"ADSB combines set-dueling DRRIP (Dynamic RRIP) with a lightweight streaming detector to adapt insertion depth and bypass logic for diverse workloads. DRRIP uses a 2-bit RRPV per line and a 10-bit PSEL counter to dynamically select between SRRIP (static insertion at distant RRPV) and BRRIP (mostly distant, occasionally MRU) based on leader set hit rates, improving performance for both recency- and thrash-sensitive codes. A compact per-set streaming detector tracks consecutive address deltas; when monotonic access is detected (e.g., in LBM/MILC), streaming blocks are bypassed (not inserted), preventing cache pollution. This design improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, Astar) via DRRIP adaptivity, while protecting against scan-induced pollution in streaming phases. All metadata fits within 64 KiB, and the policy is materially different from HSRS by changing both prediction source (set-dueling, not PC signatures) and streaming logic (true bypass, not just distant insertion).",,ChampSim_CRC2/new_policies/001_00_adaptive_drrip_with_streaming_bypass__adsb_t02.cc,0.139896411,0.139896411,14%
1204,astar,SHiP-Lite with Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-style PC signature predictor with a streaming detector to adapt cache insertion depth and bypass logic. Each cache line tracks a compact 5-bit PC signature and a 2-bit outcome counter, biasing insertion toward MRU for PCs with recent hits and toward distant RRPV for PCs with frequent misses. A per-set streaming detector identifies monotonic address strides, bypassing blocks to avoid pollution during scan phases (e.g., LBM, MILC). This hybrid approach improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, astar) by learning reuse per PC, while protecting against streaming-induced pollution. All metadata fits within 64 KiB: 5 bits per line for PC signature, 2 bits per line for outcome counter, 2 bits per line for RRPV, and a small per-set streaming table.",,ChampSim_CRC2/new_policies/002_01_ship_lite_with_streaming_bypass__slsb_t04.cc,0.045124665,0.045124665,0%
1205,lbm,SHiP-Lite with Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-style PC signature predictor with a streaming detector to adapt cache insertion depth and bypass logic. Each cache line tracks a compact 5-bit PC signature and a 2-bit outcome counter, biasing insertion toward MRU for PCs with recent hits and toward distant RRPV for PCs with frequent misses. A per-set streaming detector identifies monotonic address strides, bypassing blocks to avoid pollution during scan phases (e.g., LBM, MILC). This hybrid approach improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, astar) by learning reuse per PC, while protecting against streaming-induced pollution. All metadata fits within 64 KiB: 5 bits per line for PC signature, 2 bits per line for outcome counter, 2 bits per line for RRPV, and a small per-set streaming table.",,ChampSim_CRC2/new_policies/002_01_ship_lite_with_streaming_bypass__slsb_t04.cc,0.058753172,0.058753172,0%
1206,mcf,SHiP-Lite with Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-style PC signature predictor with a streaming detector to adapt cache insertion depth and bypass logic. Each cache line tracks a compact 5-bit PC signature and a 2-bit outcome counter, biasing insertion toward MRU for PCs with recent hits and toward distant RRPV for PCs with frequent misses. A per-set streaming detector identifies monotonic address strides, bypassing blocks to avoid pollution during scan phases (e.g., LBM, MILC). This hybrid approach improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, astar) by learning reuse per PC, while protecting against streaming-induced pollution. All metadata fits within 64 KiB: 5 bits per line for PC signature, 2 bits per line for outcome counter, 2 bits per line for RRPV, and a small per-set streaming table.",,ChampSim_CRC2/new_policies/002_01_ship_lite_with_streaming_bypass__slsb_t04.cc,0.214312084,0.214312084,0%
1207,milc,SHiP-Lite with Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-style PC signature predictor with a streaming detector to adapt cache insertion depth and bypass logic. Each cache line tracks a compact 5-bit PC signature and a 2-bit outcome counter, biasing insertion toward MRU for PCs with recent hits and toward distant RRPV for PCs with frequent misses. A per-set streaming detector identifies monotonic address strides, bypassing blocks to avoid pollution during scan phases (e.g., LBM, MILC). This hybrid approach improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, astar) by learning reuse per PC, while protecting against streaming-induced pollution. All metadata fits within 64 KiB: 5 bits per line for PC signature, 2 bits per line for outcome counter, 2 bits per line for RRPV, and a small per-set streaming table.",,ChampSim_CRC2/new_policies/002_01_ship_lite_with_streaming_bypass__slsb_t04.cc,0.009520482,0.009520482,0%
1208,omnetpp,SHiP-Lite with Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-style PC signature predictor with a streaming detector to adapt cache insertion depth and bypass logic. Each cache line tracks a compact 5-bit PC signature and a 2-bit outcome counter, biasing insertion toward MRU for PCs with recent hits and toward distant RRPV for PCs with frequent misses. A per-set streaming detector identifies monotonic address strides, bypassing blocks to avoid pollution during scan phases (e.g., LBM, MILC). This hybrid approach improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, astar) by learning reuse per PC, while protecting against streaming-induced pollution. All metadata fits within 64 KiB: 5 bits per line for PC signature, 2 bits per line for outcome counter, 2 bits per line for RRPV, and a small per-set streaming table.",,ChampSim_CRC2/new_policies/002_01_ship_lite_with_streaming_bypass__slsb_t04.cc,0.001151215,0.001151215,0%
1209,all,SHiP-Lite with Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-style PC signature predictor with a streaming detector to adapt cache insertion depth and bypass logic. Each cache line tracks a compact 5-bit PC signature and a 2-bit outcome counter, biasing insertion toward MRU for PCs with recent hits and toward distant RRPV for PCs with frequent misses. A per-set streaming detector identifies monotonic address strides, bypassing blocks to avoid pollution during scan phases (e.g., LBM, MILC). This hybrid approach improves hit rate for pointer-chasing and irregular workloads (MCF, Omnetpp, astar) by learning reuse per PC, while protecting against streaming-induced pollution. All metadata fits within 64 KiB: 5 bits per line for PC signature, 2 bits per line for outcome counter, 2 bits per line for RRPV, and a small per-set streaming table.",,ChampSim_CRC2/new_policies/002_01_ship_lite_with_streaming_bypass__slsb_t04.cc,0.065772324,0.065772324,7%
1210,astar,DRRIP with Streaming Bypass and Dead-Block Decay (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a small PSEL selector and leader sets, optimizing for both recency and scan-heavy phases. A per-set streaming detector identifies monotonic address strides and bypasses cache fills during streaming phases (e.g., LBM, MILC), reducing pollution. Each cache line tracks a 2-bit dead-block counter, decayed on eviction, to further bias insertion depth for blocks with poor reuse. This hybrid approach improves hit rate for irregular workloads (MCF, Omnetpp, astar) by adapting to reuse patterns, while protecting against streaming-induced pollution and dead-blocks. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/003_00_drrip_with_streaming_bypass_and_dead_block_decay__dsd_t02.cc,0.065193164,0.065193164,0%
1211,lbm,DRRIP with Streaming Bypass and Dead-Block Decay (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a small PSEL selector and leader sets, optimizing for both recency and scan-heavy phases. A per-set streaming detector identifies monotonic address strides and bypasses cache fills during streaming phases (e.g., LBM, MILC), reducing pollution. Each cache line tracks a 2-bit dead-block counter, decayed on eviction, to further bias insertion depth for blocks with poor reuse. This hybrid approach improves hit rate for irregular workloads (MCF, Omnetpp, astar) by adapting to reuse patterns, while protecting against streaming-induced pollution and dead-blocks. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/003_00_drrip_with_streaming_bypass_and_dead_block_decay__dsd_t02.cc,0.061206337,0.061206337,0%
1212,mcf,DRRIP with Streaming Bypass and Dead-Block Decay (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a small PSEL selector and leader sets, optimizing for both recency and scan-heavy phases. A per-set streaming detector identifies monotonic address strides and bypasses cache fills during streaming phases (e.g., LBM, MILC), reducing pollution. Each cache line tracks a 2-bit dead-block counter, decayed on eviction, to further bias insertion depth for blocks with poor reuse. This hybrid approach improves hit rate for irregular workloads (MCF, Omnetpp, astar) by adapting to reuse patterns, while protecting against streaming-induced pollution and dead-blocks. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/003_00_drrip_with_streaming_bypass_and_dead_block_decay__dsd_t02.cc,0.219332824,0.219332824,0%
1213,milc,DRRIP with Streaming Bypass and Dead-Block Decay (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a small PSEL selector and leader sets, optimizing for both recency and scan-heavy phases. A per-set streaming detector identifies monotonic address strides and bypasses cache fills during streaming phases (e.g., LBM, MILC), reducing pollution. Each cache line tracks a 2-bit dead-block counter, decayed on eviction, to further bias insertion depth for blocks with poor reuse. This hybrid approach improves hit rate for irregular workloads (MCF, Omnetpp, astar) by adapting to reuse patterns, while protecting against streaming-induced pollution and dead-blocks. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/003_00_drrip_with_streaming_bypass_and_dead_block_decay__dsd_t02.cc,0.010402109,0.010402109,0%
1214,omnetpp,DRRIP with Streaming Bypass and Dead-Block Decay (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a small PSEL selector and leader sets, optimizing for both recency and scan-heavy phases. A per-set streaming detector identifies monotonic address strides and bypasses cache fills during streaming phases (e.g., LBM, MILC), reducing pollution. Each cache line tracks a 2-bit dead-block counter, decayed on eviction, to further bias insertion depth for blocks with poor reuse. This hybrid approach improves hit rate for irregular workloads (MCF, Omnetpp, astar) by adapting to reuse patterns, while protecting against streaming-induced pollution and dead-blocks. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/003_00_drrip_with_streaming_bypass_and_dead_block_decay__dsd_t02.cc,0.011201976,0.011201976,0%
1215,astar,DRRIP with Streaming Bypass and Per-Line Dead-Block Counters (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass policies for diverse workloads. DRRIP dynamically selects between SRRIP (aggressive retention) and BRRIP (conservative retention) using a 10-bit PSEL counter with 64 leader sets, providing robust performance for both regular and irregular access patterns. A streaming detector identifies monotonic address strides, bypassing cache fills during detected scan phases (e.g., LBM, MILC) to prevent pollution. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and reset on hit, allowing the policy to penalize insertion depth for lines with frequent dead-block behavior. This hybrid approach improves hit rate for pointer-chasing and control-dominated workloads (MCF, Omnetpp, astar) by leveraging DRRIP’s adaptivity, while streaming bypass and dead-block counters protect against scan-induced pollution and phase changes. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and global DRRIP state.",,ChampSim_CRC2/new_policies/003_01_drrip_with_streaming_bypass_and_per_line_dead_block_counters__dsd_t04.cc,0.290688032,0.290688032,0%
1216,lbm,DRRIP with Streaming Bypass and Per-Line Dead-Block Counters (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass policies for diverse workloads. DRRIP dynamically selects between SRRIP (aggressive retention) and BRRIP (conservative retention) using a 10-bit PSEL counter with 64 leader sets, providing robust performance for both regular and irregular access patterns. A streaming detector identifies monotonic address strides, bypassing cache fills during detected scan phases (e.g., LBM, MILC) to prevent pollution. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and reset on hit, allowing the policy to penalize insertion depth for lines with frequent dead-block behavior. This hybrid approach improves hit rate for pointer-chasing and control-dominated workloads (MCF, Omnetpp, astar) by leveraging DRRIP’s adaptivity, while streaming bypass and dead-block counters protect against scan-induced pollution and phase changes. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and global DRRIP state.",,ChampSim_CRC2/new_policies/003_01_drrip_with_streaming_bypass_and_per_line_dead_block_counters__dsd_t04.cc,0.250629735,0.250629735,0%
1217,mcf,DRRIP with Streaming Bypass and Per-Line Dead-Block Counters (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass policies for diverse workloads. DRRIP dynamically selects between SRRIP (aggressive retention) and BRRIP (conservative retention) using a 10-bit PSEL counter with 64 leader sets, providing robust performance for both regular and irregular access patterns. A streaming detector identifies monotonic address strides, bypassing cache fills during detected scan phases (e.g., LBM, MILC) to prevent pollution. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and reset on hit, allowing the policy to penalize insertion depth for lines with frequent dead-block behavior. This hybrid approach improves hit rate for pointer-chasing and control-dominated workloads (MCF, Omnetpp, astar) by leveraging DRRIP’s adaptivity, while streaming bypass and dead-block counters protect against scan-induced pollution and phase changes. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and global DRRIP state.",,ChampSim_CRC2/new_policies/003_01_drrip_with_streaming_bypass_and_per_line_dead_block_counters__dsd_t04.cc,0.416168244,0.416168244,0%
1218,milc,DRRIP with Streaming Bypass and Per-Line Dead-Block Counters (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass policies for diverse workloads. DRRIP dynamically selects between SRRIP (aggressive retention) and BRRIP (conservative retention) using a 10-bit PSEL counter with 64 leader sets, providing robust performance for both regular and irregular access patterns. A streaming detector identifies monotonic address strides, bypassing cache fills during detected scan phases (e.g., LBM, MILC) to prevent pollution. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and reset on hit, allowing the policy to penalize insertion depth for lines with frequent dead-block behavior. This hybrid approach improves hit rate for pointer-chasing and control-dominated workloads (MCF, Omnetpp, astar) by leveraging DRRIP’s adaptivity, while streaming bypass and dead-block counters protect against scan-induced pollution and phase changes. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and global DRRIP state.",,ChampSim_CRC2/new_policies/003_01_drrip_with_streaming_bypass_and_per_line_dead_block_counters__dsd_t04.cc,0.185425824,0.185425824,0%
1219,omnetpp,DRRIP with Streaming Bypass and Per-Line Dead-Block Counters (DSD),"DSD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass policies for diverse workloads. DRRIP dynamically selects between SRRIP (aggressive retention) and BRRIP (conservative retention) using a 10-bit PSEL counter with 64 leader sets, providing robust performance for both regular and irregular access patterns. A streaming detector identifies monotonic address strides, bypassing cache fills during detected scan phases (e.g., LBM, MILC) to prevent pollution. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and reset on hit, allowing the policy to penalize insertion depth for lines with frequent dead-block behavior. This hybrid approach improves hit rate for pointer-chasing and control-dominated workloads (MCF, Omnetpp, astar) by leveraging DRRIP’s adaptivity, while streaming bypass and dead-block counters protect against scan-induced pollution and phase changes. All metadata fits within 64 KiB: 2 bits per line for RRPV, 2 bits per line for dead-block counter, a small per-set streaming table, and global DRRIP state.",,ChampSim_CRC2/new_policies/003_01_drrip_with_streaming_bypass_and_per_line_dead_block_counters__dsd_t04.cc,0.776613322,0.776613322,0%
1220,astar,DRRIP with Adaptive Streaming Bypass (DRRIP-ASB),"DRRIP-ASB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector that triggers cache line bypass for scan-like access patterns. DRRIP adapts insertion depth between mostly-MRU (SRRIP) and mostly-LRU (BRRIP) using a 10-bit PSEL counter and 64 leader sets, improving performance for both recency- and non-recency-friendly workloads (e.g., astar, mcf, omnetpp, milc). The streaming detector observes monotonic address strides within each set and, on detection, forces bypass (immediate RRPV eviction) to prevent pollution from large scans (e.g., lbm, milc streaming phases). This policy avoids dependence on PC/outcome predictors, reducing metadata overhead and improving robustness to irregular control flow and pointer-chasing. Metadata use fits within 64 KiB: 2 bits/line for RRPV, 1 bit/line for leader marking, a 10-bit global PSEL, and a 3-byte per-set streaming detector.",,ChampSim_CRC2/new_policies/003_02_drrip_with_adaptive_streaming_bypass__drrip_asb_t07.cc,0.453905264,0.453905264,0%
1221,lbm,DRRIP with Adaptive Streaming Bypass (DRRIP-ASB),"DRRIP-ASB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector that triggers cache line bypass for scan-like access patterns. DRRIP adapts insertion depth between mostly-MRU (SRRIP) and mostly-LRU (BRRIP) using a 10-bit PSEL counter and 64 leader sets, improving performance for both recency- and non-recency-friendly workloads (e.g., astar, mcf, omnetpp, milc). The streaming detector observes monotonic address strides within each set and, on detection, forces bypass (immediate RRPV eviction) to prevent pollution from large scans (e.g., lbm, milc streaming phases). This policy avoids dependence on PC/outcome predictors, reducing metadata overhead and improving robustness to irregular control flow and pointer-chasing. Metadata use fits within 64 KiB: 2 bits/line for RRPV, 1 bit/line for leader marking, a 10-bit global PSEL, and a 3-byte per-set streaming detector.",,ChampSim_CRC2/new_policies/003_02_drrip_with_adaptive_streaming_bypass__drrip_asb_t07.cc,0.433287597,0.433287597,0%
1222,mcf,DRRIP with Adaptive Streaming Bypass (DRRIP-ASB),"DRRIP-ASB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector that triggers cache line bypass for scan-like access patterns. DRRIP adapts insertion depth between mostly-MRU (SRRIP) and mostly-LRU (BRRIP) using a 10-bit PSEL counter and 64 leader sets, improving performance for both recency- and non-recency-friendly workloads (e.g., astar, mcf, omnetpp, milc). The streaming detector observes monotonic address strides within each set and, on detection, forces bypass (immediate RRPV eviction) to prevent pollution from large scans (e.g., lbm, milc streaming phases). This policy avoids dependence on PC/outcome predictors, reducing metadata overhead and improving robustness to irregular control flow and pointer-chasing. Metadata use fits within 64 KiB: 2 bits/line for RRPV, 1 bit/line for leader marking, a 10-bit global PSEL, and a 3-byte per-set streaming detector.",,ChampSim_CRC2/new_policies/003_02_drrip_with_adaptive_streaming_bypass__drrip_asb_t07.cc,0.427407169,0.427407169,0%
1223,milc,DRRIP with Adaptive Streaming Bypass (DRRIP-ASB),"DRRIP-ASB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector that triggers cache line bypass for scan-like access patterns. DRRIP adapts insertion depth between mostly-MRU (SRRIP) and mostly-LRU (BRRIP) using a 10-bit PSEL counter and 64 leader sets, improving performance for both recency- and non-recency-friendly workloads (e.g., astar, mcf, omnetpp, milc). The streaming detector observes monotonic address strides within each set and, on detection, forces bypass (immediate RRPV eviction) to prevent pollution from large scans (e.g., lbm, milc streaming phases). This policy avoids dependence on PC/outcome predictors, reducing metadata overhead and improving robustness to irregular control flow and pointer-chasing. Metadata use fits within 64 KiB: 2 bits/line for RRPV, 1 bit/line for leader marking, a 10-bit global PSEL, and a 3-byte per-set streaming detector.",,ChampSim_CRC2/new_policies/003_02_drrip_with_adaptive_streaming_bypass__drrip_asb_t07.cc,0.318441023,0.318441023,0%
1224,omnetpp,DRRIP with Adaptive Streaming Bypass (DRRIP-ASB),"DRRIP-ASB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector that triggers cache line bypass for scan-like access patterns. DRRIP adapts insertion depth between mostly-MRU (SRRIP) and mostly-LRU (BRRIP) using a 10-bit PSEL counter and 64 leader sets, improving performance for both recency- and non-recency-friendly workloads (e.g., astar, mcf, omnetpp, milc). The streaming detector observes monotonic address strides within each set and, on detection, forces bypass (immediate RRPV eviction) to prevent pollution from large scans (e.g., lbm, milc streaming phases). This policy avoids dependence on PC/outcome predictors, reducing metadata overhead and improving robustness to irregular control flow and pointer-chasing. Metadata use fits within 64 KiB: 2 bits/line for RRPV, 1 bit/line for leader marking, a 10-bit global PSEL, and a 3-byte per-set streaming detector.",,ChampSim_CRC2/new_policies/003_02_drrip_with_adaptive_streaming_bypass__drrip_asb_t07.cc,0.439144413,0.439144413,0%
1225,all,DRRIP with Adaptive Streaming Bypass (DRRIP-ASB),"DRRIP-ASB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector that triggers cache line bypass for scan-like access patterns. DRRIP adapts insertion depth between mostly-MRU (SRRIP) and mostly-LRU (BRRIP) using a 10-bit PSEL counter and 64 leader sets, improving performance for both recency- and non-recency-friendly workloads (e.g., astar, mcf, omnetpp, milc). The streaming detector observes monotonic address strides within each set and, on detection, forces bypass (immediate RRPV eviction) to prevent pollution from large scans (e.g., lbm, milc streaming phases). This policy avoids dependence on PC/outcome predictors, reducing metadata overhead and improving robustness to irregular control flow and pointer-chasing. Metadata use fits within 64 KiB: 2 bits/line for RRPV, 1 bit/line for leader marking, a 10-bit global PSEL, and a 3-byte per-set streaming detector.",,ChampSim_CRC2/new_policies/003_02_drrip_with_adaptive_streaming_bypass__drrip_asb_t07.cc,0.414437093,0.414437093,41%
1226,astar,SHiP-Lite with Streaming-Aware Dead-Block Bypass (SHiP-SA-DBB),"This policy combines SHiP-Lite (Signature-based Hit Predictor) with a set-local streaming detector and a dead-block approximation, achieving improved insertion depth control and adaptive bypassing. SHiP-Lite uses a compact per-PC signature table (6 bits per signature, 2 bits per outcome counter) to bias insertion depth toward blocks whose PC signatures have proven high reuse, directly addressing irregular workloads like astar, omnetpp, and mcf. To further reduce pollution from scan-like or streaming accesses (e.g., lbm, milc), a lightweight streaming detector monitors monotonic address strides at each set and triggers streaming mode. In streaming sets, lines with low dead-block reuse counters are bypassed (not inserted) or inserted at distant RRPV, minimizing cache pollution and improving utilization for phase-changing or scan-dominated workloads. All metadata fits in 64 KiB: 2 bits/line for RRPV, 1 byte/line for dead-block counter (decayed every 4096 fills), 6 bits/line for signature, a 2K-entry SHiP table (2 bits/counter), and 3 bytes/set for streaming detection. This hybrid improves upon DRRIP-ASB by explicitly tracking both PC-based reuse and streaming/dead-block patterns, enabling dynamic adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/004_02_ship_lite_with_streaming_aware_dead_block_bypass__ship_sa_dbb_t07.cc,0.454936463,0.454936463,0%
1227,lbm,SHiP-Lite with Streaming-Aware Dead-Block Bypass (SHiP-SA-DBB),"This policy combines SHiP-Lite (Signature-based Hit Predictor) with a set-local streaming detector and a dead-block approximation, achieving improved insertion depth control and adaptive bypassing. SHiP-Lite uses a compact per-PC signature table (6 bits per signature, 2 bits per outcome counter) to bias insertion depth toward blocks whose PC signatures have proven high reuse, directly addressing irregular workloads like astar, omnetpp, and mcf. To further reduce pollution from scan-like or streaming accesses (e.g., lbm, milc), a lightweight streaming detector monitors monotonic address strides at each set and triggers streaming mode. In streaming sets, lines with low dead-block reuse counters are bypassed (not inserted) or inserted at distant RRPV, minimizing cache pollution and improving utilization for phase-changing or scan-dominated workloads. All metadata fits in 64 KiB: 2 bits/line for RRPV, 1 byte/line for dead-block counter (decayed every 4096 fills), 6 bits/line for signature, a 2K-entry SHiP table (2 bits/counter), and 3 bytes/set for streaming detection. This hybrid improves upon DRRIP-ASB by explicitly tracking both PC-based reuse and streaming/dead-block patterns, enabling dynamic adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/004_02_ship_lite_with_streaming_aware_dead_block_bypass__ship_sa_dbb_t07.cc,0.43992869,0.43992869,0%
1228,mcf,SHiP-Lite with Streaming-Aware Dead-Block Bypass (SHiP-SA-DBB),"This policy combines SHiP-Lite (Signature-based Hit Predictor) with a set-local streaming detector and a dead-block approximation, achieving improved insertion depth control and adaptive bypassing. SHiP-Lite uses a compact per-PC signature table (6 bits per signature, 2 bits per outcome counter) to bias insertion depth toward blocks whose PC signatures have proven high reuse, directly addressing irregular workloads like astar, omnetpp, and mcf. To further reduce pollution from scan-like or streaming accesses (e.g., lbm, milc), a lightweight streaming detector monitors monotonic address strides at each set and triggers streaming mode. In streaming sets, lines with low dead-block reuse counters are bypassed (not inserted) or inserted at distant RRPV, minimizing cache pollution and improving utilization for phase-changing or scan-dominated workloads. All metadata fits in 64 KiB: 2 bits/line for RRPV, 1 byte/line for dead-block counter (decayed every 4096 fills), 6 bits/line for signature, a 2K-entry SHiP table (2 bits/counter), and 3 bytes/set for streaming detection. This hybrid improves upon DRRIP-ASB by explicitly tracking both PC-based reuse and streaming/dead-block patterns, enabling dynamic adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/004_02_ship_lite_with_streaming_aware_dead_block_bypass__ship_sa_dbb_t07.cc,0.402766764,0.402766764,0%
1229,milc,SHiP-Lite with Streaming-Aware Dead-Block Bypass (SHiP-SA-DBB),"This policy combines SHiP-Lite (Signature-based Hit Predictor) with a set-local streaming detector and a dead-block approximation, achieving improved insertion depth control and adaptive bypassing. SHiP-Lite uses a compact per-PC signature table (6 bits per signature, 2 bits per outcome counter) to bias insertion depth toward blocks whose PC signatures have proven high reuse, directly addressing irregular workloads like astar, omnetpp, and mcf. To further reduce pollution from scan-like or streaming accesses (e.g., lbm, milc), a lightweight streaming detector monitors monotonic address strides at each set and triggers streaming mode. In streaming sets, lines with low dead-block reuse counters are bypassed (not inserted) or inserted at distant RRPV, minimizing cache pollution and improving utilization for phase-changing or scan-dominated workloads. All metadata fits in 64 KiB: 2 bits/line for RRPV, 1 byte/line for dead-block counter (decayed every 4096 fills), 6 bits/line for signature, a 2K-entry SHiP table (2 bits/counter), and 3 bytes/set for streaming detection. This hybrid improves upon DRRIP-ASB by explicitly tracking both PC-based reuse and streaming/dead-block patterns, enabling dynamic adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/004_02_ship_lite_with_streaming_aware_dead_block_bypass__ship_sa_dbb_t07.cc,0.321802791,0.321802791,0%
1230,omnetpp,SHiP-Lite with Streaming-Aware Dead-Block Bypass (SHiP-SA-DBB),"This policy combines SHiP-Lite (Signature-based Hit Predictor) with a set-local streaming detector and a dead-block approximation, achieving improved insertion depth control and adaptive bypassing. SHiP-Lite uses a compact per-PC signature table (6 bits per signature, 2 bits per outcome counter) to bias insertion depth toward blocks whose PC signatures have proven high reuse, directly addressing irregular workloads like astar, omnetpp, and mcf. To further reduce pollution from scan-like or streaming accesses (e.g., lbm, milc), a lightweight streaming detector monitors monotonic address strides at each set and triggers streaming mode. In streaming sets, lines with low dead-block reuse counters are bypassed (not inserted) or inserted at distant RRPV, minimizing cache pollution and improving utilization for phase-changing or scan-dominated workloads. All metadata fits in 64 KiB: 2 bits/line for RRPV, 1 byte/line for dead-block counter (decayed every 4096 fills), 6 bits/line for signature, a 2K-entry SHiP table (2 bits/counter), and 3 bytes/set for streaming detection. This hybrid improves upon DRRIP-ASB by explicitly tracking both PC-based reuse and streaming/dead-block patterns, enabling dynamic adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/004_02_ship_lite_with_streaming_aware_dead_block_bypass__ship_sa_dbb_t07.cc,0.459866031,0.459866031,0%
1231,all,SHiP-Lite with Streaming-Aware Dead-Block Bypass (SHiP-SA-DBB),"This policy combines SHiP-Lite (Signature-based Hit Predictor) with a set-local streaming detector and a dead-block approximation, achieving improved insertion depth control and adaptive bypassing. SHiP-Lite uses a compact per-PC signature table (6 bits per signature, 2 bits per outcome counter) to bias insertion depth toward blocks whose PC signatures have proven high reuse, directly addressing irregular workloads like astar, omnetpp, and mcf. To further reduce pollution from scan-like or streaming accesses (e.g., lbm, milc), a lightweight streaming detector monitors monotonic address strides at each set and triggers streaming mode. In streaming sets, lines with low dead-block reuse counters are bypassed (not inserted) or inserted at distant RRPV, minimizing cache pollution and improving utilization for phase-changing or scan-dominated workloads. All metadata fits in 64 KiB: 2 bits/line for RRPV, 1 byte/line for dead-block counter (decayed every 4096 fills), 6 bits/line for signature, a 2K-entry SHiP table (2 bits/counter), and 3 bytes/set for streaming detection. This hybrid improves upon DRRIP-ASB by explicitly tracking both PC-based reuse and streaming/dead-block patterns, enabling dynamic adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/004_02_ship_lite_with_streaming_aware_dead_block_bypass__ship_sa_dbb_t07.cc,0.415860148,0.415860148,42%
1232,astar,DRRIP-LIP Hybrid with Streaming-Triggered Bypass (DRRIP-LIP-STB),"This policy combines Dynamic RRIP (DRRIP) with DIP-style leader sets for insertion depth control and a lightweight streaming detector that triggers aggressive bypassing in streaming phases. DRRIP dynamically chooses between SRRIP and BRRIP insertion policies using a 10-bit PSEL counter and 64 leader sets, adapting to workload locality. For sets detected as streaming (via monotonic address deltas), the policy bypasses cache insertion for blocks with low reuse, minimizing pollution from scan-like accesses (e.g., lbm, milc). This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (astar, mcf, omnetpp) and LIP's resilience against streaming pollution, while the streaming detector ensures phase-aware bypassing. All metadata fits within 64 KiB: 2 bits/line for RRPV, 10 bits for PSEL, 64 bytes for leader set mapping, and 3 bytes/set for streaming detection. This materially changes the insertion depth control and bypass logic, providing robust adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/005_00_drrip_lip_hybrid_with_streaming_triggered_bypass__drrip_lip_stb_t02.cc,0.221438291,0.221438291,0%
1233,lbm,DRRIP-LIP Hybrid with Streaming-Triggered Bypass (DRRIP-LIP-STB),"This policy combines Dynamic RRIP (DRRIP) with DIP-style leader sets for insertion depth control and a lightweight streaming detector that triggers aggressive bypassing in streaming phases. DRRIP dynamically chooses between SRRIP and BRRIP insertion policies using a 10-bit PSEL counter and 64 leader sets, adapting to workload locality. For sets detected as streaming (via monotonic address deltas), the policy bypasses cache insertion for blocks with low reuse, minimizing pollution from scan-like accesses (e.g., lbm, milc). This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (astar, mcf, omnetpp) and LIP's resilience against streaming pollution, while the streaming detector ensures phase-aware bypassing. All metadata fits within 64 KiB: 2 bits/line for RRPV, 10 bits for PSEL, 64 bytes for leader set mapping, and 3 bytes/set for streaming detection. This materially changes the insertion depth control and bypass logic, providing robust adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/005_00_drrip_lip_hybrid_with_streaming_triggered_bypass__drrip_lip_stb_t02.cc,0.111043191,0.111043191,0%
1234,mcf,DRRIP-LIP Hybrid with Streaming-Triggered Bypass (DRRIP-LIP-STB),"This policy combines Dynamic RRIP (DRRIP) with DIP-style leader sets for insertion depth control and a lightweight streaming detector that triggers aggressive bypassing in streaming phases. DRRIP dynamically chooses between SRRIP and BRRIP insertion policies using a 10-bit PSEL counter and 64 leader sets, adapting to workload locality. For sets detected as streaming (via monotonic address deltas), the policy bypasses cache insertion for blocks with low reuse, minimizing pollution from scan-like accesses (e.g., lbm, milc). This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (astar, mcf, omnetpp) and LIP's resilience against streaming pollution, while the streaming detector ensures phase-aware bypassing. All metadata fits within 64 KiB: 2 bits/line for RRPV, 10 bits for PSEL, 64 bytes for leader set mapping, and 3 bytes/set for streaming detection. This materially changes the insertion depth control and bypass logic, providing robust adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/005_00_drrip_lip_hybrid_with_streaming_triggered_bypass__drrip_lip_stb_t02.cc,0.358221314,0.358221314,0%
1235,milc,DRRIP-LIP Hybrid with Streaming-Triggered Bypass (DRRIP-LIP-STB),"This policy combines Dynamic RRIP (DRRIP) with DIP-style leader sets for insertion depth control and a lightweight streaming detector that triggers aggressive bypassing in streaming phases. DRRIP dynamically chooses between SRRIP and BRRIP insertion policies using a 10-bit PSEL counter and 64 leader sets, adapting to workload locality. For sets detected as streaming (via monotonic address deltas), the policy bypasses cache insertion for blocks with low reuse, minimizing pollution from scan-like accesses (e.g., lbm, milc). This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (astar, mcf, omnetpp) and LIP's resilience against streaming pollution, while the streaming detector ensures phase-aware bypassing. All metadata fits within 64 KiB: 2 bits/line for RRPV, 10 bits for PSEL, 64 bytes for leader set mapping, and 3 bytes/set for streaming detection. This materially changes the insertion depth control and bypass logic, providing robust adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/005_00_drrip_lip_hybrid_with_streaming_triggered_bypass__drrip_lip_stb_t02.cc,0.0265013,0.0265013,0%
1236,omnetpp,DRRIP-LIP Hybrid with Streaming-Triggered Bypass (DRRIP-LIP-STB),"This policy combines Dynamic RRIP (DRRIP) with DIP-style leader sets for insertion depth control and a lightweight streaming detector that triggers aggressive bypassing in streaming phases. DRRIP dynamically chooses between SRRIP and BRRIP insertion policies using a 10-bit PSEL counter and 64 leader sets, adapting to workload locality. For sets detected as streaming (via monotonic address deltas), the policy bypasses cache insertion for blocks with low reuse, minimizing pollution from scan-like accesses (e.g., lbm, milc). This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (astar, mcf, omnetpp) and LIP's resilience against streaming pollution, while the streaming detector ensures phase-aware bypassing. All metadata fits within 64 KiB: 2 bits/line for RRPV, 10 bits for PSEL, 64 bytes for leader set mapping, and 3 bytes/set for streaming detection. This materially changes the insertion depth control and bypass logic, providing robust adaptation across diverse workloads.",,ChampSim_CRC2/new_policies/005_00_drrip_lip_hybrid_with_streaming_triggered_bypass__drrip_lip_stb_t02.cc,0.096731862,0.096731862,0%
1237,astar,DRRIP-SHiP Hybrid with Dynamic Streaming Bypass (DSHIP-DSB),"This policy fuses DRRIP (Dynamic RRIP with set-dueling) and SHiP-lite (PC signature-based reuse prediction), using set-dueling to select between SRRIP and BRRIP insertion depths globally, while SHiP-lite locally biases insertion depth per line. Additionally, a dynamic streaming detector tracks monotonic address strides per set, triggering aggressive bypass (no fill) for blocks with low SHiP reuse scores in streaming sets. This hybrid approach improves upon prior designs by combining global adaptability (DRRIP) with fine-grained PC-based reuse prediction (SHiP), and by using SHiP counters rather than dead-block counters to guide bypass decisions in streaming regions. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By leveraging both global and local predictors, the policy adapts to workload phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), achieving higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/005_01_drrip_ship_hybrid_with_dynamic_streaming_bypass__dship_dsb_t04.cc,0.458113333,0.458113333,0%
1238,lbm,DRRIP-SHiP Hybrid with Dynamic Streaming Bypass (DSHIP-DSB),"This policy fuses DRRIP (Dynamic RRIP with set-dueling) and SHiP-lite (PC signature-based reuse prediction), using set-dueling to select between SRRIP and BRRIP insertion depths globally, while SHiP-lite locally biases insertion depth per line. Additionally, a dynamic streaming detector tracks monotonic address strides per set, triggering aggressive bypass (no fill) for blocks with low SHiP reuse scores in streaming sets. This hybrid approach improves upon prior designs by combining global adaptability (DRRIP) with fine-grained PC-based reuse prediction (SHiP), and by using SHiP counters rather than dead-block counters to guide bypass decisions in streaming regions. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By leveraging both global and local predictors, the policy adapts to workload phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), achieving higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/005_01_drrip_ship_hybrid_with_dynamic_streaming_bypass__dship_dsb_t04.cc,0.438056991,0.438056991,0%
1239,mcf,DRRIP-SHiP Hybrid with Dynamic Streaming Bypass (DSHIP-DSB),"This policy fuses DRRIP (Dynamic RRIP with set-dueling) and SHiP-lite (PC signature-based reuse prediction), using set-dueling to select between SRRIP and BRRIP insertion depths globally, while SHiP-lite locally biases insertion depth per line. Additionally, a dynamic streaming detector tracks monotonic address strides per set, triggering aggressive bypass (no fill) for blocks with low SHiP reuse scores in streaming sets. This hybrid approach improves upon prior designs by combining global adaptability (DRRIP) with fine-grained PC-based reuse prediction (SHiP), and by using SHiP counters rather than dead-block counters to guide bypass decisions in streaming regions. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By leveraging both global and local predictors, the policy adapts to workload phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), achieving higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/005_01_drrip_ship_hybrid_with_dynamic_streaming_bypass__dship_dsb_t04.cc,0.466974286,0.466974286,0%
1240,milc,DRRIP-SHiP Hybrid with Dynamic Streaming Bypass (DSHIP-DSB),"This policy fuses DRRIP (Dynamic RRIP with set-dueling) and SHiP-lite (PC signature-based reuse prediction), using set-dueling to select between SRRIP and BRRIP insertion depths globally, while SHiP-lite locally biases insertion depth per line. Additionally, a dynamic streaming detector tracks monotonic address strides per set, triggering aggressive bypass (no fill) for blocks with low SHiP reuse scores in streaming sets. This hybrid approach improves upon prior designs by combining global adaptability (DRRIP) with fine-grained PC-based reuse prediction (SHiP), and by using SHiP counters rather than dead-block counters to guide bypass decisions in streaming regions. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By leveraging both global and local predictors, the policy adapts to workload phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), achieving higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/005_01_drrip_ship_hybrid_with_dynamic_streaming_bypass__dship_dsb_t04.cc,0.320359964,0.320359964,0%
1241,omnetpp,DRRIP-SHiP Hybrid with Dynamic Streaming Bypass (DSHIP-DSB),"This policy fuses DRRIP (Dynamic RRIP with set-dueling) and SHiP-lite (PC signature-based reuse prediction), using set-dueling to select between SRRIP and BRRIP insertion depths globally, while SHiP-lite locally biases insertion depth per line. Additionally, a dynamic streaming detector tracks monotonic address strides per set, triggering aggressive bypass (no fill) for blocks with low SHiP reuse scores in streaming sets. This hybrid approach improves upon prior designs by combining global adaptability (DRRIP) with fine-grained PC-based reuse prediction (SHiP), and by using SHiP counters rather than dead-block counters to guide bypass decisions in streaming regions. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By leveraging both global and local predictors, the policy adapts to workload phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), achieving higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/005_01_drrip_ship_hybrid_with_dynamic_streaming_bypass__dship_dsb_t04.cc,0.646289017,0.646289017,0%
1242,astar,DRRIP-SHiP Hybrid with Streaming-Phase Adaptive Insertion (DRRIP-SHiP-SPAI),"This policy integrates DRRIP (Dynamic RRIP) set-dueling (SRRIP vs BRRIP) with SHiP-lite PC-based reuse prediction, and augments it with a streaming-phase detector that tracks scan-like accesses per set. DRRIP’s set-dueling (using a compact 10-bit PSEL) dynamically selects between aggressive and conservative insertion depths globally, optimizing for both recency and scan resistance. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depths at fill time, improving reuse prediction for irregular workloads (e.g., astar, mcf, omnetpp). The streaming-phase detector (3 bytes/set) monitors monotonic address strides and, during detected streaming, forces insertions at RRPV=RRPV_MAX (LRU) to minimize cache pollution. Metadata overhead remains under 64 KiB. By combining DRRIP’s global adaptation, SHiP’s fine-grained prediction, and set-local streaming awareness, this policy improves hit rate and adapts more quickly to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/005_02_drrip_ship_hybrid_with_streaming_phase_adaptive_insertion__drrip_ship_spai_t07.cc,0.263206247,0.263206247,0%
1243,lbm,DRRIP-SHiP Hybrid with Streaming-Phase Adaptive Insertion (DRRIP-SHiP-SPAI),"This policy integrates DRRIP (Dynamic RRIP) set-dueling (SRRIP vs BRRIP) with SHiP-lite PC-based reuse prediction, and augments it with a streaming-phase detector that tracks scan-like accesses per set. DRRIP’s set-dueling (using a compact 10-bit PSEL) dynamically selects between aggressive and conservative insertion depths globally, optimizing for both recency and scan resistance. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depths at fill time, improving reuse prediction for irregular workloads (e.g., astar, mcf, omnetpp). The streaming-phase detector (3 bytes/set) monitors monotonic address strides and, during detected streaming, forces insertions at RRPV=RRPV_MAX (LRU) to minimize cache pollution. Metadata overhead remains under 64 KiB. By combining DRRIP’s global adaptation, SHiP’s fine-grained prediction, and set-local streaming awareness, this policy improves hit rate and adapts more quickly to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/005_02_drrip_ship_hybrid_with_streaming_phase_adaptive_insertion__drrip_ship_spai_t07.cc,0.154412892,0.154412892,0%
1244,mcf,DRRIP-SHiP Hybrid with Streaming-Phase Adaptive Insertion (DRRIP-SHiP-SPAI),"This policy integrates DRRIP (Dynamic RRIP) set-dueling (SRRIP vs BRRIP) with SHiP-lite PC-based reuse prediction, and augments it with a streaming-phase detector that tracks scan-like accesses per set. DRRIP’s set-dueling (using a compact 10-bit PSEL) dynamically selects between aggressive and conservative insertion depths globally, optimizing for both recency and scan resistance. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depths at fill time, improving reuse prediction for irregular workloads (e.g., astar, mcf, omnetpp). The streaming-phase detector (3 bytes/set) monitors monotonic address strides and, during detected streaming, forces insertions at RRPV=RRPV_MAX (LRU) to minimize cache pollution. Metadata overhead remains under 64 KiB. By combining DRRIP’s global adaptation, SHiP’s fine-grained prediction, and set-local streaming awareness, this policy improves hit rate and adapts more quickly to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/005_02_drrip_ship_hybrid_with_streaming_phase_adaptive_insertion__drrip_ship_spai_t07.cc,0.489679232,0.489679232,0%
1245,milc,DRRIP-SHiP Hybrid with Streaming-Phase Adaptive Insertion (DRRIP-SHiP-SPAI),"This policy integrates DRRIP (Dynamic RRIP) set-dueling (SRRIP vs BRRIP) with SHiP-lite PC-based reuse prediction, and augments it with a streaming-phase detector that tracks scan-like accesses per set. DRRIP’s set-dueling (using a compact 10-bit PSEL) dynamically selects between aggressive and conservative insertion depths globally, optimizing for both recency and scan resistance. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depths at fill time, improving reuse prediction for irregular workloads (e.g., astar, mcf, omnetpp). The streaming-phase detector (3 bytes/set) monitors monotonic address strides and, during detected streaming, forces insertions at RRPV=RRPV_MAX (LRU) to minimize cache pollution. Metadata overhead remains under 64 KiB. By combining DRRIP’s global adaptation, SHiP’s fine-grained prediction, and set-local streaming awareness, this policy improves hit rate and adapts more quickly to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/005_02_drrip_ship_hybrid_with_streaming_phase_adaptive_insertion__drrip_ship_spai_t07.cc,0.02954083,0.02954083,0%
1246,omnetpp,DRRIP-SHiP Hybrid with Streaming-Phase Adaptive Insertion (DRRIP-SHiP-SPAI),"This policy integrates DRRIP (Dynamic RRIP) set-dueling (SRRIP vs BRRIP) with SHiP-lite PC-based reuse prediction, and augments it with a streaming-phase detector that tracks scan-like accesses per set. DRRIP’s set-dueling (using a compact 10-bit PSEL) dynamically selects between aggressive and conservative insertion depths globally, optimizing for both recency and scan resistance. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depths at fill time, improving reuse prediction for irregular workloads (e.g., astar, mcf, omnetpp). The streaming-phase detector (3 bytes/set) monitors monotonic address strides and, during detected streaming, forces insertions at RRPV=RRPV_MAX (LRU) to minimize cache pollution. Metadata overhead remains under 64 KiB. By combining DRRIP’s global adaptation, SHiP’s fine-grained prediction, and set-local streaming awareness, this policy improves hit rate and adapts more quickly to phase changes and workload diversity.",,ChampSim_CRC2/new_policies/005_02_drrip_ship_hybrid_with_streaming_phase_adaptive_insertion__drrip_ship_spai_t07.cc,0.723308818,0.723308818,0%
1247,all,DRRIP-SHiP Hybrid with Dynamic Streaming Bypass (DSHIP-DSB),"This policy fuses DRRIP (Dynamic RRIP with set-dueling) and SHiP-lite (PC signature-based reuse prediction), using set-dueling to select between SRRIP and BRRIP insertion depths globally, while SHiP-lite locally biases insertion depth per line. Additionally, a dynamic streaming detector tracks monotonic address strides per set, triggering aggressive bypass (no fill) for blocks with low SHiP reuse scores in streaming sets. This hybrid approach improves upon prior designs by combining global adaptability (DRRIP) with fine-grained PC-based reuse prediction (SHiP), and by using SHiP counters rather than dead-block counters to guide bypass decisions in streaming regions. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By leveraging both global and local predictors, the policy adapts to workload phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), achieving higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/005_01_drrip_ship_hybrid_with_dynamic_streaming_bypass__dship_dsb_t04.cc,0.465958718,0.465958718,47%
1248,astar,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"SLIP-ASB combines SHiP-lite’s PC-based reuse prediction with LIP (Low Insertion Position) insertion depth control, using set-dueling to adapt between LIP and BIP (Bimodal Insertion Policy) globally. Instead of DRRIP, this design leverages LIP’s tendency to evict dead-on-arrival blocks quickly, which benefits workloads like LBM and OMNETPP with streaming or low-reuse patterns. SHiP-lite locally biases insertion depth: blocks with high signature reuse are inserted at MRU, while others follow the global LIP/BIP policy. The streaming detector is enhanced to track both monotonic address strides and bursty streaming phases, triggering bypass (no fill) for blocks with low SHiP reuse in detected streaming sets. Metadata remains compact: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By switching to LIP/BIP, the policy more aggressively evicts non-reused blocks, improving performance for memory-bound and streaming workloads, while SHiP and adaptive streaming bypass preserve hit rates for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/006_00_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t02.cc,0.35404825,0.35404825,0%
1249,lbm,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"SLIP-ASB combines SHiP-lite’s PC-based reuse prediction with LIP (Low Insertion Position) insertion depth control, using set-dueling to adapt between LIP and BIP (Bimodal Insertion Policy) globally. Instead of DRRIP, this design leverages LIP’s tendency to evict dead-on-arrival blocks quickly, which benefits workloads like LBM and OMNETPP with streaming or low-reuse patterns. SHiP-lite locally biases insertion depth: blocks with high signature reuse are inserted at MRU, while others follow the global LIP/BIP policy. The streaming detector is enhanced to track both monotonic address strides and bursty streaming phases, triggering bypass (no fill) for blocks with low SHiP reuse in detected streaming sets. Metadata remains compact: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By switching to LIP/BIP, the policy more aggressively evicts non-reused blocks, improving performance for memory-bound and streaming workloads, while SHiP and adaptive streaming bypass preserve hit rates for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/006_00_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t02.cc,0.350215841,0.350215841,0%
1250,mcf,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"SLIP-ASB combines SHiP-lite’s PC-based reuse prediction with LIP (Low Insertion Position) insertion depth control, using set-dueling to adapt between LIP and BIP (Bimodal Insertion Policy) globally. Instead of DRRIP, this design leverages LIP’s tendency to evict dead-on-arrival blocks quickly, which benefits workloads like LBM and OMNETPP with streaming or low-reuse patterns. SHiP-lite locally biases insertion depth: blocks with high signature reuse are inserted at MRU, while others follow the global LIP/BIP policy. The streaming detector is enhanced to track both monotonic address strides and bursty streaming phases, triggering bypass (no fill) for blocks with low SHiP reuse in detected streaming sets. Metadata remains compact: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By switching to LIP/BIP, the policy more aggressively evicts non-reused blocks, improving performance for memory-bound and streaming workloads, while SHiP and adaptive streaming bypass preserve hit rates for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/006_00_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t02.cc,0.490336428,0.490336428,0%
1251,milc,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"SLIP-ASB combines SHiP-lite’s PC-based reuse prediction with LIP (Low Insertion Position) insertion depth control, using set-dueling to adapt between LIP and BIP (Bimodal Insertion Policy) globally. Instead of DRRIP, this design leverages LIP’s tendency to evict dead-on-arrival blocks quickly, which benefits workloads like LBM and OMNETPP with streaming or low-reuse patterns. SHiP-lite locally biases insertion depth: blocks with high signature reuse are inserted at MRU, while others follow the global LIP/BIP policy. The streaming detector is enhanced to track both monotonic address strides and bursty streaming phases, triggering bypass (no fill) for blocks with low SHiP reuse in detected streaming sets. Metadata remains compact: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By switching to LIP/BIP, the policy more aggressively evicts non-reused blocks, improving performance for memory-bound and streaming workloads, while SHiP and adaptive streaming bypass preserve hit rates for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/006_00_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t02.cc,0.241352093,0.241352093,0%
1252,omnetpp,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"SLIP-ASB combines SHiP-lite’s PC-based reuse prediction with LIP (Low Insertion Position) insertion depth control, using set-dueling to adapt between LIP and BIP (Bimodal Insertion Policy) globally. Instead of DRRIP, this design leverages LIP’s tendency to evict dead-on-arrival blocks quickly, which benefits workloads like LBM and OMNETPP with streaming or low-reuse patterns. SHiP-lite locally biases insertion depth: blocks with high signature reuse are inserted at MRU, while others follow the global LIP/BIP policy. The streaming detector is enhanced to track both monotonic address strides and bursty streaming phases, triggering bypass (no fill) for blocks with low SHiP reuse in detected streaming sets. Metadata remains compact: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, and a 10-bit PSEL counter for set-dueling. By switching to LIP/BIP, the policy more aggressively evicts non-reused blocks, improving performance for memory-bound and streaming workloads, while SHiP and adaptive streaming bypass preserve hit rates for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/006_00_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t02.cc,0.484446857,0.484446857,0%
1253,astar,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"This policy synergistically combines SHiP-lite's PC-based reuse prediction with LIP (Low Insertion Position) for leader sets, using set-dueling to select between SHiP-biased MRU insertion and LIP's LRU insertion globally. The streaming detector is enhanced to track both monotonic address strides and short-term reuse via a tiny per-set reuse counter. Blocks in streaming sets with low SHiP reuse and low recent reuse are aggressively bypassed, while others are inserted according to the selected policy. This approach improves performance by leveraging SHiP's fine-grained reuse prediction for irregular workloads (MCF, OMNETPP, ASTAR), LIP's dead-block filtering for streaming scans (LBM), and adaptive bypass for phase changes (MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, 1 bit/set for recent reuse, and a 10-bit PSEL counter for set-dueling. By diversifying both insertion depth control and streaming logic, the policy achieves higher hit rates and lower pollution across all workloads.",,ChampSim_CRC2/new_policies/006_01_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t04.cc,0.045532183,0.045532183,0%
1254,lbm,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"This policy synergistically combines SHiP-lite's PC-based reuse prediction with LIP (Low Insertion Position) for leader sets, using set-dueling to select between SHiP-biased MRU insertion and LIP's LRU insertion globally. The streaming detector is enhanced to track both monotonic address strides and short-term reuse via a tiny per-set reuse counter. Blocks in streaming sets with low SHiP reuse and low recent reuse are aggressively bypassed, while others are inserted according to the selected policy. This approach improves performance by leveraging SHiP's fine-grained reuse prediction for irregular workloads (MCF, OMNETPP, ASTAR), LIP's dead-block filtering for streaming scans (LBM), and adaptive bypass for phase changes (MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, 1 bit/set for recent reuse, and a 10-bit PSEL counter for set-dueling. By diversifying both insertion depth control and streaming logic, the policy achieves higher hit rates and lower pollution across all workloads.",,ChampSim_CRC2/new_policies/006_01_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t04.cc,0.063015119,0.063015119,0%
1255,mcf,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"This policy synergistically combines SHiP-lite's PC-based reuse prediction with LIP (Low Insertion Position) for leader sets, using set-dueling to select between SHiP-biased MRU insertion and LIP's LRU insertion globally. The streaming detector is enhanced to track both monotonic address strides and short-term reuse via a tiny per-set reuse counter. Blocks in streaming sets with low SHiP reuse and low recent reuse are aggressively bypassed, while others are inserted according to the selected policy. This approach improves performance by leveraging SHiP's fine-grained reuse prediction for irregular workloads (MCF, OMNETPP, ASTAR), LIP's dead-block filtering for streaming scans (LBM), and adaptive bypass for phase changes (MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, 1 bit/set for recent reuse, and a 10-bit PSEL counter for set-dueling. By diversifying both insertion depth control and streaming logic, the policy achieves higher hit rates and lower pollution across all workloads.",,ChampSim_CRC2/new_policies/006_01_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t04.cc,0.393611529,0.393611529,0%
1256,milc,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"This policy synergistically combines SHiP-lite's PC-based reuse prediction with LIP (Low Insertion Position) for leader sets, using set-dueling to select between SHiP-biased MRU insertion and LIP's LRU insertion globally. The streaming detector is enhanced to track both monotonic address strides and short-term reuse via a tiny per-set reuse counter. Blocks in streaming sets with low SHiP reuse and low recent reuse are aggressively bypassed, while others are inserted according to the selected policy. This approach improves performance by leveraging SHiP's fine-grained reuse prediction for irregular workloads (MCF, OMNETPP, ASTAR), LIP's dead-block filtering for streaming scans (LBM), and adaptive bypass for phase changes (MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, 1 bit/set for recent reuse, and a 10-bit PSEL counter for set-dueling. By diversifying both insertion depth control and streaming logic, the policy achieves higher hit rates and lower pollution across all workloads.",,ChampSim_CRC2/new_policies/006_01_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t04.cc,0.009933235,0.009933235,0%
1257,omnetpp,SHiP-LIP Hybrid with Adaptive Streaming Bypass (SLIP-ASB),"This policy synergistically combines SHiP-lite's PC-based reuse prediction with LIP (Low Insertion Position) for leader sets, using set-dueling to select between SHiP-biased MRU insertion and LIP's LRU insertion globally. The streaming detector is enhanced to track both monotonic address strides and short-term reuse via a tiny per-set reuse counter. Blocks in streaming sets with low SHiP reuse and low recent reuse are aggressively bypassed, while others are inserted according to the selected policy. This approach improves performance by leveraging SHiP's fine-grained reuse prediction for irregular workloads (MCF, OMNETPP, ASTAR), LIP's dead-block filtering for streaming scans (LBM), and adaptive bypass for phase changes (MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 3 bytes/set for streaming detection, 1 bit/set for recent reuse, and a 10-bit PSEL counter for set-dueling. By diversifying both insertion depth control and streaming logic, the policy achieves higher hit rates and lower pollution across all workloads.",,ChampSim_CRC2/new_policies/006_01_ship_lip_hybrid_with_adaptive_streaming_bypass__slip_asb_t04.cc,0.001151215,0.001151215,0%
1258,astar,SHiP-BIP Hybrid with Streaming-Aware Distant RRPV Insertion (SHIP-BIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with BIP-inspired insertion depth control, and refines streaming handling by inserting streaming-detected blocks at a distant RRPV (not bypassing fills, but making them highly likely to be evicted soon). Specifically, SHiP signatures bias insertion depth: blocks with high predicted reuse are inserted at MRU (RRPV=0), while others use either BIP (RRPV=3, except for rare MRU insertions) or, if a streaming region is detected, always insert at RRPV=3 (never bypass). Streaming detection is improved using a short history of recent address strides per set. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for BIP/SRRIP set-dueling (10-bit PSEL counter). This policy leverages SHiP’s ability to adapt to code locality and BIP’s resistance to cache pollution, while streaming fills are deprioritized rather than bypassed, improving hit rates for workloads like LBM and MILC and retaining adaptability for irregular workloads (MCF, OMNETPP, ASTAR).",,ChampSim_CRC2/new_policies/006_02_ship_bip_hybrid_with_streaming_aware_distant_rrpv_insertion__ship_bip_sdi_t07.cc,0.456040305,0.456040305,0%
1259,lbm,SHiP-BIP Hybrid with Streaming-Aware Distant RRPV Insertion (SHIP-BIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with BIP-inspired insertion depth control, and refines streaming handling by inserting streaming-detected blocks at a distant RRPV (not bypassing fills, but making them highly likely to be evicted soon). Specifically, SHiP signatures bias insertion depth: blocks with high predicted reuse are inserted at MRU (RRPV=0), while others use either BIP (RRPV=3, except for rare MRU insertions) or, if a streaming region is detected, always insert at RRPV=3 (never bypass). Streaming detection is improved using a short history of recent address strides per set. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for BIP/SRRIP set-dueling (10-bit PSEL counter). This policy leverages SHiP’s ability to adapt to code locality and BIP’s resistance to cache pollution, while streaming fills are deprioritized rather than bypassed, improving hit rates for workloads like LBM and MILC and retaining adaptability for irregular workloads (MCF, OMNETPP, ASTAR).",,ChampSim_CRC2/new_policies/006_02_ship_bip_hybrid_with_streaming_aware_distant_rrpv_insertion__ship_bip_sdi_t07.cc,0.435638355,0.435638355,0%
1260,mcf,SHiP-BIP Hybrid with Streaming-Aware Distant RRPV Insertion (SHIP-BIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with BIP-inspired insertion depth control, and refines streaming handling by inserting streaming-detected blocks at a distant RRPV (not bypassing fills, but making them highly likely to be evicted soon). Specifically, SHiP signatures bias insertion depth: blocks with high predicted reuse are inserted at MRU (RRPV=0), while others use either BIP (RRPV=3, except for rare MRU insertions) or, if a streaming region is detected, always insert at RRPV=3 (never bypass). Streaming detection is improved using a short history of recent address strides per set. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for BIP/SRRIP set-dueling (10-bit PSEL counter). This policy leverages SHiP’s ability to adapt to code locality and BIP’s resistance to cache pollution, while streaming fills are deprioritized rather than bypassed, improving hit rates for workloads like LBM and MILC and retaining adaptability for irregular workloads (MCF, OMNETPP, ASTAR).",,ChampSim_CRC2/new_policies/006_02_ship_bip_hybrid_with_streaming_aware_distant_rrpv_insertion__ship_bip_sdi_t07.cc,0.484327792,0.484327792,0%
1261,milc,SHiP-BIP Hybrid with Streaming-Aware Distant RRPV Insertion (SHIP-BIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with BIP-inspired insertion depth control, and refines streaming handling by inserting streaming-detected blocks at a distant RRPV (not bypassing fills, but making them highly likely to be evicted soon). Specifically, SHiP signatures bias insertion depth: blocks with high predicted reuse are inserted at MRU (RRPV=0), while others use either BIP (RRPV=3, except for rare MRU insertions) or, if a streaming region is detected, always insert at RRPV=3 (never bypass). Streaming detection is improved using a short history of recent address strides per set. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for BIP/SRRIP set-dueling (10-bit PSEL counter). This policy leverages SHiP’s ability to adapt to code locality and BIP’s resistance to cache pollution, while streaming fills are deprioritized rather than bypassed, improving hit rates for workloads like LBM and MILC and retaining adaptability for irregular workloads (MCF, OMNETPP, ASTAR).",,ChampSim_CRC2/new_policies/006_02_ship_bip_hybrid_with_streaming_aware_distant_rrpv_insertion__ship_bip_sdi_t07.cc,0.319958073,0.319958073,0%
1262,omnetpp,SHiP-BIP Hybrid with Streaming-Aware Distant RRPV Insertion (SHIP-BIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with BIP-inspired insertion depth control, and refines streaming handling by inserting streaming-detected blocks at a distant RRPV (not bypassing fills, but making them highly likely to be evicted soon). Specifically, SHiP signatures bias insertion depth: blocks with high predicted reuse are inserted at MRU (RRPV=0), while others use either BIP (RRPV=3, except for rare MRU insertions) or, if a streaming region is detected, always insert at RRPV=3 (never bypass). Streaming detection is improved using a short history of recent address strides per set. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for BIP/SRRIP set-dueling (10-bit PSEL counter). This policy leverages SHiP’s ability to adapt to code locality and BIP’s resistance to cache pollution, while streaming fills are deprioritized rather than bypassed, improving hit rates for workloads like LBM and MILC and retaining adaptability for irregular workloads (MCF, OMNETPP, ASTAR).",,ChampSim_CRC2/new_policies/006_02_ship_bip_hybrid_with_streaming_aware_distant_rrpv_insertion__ship_bip_sdi_t07.cc,0.46042672,0.46042672,0%
1263,all,SHiP-BIP Hybrid with Streaming-Aware Distant RRPV Insertion (SHIP-BIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with BIP-inspired insertion depth control, and refines streaming handling by inserting streaming-detected blocks at a distant RRPV (not bypassing fills, but making them highly likely to be evicted soon). Specifically, SHiP signatures bias insertion depth: blocks with high predicted reuse are inserted at MRU (RRPV=0), while others use either BIP (RRPV=3, except for rare MRU insertions) or, if a streaming region is detected, always insert at RRPV=3 (never bypass). Streaming detection is improved using a short history of recent address strides per set. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for BIP/SRRIP set-dueling (10-bit PSEL counter). This policy leverages SHiP’s ability to adapt to code locality and BIP’s resistance to cache pollution, while streaming fills are deprioritized rather than bypassed, improving hit rates for workloads like LBM and MILC and retaining adaptability for irregular workloads (MCF, OMNETPP, ASTAR).",,ChampSim_CRC2/new_policies/006_02_ship_bip_hybrid_with_streaming_aware_distant_rrpv_insertion__ship_bip_sdi_t07.cc,0.431278249,0.431278249,43%
1264,astar,SHiP-DeadBlock Hybrid with Streaming Bypass (SHIP-DB-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-line dead-block approximation and aggressive streaming bypass. On fill, blocks predicted as dead (low SHiP signature counter and low per-line reuse counter) or detected as part of a streaming region are bypassed (not inserted into the cache). Otherwise, insertion depth is biased: blocks with high SHiP counter or high per-line reuse counter are inserted at MRU (RRPV=0), others at distant RRPV (RRPV=3). Streaming detection uses a short history of address strides per set. Per-line 2-bit reuse counters are periodically decayed to approximate dead-block status. This hybrid approach improves performance by reducing pollution from streaming and dead blocks (benefiting LBM, MILC, OMNETPP), while SHiP and dead-block signals adapt to irregular and control-dominated workloads (MCF, ASTAR). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bits/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/007_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.046018547,0.046018547,0%
1265,lbm,SHiP-DeadBlock Hybrid with Streaming Bypass (SHIP-DB-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-line dead-block approximation and aggressive streaming bypass. On fill, blocks predicted as dead (low SHiP signature counter and low per-line reuse counter) or detected as part of a streaming region are bypassed (not inserted into the cache). Otherwise, insertion depth is biased: blocks with high SHiP counter or high per-line reuse counter are inserted at MRU (RRPV=0), others at distant RRPV (RRPV=3). Streaming detection uses a short history of address strides per set. Per-line 2-bit reuse counters are periodically decayed to approximate dead-block status. This hybrid approach improves performance by reducing pollution from streaming and dead blocks (benefiting LBM, MILC, OMNETPP), while SHiP and dead-block signals adapt to irregular and control-dominated workloads (MCF, ASTAR). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bits/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/007_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.068486384,0.068486384,0%
1266,mcf,SHiP-DeadBlock Hybrid with Streaming Bypass (SHIP-DB-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-line dead-block approximation and aggressive streaming bypass. On fill, blocks predicted as dead (low SHiP signature counter and low per-line reuse counter) or detected as part of a streaming region are bypassed (not inserted into the cache). Otherwise, insertion depth is biased: blocks with high SHiP counter or high per-line reuse counter are inserted at MRU (RRPV=0), others at distant RRPV (RRPV=3). Streaming detection uses a short history of address strides per set. Per-line 2-bit reuse counters are periodically decayed to approximate dead-block status. This hybrid approach improves performance by reducing pollution from streaming and dead blocks (benefiting LBM, MILC, OMNETPP), while SHiP and dead-block signals adapt to irregular and control-dominated workloads (MCF, ASTAR). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bits/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/007_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.402029408,0.402029408,0%
1267,milc,SHiP-DeadBlock Hybrid with Streaming Bypass (SHIP-DB-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-line dead-block approximation and aggressive streaming bypass. On fill, blocks predicted as dead (low SHiP signature counter and low per-line reuse counter) or detected as part of a streaming region are bypassed (not inserted into the cache). Otherwise, insertion depth is biased: blocks with high SHiP counter or high per-line reuse counter are inserted at MRU (RRPV=0), others at distant RRPV (RRPV=3). Streaming detection uses a short history of address strides per set. Per-line 2-bit reuse counters are periodically decayed to approximate dead-block status. This hybrid approach improves performance by reducing pollution from streaming and dead blocks (benefiting LBM, MILC, OMNETPP), while SHiP and dead-block signals adapt to irregular and control-dominated workloads (MCF, ASTAR). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bits/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/007_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.009964011,0.009964011,0%
1268,omnetpp,SHiP-DeadBlock Hybrid with Streaming Bypass (SHIP-DB-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-line dead-block approximation and aggressive streaming bypass. On fill, blocks predicted as dead (low SHiP signature counter and low per-line reuse counter) or detected as part of a streaming region are bypassed (not inserted into the cache). Otherwise, insertion depth is biased: blocks with high SHiP counter or high per-line reuse counter are inserted at MRU (RRPV=0), others at distant RRPV (RRPV=3). Streaming detection uses a short history of address strides per set. Per-line 2-bit reuse counters are periodically decayed to approximate dead-block status. This hybrid approach improves performance by reducing pollution from streaming and dead blocks (benefiting LBM, MILC, OMNETPP), while SHiP and dead-block signals adapt to irregular and control-dominated workloads (MCF, ASTAR). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bits/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/007_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.001264547,0.001264547,0%
1269,astar,SRRIP-DBP Hybrid with Streaming Bypass (SRRIP-DBP-SB),"This policy combines SRRIP’s robust recency-based insertion and victim selection with a lightweight per-line dead-block predictor (DBP) and an aggressive streaming detector that fully bypasses streaming-region fills. Each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block status. On fill, lines predicted dead (counter=0) are inserted at distant RRPV (RRPV=3), while reused lines (counter>0) use SRRIP’s default (RRPV=1). Streaming regions, detected via short address stride history per set, are bypassed entirely, preventing pollution from streaming accesses (LBM, MILC). This design improves performance by reducing cache pollution from dead and streaming blocks, while responding quickly to phase changes (MCF, OMNETPP, ASTAR) via the DBP. Metadata fits in 64 KiB: 2 bits/line for RRPV, 2 bits/line for DBP, 2 bytes/set for streaming detection, and 32 leader sets for future extensibility.",,ChampSim_CRC2/new_policies/007_01_srrip_dbp_hybrid_with_streaming_bypass__srrip_dbp_sb_t04.cc,0.045124665,0.045124665,0%
1270,lbm,SRRIP-DBP Hybrid with Streaming Bypass (SRRIP-DBP-SB),"This policy combines SRRIP’s robust recency-based insertion and victim selection with a lightweight per-line dead-block predictor (DBP) and an aggressive streaming detector that fully bypasses streaming-region fills. Each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block status. On fill, lines predicted dead (counter=0) are inserted at distant RRPV (RRPV=3), while reused lines (counter>0) use SRRIP’s default (RRPV=1). Streaming regions, detected via short address stride history per set, are bypassed entirely, preventing pollution from streaming accesses (LBM, MILC). This design improves performance by reducing cache pollution from dead and streaming blocks, while responding quickly to phase changes (MCF, OMNETPP, ASTAR) via the DBP. Metadata fits in 64 KiB: 2 bits/line for RRPV, 2 bits/line for DBP, 2 bytes/set for streaming detection, and 32 leader sets for future extensibility.",,ChampSim_CRC2/new_policies/007_01_srrip_dbp_hybrid_with_streaming_bypass__srrip_dbp_sb_t04.cc,0.058753172,0.058753172,0%
1271,mcf,SRRIP-DBP Hybrid with Streaming Bypass (SRRIP-DBP-SB),"This policy combines SRRIP’s robust recency-based insertion and victim selection with a lightweight per-line dead-block predictor (DBP) and an aggressive streaming detector that fully bypasses streaming-region fills. Each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block status. On fill, lines predicted dead (counter=0) are inserted at distant RRPV (RRPV=3), while reused lines (counter>0) use SRRIP’s default (RRPV=1). Streaming regions, detected via short address stride history per set, are bypassed entirely, preventing pollution from streaming accesses (LBM, MILC). This design improves performance by reducing cache pollution from dead and streaming blocks, while responding quickly to phase changes (MCF, OMNETPP, ASTAR) via the DBP. Metadata fits in 64 KiB: 2 bits/line for RRPV, 2 bits/line for DBP, 2 bytes/set for streaming detection, and 32 leader sets for future extensibility.",,ChampSim_CRC2/new_policies/007_01_srrip_dbp_hybrid_with_streaming_bypass__srrip_dbp_sb_t04.cc,0.214312084,0.214312084,0%
1272,milc,SRRIP-DBP Hybrid with Streaming Bypass (SRRIP-DBP-SB),"This policy combines SRRIP’s robust recency-based insertion and victim selection with a lightweight per-line dead-block predictor (DBP) and an aggressive streaming detector that fully bypasses streaming-region fills. Each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block status. On fill, lines predicted dead (counter=0) are inserted at distant RRPV (RRPV=3), while reused lines (counter>0) use SRRIP’s default (RRPV=1). Streaming regions, detected via short address stride history per set, are bypassed entirely, preventing pollution from streaming accesses (LBM, MILC). This design improves performance by reducing cache pollution from dead and streaming blocks, while responding quickly to phase changes (MCF, OMNETPP, ASTAR) via the DBP. Metadata fits in 64 KiB: 2 bits/line for RRPV, 2 bits/line for DBP, 2 bytes/set for streaming detection, and 32 leader sets for future extensibility.",,ChampSim_CRC2/new_policies/007_01_srrip_dbp_hybrid_with_streaming_bypass__srrip_dbp_sb_t04.cc,0.009520482,0.009520482,0%
1273,omnetpp,SRRIP-DBP Hybrid with Streaming Bypass (SRRIP-DBP-SB),"This policy combines SRRIP’s robust recency-based insertion and victim selection with a lightweight per-line dead-block predictor (DBP) and an aggressive streaming detector that fully bypasses streaming-region fills. Each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block status. On fill, lines predicted dead (counter=0) are inserted at distant RRPV (RRPV=3), while reused lines (counter>0) use SRRIP’s default (RRPV=1). Streaming regions, detected via short address stride history per set, are bypassed entirely, preventing pollution from streaming accesses (LBM, MILC). This design improves performance by reducing cache pollution from dead and streaming blocks, while responding quickly to phase changes (MCF, OMNETPP, ASTAR) via the DBP. Metadata fits in 64 KiB: 2 bits/line for RRPV, 2 bits/line for DBP, 2 bytes/set for streaming detection, and 32 leader sets for future extensibility.",,ChampSim_CRC2/new_policies/007_01_srrip_dbp_hybrid_with_streaming_bypass__srrip_dbp_sb_t04.cc,0.001151215,0.001151215,0%
1274,astar,LRDP: Lightweight Reuse & Dead-block Predictor,"LRDP combines a per-line dead-block predictor with basic PC-based SHiP-lite reuse signatures to guide cache insertion and victim selection. Each line maintains a tiny 2-bit reuse counter that tracks recent hits, decaying periodically to approximate dead blocks. On a fill, the policy checks both the dead-block counter and the SHiP signature: blocks predicted dead (counter=0) are inserted at distant RRPV (max), while blocks with high SHiP reuse or live counters are inserted at MRU. A compact streaming detector bypasses fills in detected streaming regions. Victim selection prefers blocks predicted dead, minimizing cache pollution from one-shot or streaming accesses, while retaining adaptability for irregular and regular workloads. All metadata fits within 64 KiB: 2 bits/line for RRPV, 2 bits/line for dead-block counter, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and periodic decay logic.",,ChampSim_CRC2/new_policies/007_02_lrdp__lightweight_reuse___dead_block_predictor_t07.cc,0.021938653,0.021938653,0%
1275,lbm,LRDP: Lightweight Reuse & Dead-block Predictor,"LRDP combines a per-line dead-block predictor with basic PC-based SHiP-lite reuse signatures to guide cache insertion and victim selection. Each line maintains a tiny 2-bit reuse counter that tracks recent hits, decaying periodically to approximate dead blocks. On a fill, the policy checks both the dead-block counter and the SHiP signature: blocks predicted dead (counter=0) are inserted at distant RRPV (max), while blocks with high SHiP reuse or live counters are inserted at MRU. A compact streaming detector bypasses fills in detected streaming regions. Victim selection prefers blocks predicted dead, minimizing cache pollution from one-shot or streaming accesses, while retaining adaptability for irregular and regular workloads. All metadata fits within 64 KiB: 2 bits/line for RRPV, 2 bits/line for dead-block counter, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and periodic decay logic.",,ChampSim_CRC2/new_policies/007_02_lrdp__lightweight_reuse___dead_block_predictor_t07.cc,0.035078057,0.035078057,0%
1276,mcf,LRDP: Lightweight Reuse & Dead-block Predictor,"LRDP combines a per-line dead-block predictor with basic PC-based SHiP-lite reuse signatures to guide cache insertion and victim selection. Each line maintains a tiny 2-bit reuse counter that tracks recent hits, decaying periodically to approximate dead blocks. On a fill, the policy checks both the dead-block counter and the SHiP signature: blocks predicted dead (counter=0) are inserted at distant RRPV (max), while blocks with high SHiP reuse or live counters are inserted at MRU. A compact streaming detector bypasses fills in detected streaming regions. Victim selection prefers blocks predicted dead, minimizing cache pollution from one-shot or streaming accesses, while retaining adaptability for irregular and regular workloads. All metadata fits within 64 KiB: 2 bits/line for RRPV, 2 bits/line for dead-block counter, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and periodic decay logic.",,ChampSim_CRC2/new_policies/007_02_lrdp__lightweight_reuse___dead_block_predictor_t07.cc,0.115899642,0.115899642,0%
1277,milc,LRDP: Lightweight Reuse & Dead-block Predictor,"LRDP combines a per-line dead-block predictor with basic PC-based SHiP-lite reuse signatures to guide cache insertion and victim selection. Each line maintains a tiny 2-bit reuse counter that tracks recent hits, decaying periodically to approximate dead blocks. On a fill, the policy checks both the dead-block counter and the SHiP signature: blocks predicted dead (counter=0) are inserted at distant RRPV (max), while blocks with high SHiP reuse or live counters are inserted at MRU. A compact streaming detector bypasses fills in detected streaming regions. Victim selection prefers blocks predicted dead, minimizing cache pollution from one-shot or streaming accesses, while retaining adaptability for irregular and regular workloads. All metadata fits within 64 KiB: 2 bits/line for RRPV, 2 bits/line for dead-block counter, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and periodic decay logic.",,ChampSim_CRC2/new_policies/007_02_lrdp__lightweight_reuse___dead_block_predictor_t07.cc,0.012558202,0.012558202,0%
1278,omnetpp,LRDP: Lightweight Reuse & Dead-block Predictor,"LRDP combines a per-line dead-block predictor with basic PC-based SHiP-lite reuse signatures to guide cache insertion and victim selection. Each line maintains a tiny 2-bit reuse counter that tracks recent hits, decaying periodically to approximate dead blocks. On a fill, the policy checks both the dead-block counter and the SHiP signature: blocks predicted dead (counter=0) are inserted at distant RRPV (max), while blocks with high SHiP reuse or live counters are inserted at MRU. A compact streaming detector bypasses fills in detected streaming regions. Victim selection prefers blocks predicted dead, minimizing cache pollution from one-shot or streaming accesses, while retaining adaptability for irregular and regular workloads. All metadata fits within 64 KiB: 2 bits/line for RRPV, 2 bits/line for dead-block counter, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and periodic decay logic.",,ChampSim_CRC2/new_policies/007_02_lrdp__lightweight_reuse___dead_block_predictor_t07.cc,0.001592613,0.001592613,0%
1279,all,SHiP-DeadBlock Hybrid with Streaming Bypass (SHIP-DB-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-line dead-block approximation and aggressive streaming bypass. On fill, blocks predicted as dead (low SHiP signature counter and low per-line reuse counter) or detected as part of a streaming region are bypassed (not inserted into the cache). Otherwise, insertion depth is biased: blocks with high SHiP counter or high per-line reuse counter are inserted at MRU (RRPV=0), others at distant RRPV (RRPV=3). Streaming detection uses a short history of address strides per set. Per-line 2-bit reuse counters are periodically decayed to approximate dead-block status. This hybrid approach improves performance by reducing pollution from streaming and dead blocks (benefiting LBM, MILC, OMNETPP), while SHiP and dead-block signals adapt to irregular and control-dominated workloads (MCF, ASTAR). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bits/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/007_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.105552579,0.105552579,11%
1280,astar,DRRIP-SHiP Hybrid with Streaming-Aware Distant Insert (DRRIP-SHIP-SA),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and a streaming-aware distant insert mechanism. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths using leader sets and a 10-bit PSEL, providing robust baseline performance for both regular and irregular workloads. SHiP-lite augments this by biasing insertion depth toward MRU for blocks with high predicted reuse (based on PC signatures), improving retention for control-dominated and pointer-chasing workloads (ASTAR, MCF, OMNETPP). For sets detected as streaming (via a compact stride detector), all fills are inserted at distant RRPV (RRPV=3), reducing cache pollution from large, regular accesses (LBM, MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BRRIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, and streaming-aware pollution control.",,ChampSim_CRC2/new_policies/008_00_drrip_ship_hybrid_with_streaming_aware_distant_insert__drrip_ship_sa_t02.cc,0.458078782,0.458078782,0%
1281,lbm,DRRIP-SHiP Hybrid with Streaming-Aware Distant Insert (DRRIP-SHIP-SA),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and a streaming-aware distant insert mechanism. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths using leader sets and a 10-bit PSEL, providing robust baseline performance for both regular and irregular workloads. SHiP-lite augments this by biasing insertion depth toward MRU for blocks with high predicted reuse (based on PC signatures), improving retention for control-dominated and pointer-chasing workloads (ASTAR, MCF, OMNETPP). For sets detected as streaming (via a compact stride detector), all fills are inserted at distant RRPV (RRPV=3), reducing cache pollution from large, regular accesses (LBM, MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BRRIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, and streaming-aware pollution control.",,ChampSim_CRC2/new_policies/008_00_drrip_ship_hybrid_with_streaming_aware_distant_insert__drrip_ship_sa_t02.cc,0.438056991,0.438056991,0%
1282,mcf,DRRIP-SHiP Hybrid with Streaming-Aware Distant Insert (DRRIP-SHIP-SA),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and a streaming-aware distant insert mechanism. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths using leader sets and a 10-bit PSEL, providing robust baseline performance for both regular and irregular workloads. SHiP-lite augments this by biasing insertion depth toward MRU for blocks with high predicted reuse (based on PC signatures), improving retention for control-dominated and pointer-chasing workloads (ASTAR, MCF, OMNETPP). For sets detected as streaming (via a compact stride detector), all fills are inserted at distant RRPV (RRPV=3), reducing cache pollution from large, regular accesses (LBM, MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BRRIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, and streaming-aware pollution control.",,ChampSim_CRC2/new_policies/008_00_drrip_ship_hybrid_with_streaming_aware_distant_insert__drrip_ship_sa_t02.cc,0.467001513,0.467001513,0%
1283,milc,DRRIP-SHiP Hybrid with Streaming-Aware Distant Insert (DRRIP-SHIP-SA),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and a streaming-aware distant insert mechanism. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths using leader sets and a 10-bit PSEL, providing robust baseline performance for both regular and irregular workloads. SHiP-lite augments this by biasing insertion depth toward MRU for blocks with high predicted reuse (based on PC signatures), improving retention for control-dominated and pointer-chasing workloads (ASTAR, MCF, OMNETPP). For sets detected as streaming (via a compact stride detector), all fills are inserted at distant RRPV (RRPV=3), reducing cache pollution from large, regular accesses (LBM, MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BRRIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, and streaming-aware pollution control.",,ChampSim_CRC2/new_policies/008_00_drrip_ship_hybrid_with_streaming_aware_distant_insert__drrip_ship_sa_t02.cc,0.312139293,0.312139293,0%
1284,omnetpp,DRRIP-SHiP Hybrid with Streaming-Aware Distant Insert (DRRIP-SHIP-SA),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and a streaming-aware distant insert mechanism. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths using leader sets and a 10-bit PSEL, providing robust baseline performance for both regular and irregular workloads. SHiP-lite augments this by biasing insertion depth toward MRU for blocks with high predicted reuse (based on PC signatures), improving retention for control-dominated and pointer-chasing workloads (ASTAR, MCF, OMNETPP). For sets detected as streaming (via a compact stride detector), all fills are inserted at distant RRPV (RRPV=3), reducing cache pollution from large, regular accesses (LBM, MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BRRIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, and streaming-aware pollution control.",,ChampSim_CRC2/new_policies/008_00_drrip_ship_hybrid_with_streaming_aware_distant_insert__drrip_ship_sa_t02.cc,0.646211475,0.646211475,0%
1285,astar,SHiP-LIP Hybrid with Streaming-aware Distant Insert (SHIP-LIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with LIP-style insertion and a streaming-aware distant insert mechanism. On fill, blocks predicted as dead (low SHiP signature counter) or detected as part of a streaming region are inserted at distant RRPV (RRPV=3), not bypassed. Otherwise, blocks are inserted at LRU (RRPV=RRPV_MAX) to minimize cache pollution from single-use blocks, except for leader sets that use SRRIP for set-dueling. Streaming detection uses a short stride history per set. The SHiP table is indexed by a 6-bit signature and uses 2-bit saturating counters to bias insertion depth. This approach improves performance by combining LIP’s strong protection against scan/streaming pollution (LBM, MILC, OMNETPP) with SHiP’s adaptive PC-based reuse prediction for irregular workloads (MCF, ASTAR). Streaming blocks are not bypassed but inserted at distant RRPV, allowing for rare reuse. Metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/LIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/008_01_ship_lip_hybrid_with_streaming_aware_distant_insert__ship_lip_sdi_t04.cc,0.30694978,0.30694978,0%
1286,lbm,SHiP-LIP Hybrid with Streaming-aware Distant Insert (SHIP-LIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with LIP-style insertion and a streaming-aware distant insert mechanism. On fill, blocks predicted as dead (low SHiP signature counter) or detected as part of a streaming region are inserted at distant RRPV (RRPV=3), not bypassed. Otherwise, blocks are inserted at LRU (RRPV=RRPV_MAX) to minimize cache pollution from single-use blocks, except for leader sets that use SRRIP for set-dueling. Streaming detection uses a short stride history per set. The SHiP table is indexed by a 6-bit signature and uses 2-bit saturating counters to bias insertion depth. This approach improves performance by combining LIP’s strong protection against scan/streaming pollution (LBM, MILC, OMNETPP) with SHiP’s adaptive PC-based reuse prediction for irregular workloads (MCF, ASTAR). Streaming blocks are not bypassed but inserted at distant RRPV, allowing for rare reuse. Metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/LIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/008_01_ship_lip_hybrid_with_streaming_aware_distant_insert__ship_lip_sdi_t04.cc,0.238241322,0.238241322,0%
1287,mcf,SHiP-LIP Hybrid with Streaming-aware Distant Insert (SHIP-LIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with LIP-style insertion and a streaming-aware distant insert mechanism. On fill, blocks predicted as dead (low SHiP signature counter) or detected as part of a streaming region are inserted at distant RRPV (RRPV=3), not bypassed. Otherwise, blocks are inserted at LRU (RRPV=RRPV_MAX) to minimize cache pollution from single-use blocks, except for leader sets that use SRRIP for set-dueling. Streaming detection uses a short stride history per set. The SHiP table is indexed by a 6-bit signature and uses 2-bit saturating counters to bias insertion depth. This approach improves performance by combining LIP’s strong protection against scan/streaming pollution (LBM, MILC, OMNETPP) with SHiP’s adaptive PC-based reuse prediction for irregular workloads (MCF, ASTAR). Streaming blocks are not bypassed but inserted at distant RRPV, allowing for rare reuse. Metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/LIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/008_01_ship_lip_hybrid_with_streaming_aware_distant_insert__ship_lip_sdi_t04.cc,0.504909948,0.504909948,0%
1288,milc,SHiP-LIP Hybrid with Streaming-aware Distant Insert (SHIP-LIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with LIP-style insertion and a streaming-aware distant insert mechanism. On fill, blocks predicted as dead (low SHiP signature counter) or detected as part of a streaming region are inserted at distant RRPV (RRPV=3), not bypassed. Otherwise, blocks are inserted at LRU (RRPV=RRPV_MAX) to minimize cache pollution from single-use blocks, except for leader sets that use SRRIP for set-dueling. Streaming detection uses a short stride history per set. The SHiP table is indexed by a 6-bit signature and uses 2-bit saturating counters to bias insertion depth. This approach improves performance by combining LIP’s strong protection against scan/streaming pollution (LBM, MILC, OMNETPP) with SHiP’s adaptive PC-based reuse prediction for irregular workloads (MCF, ASTAR). Streaming blocks are not bypassed but inserted at distant RRPV, allowing for rare reuse. Metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/LIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/008_01_ship_lip_hybrid_with_streaming_aware_distant_insert__ship_lip_sdi_t04.cc,0.058515029,0.058515029,0%
1289,omnetpp,SHiP-LIP Hybrid with Streaming-aware Distant Insert (SHIP-LIP-SDI),"This policy combines SHiP-lite’s PC-based reuse prediction with LIP-style insertion and a streaming-aware distant insert mechanism. On fill, blocks predicted as dead (low SHiP signature counter) or detected as part of a streaming region are inserted at distant RRPV (RRPV=3), not bypassed. Otherwise, blocks are inserted at LRU (RRPV=RRPV_MAX) to minimize cache pollution from single-use blocks, except for leader sets that use SRRIP for set-dueling. Streaming detection uses a short stride history per set. The SHiP table is indexed by a 6-bit signature and uses 2-bit saturating counters to bias insertion depth. This approach improves performance by combining LIP’s strong protection against scan/streaming pollution (LBM, MILC, OMNETPP) with SHiP’s adaptive PC-based reuse prediction for irregular workloads (MCF, ASTAR). Streaming blocks are not bypassed but inserted at distant RRPV, allowing for rare reuse. Metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/LIP set-dueling (10-bit PSEL).",,ChampSim_CRC2/new_policies/008_01_ship_lip_hybrid_with_streaming_aware_distant_insert__ship_lip_sdi_t04.cc,0.001151215,0.001151215,0%
1290,all,DRRIP-SHiP Hybrid with Streaming-Aware Distant Insert (DRRIP-SHIP-SA),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and a streaming-aware distant insert mechanism. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths using leader sets and a 10-bit PSEL, providing robust baseline performance for both regular and irregular workloads. SHiP-lite augments this by biasing insertion depth toward MRU for blocks with high predicted reuse (based on PC signatures), improving retention for control-dominated and pointer-chasing workloads (ASTAR, MCF, OMNETPP). For sets detected as streaming (via a compact stride detector), all fills are inserted at distant RRPV (RRPV=3), reducing cache pollution from large, regular accesses (LBM, MILC). Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, and 32 leader sets for SRRIP/BRRIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, and streaming-aware pollution control.",,ChampSim_CRC2/new_policies/008_00_drrip_ship_hybrid_with_streaming_aware_distant_insert__drrip_ship_sa_t02.cc,0.464297611,0.464297611,46%
1291,astar,SHiP-LIP Hybrid with Streaming Bypass and Per-Line Dead-Block Counter (SHiP-LIP-SB-DBC),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-aware bypass, and a compact per-line dead-block counter. SHiP-lite uses PC signatures to bias insertion depth toward MRU for predicted-high-reuse blocks, while LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) for other fills, improving retention for irregular and regular workloads. A streaming detector identifies monotonic stride regions and bypasses cache fills for blocks detected as streaming, reducing pollution from workloads like LBM and MILC. Additionally, each cache line maintains a 1-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block status and further bias insertion toward LRU for lines with repeated non-reuse. All metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 1 bit/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, streaming-aware bypass, and dead-block approximation.",,ChampSim_CRC2/new_policies/009_00_ship_lip_hybrid_with_streaming_bypass_and_per_line_dead_block_counter__ship_lip_sb_dbc_t02.cc,0.103762102,0.103762102,0%
1292,lbm,SHiP-LIP Hybrid with Streaming Bypass and Per-Line Dead-Block Counter (SHiP-LIP-SB-DBC),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-aware bypass, and a compact per-line dead-block counter. SHiP-lite uses PC signatures to bias insertion depth toward MRU for predicted-high-reuse blocks, while LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) for other fills, improving retention for irregular and regular workloads. A streaming detector identifies monotonic stride regions and bypasses cache fills for blocks detected as streaming, reducing pollution from workloads like LBM and MILC. Additionally, each cache line maintains a 1-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block status and further bias insertion toward LRU for lines with repeated non-reuse. All metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 1 bit/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, streaming-aware bypass, and dead-block approximation.",,ChampSim_CRC2/new_policies/009_00_ship_lip_hybrid_with_streaming_bypass_and_per_line_dead_block_counter__ship_lip_sb_dbc_t02.cc,0.094219643,0.094219643,0%
1293,mcf,SHiP-LIP Hybrid with Streaming Bypass and Per-Line Dead-Block Counter (SHiP-LIP-SB-DBC),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-aware bypass, and a compact per-line dead-block counter. SHiP-lite uses PC signatures to bias insertion depth toward MRU for predicted-high-reuse blocks, while LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) for other fills, improving retention for irregular and regular workloads. A streaming detector identifies monotonic stride regions and bypasses cache fills for blocks detected as streaming, reducing pollution from workloads like LBM and MILC. Additionally, each cache line maintains a 1-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block status and further bias insertion toward LRU for lines with repeated non-reuse. All metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 1 bit/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, streaming-aware bypass, and dead-block approximation.",,ChampSim_CRC2/new_policies/009_00_ship_lip_hybrid_with_streaming_bypass_and_per_line_dead_block_counter__ship_lip_sb_dbc_t02.cc,0.439924176,0.439924176,0%
1294,milc,SHiP-LIP Hybrid with Streaming Bypass and Per-Line Dead-Block Counter (SHiP-LIP-SB-DBC),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-aware bypass, and a compact per-line dead-block counter. SHiP-lite uses PC signatures to bias insertion depth toward MRU for predicted-high-reuse blocks, while LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) for other fills, improving retention for irregular and regular workloads. A streaming detector identifies monotonic stride regions and bypasses cache fills for blocks detected as streaming, reducing pollution from workloads like LBM and MILC. Additionally, each cache line maintains a 1-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block status and further bias insertion toward LRU for lines with repeated non-reuse. All metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 1 bit/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, streaming-aware bypass, and dead-block approximation.",,ChampSim_CRC2/new_policies/009_00_ship_lip_hybrid_with_streaming_bypass_and_per_line_dead_block_counter__ship_lip_sb_dbc_t02.cc,0.014156716,0.014156716,0%
1295,omnetpp,SHiP-LIP Hybrid with Streaming Bypass and Per-Line Dead-Block Counter (SHiP-LIP-SB-DBC),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-aware bypass, and a compact per-line dead-block counter. SHiP-lite uses PC signatures to bias insertion depth toward MRU for predicted-high-reuse blocks, while LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) for other fills, improving retention for irregular and regular workloads. A streaming detector identifies monotonic stride regions and bypasses cache fills for blocks detected as streaming, reducing pollution from workloads like LBM and MILC. Additionally, each cache line maintains a 1-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block status and further bias insertion toward LRU for lines with repeated non-reuse. All metadata fits within 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 1 bit/line for dead-block counter, 2 bytes/set for streaming detection, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rate by combining adaptive insertion, learned reuse, streaming-aware bypass, and dead-block approximation.",,ChampSim_CRC2/new_policies/009_00_ship_lip_hybrid_with_streaming_bypass_and_per_line_dead_block_counter__ship_lip_sb_dbc_t02.cc,0.039636383,0.039636383,0%
1296,astar,SHiP-LIP Hybrid with Streaming Bypass and Dead-Block Decay (SHiP-LIP-SBDB),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-region bypass, and per-line dead-block approximation. SHiP-lite uses PC signatures to predict block reuse, biasing insertion toward MRU for high-reuse PCs and toward LRU for others. LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between MRU (for high-reuse phases) and LRU (for streaming/pointer-chasing phases) insertion depths. Streaming regions, detected via a compact stride detector, trigger cache bypass for fills to minimize pollution from regular, low-reuse accesses (LBM, MILC). Additionally, each line has a tiny dead-block counter (1 bit), periodically decayed, to identify blocks that are never reused and bias their eviction. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, 1 bit/line dead-block counter, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rates by combining adaptive insertion, learned reuse, streaming bypass, and dead-block tracking, ensuring robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/009_01_ship_lip_hybrid_with_streaming_bypass_and_dead_block_decay__ship_lip_sbdb_t04.cc,0.186944535,0.186944535,0%
1297,lbm,SHiP-LIP Hybrid with Streaming Bypass and Dead-Block Decay (SHiP-LIP-SBDB),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-region bypass, and per-line dead-block approximation. SHiP-lite uses PC signatures to predict block reuse, biasing insertion toward MRU for high-reuse PCs and toward LRU for others. LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between MRU (for high-reuse phases) and LRU (for streaming/pointer-chasing phases) insertion depths. Streaming regions, detected via a compact stride detector, trigger cache bypass for fills to minimize pollution from regular, low-reuse accesses (LBM, MILC). Additionally, each line has a tiny dead-block counter (1 bit), periodically decayed, to identify blocks that are never reused and bias their eviction. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, 1 bit/line dead-block counter, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rates by combining adaptive insertion, learned reuse, streaming bypass, and dead-block tracking, ensuring robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/009_01_ship_lip_hybrid_with_streaming_bypass_and_dead_block_decay__ship_lip_sbdb_t04.cc,0.127744375,0.127744375,0%
1298,mcf,SHiP-LIP Hybrid with Streaming Bypass and Dead-Block Decay (SHiP-LIP-SBDB),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-region bypass, and per-line dead-block approximation. SHiP-lite uses PC signatures to predict block reuse, biasing insertion toward MRU for high-reuse PCs and toward LRU for others. LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between MRU (for high-reuse phases) and LRU (for streaming/pointer-chasing phases) insertion depths. Streaming regions, detected via a compact stride detector, trigger cache bypass for fills to minimize pollution from regular, low-reuse accesses (LBM, MILC). Additionally, each line has a tiny dead-block counter (1 bit), periodically decayed, to identify blocks that are never reused and bias their eviction. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, 1 bit/line dead-block counter, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rates by combining adaptive insertion, learned reuse, streaming bypass, and dead-block tracking, ensuring robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/009_01_ship_lip_hybrid_with_streaming_bypass_and_dead_block_decay__ship_lip_sbdb_t04.cc,0.457710456,0.457710456,0%
1299,milc,SHiP-LIP Hybrid with Streaming Bypass and Dead-Block Decay (SHiP-LIP-SBDB),"This policy combines SHiP-lite PC-based reuse prediction with LIP (Low Insertion Position) set-dueling, streaming-region bypass, and per-line dead-block approximation. SHiP-lite uses PC signatures to predict block reuse, biasing insertion toward MRU for high-reuse PCs and toward LRU for others. LIP set-dueling (with 32 leader sets and a 10-bit PSEL) adaptively chooses between MRU (for high-reuse phases) and LRU (for streaming/pointer-chasing phases) insertion depths. Streaming regions, detected via a compact stride detector, trigger cache bypass for fills to minimize pollution from regular, low-reuse accesses (LBM, MILC). Additionally, each line has a tiny dead-block counter (1 bit), periodically decayed, to identify blocks that are never reused and bias their eviction. Metadata fits in 64 KiB: 2 bits/line for RRPV, 6 bits/line for SHiP signature, 2K-entry SHiP table (2 bits/counter), 2 bytes/set for streaming detection, 1 bit/line dead-block counter, and 32 leader sets for LIP/BIP set-dueling (10-bit PSEL). This hybrid approach improves hit rates by combining adaptive insertion, learned reuse, streaming bypass, and dead-block tracking, ensuring robust performance across diverse workloads.",,ChampSim_CRC2/new_policies/009_01_ship_lip_hybrid_with_streaming_bypass_and_dead_block_decay__ship_lip_sbdb_t04.cc,0.022962121,0.022962121,0%
1300,astar,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to maximize hit rate across diverse workloads: (1) PC signature-based reuse prediction (SHiP-lite) for control-dominated and pointer-chasing codes (ASTAR, MCF, OMNETPP), (2) address-based streaming detection to identify monotonic scans and avoid cache pollution (LBM, MILC), and (3) recency-based distant insertion (SRRIP) for sets not exhibiting strong reuse or streaming. Each cache line is tagged with a 5-bit PC signature and a 2-bit RRPV. A 2K-entry SHiP table (2 bits/counter) tracks reuse by signature. Per-set streaming detectors (2 bytes/set) monitor recent address deltas; if a set is streaming and the SHiP score is low, fills are bypassed. Otherwise, insertion depth is biased by SHiP prediction: high-reuse signatures get MRU (RRPV=0), others get distant (RRPV=2). This hybrid approach adapts to phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), outperforming prior policies by combining signature, address, and recency signals within 64 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_signature_address_streaming_adaptive_replacement__sasar_t02.cc,0.448201782,0.448201782,0%
1301,lbm,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to maximize hit rate across diverse workloads: (1) PC signature-based reuse prediction (SHiP-lite) for control-dominated and pointer-chasing codes (ASTAR, MCF, OMNETPP), (2) address-based streaming detection to identify monotonic scans and avoid cache pollution (LBM, MILC), and (3) recency-based distant insertion (SRRIP) for sets not exhibiting strong reuse or streaming. Each cache line is tagged with a 5-bit PC signature and a 2-bit RRPV. A 2K-entry SHiP table (2 bits/counter) tracks reuse by signature. Per-set streaming detectors (2 bytes/set) monitor recent address deltas; if a set is streaming and the SHiP score is low, fills are bypassed. Otherwise, insertion depth is biased by SHiP prediction: high-reuse signatures get MRU (RRPV=0), others get distant (RRPV=2). This hybrid approach adapts to phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), outperforming prior policies by combining signature, address, and recency signals within 64 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_signature_address_streaming_adaptive_replacement__sasar_t02.cc,0.411767712,0.411767712,0%
1302,mcf,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to maximize hit rate across diverse workloads: (1) PC signature-based reuse prediction (SHiP-lite) for control-dominated and pointer-chasing codes (ASTAR, MCF, OMNETPP), (2) address-based streaming detection to identify monotonic scans and avoid cache pollution (LBM, MILC), and (3) recency-based distant insertion (SRRIP) for sets not exhibiting strong reuse or streaming. Each cache line is tagged with a 5-bit PC signature and a 2-bit RRPV. A 2K-entry SHiP table (2 bits/counter) tracks reuse by signature. Per-set streaming detectors (2 bytes/set) monitor recent address deltas; if a set is streaming and the SHiP score is low, fills are bypassed. Otherwise, insertion depth is biased by SHiP prediction: high-reuse signatures get MRU (RRPV=0), others get distant (RRPV=2). This hybrid approach adapts to phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), outperforming prior policies by combining signature, address, and recency signals within 64 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_signature_address_streaming_adaptive_replacement__sasar_t02.cc,0.475148614,0.475148614,0%
1303,milc,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to maximize hit rate across diverse workloads: (1) PC signature-based reuse prediction (SHiP-lite) for control-dominated and pointer-chasing codes (ASTAR, MCF, OMNETPP), (2) address-based streaming detection to identify monotonic scans and avoid cache pollution (LBM, MILC), and (3) recency-based distant insertion (SRRIP) for sets not exhibiting strong reuse or streaming. Each cache line is tagged with a 5-bit PC signature and a 2-bit RRPV. A 2K-entry SHiP table (2 bits/counter) tracks reuse by signature. Per-set streaming detectors (2 bytes/set) monitor recent address deltas; if a set is streaming and the SHiP score is low, fills are bypassed. Otherwise, insertion depth is biased by SHiP prediction: high-reuse signatures get MRU (RRPV=0), others get distant (RRPV=2). This hybrid approach adapts to phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), outperforming prior policies by combining signature, address, and recency signals within 64 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_signature_address_streaming_adaptive_replacement__sasar_t02.cc,0.311310166,0.311310166,0%
1304,omnetpp,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to maximize hit rate across diverse workloads: (1) PC signature-based reuse prediction (SHiP-lite) for control-dominated and pointer-chasing codes (ASTAR, MCF, OMNETPP), (2) address-based streaming detection to identify monotonic scans and avoid cache pollution (LBM, MILC), and (3) recency-based distant insertion (SRRIP) for sets not exhibiting strong reuse or streaming. Each cache line is tagged with a 5-bit PC signature and a 2-bit RRPV. A 2K-entry SHiP table (2 bits/counter) tracks reuse by signature. Per-set streaming detectors (2 bytes/set) monitor recent address deltas; if a set is streaming and the SHiP score is low, fills are bypassed. Otherwise, insertion depth is biased by SHiP prediction: high-reuse signatures get MRU (RRPV=0), others get distant (RRPV=2). This hybrid approach adapts to phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), outperforming prior policies by combining signature, address, and recency signals within 64 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_signature_address_streaming_adaptive_replacement__sasar_t02.cc,0.610780729,0.610780729,0%
1305,astar,SHiP-Address Hybrid with Adaptive Streaming Bypass (SAH-Stream),"SAH-Stream combines PC-based reuse prediction (SHiP-lite) with address-bit-based reuse tracking and an adaptive streaming detector to optimize cache insertion and bypass. For each line, both the PC signature and a compact address hash are used to predict reuse: high SHiP or address reuse scores result in MRU insertion, while low scores trigger distant RRPV or bypass in streaming regions. The streaming detector tracks monotonic address deltas per set, activating aggressive bypass when sustained scans are detected (LBM, MILC). Address-bit reuse counters help capture regular stride-based reuse not visible to PC signatures (helpful for stencil codes and phase changes). By fusing these mechanisms, SAH-Stream adapts to pointer-chasing (MCF, OMNETPP), speculative control (ASTAR), and streaming/phase workloads (LBM, MILC), outperforming prior policies by leveraging both code and data locality signals. Total metadata fits in 64 KiB: 2 bits/line RRPV, 6 bits/line SHiP signature, 2K-entry SHiP table (2 bits/counter), 1K-entry address table (2 bits/counter), 2 bytes/set for streaming detection, and 10-bit PSEL counter for set-dueling.",,ChampSim_CRC2/new_policies/000_01_ship_address_hybrid_with_adaptive_streaming_bypass__sah_stream_t04.cc,0.228488356,0.228488356,0%
1306,lbm,SHiP-Address Hybrid with Adaptive Streaming Bypass (SAH-Stream),"SAH-Stream combines PC-based reuse prediction (SHiP-lite) with address-bit-based reuse tracking and an adaptive streaming detector to optimize cache insertion and bypass. For each line, both the PC signature and a compact address hash are used to predict reuse: high SHiP or address reuse scores result in MRU insertion, while low scores trigger distant RRPV or bypass in streaming regions. The streaming detector tracks monotonic address deltas per set, activating aggressive bypass when sustained scans are detected (LBM, MILC). Address-bit reuse counters help capture regular stride-based reuse not visible to PC signatures (helpful for stencil codes and phase changes). By fusing these mechanisms, SAH-Stream adapts to pointer-chasing (MCF, OMNETPP), speculative control (ASTAR), and streaming/phase workloads (LBM, MILC), outperforming prior policies by leveraging both code and data locality signals. Total metadata fits in 64 KiB: 2 bits/line RRPV, 6 bits/line SHiP signature, 2K-entry SHiP table (2 bits/counter), 1K-entry address table (2 bits/counter), 2 bytes/set for streaming detection, and 10-bit PSEL counter for set-dueling.",,ChampSim_CRC2/new_policies/000_01_ship_address_hybrid_with_adaptive_streaming_bypass__sah_stream_t04.cc,0.13630471,0.13630471,0%
1307,mcf,SHiP-Address Hybrid with Adaptive Streaming Bypass (SAH-Stream),"SAH-Stream combines PC-based reuse prediction (SHiP-lite) with address-bit-based reuse tracking and an adaptive streaming detector to optimize cache insertion and bypass. For each line, both the PC signature and a compact address hash are used to predict reuse: high SHiP or address reuse scores result in MRU insertion, while low scores trigger distant RRPV or bypass in streaming regions. The streaming detector tracks monotonic address deltas per set, activating aggressive bypass when sustained scans are detected (LBM, MILC). Address-bit reuse counters help capture regular stride-based reuse not visible to PC signatures (helpful for stencil codes and phase changes). By fusing these mechanisms, SAH-Stream adapts to pointer-chasing (MCF, OMNETPP), speculative control (ASTAR), and streaming/phase workloads (LBM, MILC), outperforming prior policies by leveraging both code and data locality signals. Total metadata fits in 64 KiB: 2 bits/line RRPV, 6 bits/line SHiP signature, 2K-entry SHiP table (2 bits/counter), 1K-entry address table (2 bits/counter), 2 bytes/set for streaming detection, and 10-bit PSEL counter for set-dueling.",,ChampSim_CRC2/new_policies/000_01_ship_address_hybrid_with_adaptive_streaming_bypass__sah_stream_t04.cc,0.439055674,0.439055674,0%
1308,milc,SHiP-Address Hybrid with Adaptive Streaming Bypass (SAH-Stream),"SAH-Stream combines PC-based reuse prediction (SHiP-lite) with address-bit-based reuse tracking and an adaptive streaming detector to optimize cache insertion and bypass. For each line, both the PC signature and a compact address hash are used to predict reuse: high SHiP or address reuse scores result in MRU insertion, while low scores trigger distant RRPV or bypass in streaming regions. The streaming detector tracks monotonic address deltas per set, activating aggressive bypass when sustained scans are detected (LBM, MILC). Address-bit reuse counters help capture regular stride-based reuse not visible to PC signatures (helpful for stencil codes and phase changes). By fusing these mechanisms, SAH-Stream adapts to pointer-chasing (MCF, OMNETPP), speculative control (ASTAR), and streaming/phase workloads (LBM, MILC), outperforming prior policies by leveraging both code and data locality signals. Total metadata fits in 64 KiB: 2 bits/line RRPV, 6 bits/line SHiP signature, 2K-entry SHiP table (2 bits/counter), 1K-entry address table (2 bits/counter), 2 bytes/set for streaming detection, and 10-bit PSEL counter for set-dueling.",,ChampSim_CRC2/new_policies/000_01_ship_address_hybrid_with_adaptive_streaming_bypass__sah_stream_t04.cc,0.044218919,0.044218919,0%
1309,omnetpp,SHiP-Address Hybrid with Adaptive Streaming Bypass (SAH-Stream),"SAH-Stream combines PC-based reuse prediction (SHiP-lite) with address-bit-based reuse tracking and an adaptive streaming detector to optimize cache insertion and bypass. For each line, both the PC signature and a compact address hash are used to predict reuse: high SHiP or address reuse scores result in MRU insertion, while low scores trigger distant RRPV or bypass in streaming regions. The streaming detector tracks monotonic address deltas per set, activating aggressive bypass when sustained scans are detected (LBM, MILC). Address-bit reuse counters help capture regular stride-based reuse not visible to PC signatures (helpful for stencil codes and phase changes). By fusing these mechanisms, SAH-Stream adapts to pointer-chasing (MCF, OMNETPP), speculative control (ASTAR), and streaming/phase workloads (LBM, MILC), outperforming prior policies by leveraging both code and data locality signals. Total metadata fits in 64 KiB: 2 bits/line RRPV, 6 bits/line SHiP signature, 2K-entry SHiP table (2 bits/counter), 1K-entry address table (2 bits/counter), 2 bytes/set for streaming detection, and 10-bit PSEL counter for set-dueling.",,ChampSim_CRC2/new_policies/000_01_ship_address_hybrid_with_adaptive_streaming_bypass__sah_stream_t04.cc,0.343193219,0.343193219,0%
1310,astar,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to adaptively capture reuse and avoid cache pollution across diverse workloads: (1) a SHiP-lite 5-bit PC signature table (2K entries, 2 bits/counter) for fine-grained reuse prediction, (2) a compact streaming detector per set (2 bytes/set) that tracks address stride monotonicity and triggers bypass for detected streaming phases, and (3) a 6-bit address hash per line (no extra storage, computed on fill) to bias insertion depth for lines with recurring patterns even if PC reuse is weak. On fill, the policy uses set-dueling (10-bit PSEL) to select between SRRIP and BRRIP baseline insertion depths, then overrides insertion depth to MRU for blocks with either high SHiP reuse or recurring address hashes, and to distant RRPV (or bypass) for streaming sets. This approach maximizes hit rate by combining PC-based, address-based, and streaming-based signals: PC signatures help irregular/pointer-chasing/control-dominated workloads (MCF, ASTAR, Omnet++), streaming detection curtails pollution for scan/stencil codes (LBM, MILC), and address-hash reuse rescue blocks missed by PC-only heuristics. All metadata fits within 64 KiB.",,ChampSim_CRC2/new_policies/000_02_signature_address_streaming_adaptive_replacement__sasar_t07.cc,0.427078166,0.427078166,0%
1311,lbm,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to adaptively capture reuse and avoid cache pollution across diverse workloads: (1) a SHiP-lite 5-bit PC signature table (2K entries, 2 bits/counter) for fine-grained reuse prediction, (2) a compact streaming detector per set (2 bytes/set) that tracks address stride monotonicity and triggers bypass for detected streaming phases, and (3) a 6-bit address hash per line (no extra storage, computed on fill) to bias insertion depth for lines with recurring patterns even if PC reuse is weak. On fill, the policy uses set-dueling (10-bit PSEL) to select between SRRIP and BRRIP baseline insertion depths, then overrides insertion depth to MRU for blocks with either high SHiP reuse or recurring address hashes, and to distant RRPV (or bypass) for streaming sets. This approach maximizes hit rate by combining PC-based, address-based, and streaming-based signals: PC signatures help irregular/pointer-chasing/control-dominated workloads (MCF, ASTAR, Omnet++), streaming detection curtails pollution for scan/stencil codes (LBM, MILC), and address-hash reuse rescue blocks missed by PC-only heuristics. All metadata fits within 64 KiB.",,ChampSim_CRC2/new_policies/000_02_signature_address_streaming_adaptive_replacement__sasar_t07.cc,0.40662951,0.40662951,0%
1312,mcf,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to adaptively capture reuse and avoid cache pollution across diverse workloads: (1) a SHiP-lite 5-bit PC signature table (2K entries, 2 bits/counter) for fine-grained reuse prediction, (2) a compact streaming detector per set (2 bytes/set) that tracks address stride monotonicity and triggers bypass for detected streaming phases, and (3) a 6-bit address hash per line (no extra storage, computed on fill) to bias insertion depth for lines with recurring patterns even if PC reuse is weak. On fill, the policy uses set-dueling (10-bit PSEL) to select between SRRIP and BRRIP baseline insertion depths, then overrides insertion depth to MRU for blocks with either high SHiP reuse or recurring address hashes, and to distant RRPV (or bypass) for streaming sets. This approach maximizes hit rate by combining PC-based, address-based, and streaming-based signals: PC signatures help irregular/pointer-chasing/control-dominated workloads (MCF, ASTAR, Omnet++), streaming detection curtails pollution for scan/stencil codes (LBM, MILC), and address-hash reuse rescue blocks missed by PC-only heuristics. All metadata fits within 64 KiB.",,ChampSim_CRC2/new_policies/000_02_signature_address_streaming_adaptive_replacement__sasar_t07.cc,0.497811244,0.497811244,0%
1313,milc,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to adaptively capture reuse and avoid cache pollution across diverse workloads: (1) a SHiP-lite 5-bit PC signature table (2K entries, 2 bits/counter) for fine-grained reuse prediction, (2) a compact streaming detector per set (2 bytes/set) that tracks address stride monotonicity and triggers bypass for detected streaming phases, and (3) a 6-bit address hash per line (no extra storage, computed on fill) to bias insertion depth for lines with recurring patterns even if PC reuse is weak. On fill, the policy uses set-dueling (10-bit PSEL) to select between SRRIP and BRRIP baseline insertion depths, then overrides insertion depth to MRU for blocks with either high SHiP reuse or recurring address hashes, and to distant RRPV (or bypass) for streaming sets. This approach maximizes hit rate by combining PC-based, address-based, and streaming-based signals: PC signatures help irregular/pointer-chasing/control-dominated workloads (MCF, ASTAR, Omnet++), streaming detection curtails pollution for scan/stencil codes (LBM, MILC), and address-hash reuse rescue blocks missed by PC-only heuristics. All metadata fits within 64 KiB.",,ChampSim_CRC2/new_policies/000_02_signature_address_streaming_adaptive_replacement__sasar_t07.cc,0.307365475,0.307365475,0%
1314,omnetpp,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to adaptively capture reuse and avoid cache pollution across diverse workloads: (1) a SHiP-lite 5-bit PC signature table (2K entries, 2 bits/counter) for fine-grained reuse prediction, (2) a compact streaming detector per set (2 bytes/set) that tracks address stride monotonicity and triggers bypass for detected streaming phases, and (3) a 6-bit address hash per line (no extra storage, computed on fill) to bias insertion depth for lines with recurring patterns even if PC reuse is weak. On fill, the policy uses set-dueling (10-bit PSEL) to select between SRRIP and BRRIP baseline insertion depths, then overrides insertion depth to MRU for blocks with either high SHiP reuse or recurring address hashes, and to distant RRPV (or bypass) for streaming sets. This approach maximizes hit rate by combining PC-based, address-based, and streaming-based signals: PC signatures help irregular/pointer-chasing/control-dominated workloads (MCF, ASTAR, Omnet++), streaming detection curtails pollution for scan/stencil codes (LBM, MILC), and address-hash reuse rescue blocks missed by PC-only heuristics. All metadata fits within 64 KiB.",,ChampSim_CRC2/new_policies/000_02_signature_address_streaming_adaptive_replacement__sasar_t07.cc,0.552200703,0.552200703,0%
1315,all,Signature-Address Streaming Adaptive Replacement (SASAR),"SASAR combines three compact mechanisms to maximize hit rate across diverse workloads: (1) PC signature-based reuse prediction (SHiP-lite) for control-dominated and pointer-chasing codes (ASTAR, MCF, OMNETPP), (2) address-based streaming detection to identify monotonic scans and avoid cache pollution (LBM, MILC), and (3) recency-based distant insertion (SRRIP) for sets not exhibiting strong reuse or streaming. Each cache line is tagged with a 5-bit PC signature and a 2-bit RRPV. A 2K-entry SHiP table (2 bits/counter) tracks reuse by signature. Per-set streaming detectors (2 bytes/set) monitor recent address deltas; if a set is streaming and the SHiP score is low, fills are bypassed. Otherwise, insertion depth is biased by SHiP prediction: high-reuse signatures get MRU (RRPV=0), others get distant (RRPV=2). This hybrid approach adapts to phase changes (MILC), streaming scans (LBM), and irregular access (MCF, OMNETPP, ASTAR), outperforming prior policies by combining signature, address, and recency signals within 64 KiB metadata.",,ChampSim_CRC2/new_policies/000_00_signature_address_streaming_adaptive_replacement__sasar_t02.cc,0.4514418,0.4514418,45%
1316,astar,SHiP-Deadblock Hybrid Replacement (SDHR),"SDHR combines PC signature-based reuse prediction (SHiP-lite) with a per-line dead-block approximation to improve cache hit rates across diverse workloads. Each cache line is tagged with a 6-bit PC signature and a 1-bit dead-block indicator, while a compact SHiP table (2K entries, 2 bits/counter) tracks signature reuse. On fill, insertion depth is biased by both SHiP prediction and dead-block status: lines with high-reuse signatures or recently reused lines are inserted at MRU (RRPV=0), while lines predicted dead or with low-reuse signatures are inserted at distant (RRPV=2). The dead-block bit is set on eviction if the line was not reused, and decayed periodically. This hybrid approach enables rapid adaptation to streaming scans (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), outperforming pure recency or signature-only policies by leveraging both temporal and contextual reuse signals, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_00_ship_deadblock_hybrid_replacement__sdhr_t02.cc,0.454947094,0.454947094,0%
1317,lbm,SHiP-Deadblock Hybrid Replacement (SDHR),"SDHR combines PC signature-based reuse prediction (SHiP-lite) with a per-line dead-block approximation to improve cache hit rates across diverse workloads. Each cache line is tagged with a 6-bit PC signature and a 1-bit dead-block indicator, while a compact SHiP table (2K entries, 2 bits/counter) tracks signature reuse. On fill, insertion depth is biased by both SHiP prediction and dead-block status: lines with high-reuse signatures or recently reused lines are inserted at MRU (RRPV=0), while lines predicted dead or with low-reuse signatures are inserted at distant (RRPV=2). The dead-block bit is set on eviction if the line was not reused, and decayed periodically. This hybrid approach enables rapid adaptation to streaming scans (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), outperforming pure recency or signature-only policies by leveraging both temporal and contextual reuse signals, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_00_ship_deadblock_hybrid_replacement__sdhr_t02.cc,0.43992869,0.43992869,0%
1318,mcf,SHiP-Deadblock Hybrid Replacement (SDHR),"SDHR combines PC signature-based reuse prediction (SHiP-lite) with a per-line dead-block approximation to improve cache hit rates across diverse workloads. Each cache line is tagged with a 6-bit PC signature and a 1-bit dead-block indicator, while a compact SHiP table (2K entries, 2 bits/counter) tracks signature reuse. On fill, insertion depth is biased by both SHiP prediction and dead-block status: lines with high-reuse signatures or recently reused lines are inserted at MRU (RRPV=0), while lines predicted dead or with low-reuse signatures are inserted at distant (RRPV=2). The dead-block bit is set on eviction if the line was not reused, and decayed periodically. This hybrid approach enables rapid adaptation to streaming scans (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), outperforming pure recency or signature-only policies by leveraging both temporal and contextual reuse signals, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_00_ship_deadblock_hybrid_replacement__sdhr_t02.cc,0.402761442,0.402761442,0%
1319,milc,SHiP-Deadblock Hybrid Replacement (SDHR),"SDHR combines PC signature-based reuse prediction (SHiP-lite) with a per-line dead-block approximation to improve cache hit rates across diverse workloads. Each cache line is tagged with a 6-bit PC signature and a 1-bit dead-block indicator, while a compact SHiP table (2K entries, 2 bits/counter) tracks signature reuse. On fill, insertion depth is biased by both SHiP prediction and dead-block status: lines with high-reuse signatures or recently reused lines are inserted at MRU (RRPV=0), while lines predicted dead or with low-reuse signatures are inserted at distant (RRPV=2). The dead-block bit is set on eviction if the line was not reused, and decayed periodically. This hybrid approach enables rapid adaptation to streaming scans (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), outperforming pure recency or signature-only policies by leveraging both temporal and contextual reuse signals, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_00_ship_deadblock_hybrid_replacement__sdhr_t02.cc,0.321811842,0.321811842,0%
1320,omnetpp,SHiP-Deadblock Hybrid Replacement (SDHR),"SDHR combines PC signature-based reuse prediction (SHiP-lite) with a per-line dead-block approximation to improve cache hit rates across diverse workloads. Each cache line is tagged with a 6-bit PC signature and a 1-bit dead-block indicator, while a compact SHiP table (2K entries, 2 bits/counter) tracks signature reuse. On fill, insertion depth is biased by both SHiP prediction and dead-block status: lines with high-reuse signatures or recently reused lines are inserted at MRU (RRPV=0), while lines predicted dead or with low-reuse signatures are inserted at distant (RRPV=2). The dead-block bit is set on eviction if the line was not reused, and decayed periodically. This hybrid approach enables rapid adaptation to streaming scans (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), outperforming pure recency or signature-only policies by leveraging both temporal and contextual reuse signals, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_00_ship_deadblock_hybrid_replacement__sdhr_t02.cc,0.460104622,0.460104622,0%
1321,astar,BRRIP-SHiP Dead-Block Hybrid (BSDH),"BSDH combines three mechanisms to improve hit rate across diverse workloads: (1) BRRIP/DRRIP set-dueling with a 10-bit PSEL selector, dynamically choosing between frequent distant (BRRIP) and recency-biased (SRRIP) insertion depths, (2) SHiP-lite signature-based reuse prediction (5-bit PC signature, 2-bit counter per signature) to bias insertion depth for control-dominated and pointer-chasing codes, and (3) per-line dead-block approximation using a 1-bit dead flag and periodic decay to better identify blocks unlikely to be reused (especially in streaming or sparse workloads). On fill, insertion depth is determined by the winning policy (BRRIP or SRRIP) but is overridden to MRU if the SHiP counter is high or to distant if the block is marked dead. Streaming detection is implicit via dead-block flags, reducing unnecessary metadata. This hybrid approach adapts to both regular and irregular access patterns, improves handling of dead blocks, and dynamically tunes insertion depth, yielding higher hit rates within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_01_brrip_ship_dead_block_hybrid__bsdh_t04.cc,0.045124665,0.045124665,0%
1322,lbm,BRRIP-SHiP Dead-Block Hybrid (BSDH),"BSDH combines three mechanisms to improve hit rate across diverse workloads: (1) BRRIP/DRRIP set-dueling with a 10-bit PSEL selector, dynamically choosing between frequent distant (BRRIP) and recency-biased (SRRIP) insertion depths, (2) SHiP-lite signature-based reuse prediction (5-bit PC signature, 2-bit counter per signature) to bias insertion depth for control-dominated and pointer-chasing codes, and (3) per-line dead-block approximation using a 1-bit dead flag and periodic decay to better identify blocks unlikely to be reused (especially in streaming or sparse workloads). On fill, insertion depth is determined by the winning policy (BRRIP or SRRIP) but is overridden to MRU if the SHiP counter is high or to distant if the block is marked dead. Streaming detection is implicit via dead-block flags, reducing unnecessary metadata. This hybrid approach adapts to both regular and irregular access patterns, improves handling of dead blocks, and dynamically tunes insertion depth, yielding higher hit rates within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_01_brrip_ship_dead_block_hybrid__bsdh_t04.cc,0.058753172,0.058753172,0%
1323,mcf,BRRIP-SHiP Dead-Block Hybrid (BSDH),"BSDH combines three mechanisms to improve hit rate across diverse workloads: (1) BRRIP/DRRIP set-dueling with a 10-bit PSEL selector, dynamically choosing between frequent distant (BRRIP) and recency-biased (SRRIP) insertion depths, (2) SHiP-lite signature-based reuse prediction (5-bit PC signature, 2-bit counter per signature) to bias insertion depth for control-dominated and pointer-chasing codes, and (3) per-line dead-block approximation using a 1-bit dead flag and periodic decay to better identify blocks unlikely to be reused (especially in streaming or sparse workloads). On fill, insertion depth is determined by the winning policy (BRRIP or SRRIP) but is overridden to MRU if the SHiP counter is high or to distant if the block is marked dead. Streaming detection is implicit via dead-block flags, reducing unnecessary metadata. This hybrid approach adapts to both regular and irregular access patterns, improves handling of dead blocks, and dynamically tunes insertion depth, yielding higher hit rates within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_01_brrip_ship_dead_block_hybrid__bsdh_t04.cc,0.214312084,0.214312084,0%
1324,milc,BRRIP-SHiP Dead-Block Hybrid (BSDH),"BSDH combines three mechanisms to improve hit rate across diverse workloads: (1) BRRIP/DRRIP set-dueling with a 10-bit PSEL selector, dynamically choosing between frequent distant (BRRIP) and recency-biased (SRRIP) insertion depths, (2) SHiP-lite signature-based reuse prediction (5-bit PC signature, 2-bit counter per signature) to bias insertion depth for control-dominated and pointer-chasing codes, and (3) per-line dead-block approximation using a 1-bit dead flag and periodic decay to better identify blocks unlikely to be reused (especially in streaming or sparse workloads). On fill, insertion depth is determined by the winning policy (BRRIP or SRRIP) but is overridden to MRU if the SHiP counter is high or to distant if the block is marked dead. Streaming detection is implicit via dead-block flags, reducing unnecessary metadata. This hybrid approach adapts to both regular and irregular access patterns, improves handling of dead blocks, and dynamically tunes insertion depth, yielding higher hit rates within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_01_brrip_ship_dead_block_hybrid__bsdh_t04.cc,0.009520482,0.009520482,0%
1325,omnetpp,BRRIP-SHiP Dead-Block Hybrid (BSDH),"BSDH combines three mechanisms to improve hit rate across diverse workloads: (1) BRRIP/DRRIP set-dueling with a 10-bit PSEL selector, dynamically choosing between frequent distant (BRRIP) and recency-biased (SRRIP) insertion depths, (2) SHiP-lite signature-based reuse prediction (5-bit PC signature, 2-bit counter per signature) to bias insertion depth for control-dominated and pointer-chasing codes, and (3) per-line dead-block approximation using a 1-bit dead flag and periodic decay to better identify blocks unlikely to be reused (especially in streaming or sparse workloads). On fill, insertion depth is determined by the winning policy (BRRIP or SRRIP) but is overridden to MRU if the SHiP counter is high or to distant if the block is marked dead. Streaming detection is implicit via dead-block flags, reducing unnecessary metadata. This hybrid approach adapts to both regular and irregular access patterns, improves handling of dead blocks, and dynamically tunes insertion depth, yielding higher hit rates within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_01_brrip_ship_dead_block_hybrid__bsdh_t04.cc,0.001151215,0.001151215,0%
1326,astar,Dynamic Streaming-Aware Dead-Block Replacement (DSA-DBR),"DSA-DBR fuses dead-block prediction with lightweight streaming detection and SRRIP-based recency to boost hit rates across diverse workloads. Each cache line tracks a 2-bit RRPV and a 1-bit dead-block flag that is set on eviction if the block was not reused. Per-set streaming detectors (2 bytes/set) monitor address stride patterns to identify sequential scans; when detected, fills are bypassed if the victim is dead. On regular accesses, blocks predicted as dead are inserted at distant RRPV (2); otherwise, at MRU (0). This approach improves over SASAR by directly tracking actual reuse (not just PC signatures), leveraging dead-blocks to limit pollution, and using streaming detection for selective bypass. The compact metadata (≈32 KiB) enables precise adaptation to irregular pointer-chasing (MCF, OMNETPP), streaming scans (LBM, MILC), and control-dominated phases (ASTAR), yielding higher hit rates by combining address-based reuse and streaming signals.",,ChampSim_CRC2/new_policies/001_02_dynamic_streaming_aware_dead_block_replacement__dsa_dbr_t07.cc,0.045124665,0.045124665,0%
1327,lbm,Dynamic Streaming-Aware Dead-Block Replacement (DSA-DBR),"DSA-DBR fuses dead-block prediction with lightweight streaming detection and SRRIP-based recency to boost hit rates across diverse workloads. Each cache line tracks a 2-bit RRPV and a 1-bit dead-block flag that is set on eviction if the block was not reused. Per-set streaming detectors (2 bytes/set) monitor address stride patterns to identify sequential scans; when detected, fills are bypassed if the victim is dead. On regular accesses, blocks predicted as dead are inserted at distant RRPV (2); otherwise, at MRU (0). This approach improves over SASAR by directly tracking actual reuse (not just PC signatures), leveraging dead-blocks to limit pollution, and using streaming detection for selective bypass. The compact metadata (≈32 KiB) enables precise adaptation to irregular pointer-chasing (MCF, OMNETPP), streaming scans (LBM, MILC), and control-dominated phases (ASTAR), yielding higher hit rates by combining address-based reuse and streaming signals.",,ChampSim_CRC2/new_policies/001_02_dynamic_streaming_aware_dead_block_replacement__dsa_dbr_t07.cc,0.058753172,0.058753172,0%
1328,mcf,Dynamic Streaming-Aware Dead-Block Replacement (DSA-DBR),"DSA-DBR fuses dead-block prediction with lightweight streaming detection and SRRIP-based recency to boost hit rates across diverse workloads. Each cache line tracks a 2-bit RRPV and a 1-bit dead-block flag that is set on eviction if the block was not reused. Per-set streaming detectors (2 bytes/set) monitor address stride patterns to identify sequential scans; when detected, fills are bypassed if the victim is dead. On regular accesses, blocks predicted as dead are inserted at distant RRPV (2); otherwise, at MRU (0). This approach improves over SASAR by directly tracking actual reuse (not just PC signatures), leveraging dead-blocks to limit pollution, and using streaming detection for selective bypass. The compact metadata (≈32 KiB) enables precise adaptation to irregular pointer-chasing (MCF, OMNETPP), streaming scans (LBM, MILC), and control-dominated phases (ASTAR), yielding higher hit rates by combining address-based reuse and streaming signals.",,ChampSim_CRC2/new_policies/001_02_dynamic_streaming_aware_dead_block_replacement__dsa_dbr_t07.cc,0.214312084,0.214312084,0%
1329,milc,Dynamic Streaming-Aware Dead-Block Replacement (DSA-DBR),"DSA-DBR fuses dead-block prediction with lightweight streaming detection and SRRIP-based recency to boost hit rates across diverse workloads. Each cache line tracks a 2-bit RRPV and a 1-bit dead-block flag that is set on eviction if the block was not reused. Per-set streaming detectors (2 bytes/set) monitor address stride patterns to identify sequential scans; when detected, fills are bypassed if the victim is dead. On regular accesses, blocks predicted as dead are inserted at distant RRPV (2); otherwise, at MRU (0). This approach improves over SASAR by directly tracking actual reuse (not just PC signatures), leveraging dead-blocks to limit pollution, and using streaming detection for selective bypass. The compact metadata (≈32 KiB) enables precise adaptation to irregular pointer-chasing (MCF, OMNETPP), streaming scans (LBM, MILC), and control-dominated phases (ASTAR), yielding higher hit rates by combining address-based reuse and streaming signals.",,ChampSim_CRC2/new_policies/001_02_dynamic_streaming_aware_dead_block_replacement__dsa_dbr_t07.cc,0.009520482,0.009520482,0%
1330,omnetpp,Dynamic Streaming-Aware Dead-Block Replacement (DSA-DBR),"DSA-DBR fuses dead-block prediction with lightweight streaming detection and SRRIP-based recency to boost hit rates across diverse workloads. Each cache line tracks a 2-bit RRPV and a 1-bit dead-block flag that is set on eviction if the block was not reused. Per-set streaming detectors (2 bytes/set) monitor address stride patterns to identify sequential scans; when detected, fills are bypassed if the victim is dead. On regular accesses, blocks predicted as dead are inserted at distant RRPV (2); otherwise, at MRU (0). This approach improves over SASAR by directly tracking actual reuse (not just PC signatures), leveraging dead-blocks to limit pollution, and using streaming detection for selective bypass. The compact metadata (≈32 KiB) enables precise adaptation to irregular pointer-chasing (MCF, OMNETPP), streaming scans (LBM, MILC), and control-dominated phases (ASTAR), yielding higher hit rates by combining address-based reuse and streaming signals.",,ChampSim_CRC2/new_policies/001_02_dynamic_streaming_aware_dead_block_replacement__dsa_dbr_t07.cc,0.001151215,0.001151215,0%
1331,all,SHiP-Deadblock Hybrid Replacement (SDHR),"SDHR combines PC signature-based reuse prediction (SHiP-lite) with a per-line dead-block approximation to improve cache hit rates across diverse workloads. Each cache line is tagged with a 6-bit PC signature and a 1-bit dead-block indicator, while a compact SHiP table (2K entries, 2 bits/counter) tracks signature reuse. On fill, insertion depth is biased by both SHiP prediction and dead-block status: lines with high-reuse signatures or recently reused lines are inserted at MRU (RRPV=0), while lines predicted dead or with low-reuse signatures are inserted at distant (RRPV=2). The dead-block bit is set on eviction if the line was not reused, and decayed periodically. This hybrid approach enables rapid adaptation to streaming scans (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), outperforming pure recency or signature-only policies by leveraging both temporal and contextual reuse signals, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/001_00_ship_deadblock_hybrid_replacement__sdhr_t02.cc,0.415910738,0.415910738,42%
1332,astar,SHiP-Streaming Adaptive Replacement (SSAR),"SSAR combines SHiP-lite signature-based reuse prediction with a lightweight streaming detector that monitors address deltas to identify streaming or scan phases. For each cache fill, the policy uses both the PC signature’s reuse history and the recent address stride pattern: if a block is predicted as streaming (near-monotonic address deltas), it is inserted at distant RRPV or bypassed with low reuse signatures; otherwise, SHiP guides insertion depth (MRU for high-reuse, distant for low-reuse). This dual mechanism enables rapid adaptation to streaming workloads (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), reducing cache pollution and improving hit rates. Metadata includes per-line RRPV, 6-bit PC signature, a compact SHiP table, and a small per-set stride history (8 bits/set), all fitting within 64 KiB.",,ChampSim_CRC2/new_policies/002_00_ship_streaming_adaptive_replacement__ssar_t02.cc,0.433164361,0.433164361,0%
1333,lbm,SHiP-Streaming Adaptive Replacement (SSAR),"SSAR combines SHiP-lite signature-based reuse prediction with a lightweight streaming detector that monitors address deltas to identify streaming or scan phases. For each cache fill, the policy uses both the PC signature’s reuse history and the recent address stride pattern: if a block is predicted as streaming (near-monotonic address deltas), it is inserted at distant RRPV or bypassed with low reuse signatures; otherwise, SHiP guides insertion depth (MRU for high-reuse, distant for low-reuse). This dual mechanism enables rapid adaptation to streaming workloads (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), reducing cache pollution and improving hit rates. Metadata includes per-line RRPV, 6-bit PC signature, a compact SHiP table, and a small per-set stride history (8 bits/set), all fitting within 64 KiB.",,ChampSim_CRC2/new_policies/002_00_ship_streaming_adaptive_replacement__ssar_t02.cc,0.411601504,0.411601504,0%
1334,mcf,SHiP-Streaming Adaptive Replacement (SSAR),"SSAR combines SHiP-lite signature-based reuse prediction with a lightweight streaming detector that monitors address deltas to identify streaming or scan phases. For each cache fill, the policy uses both the PC signature’s reuse history and the recent address stride pattern: if a block is predicted as streaming (near-monotonic address deltas), it is inserted at distant RRPV or bypassed with low reuse signatures; otherwise, SHiP guides insertion depth (MRU for high-reuse, distant for low-reuse). This dual mechanism enables rapid adaptation to streaming workloads (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), reducing cache pollution and improving hit rates. Metadata includes per-line RRPV, 6-bit PC signature, a compact SHiP table, and a small per-set stride history (8 bits/set), all fitting within 64 KiB.",,ChampSim_CRC2/new_policies/002_00_ship_streaming_adaptive_replacement__ssar_t02.cc,0.475650813,0.475650813,0%
1335,milc,SHiP-Streaming Adaptive Replacement (SSAR),"SSAR combines SHiP-lite signature-based reuse prediction with a lightweight streaming detector that monitors address deltas to identify streaming or scan phases. For each cache fill, the policy uses both the PC signature’s reuse history and the recent address stride pattern: if a block is predicted as streaming (near-monotonic address deltas), it is inserted at distant RRPV or bypassed with low reuse signatures; otherwise, SHiP guides insertion depth (MRU for high-reuse, distant for low-reuse). This dual mechanism enables rapid adaptation to streaming workloads (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), reducing cache pollution and improving hit rates. Metadata includes per-line RRPV, 6-bit PC signature, a compact SHiP table, and a small per-set stride history (8 bits/set), all fitting within 64 KiB.",,ChampSim_CRC2/new_policies/002_00_ship_streaming_adaptive_replacement__ssar_t02.cc,0.311315597,0.311315597,0%
1336,omnetpp,SHiP-Streaming Adaptive Replacement (SSAR),"SSAR combines SHiP-lite signature-based reuse prediction with a lightweight streaming detector that monitors address deltas to identify streaming or scan phases. For each cache fill, the policy uses both the PC signature’s reuse history and the recent address stride pattern: if a block is predicted as streaming (near-monotonic address deltas), it is inserted at distant RRPV or bypassed with low reuse signatures; otherwise, SHiP guides insertion depth (MRU for high-reuse, distant for low-reuse). This dual mechanism enables rapid adaptation to streaming workloads (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), reducing cache pollution and improving hit rates. Metadata includes per-line RRPV, 6-bit PC signature, a compact SHiP table, and a small per-set stride history (8 bits/set), all fitting within 64 KiB.",,ChampSim_CRC2/new_policies/002_00_ship_streaming_adaptive_replacement__ssar_t02.cc,0.611001426,0.611001426,0%
1337,astar,SDRRIP-Streaming Hybrid Replacement (SDRRIP-SH),"SDRRIP-SH combines dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to better distinguish between temporal and streaming access patterns. DRRIP uses set-dueling (32 leader sets) and a 10-bit PSEL counter to adapt between SRRIP (favoring recency) and BRRIP (favoring distant insertions), improving performance on workloads with phase changes (MILC, ASTAR, OMNETPP). A per-set streaming detector tracks recent address deltas (8 bits per set); when monotonic or near-monotonic strides are detected (as in LBM, MILC streaming phases), new fills are inserted at the most distant RRPV (bypassed if possible), reducing cache pollution. The hybrid approach enables rapid adaptation between reuse- and streaming-dominated phases, outperforming pure recency or signature-only policies, while keeping metadata under 64 KiB. No per-line dead-block bits are used, and the insertion policy is diversified by combining DRRIP set-dueling with streaming-aware bypass.",,ChampSim_CRC2/new_policies/002_01_sdrrip_streaming_hybrid_replacement__sdrrip_sh_t04.cc,0.454923174,0.454923174,0%
1338,lbm,SDRRIP-Streaming Hybrid Replacement (SDRRIP-SH),"SDRRIP-SH combines dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to better distinguish between temporal and streaming access patterns. DRRIP uses set-dueling (32 leader sets) and a 10-bit PSEL counter to adapt between SRRIP (favoring recency) and BRRIP (favoring distant insertions), improving performance on workloads with phase changes (MILC, ASTAR, OMNETPP). A per-set streaming detector tracks recent address deltas (8 bits per set); when monotonic or near-monotonic strides are detected (as in LBM, MILC streaming phases), new fills are inserted at the most distant RRPV (bypassed if possible), reducing cache pollution. The hybrid approach enables rapid adaptation between reuse- and streaming-dominated phases, outperforming pure recency or signature-only policies, while keeping metadata under 64 KiB. No per-line dead-block bits are used, and the insertion policy is diversified by combining DRRIP set-dueling with streaming-aware bypass.",,ChampSim_CRC2/new_policies/002_01_sdrrip_streaming_hybrid_replacement__sdrrip_sh_t04.cc,0.414402104,0.414402104,0%
1339,mcf,SDRRIP-Streaming Hybrid Replacement (SDRRIP-SH),"SDRRIP-SH combines dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to better distinguish between temporal and streaming access patterns. DRRIP uses set-dueling (32 leader sets) and a 10-bit PSEL counter to adapt between SRRIP (favoring recency) and BRRIP (favoring distant insertions), improving performance on workloads with phase changes (MILC, ASTAR, OMNETPP). A per-set streaming detector tracks recent address deltas (8 bits per set); when monotonic or near-monotonic strides are detected (as in LBM, MILC streaming phases), new fills are inserted at the most distant RRPV (bypassed if possible), reducing cache pollution. The hybrid approach enables rapid adaptation between reuse- and streaming-dominated phases, outperforming pure recency or signature-only policies, while keeping metadata under 64 KiB. No per-line dead-block bits are used, and the insertion policy is diversified by combining DRRIP set-dueling with streaming-aware bypass.",,ChampSim_CRC2/new_policies/002_01_sdrrip_streaming_hybrid_replacement__sdrrip_sh_t04.cc,0.455752944,0.455752944,0%
1340,milc,SDRRIP-Streaming Hybrid Replacement (SDRRIP-SH),"SDRRIP-SH combines dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to better distinguish between temporal and streaming access patterns. DRRIP uses set-dueling (32 leader sets) and a 10-bit PSEL counter to adapt between SRRIP (favoring recency) and BRRIP (favoring distant insertions), improving performance on workloads with phase changes (MILC, ASTAR, OMNETPP). A per-set streaming detector tracks recent address deltas (8 bits per set); when monotonic or near-monotonic strides are detected (as in LBM, MILC streaming phases), new fills are inserted at the most distant RRPV (bypassed if possible), reducing cache pollution. The hybrid approach enables rapid adaptation between reuse- and streaming-dominated phases, outperforming pure recency or signature-only policies, while keeping metadata under 64 KiB. No per-line dead-block bits are used, and the insertion policy is diversified by combining DRRIP set-dueling with streaming-aware bypass.",,ChampSim_CRC2/new_policies/002_01_sdrrip_streaming_hybrid_replacement__sdrrip_sh_t04.cc,0.307720298,0.307720298,0%
1341,omnetpp,SDRRIP-Streaming Hybrid Replacement (SDRRIP-SH),"SDRRIP-SH combines dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to better distinguish between temporal and streaming access patterns. DRRIP uses set-dueling (32 leader sets) and a 10-bit PSEL counter to adapt between SRRIP (favoring recency) and BRRIP (favoring distant insertions), improving performance on workloads with phase changes (MILC, ASTAR, OMNETPP). A per-set streaming detector tracks recent address deltas (8 bits per set); when monotonic or near-monotonic strides are detected (as in LBM, MILC streaming phases), new fills are inserted at the most distant RRPV (bypassed if possible), reducing cache pollution. The hybrid approach enables rapid adaptation between reuse- and streaming-dominated phases, outperforming pure recency or signature-only policies, while keeping metadata under 64 KiB. No per-line dead-block bits are used, and the insertion policy is diversified by combining DRRIP set-dueling with streaming-aware bypass.",,ChampSim_CRC2/new_policies/002_01_sdrrip_streaming_hybrid_replacement__sdrrip_sh_t04.cc,0.464118914,0.464118914,0%
1342,astar,Adaptive Streaming-Aware DRRIP (ASAD),"ASAD augments DRRIP (Dynamic RRIP) with a compact streaming access detector to better handle workloads that exhibit high degrees of sequential or monotonic memory accesses (e.g., LBM, MILC), while still adapting to control- and pointer-heavy patterns (e.g., MCF, OMNETPP, ASTAR). It uses set-dueling (DIP-style) to dynamically select between SRRIP and BRRIP insertion policies based on a 10-bit PSEL counter. For each line, ASAD tracks a small recent address delta history (4 bits/line) and detects streaming when most deltas are consistent, triggering distant insertion or bypass. The streaming detector is lightweight (~16 KiB for all sets/ways), leaving room for DRRIP and PSEL metadata. This hybrid approach reduces cache pollution from scans, improves hit rates for irregular and temporal reuse, and adapts insertion depth to workload phase changes, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/002_02_adaptive_streaming_aware_drrip__asad_t07.cc,0.426582942,0.426582942,0%
1343,lbm,Adaptive Streaming-Aware DRRIP (ASAD),"ASAD augments DRRIP (Dynamic RRIP) with a compact streaming access detector to better handle workloads that exhibit high degrees of sequential or monotonic memory accesses (e.g., LBM, MILC), while still adapting to control- and pointer-heavy patterns (e.g., MCF, OMNETPP, ASTAR). It uses set-dueling (DIP-style) to dynamically select between SRRIP and BRRIP insertion policies based on a 10-bit PSEL counter. For each line, ASAD tracks a small recent address delta history (4 bits/line) and detects streaming when most deltas are consistent, triggering distant insertion or bypass. The streaming detector is lightweight (~16 KiB for all sets/ways), leaving room for DRRIP and PSEL metadata. This hybrid approach reduces cache pollution from scans, improves hit rates for irregular and temporal reuse, and adapts insertion depth to workload phase changes, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/002_02_adaptive_streaming_aware_drrip__asad_t07.cc,0.406196122,0.406196122,0%
1344,mcf,Adaptive Streaming-Aware DRRIP (ASAD),"ASAD augments DRRIP (Dynamic RRIP) with a compact streaming access detector to better handle workloads that exhibit high degrees of sequential or monotonic memory accesses (e.g., LBM, MILC), while still adapting to control- and pointer-heavy patterns (e.g., MCF, OMNETPP, ASTAR). It uses set-dueling (DIP-style) to dynamically select between SRRIP and BRRIP insertion policies based on a 10-bit PSEL counter. For each line, ASAD tracks a small recent address delta history (4 bits/line) and detects streaming when most deltas are consistent, triggering distant insertion or bypass. The streaming detector is lightweight (~16 KiB for all sets/ways), leaving room for DRRIP and PSEL metadata. This hybrid approach reduces cache pollution from scans, improves hit rates for irregular and temporal reuse, and adapts insertion depth to workload phase changes, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/002_02_adaptive_streaming_aware_drrip__asad_t07.cc,0.457681331,0.457681331,0%
1345,milc,Adaptive Streaming-Aware DRRIP (ASAD),"ASAD augments DRRIP (Dynamic RRIP) with a compact streaming access detector to better handle workloads that exhibit high degrees of sequential or monotonic memory accesses (e.g., LBM, MILC), while still adapting to control- and pointer-heavy patterns (e.g., MCF, OMNETPP, ASTAR). It uses set-dueling (DIP-style) to dynamically select between SRRIP and BRRIP insertion policies based on a 10-bit PSEL counter. For each line, ASAD tracks a small recent address delta history (4 bits/line) and detects streaming when most deltas are consistent, triggering distant insertion or bypass. The streaming detector is lightweight (~16 KiB for all sets/ways), leaving room for DRRIP and PSEL metadata. This hybrid approach reduces cache pollution from scans, improves hit rates for irregular and temporal reuse, and adapts insertion depth to workload phase changes, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/002_02_adaptive_streaming_aware_drrip__asad_t07.cc,0.302540968,0.302540968,0%
1346,omnetpp,Adaptive Streaming-Aware DRRIP (ASAD),"ASAD augments DRRIP (Dynamic RRIP) with a compact streaming access detector to better handle workloads that exhibit high degrees of sequential or monotonic memory accesses (e.g., LBM, MILC), while still adapting to control- and pointer-heavy patterns (e.g., MCF, OMNETPP, ASTAR). It uses set-dueling (DIP-style) to dynamically select between SRRIP and BRRIP insertion policies based on a 10-bit PSEL counter. For each line, ASAD tracks a small recent address delta history (4 bits/line) and detects streaming when most deltas are consistent, triggering distant insertion or bypass. The streaming detector is lightweight (~16 KiB for all sets/ways), leaving room for DRRIP and PSEL metadata. This hybrid approach reduces cache pollution from scans, improves hit rates for irregular and temporal reuse, and adapts insertion depth to workload phase changes, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/002_02_adaptive_streaming_aware_drrip__asad_t07.cc,0.440826479,0.440826479,0%
1347,all,SHiP-Streaming Adaptive Replacement (SSAR),"SSAR combines SHiP-lite signature-based reuse prediction with a lightweight streaming detector that monitors address deltas to identify streaming or scan phases. For each cache fill, the policy uses both the PC signature’s reuse history and the recent address stride pattern: if a block is predicted as streaming (near-monotonic address deltas), it is inserted at distant RRPV or bypassed with low reuse signatures; otherwise, SHiP guides insertion depth (MRU for high-reuse, distant for low-reuse). This dual mechanism enables rapid adaptation to streaming workloads (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated phases (ASTAR), reducing cache pollution and improving hit rates. Metadata includes per-line RRPV, 6-bit PC signature, a compact SHiP table, and a small per-set stride history (8 bits/set), all fitting within 64 KiB.",,ChampSim_CRC2/new_policies/002_00_ship_streaming_adaptive_replacement__ssar_t02.cc,0.44854674,0.44854674,45%
1348,astar,DIP-SHiP Streaming Hybrid (DSSH),"DSSH combines DIP-style set-dueling for insertion depth control (LIP vs BIP) with SHiP-lite PC-based reuse prediction and a streaming detector for scan/bypass phases. Leader sets (32) are used to dynamically select between LIP (always insert at LRU) and BIP (insert mostly at LRU, occasionally at MRU) via a 10-bit PSEL counter, adapting to recency- or frequency-dominated workloads. For non-leader sets, insertion depth is chosen by the winning policy, but further refined by SHiP signature outcome counters (4 bits/signature, 1K entries) to bias toward MRU for high-reuse PCs. A lightweight per-set streaming detector (2 bits/set, 8 bits/set for last stride) identifies scan phases and triggers bypass or distant insertion. This hybrid approach improves performance by rapidly adapting to streaming (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated (ASTAR) phases, while leveraging both recency and PC-based reuse signals. Metadata fits within 64 KiB: 2 bits/line RRPV, 4 bits/line PC signature, 1K×4 bits SHiP table, 32 leader set bits, 10-bit PSEL, and per-set streaming detector.",,ChampSim_CRC2/new_policies/003_00_dip_ship_streaming_hybrid__dssh_t02.cc,0.214952551,0.214952551,0%
1349,lbm,DIP-SHiP Streaming Hybrid (DSSH),"DSSH combines DIP-style set-dueling for insertion depth control (LIP vs BIP) with SHiP-lite PC-based reuse prediction and a streaming detector for scan/bypass phases. Leader sets (32) are used to dynamically select between LIP (always insert at LRU) and BIP (insert mostly at LRU, occasionally at MRU) via a 10-bit PSEL counter, adapting to recency- or frequency-dominated workloads. For non-leader sets, insertion depth is chosen by the winning policy, but further refined by SHiP signature outcome counters (4 bits/signature, 1K entries) to bias toward MRU for high-reuse PCs. A lightweight per-set streaming detector (2 bits/set, 8 bits/set for last stride) identifies scan phases and triggers bypass or distant insertion. This hybrid approach improves performance by rapidly adapting to streaming (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated (ASTAR) phases, while leveraging both recency and PC-based reuse signals. Metadata fits within 64 KiB: 2 bits/line RRPV, 4 bits/line PC signature, 1K×4 bits SHiP table, 32 leader set bits, 10-bit PSEL, and per-set streaming detector.",,ChampSim_CRC2/new_policies/003_00_dip_ship_streaming_hybrid__dssh_t02.cc,0.093244284,0.093244284,0%
1350,mcf,DIP-SHiP Streaming Hybrid (DSSH),"DSSH combines DIP-style set-dueling for insertion depth control (LIP vs BIP) with SHiP-lite PC-based reuse prediction and a streaming detector for scan/bypass phases. Leader sets (32) are used to dynamically select between LIP (always insert at LRU) and BIP (insert mostly at LRU, occasionally at MRU) via a 10-bit PSEL counter, adapting to recency- or frequency-dominated workloads. For non-leader sets, insertion depth is chosen by the winning policy, but further refined by SHiP signature outcome counters (4 bits/signature, 1K entries) to bias toward MRU for high-reuse PCs. A lightweight per-set streaming detector (2 bits/set, 8 bits/set for last stride) identifies scan phases and triggers bypass or distant insertion. This hybrid approach improves performance by rapidly adapting to streaming (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated (ASTAR) phases, while leveraging both recency and PC-based reuse signals. Metadata fits within 64 KiB: 2 bits/line RRPV, 4 bits/line PC signature, 1K×4 bits SHiP table, 32 leader set bits, 10-bit PSEL, and per-set streaming detector.",,ChampSim_CRC2/new_policies/003_00_dip_ship_streaming_hybrid__dssh_t02.cc,0.382793859,0.382793859,0%
1351,milc,DIP-SHiP Streaming Hybrid (DSSH),"DSSH combines DIP-style set-dueling for insertion depth control (LIP vs BIP) with SHiP-lite PC-based reuse prediction and a streaming detector for scan/bypass phases. Leader sets (32) are used to dynamically select between LIP (always insert at LRU) and BIP (insert mostly at LRU, occasionally at MRU) via a 10-bit PSEL counter, adapting to recency- or frequency-dominated workloads. For non-leader sets, insertion depth is chosen by the winning policy, but further refined by SHiP signature outcome counters (4 bits/signature, 1K entries) to bias toward MRU for high-reuse PCs. A lightweight per-set streaming detector (2 bits/set, 8 bits/set for last stride) identifies scan phases and triggers bypass or distant insertion. This hybrid approach improves performance by rapidly adapting to streaming (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated (ASTAR) phases, while leveraging both recency and PC-based reuse signals. Metadata fits within 64 KiB: 2 bits/line RRPV, 4 bits/line PC signature, 1K×4 bits SHiP table, 32 leader set bits, 10-bit PSEL, and per-set streaming detector.",,ChampSim_CRC2/new_policies/003_00_dip_ship_streaming_hybrid__dssh_t02.cc,0.022145666,0.022145666,0%
1352,omnetpp,DIP-SHiP Streaming Hybrid (DSSH),"DSSH combines DIP-style set-dueling for insertion depth control (LIP vs BIP) with SHiP-lite PC-based reuse prediction and a streaming detector for scan/bypass phases. Leader sets (32) are used to dynamically select between LIP (always insert at LRU) and BIP (insert mostly at LRU, occasionally at MRU) via a 10-bit PSEL counter, adapting to recency- or frequency-dominated workloads. For non-leader sets, insertion depth is chosen by the winning policy, but further refined by SHiP signature outcome counters (4 bits/signature, 1K entries) to bias toward MRU for high-reuse PCs. A lightweight per-set streaming detector (2 bits/set, 8 bits/set for last stride) identifies scan phases and triggers bypass or distant insertion. This hybrid approach improves performance by rapidly adapting to streaming (LBM, MILC), pointer-chasing (MCF, OMNETPP), and control-dominated (ASTAR) phases, while leveraging both recency and PC-based reuse signals. Metadata fits within 64 KiB: 2 bits/line RRPV, 4 bits/line PC signature, 1K×4 bits SHiP table, 32 leader set bits, 10-bit PSEL, and per-set streaming detector.",,ChampSim_CRC2/new_policies/003_00_dip_ship_streaming_hybrid__dssh_t02.cc,0.089125624,0.089125624,0%
1353,astar,Hybrid DRRIP + Streaming Bypass (HDSB),"HDSB combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to adaptively optimize cache insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP via a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to recency vs. distant reuse patterns across workloads. A per-set streaming detector (8 bits/set) identifies near-monotonic address strides; when streaming is detected, cache fills are bypassed entirely for low-reuse phases, preventing pollution from scan-like access (LBM, MILC). For pointer-chasing or control-dominated phases (MCF, OMNETPP, ASTAR), DRRIP’s adaptive insertion depth ensures blocks with potential reuse are retained. Metadata includes 2-bit RRPV per line, a 10-bit PSEL selector, 64 leader set flags, and an 8-bit streaming detector per set—totaling well under 64 KiB. This hybrid approach improves hit rates by quickly responding to phase changes and avoiding cache pollution from streaming accesses.",,ChampSim_CRC2/new_policies/003_01_hybrid_drrip___streaming_bypass__hdsb_t04.cc,0.433293704,0.433293704,0%
1354,lbm,Hybrid DRRIP + Streaming Bypass (HDSB),"HDSB combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to adaptively optimize cache insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP via a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to recency vs. distant reuse patterns across workloads. A per-set streaming detector (8 bits/set) identifies near-monotonic address strides; when streaming is detected, cache fills are bypassed entirely for low-reuse phases, preventing pollution from scan-like access (LBM, MILC). For pointer-chasing or control-dominated phases (MCF, OMNETPP, ASTAR), DRRIP’s adaptive insertion depth ensures blocks with potential reuse are retained. Metadata includes 2-bit RRPV per line, a 10-bit PSEL selector, 64 leader set flags, and an 8-bit streaming detector per set—totaling well under 64 KiB. This hybrid approach improves hit rates by quickly responding to phase changes and avoiding cache pollution from streaming accesses.",,ChampSim_CRC2/new_policies/003_01_hybrid_drrip___streaming_bypass__hdsb_t04.cc,0.413577291,0.413577291,0%
1355,mcf,Hybrid DRRIP + Streaming Bypass (HDSB),"HDSB combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to adaptively optimize cache insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP via a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to recency vs. distant reuse patterns across workloads. A per-set streaming detector (8 bits/set) identifies near-monotonic address strides; when streaming is detected, cache fills are bypassed entirely for low-reuse phases, preventing pollution from scan-like access (LBM, MILC). For pointer-chasing or control-dominated phases (MCF, OMNETPP, ASTAR), DRRIP’s adaptive insertion depth ensures blocks with potential reuse are retained. Metadata includes 2-bit RRPV per line, a 10-bit PSEL selector, 64 leader set flags, and an 8-bit streaming detector per set—totaling well under 64 KiB. This hybrid approach improves hit rates by quickly responding to phase changes and avoiding cache pollution from streaming accesses.",,ChampSim_CRC2/new_policies/003_01_hybrid_drrip___streaming_bypass__hdsb_t04.cc,0.461048695,0.461048695,0%
1356,milc,Hybrid DRRIP + Streaming Bypass (HDSB),"HDSB combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to adaptively optimize cache insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP via a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to recency vs. distant reuse patterns across workloads. A per-set streaming detector (8 bits/set) identifies near-monotonic address strides; when streaming is detected, cache fills are bypassed entirely for low-reuse phases, preventing pollution from scan-like access (LBM, MILC). For pointer-chasing or control-dominated phases (MCF, OMNETPP, ASTAR), DRRIP’s adaptive insertion depth ensures blocks with potential reuse are retained. Metadata includes 2-bit RRPV per line, a 10-bit PSEL selector, 64 leader set flags, and an 8-bit streaming detector per set—totaling well under 64 KiB. This hybrid approach improves hit rates by quickly responding to phase changes and avoiding cache pollution from streaming accesses.",,ChampSim_CRC2/new_policies/003_01_hybrid_drrip___streaming_bypass__hdsb_t04.cc,0.311254046,0.311254046,0%
1357,omnetpp,Hybrid DRRIP + Streaming Bypass (HDSB),"HDSB combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to adaptively optimize cache insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP via a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to recency vs. distant reuse patterns across workloads. A per-set streaming detector (8 bits/set) identifies near-monotonic address strides; when streaming is detected, cache fills are bypassed entirely for low-reuse phases, preventing pollution from scan-like access (LBM, MILC). For pointer-chasing or control-dominated phases (MCF, OMNETPP, ASTAR), DRRIP’s adaptive insertion depth ensures blocks with potential reuse are retained. Metadata includes 2-bit RRPV per line, a 10-bit PSEL selector, 64 leader set flags, and an 8-bit streaming detector per set—totaling well under 64 KiB. This hybrid approach improves hit rates by quickly responding to phase changes and avoiding cache pollution from streaming accesses.",,ChampSim_CRC2/new_policies/003_01_hybrid_drrip___streaming_bypass__hdsb_t04.cc,0.453173557,0.453173557,0%
1358,astar,DIP-DeadBlock Streaming Hybrid Replacement (DDSHR),"DDSHR integrates three compact but powerful mechanisms: DIP-style leader set insertion control, dead-block prediction, and streaming detection. DIP dynamically selects between LIP (always insert at LRU) and BIP (insert mostly at LRU, rarely at MRU) via a 10-bit PSEL counter and 64 leader sets, adapting to recency- or thrashing-dominated workloads (e.g., ASTAR, OMNETPP). Dead-block prediction uses a 1-bit per-line ""dead"" tag with periodic decay, enabling early eviction of lines that are unlikely to be reused—a boon for sparse, pointer-chasing workloads (MCF, OMNETPP). Streaming detection tracks near-monotonic strides per set with 2 bits/set; when sustained streaming is detected, blocks are bypassed or inserted at distant RRPV to minimize cache pollution (LBM, MILC). Together, these mechanisms allow DDSHR to rapidly adapt to phase changes, minimize pollution, and target both regular and irregular memory behaviors, all within 64 KiB of metadata. The policy offers diverse prediction sources (leader sets, dead-block tags, streaming detector) and a materially different insertion logic from SSAR.",,ChampSim_CRC2/new_policies/003_02_dip_deadblock_streaming_hybrid_replacement__ddshr_t07.cc,0.051093035,0.051093035,0%
1359,lbm,DIP-DeadBlock Streaming Hybrid Replacement (DDSHR),"DDSHR integrates three compact but powerful mechanisms: DIP-style leader set insertion control, dead-block prediction, and streaming detection. DIP dynamically selects between LIP (always insert at LRU) and BIP (insert mostly at LRU, rarely at MRU) via a 10-bit PSEL counter and 64 leader sets, adapting to recency- or thrashing-dominated workloads (e.g., ASTAR, OMNETPP). Dead-block prediction uses a 1-bit per-line ""dead"" tag with periodic decay, enabling early eviction of lines that are unlikely to be reused—a boon for sparse, pointer-chasing workloads (MCF, OMNETPP). Streaming detection tracks near-monotonic strides per set with 2 bits/set; when sustained streaming is detected, blocks are bypassed or inserted at distant RRPV to minimize cache pollution (LBM, MILC). Together, these mechanisms allow DDSHR to rapidly adapt to phase changes, minimize pollution, and target both regular and irregular memory behaviors, all within 64 KiB of metadata. The policy offers diverse prediction sources (leader sets, dead-block tags, streaming detector) and a materially different insertion logic from SSAR.",,ChampSim_CRC2/new_policies/003_02_dip_deadblock_streaming_hybrid_replacement__ddshr_t07.cc,0.060280433,0.060280433,0%
1360,mcf,DIP-DeadBlock Streaming Hybrid Replacement (DDSHR),"DDSHR integrates three compact but powerful mechanisms: DIP-style leader set insertion control, dead-block prediction, and streaming detection. DIP dynamically selects between LIP (always insert at LRU) and BIP (insert mostly at LRU, rarely at MRU) via a 10-bit PSEL counter and 64 leader sets, adapting to recency- or thrashing-dominated workloads (e.g., ASTAR, OMNETPP). Dead-block prediction uses a 1-bit per-line ""dead"" tag with periodic decay, enabling early eviction of lines that are unlikely to be reused—a boon for sparse, pointer-chasing workloads (MCF, OMNETPP). Streaming detection tracks near-monotonic strides per set with 2 bits/set; when sustained streaming is detected, blocks are bypassed or inserted at distant RRPV to minimize cache pollution (LBM, MILC). Together, these mechanisms allow DDSHR to rapidly adapt to phase changes, minimize pollution, and target both regular and irregular memory behaviors, all within 64 KiB of metadata. The policy offers diverse prediction sources (leader sets, dead-block tags, streaming detector) and a materially different insertion logic from SSAR.",,ChampSim_CRC2/new_policies/003_02_dip_deadblock_streaming_hybrid_replacement__ddshr_t07.cc,0.221366099,0.221366099,0%
1361,milc,DIP-DeadBlock Streaming Hybrid Replacement (DDSHR),"DDSHR integrates three compact but powerful mechanisms: DIP-style leader set insertion control, dead-block prediction, and streaming detection. DIP dynamically selects between LIP (always insert at LRU) and BIP (insert mostly at LRU, rarely at MRU) via a 10-bit PSEL counter and 64 leader sets, adapting to recency- or thrashing-dominated workloads (e.g., ASTAR, OMNETPP). Dead-block prediction uses a 1-bit per-line ""dead"" tag with periodic decay, enabling early eviction of lines that are unlikely to be reused—a boon for sparse, pointer-chasing workloads (MCF, OMNETPP). Streaming detection tracks near-monotonic strides per set with 2 bits/set; when sustained streaming is detected, blocks are bypassed or inserted at distant RRPV to minimize cache pollution (LBM, MILC). Together, these mechanisms allow DDSHR to rapidly adapt to phase changes, minimize pollution, and target both regular and irregular memory behaviors, all within 64 KiB of metadata. The policy offers diverse prediction sources (leader sets, dead-block tags, streaming detector) and a materially different insertion logic from SSAR.",,ChampSim_CRC2/new_policies/003_02_dip_deadblock_streaming_hybrid_replacement__ddshr_t07.cc,0.009603757,0.009603757,0%
1362,omnetpp,DIP-DeadBlock Streaming Hybrid Replacement (DDSHR),"DDSHR integrates three compact but powerful mechanisms: DIP-style leader set insertion control, dead-block prediction, and streaming detection. DIP dynamically selects between LIP (always insert at LRU) and BIP (insert mostly at LRU, rarely at MRU) via a 10-bit PSEL counter and 64 leader sets, adapting to recency- or thrashing-dominated workloads (e.g., ASTAR, OMNETPP). Dead-block prediction uses a 1-bit per-line ""dead"" tag with periodic decay, enabling early eviction of lines that are unlikely to be reused—a boon for sparse, pointer-chasing workloads (MCF, OMNETPP). Streaming detection tracks near-monotonic strides per set with 2 bits/set; when sustained streaming is detected, blocks are bypassed or inserted at distant RRPV to minimize cache pollution (LBM, MILC). Together, these mechanisms allow DDSHR to rapidly adapt to phase changes, minimize pollution, and target both regular and irregular memory behaviors, all within 64 KiB of metadata. The policy offers diverse prediction sources (leader sets, dead-block tags, streaming detector) and a materially different insertion logic from SSAR.",,ChampSim_CRC2/new_policies/003_02_dip_deadblock_streaming_hybrid_replacement__ddshr_t07.cc,0.001592613,0.001592613,0%
1363,all,Hybrid DRRIP + Streaming Bypass (HDSB),"HDSB combines Dynamic RRIP (DRRIP) set-dueling with a lightweight streaming detector to adaptively optimize cache insertion and bypass decisions. DRRIP dynamically chooses between SRRIP and BRRIP via a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to recency vs. distant reuse patterns across workloads. A per-set streaming detector (8 bits/set) identifies near-monotonic address strides; when streaming is detected, cache fills are bypassed entirely for low-reuse phases, preventing pollution from scan-like access (LBM, MILC). For pointer-chasing or control-dominated phases (MCF, OMNETPP, ASTAR), DRRIP’s adaptive insertion depth ensures blocks with potential reuse are retained. Metadata includes 2-bit RRPV per line, a 10-bit PSEL selector, 64 leader set flags, and an 8-bit streaming detector per set—totaling well under 64 KiB. This hybrid approach improves hit rates by quickly responding to phase changes and avoiding cache pollution from streaming accesses.",,ChampSim_CRC2/new_policies/003_01_hybrid_drrip___streaming_bypass__hdsb_t04.cc,0.414469459,0.414469459,41%
1364,astar,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to adaptively control cache insertion and bypass. Each cache line is tagged with a 6-bit signature derived from the PC of the fill, and a global table of 4096 2-bit saturating counters tracks reuse outcomes for these signatures. On fill, the signature’s counter biases insertion depth: blocks with a history of reuse are inserted at MRU (RRPV=0), while others are inserted at distant (RRPV=2). A per-set streaming detector (2 bits/set) identifies monotonic address strides and triggers bypass for scan-like phases (LBM, MILC), preventing pollution. This hybrid approach improves hit rates by learning which PCs produce reusable blocks, while quickly bypassing streaming accesses. Metadata fits under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 4096×2 bits SHiP table, and 2 bits/set streaming detector. SLSB is robust to phase changes and pointer-chasing, outperforming recency-only policies.",,ChampSim_CRC2/new_policies/004_00_ship_lite___streaming_bypass__slsb_t02.cc,0.429623382,0.429623382,0%
1365,lbm,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to adaptively control cache insertion and bypass. Each cache line is tagged with a 6-bit signature derived from the PC of the fill, and a global table of 4096 2-bit saturating counters tracks reuse outcomes for these signatures. On fill, the signature’s counter biases insertion depth: blocks with a history of reuse are inserted at MRU (RRPV=0), while others are inserted at distant (RRPV=2). A per-set streaming detector (2 bits/set) identifies monotonic address strides and triggers bypass for scan-like phases (LBM, MILC), preventing pollution. This hybrid approach improves hit rates by learning which PCs produce reusable blocks, while quickly bypassing streaming accesses. Metadata fits under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 4096×2 bits SHiP table, and 2 bits/set streaming detector. SLSB is robust to phase changes and pointer-chasing, outperforming recency-only policies.",,ChampSim_CRC2/new_policies/004_00_ship_lite___streaming_bypass__slsb_t02.cc,0.409168072,0.409168072,0%
1366,mcf,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to adaptively control cache insertion and bypass. Each cache line is tagged with a 6-bit signature derived from the PC of the fill, and a global table of 4096 2-bit saturating counters tracks reuse outcomes for these signatures. On fill, the signature’s counter biases insertion depth: blocks with a history of reuse are inserted at MRU (RRPV=0), while others are inserted at distant (RRPV=2). A per-set streaming detector (2 bits/set) identifies monotonic address strides and triggers bypass for scan-like phases (LBM, MILC), preventing pollution. This hybrid approach improves hit rates by learning which PCs produce reusable blocks, while quickly bypassing streaming accesses. Metadata fits under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 4096×2 bits SHiP table, and 2 bits/set streaming detector. SLSB is robust to phase changes and pointer-chasing, outperforming recency-only policies.",,ChampSim_CRC2/new_policies/004_00_ship_lite___streaming_bypass__slsb_t02.cc,0.474799179,0.474799179,0%
1367,milc,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to adaptively control cache insertion and bypass. Each cache line is tagged with a 6-bit signature derived from the PC of the fill, and a global table of 4096 2-bit saturating counters tracks reuse outcomes for these signatures. On fill, the signature’s counter biases insertion depth: blocks with a history of reuse are inserted at MRU (RRPV=0), while others are inserted at distant (RRPV=2). A per-set streaming detector (2 bits/set) identifies monotonic address strides and triggers bypass for scan-like phases (LBM, MILC), preventing pollution. This hybrid approach improves hit rates by learning which PCs produce reusable blocks, while quickly bypassing streaming accesses. Metadata fits under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 4096×2 bits SHiP table, and 2 bits/set streaming detector. SLSB is robust to phase changes and pointer-chasing, outperforming recency-only policies.",,ChampSim_CRC2/new_policies/004_00_ship_lite___streaming_bypass__slsb_t02.cc,0.31161249,0.31161249,0%
1368,omnetpp,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to adaptively control cache insertion and bypass. Each cache line is tagged with a 6-bit signature derived from the PC of the fill, and a global table of 4096 2-bit saturating counters tracks reuse outcomes for these signatures. On fill, the signature’s counter biases insertion depth: blocks with a history of reuse are inserted at MRU (RRPV=0), while others are inserted at distant (RRPV=2). A per-set streaming detector (2 bits/set) identifies monotonic address strides and triggers bypass for scan-like phases (LBM, MILC), preventing pollution. This hybrid approach improves hit rates by learning which PCs produce reusable blocks, while quickly bypassing streaming accesses. Metadata fits under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 4096×2 bits SHiP table, and 2 bits/set streaming detector. SLSB is robust to phase changes and pointer-chasing, outperforming recency-only policies.",,ChampSim_CRC2/new_policies/004_00_ship_lite___streaming_bypass__slsb_t02.cc,0.61180667,0.61180667,0%
1369,astar,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to guide cache insertion and bypass decisions. For each cache line, a compact 5-bit signature (from PC) is tracked, and a 2-bit outcome counter per signature biases insertion depth: blocks from PCs with a history of reuse are inserted at MRU, while others are inserted at LRU. This enables the policy to learn and adapt to control-dominated, pointer-chasing, and irregular access patterns (MCF, OMNETPP, ASTAR) by retaining blocks with likely reuse. In parallel, a per-set streaming detector identifies monotonic access strides (LBM, MILC phases), causing blocks to be bypassed during streaming to avoid cache pollution. The combined approach quickly adapts to phase changes and workload diversity, improving hit rates across all benchmarks. Metadata fits well under 64 KiB: 5 bits/line signature, 2 bits/signature outcome (4096 entries), and 2 bits/set streaming score.",,ChampSim_CRC2/new_policies/004_01_ship_lite___streaming_bypass__slsb_t04.cc,0.440536896,0.440536896,0%
1370,lbm,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to guide cache insertion and bypass decisions. For each cache line, a compact 5-bit signature (from PC) is tracked, and a 2-bit outcome counter per signature biases insertion depth: blocks from PCs with a history of reuse are inserted at MRU, while others are inserted at LRU. This enables the policy to learn and adapt to control-dominated, pointer-chasing, and irregular access patterns (MCF, OMNETPP, ASTAR) by retaining blocks with likely reuse. In parallel, a per-set streaming detector identifies monotonic access strides (LBM, MILC phases), causing blocks to be bypassed during streaming to avoid cache pollution. The combined approach quickly adapts to phase changes and workload diversity, improving hit rates across all benchmarks. Metadata fits well under 64 KiB: 5 bits/line signature, 2 bits/signature outcome (4096 entries), and 2 bits/set streaming score.",,ChampSim_CRC2/new_policies/004_01_ship_lite___streaming_bypass__slsb_t04.cc,0.417309021,0.417309021,0%
1371,mcf,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to guide cache insertion and bypass decisions. For each cache line, a compact 5-bit signature (from PC) is tracked, and a 2-bit outcome counter per signature biases insertion depth: blocks from PCs with a history of reuse are inserted at MRU, while others are inserted at LRU. This enables the policy to learn and adapt to control-dominated, pointer-chasing, and irregular access patterns (MCF, OMNETPP, ASTAR) by retaining blocks with likely reuse. In parallel, a per-set streaming detector identifies monotonic access strides (LBM, MILC phases), causing blocks to be bypassed during streaming to avoid cache pollution. The combined approach quickly adapts to phase changes and workload diversity, improving hit rates across all benchmarks. Metadata fits well under 64 KiB: 5 bits/line signature, 2 bits/signature outcome (4096 entries), and 2 bits/set streaming score.",,ChampSim_CRC2/new_policies/004_01_ship_lite___streaming_bypass__slsb_t04.cc,0.46111589,0.46111589,0%
1372,milc,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to guide cache insertion and bypass decisions. For each cache line, a compact 5-bit signature (from PC) is tracked, and a 2-bit outcome counter per signature biases insertion depth: blocks from PCs with a history of reuse are inserted at MRU, while others are inserted at LRU. This enables the policy to learn and adapt to control-dominated, pointer-chasing, and irregular access patterns (MCF, OMNETPP, ASTAR) by retaining blocks with likely reuse. In parallel, a per-set streaming detector identifies monotonic access strides (LBM, MILC phases), causing blocks to be bypassed during streaming to avoid cache pollution. The combined approach quickly adapts to phase changes and workload diversity, improving hit rates across all benchmarks. Metadata fits well under 64 KiB: 5 bits/line signature, 2 bits/signature outcome (4096 entries), and 2 bits/set streaming score.",,ChampSim_CRC2/new_policies/004_01_ship_lite___streaming_bypass__slsb_t04.cc,0.31431349,0.31431349,0%
1373,omnetpp,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to guide cache insertion and bypass decisions. For each cache line, a compact 5-bit signature (from PC) is tracked, and a 2-bit outcome counter per signature biases insertion depth: blocks from PCs with a history of reuse are inserted at MRU, while others are inserted at LRU. This enables the policy to learn and adapt to control-dominated, pointer-chasing, and irregular access patterns (MCF, OMNETPP, ASTAR) by retaining blocks with likely reuse. In parallel, a per-set streaming detector identifies monotonic access strides (LBM, MILC phases), causing blocks to be bypassed during streaming to avoid cache pollution. The combined approach quickly adapts to phase changes and workload diversity, improving hit rates across all benchmarks. Metadata fits well under 64 KiB: 5 bits/line signature, 2 bits/signature outcome (4096 entries), and 2 bits/set streaming score.",,ChampSim_CRC2/new_policies/004_01_ship_lite___streaming_bypass__slsb_t04.cc,0.453907224,0.453907224,0%
1374,astar,SHiP-Lite + Dead-Block Decay Hybrid (SLDB),"SLDB combines a lightweight SHiP-like PC-based reuse predictor with per-line dead-block approximation to optimize insertion and retention decisions. Each line is tagged with a compact 6-bit PC signature and a 2-bit reuse counter, while a global table of 2048 PC signatures tracks recent reuse patterns (incremented on hits, decayed periodically). On fill, blocks predicted ""dead"" by either the PC table (low counter) or the local line counter are inserted at high RRPV (LRU); otherwise, they're inserted at distant (medium RRPV). Periodic decay of counters adapts to phase changes, ensuring streaming and pointer-chasing phases don't pollute the cache, while regular reuse (LBM, MILC) is retained. This dual-source prediction (per-PC and per-line) delivers better hit rates across diverse workloads, especially for MCF and OMNETPP where reuse is sparse and unpredictable, while staying under 64 KiB metadata.",,ChampSim_CRC2/new_policies/004_02_ship_lite___dead_block_decay_hybrid__sldb_t07.cc,0.399770904,0.399770904,0%
1375,lbm,SHiP-Lite + Dead-Block Decay Hybrid (SLDB),"SLDB combines a lightweight SHiP-like PC-based reuse predictor with per-line dead-block approximation to optimize insertion and retention decisions. Each line is tagged with a compact 6-bit PC signature and a 2-bit reuse counter, while a global table of 2048 PC signatures tracks recent reuse patterns (incremented on hits, decayed periodically). On fill, blocks predicted ""dead"" by either the PC table (low counter) or the local line counter are inserted at high RRPV (LRU); otherwise, they're inserted at distant (medium RRPV). Periodic decay of counters adapts to phase changes, ensuring streaming and pointer-chasing phases don't pollute the cache, while regular reuse (LBM, MILC) is retained. This dual-source prediction (per-PC and per-line) delivers better hit rates across diverse workloads, especially for MCF and OMNETPP where reuse is sparse and unpredictable, while staying under 64 KiB metadata.",,ChampSim_CRC2/new_policies/004_02_ship_lite___dead_block_decay_hybrid__sldb_t07.cc,0.148063475,0.148063475,0%
1376,mcf,SHiP-Lite + Dead-Block Decay Hybrid (SLDB),"SLDB combines a lightweight SHiP-like PC-based reuse predictor with per-line dead-block approximation to optimize insertion and retention decisions. Each line is tagged with a compact 6-bit PC signature and a 2-bit reuse counter, while a global table of 2048 PC signatures tracks recent reuse patterns (incremented on hits, decayed periodically). On fill, blocks predicted ""dead"" by either the PC table (low counter) or the local line counter are inserted at high RRPV (LRU); otherwise, they're inserted at distant (medium RRPV). Periodic decay of counters adapts to phase changes, ensuring streaming and pointer-chasing phases don't pollute the cache, while regular reuse (LBM, MILC) is retained. This dual-source prediction (per-PC and per-line) delivers better hit rates across diverse workloads, especially for MCF and OMNETPP where reuse is sparse and unpredictable, while staying under 64 KiB metadata.",,ChampSim_CRC2/new_policies/004_02_ship_lite___dead_block_decay_hybrid__sldb_t07.cc,0.526166949,0.526166949,0%
1377,milc,SHiP-Lite + Dead-Block Decay Hybrid (SLDB),"SLDB combines a lightweight SHiP-like PC-based reuse predictor with per-line dead-block approximation to optimize insertion and retention decisions. Each line is tagged with a compact 6-bit PC signature and a 2-bit reuse counter, while a global table of 2048 PC signatures tracks recent reuse patterns (incremented on hits, decayed periodically). On fill, blocks predicted ""dead"" by either the PC table (low counter) or the local line counter are inserted at high RRPV (LRU); otherwise, they're inserted at distant (medium RRPV). Periodic decay of counters adapts to phase changes, ensuring streaming and pointer-chasing phases don't pollute the cache, while regular reuse (LBM, MILC) is retained. This dual-source prediction (per-PC and per-line) delivers better hit rates across diverse workloads, especially for MCF and OMNETPP where reuse is sparse and unpredictable, while staying under 64 KiB metadata.",,ChampSim_CRC2/new_policies/004_02_ship_lite___dead_block_decay_hybrid__sldb_t07.cc,0.015662904,0.015662904,0%
1378,omnetpp,SHiP-Lite + Dead-Block Decay Hybrid (SLDB),"SLDB combines a lightweight SHiP-like PC-based reuse predictor with per-line dead-block approximation to optimize insertion and retention decisions. Each line is tagged with a compact 6-bit PC signature and a 2-bit reuse counter, while a global table of 2048 PC signatures tracks recent reuse patterns (incremented on hits, decayed periodically). On fill, blocks predicted ""dead"" by either the PC table (low counter) or the local line counter are inserted at high RRPV (LRU); otherwise, they're inserted at distant (medium RRPV). Periodic decay of counters adapts to phase changes, ensuring streaming and pointer-chasing phases don't pollute the cache, while regular reuse (LBM, MILC) is retained. This dual-source prediction (per-PC and per-line) delivers better hit rates across diverse workloads, especially for MCF and OMNETPP where reuse is sparse and unpredictable, while staying under 64 KiB metadata.",,ChampSim_CRC2/new_policies/004_02_ship_lite___dead_block_decay_hybrid__sldb_t07.cc,0.00874446,0.00874446,0%
1379,all,SHiP-Lite + Streaming Bypass (SLSB),"SLSB combines a lightweight SHiP-inspired PC signature predictor with a streaming detector to adaptively control cache insertion and bypass. Each cache line is tagged with a 6-bit signature derived from the PC of the fill, and a global table of 4096 2-bit saturating counters tracks reuse outcomes for these signatures. On fill, the signature’s counter biases insertion depth: blocks with a history of reuse are inserted at MRU (RRPV=0), while others are inserted at distant (RRPV=2). A per-set streaming detector (2 bits/set) identifies monotonic address strides and triggers bypass for scan-like phases (LBM, MILC), preventing pollution. This hybrid approach improves hit rates by learning which PCs produce reusable blocks, while quickly bypassing streaming accesses. Metadata fits under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 4096×2 bits SHiP table, and 2 bits/set streaming detector. SLSB is robust to phase changes and pointer-chasing, outperforming recency-only policies.",,ChampSim_CRC2/new_policies/004_00_ship_lite___streaming_bypass__slsb_t02.cc,0.447401958,0.447401958,45%
1380,astar,DRRIP + Dead-Block Decay (DRRIP-DBD),"DRRIP-DBD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight per-line dead-block approximation to improve cache performance across diverse workloads. DRRIP adaptively chooses between SRRIP (aggressive insertion) and BRRIP (conservative insertion) using a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to changing locality and streaming phases. To further reduce pollution from dead blocks (especially in pointer-chasing and streaming workloads), each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed. Lines with low reuse are inserted at distant RRPV, while lines with high reuse are promoted to MRU. This hybrid approach leverages global set-dueling for phase adaptation and local dead-block tracking for fine-grained insertion control, outperforming recency-only and PC-based predictors. All metadata fits within 64 KiB: 2 bits/line RRPV, 2 bits/line reuse counter, 64 leader set flags, and a 10-bit PSEL counter.",,ChampSim_CRC2/new_policies/005_00_drrip___dead_block_decay__drrip_dbd_t02.cc,0.426464231,0.426464231,0%
1381,lbm,DRRIP + Dead-Block Decay (DRRIP-DBD),"DRRIP-DBD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight per-line dead-block approximation to improve cache performance across diverse workloads. DRRIP adaptively chooses between SRRIP (aggressive insertion) and BRRIP (conservative insertion) using a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to changing locality and streaming phases. To further reduce pollution from dead blocks (especially in pointer-chasing and streaming workloads), each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed. Lines with low reuse are inserted at distant RRPV, while lines with high reuse are promoted to MRU. This hybrid approach leverages global set-dueling for phase adaptation and local dead-block tracking for fine-grained insertion control, outperforming recency-only and PC-based predictors. All metadata fits within 64 KiB: 2 bits/line RRPV, 2 bits/line reuse counter, 64 leader set flags, and a 10-bit PSEL counter.",,ChampSim_CRC2/new_policies/005_00_drrip___dead_block_decay__drrip_dbd_t02.cc,0.403951589,0.403951589,0%
1382,mcf,DRRIP + Dead-Block Decay (DRRIP-DBD),"DRRIP-DBD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight per-line dead-block approximation to improve cache performance across diverse workloads. DRRIP adaptively chooses between SRRIP (aggressive insertion) and BRRIP (conservative insertion) using a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to changing locality and streaming phases. To further reduce pollution from dead blocks (especially in pointer-chasing and streaming workloads), each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed. Lines with low reuse are inserted at distant RRPV, while lines with high reuse are promoted to MRU. This hybrid approach leverages global set-dueling for phase adaptation and local dead-block tracking for fine-grained insertion control, outperforming recency-only and PC-based predictors. All metadata fits within 64 KiB: 2 bits/line RRPV, 2 bits/line reuse counter, 64 leader set flags, and a 10-bit PSEL counter.",,ChampSim_CRC2/new_policies/005_00_drrip___dead_block_decay__drrip_dbd_t02.cc,0.457819653,0.457819653,0%
1383,milc,DRRIP + Dead-Block Decay (DRRIP-DBD),"DRRIP-DBD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight per-line dead-block approximation to improve cache performance across diverse workloads. DRRIP adaptively chooses between SRRIP (aggressive insertion) and BRRIP (conservative insertion) using a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to changing locality and streaming phases. To further reduce pollution from dead blocks (especially in pointer-chasing and streaming workloads), each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed. Lines with low reuse are inserted at distant RRPV, while lines with high reuse are promoted to MRU. This hybrid approach leverages global set-dueling for phase adaptation and local dead-block tracking for fine-grained insertion control, outperforming recency-only and PC-based predictors. All metadata fits within 64 KiB: 2 bits/line RRPV, 2 bits/line reuse counter, 64 leader set flags, and a 10-bit PSEL counter.",,ChampSim_CRC2/new_policies/005_00_drrip___dead_block_decay__drrip_dbd_t02.cc,0.304258963,0.304258963,0%
1384,omnetpp,DRRIP + Dead-Block Decay (DRRIP-DBD),"DRRIP-DBD combines Dynamic RRIP (DRRIP) set-dueling with a lightweight per-line dead-block approximation to improve cache performance across diverse workloads. DRRIP adaptively chooses between SRRIP (aggressive insertion) and BRRIP (conservative insertion) using a 10-bit PSEL counter and 64 leader sets, allowing the policy to respond to changing locality and streaming phases. To further reduce pollution from dead blocks (especially in pointer-chasing and streaming workloads), each cache line maintains a 2-bit reuse counter that is incremented on hits and periodically decayed. Lines with low reuse are inserted at distant RRPV, while lines with high reuse are promoted to MRU. This hybrid approach leverages global set-dueling for phase adaptation and local dead-block tracking for fine-grained insertion control, outperforming recency-only and PC-based predictors. All metadata fits within 64 KiB: 2 bits/line RRPV, 2 bits/line reuse counter, 64 leader set flags, and a 10-bit PSEL counter.",,ChampSim_CRC2/new_policies/005_00_drrip___dead_block_decay__drrip_dbd_t02.cc,0.441995574,0.441995574,0%
1385,astar,DRRIP + Per-Line Dead-Block Counter (DRRIP-DBC),"DRRIP-DBC combines Dynamic RRIP (SRRIP/BRRIP with set-dueling and a 10-bit PSEL selector) for adaptive insertion depth control, with a compact per-line dead-block approximation to better identify and evict blocks unlikely to be reused. DRRIP adapts between frequent and infrequent MRU insertion based on global workload reuse, improving performance for both streaming (LBM, MILC) and irregular (mcf, omnetpp) phases. Each cache line is augmented with a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing the policy to preferentially evict lines predicted dead even if their RRPV is not maximal. This mechanism improves upon recency-only and SHiP-lite approaches by directly tracking block liveness, reducing pollution and retention of useless blocks. All metadata (2 bits/line RRPV, 2 bits/line dead-counter, 10 bits PSEL, 64 leader sets × 4 bits) fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/005_01_drrip___per_line_dead_block_counter__drrip_dbc_t04.cc,0.433282187,0.433282187,0%
1386,lbm,DRRIP + Per-Line Dead-Block Counter (DRRIP-DBC),"DRRIP-DBC combines Dynamic RRIP (SRRIP/BRRIP with set-dueling and a 10-bit PSEL selector) for adaptive insertion depth control, with a compact per-line dead-block approximation to better identify and evict blocks unlikely to be reused. DRRIP adapts between frequent and infrequent MRU insertion based on global workload reuse, improving performance for both streaming (LBM, MILC) and irregular (mcf, omnetpp) phases. Each cache line is augmented with a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing the policy to preferentially evict lines predicted dead even if their RRPV is not maximal. This mechanism improves upon recency-only and SHiP-lite approaches by directly tracking block liveness, reducing pollution and retention of useless blocks. All metadata (2 bits/line RRPV, 2 bits/line dead-counter, 10 bits PSEL, 64 leader sets × 4 bits) fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/005_01_drrip___per_line_dead_block_counter__drrip_dbc_t04.cc,0.413675702,0.413675702,0%
1387,mcf,DRRIP + Per-Line Dead-Block Counter (DRRIP-DBC),"DRRIP-DBC combines Dynamic RRIP (SRRIP/BRRIP with set-dueling and a 10-bit PSEL selector) for adaptive insertion depth control, with a compact per-line dead-block approximation to better identify and evict blocks unlikely to be reused. DRRIP adapts between frequent and infrequent MRU insertion based on global workload reuse, improving performance for both streaming (LBM, MILC) and irregular (mcf, omnetpp) phases. Each cache line is augmented with a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing the policy to preferentially evict lines predicted dead even if their RRPV is not maximal. This mechanism improves upon recency-only and SHiP-lite approaches by directly tracking block liveness, reducing pollution and retention of useless blocks. All metadata (2 bits/line RRPV, 2 bits/line dead-counter, 10 bits PSEL, 64 leader sets × 4 bits) fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/005_01_drrip___per_line_dead_block_counter__drrip_dbc_t04.cc,0.460862682,0.460862682,0%
1388,milc,DRRIP + Per-Line Dead-Block Counter (DRRIP-DBC),"DRRIP-DBC combines Dynamic RRIP (SRRIP/BRRIP with set-dueling and a 10-bit PSEL selector) for adaptive insertion depth control, with a compact per-line dead-block approximation to better identify and evict blocks unlikely to be reused. DRRIP adapts between frequent and infrequent MRU insertion based on global workload reuse, improving performance for both streaming (LBM, MILC) and irregular (mcf, omnetpp) phases. Each cache line is augmented with a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing the policy to preferentially evict lines predicted dead even if their RRPV is not maximal. This mechanism improves upon recency-only and SHiP-lite approaches by directly tracking block liveness, reducing pollution and retention of useless blocks. All metadata (2 bits/line RRPV, 2 bits/line dead-counter, 10 bits PSEL, 64 leader sets × 4 bits) fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/005_01_drrip___per_line_dead_block_counter__drrip_dbc_t04.cc,0.310729053,0.310729053,0%
1389,omnetpp,DRRIP + Per-Line Dead-Block Counter (DRRIP-DBC),"DRRIP-DBC combines Dynamic RRIP (SRRIP/BRRIP with set-dueling and a 10-bit PSEL selector) for adaptive insertion depth control, with a compact per-line dead-block approximation to better identify and evict blocks unlikely to be reused. DRRIP adapts between frequent and infrequent MRU insertion based on global workload reuse, improving performance for both streaming (LBM, MILC) and irregular (mcf, omnetpp) phases. Each cache line is augmented with a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing the policy to preferentially evict lines predicted dead even if their RRPV is not maximal. This mechanism improves upon recency-only and SHiP-lite approaches by directly tracking block liveness, reducing pollution and retention of useless blocks. All metadata (2 bits/line RRPV, 2 bits/line dead-counter, 10 bits PSEL, 64 leader sets × 4 bits) fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/005_01_drrip___per_line_dead_block_counter__drrip_dbc_t04.cc,0.47625126,0.47625126,0%
1390,astar,DIP-LIP+BIP with Streaming Dead-Block Detector (DLSD),"DLSD combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a lightweight streaming dead-block detector, improving adaptability to diverse workloads. DIP set-dueling uses 64 leader sets and a 10-bit PSEL counter to dynamically select between aggressive MRU (LIP) and rare MRU (BIP), balancing recency sensitivity for control-heavy and pointer-chasing apps (astar, mcf, omnetpp). For streaming phases (lbm, milc), a per-set streaming detector identifies regular address strides and triggers distant RRPV insertion and bypass if blocks are likely dead on arrival, reducing cache pollution. Dead-block detection is assisted by a per-line 2-bit reuse counter, incremented on hits and periodically decayed, informing eviction decisions and further adaptively tuning insertion depth. All metadata fits under 64 KiB: 2 bits/line RRPV, 2 bits/line reuse, 10 bits global PSEL, 64 bits for leader set IDs, and 2 bits/set for streaming. This hybrid policy robustly adapts to control, pointer, and streaming phases, outperforming recency-only and SHiP-only policies.",,ChampSim_CRC2/new_policies/005_02_dip_lip_bip_with_streaming_dead_block_detector__dlsd_t07.cc,0.03443883,0.03443883,0%
1391,lbm,DIP-LIP+BIP with Streaming Dead-Block Detector (DLSD),"DLSD combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a lightweight streaming dead-block detector, improving adaptability to diverse workloads. DIP set-dueling uses 64 leader sets and a 10-bit PSEL counter to dynamically select between aggressive MRU (LIP) and rare MRU (BIP), balancing recency sensitivity for control-heavy and pointer-chasing apps (astar, mcf, omnetpp). For streaming phases (lbm, milc), a per-set streaming detector identifies regular address strides and triggers distant RRPV insertion and bypass if blocks are likely dead on arrival, reducing cache pollution. Dead-block detection is assisted by a per-line 2-bit reuse counter, incremented on hits and periodically decayed, informing eviction decisions and further adaptively tuning insertion depth. All metadata fits under 64 KiB: 2 bits/line RRPV, 2 bits/line reuse, 10 bits global PSEL, 64 bits for leader set IDs, and 2 bits/set for streaming. This hybrid policy robustly adapts to control, pointer, and streaming phases, outperforming recency-only and SHiP-only policies.",,ChampSim_CRC2/new_policies/005_02_dip_lip_bip_with_streaming_dead_block_detector__dlsd_t07.cc,0.037908996,0.037908996,0%
1392,mcf,DIP-LIP+BIP with Streaming Dead-Block Detector (DLSD),"DLSD combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a lightweight streaming dead-block detector, improving adaptability to diverse workloads. DIP set-dueling uses 64 leader sets and a 10-bit PSEL counter to dynamically select between aggressive MRU (LIP) and rare MRU (BIP), balancing recency sensitivity for control-heavy and pointer-chasing apps (astar, mcf, omnetpp). For streaming phases (lbm, milc), a per-set streaming detector identifies regular address strides and triggers distant RRPV insertion and bypass if blocks are likely dead on arrival, reducing cache pollution. Dead-block detection is assisted by a per-line 2-bit reuse counter, incremented on hits and periodically decayed, informing eviction decisions and further adaptively tuning insertion depth. All metadata fits under 64 KiB: 2 bits/line RRPV, 2 bits/line reuse, 10 bits global PSEL, 64 bits for leader set IDs, and 2 bits/set for streaming. This hybrid policy robustly adapts to control, pointer, and streaming phases, outperforming recency-only and SHiP-only policies.",,ChampSim_CRC2/new_policies/005_02_dip_lip_bip_with_streaming_dead_block_detector__dlsd_t07.cc,0.080734751,0.080734751,0%
1393,milc,DIP-LIP+BIP with Streaming Dead-Block Detector (DLSD),"DLSD combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a lightweight streaming dead-block detector, improving adaptability to diverse workloads. DIP set-dueling uses 64 leader sets and a 10-bit PSEL counter to dynamically select between aggressive MRU (LIP) and rare MRU (BIP), balancing recency sensitivity for control-heavy and pointer-chasing apps (astar, mcf, omnetpp). For streaming phases (lbm, milc), a per-set streaming detector identifies regular address strides and triggers distant RRPV insertion and bypass if blocks are likely dead on arrival, reducing cache pollution. Dead-block detection is assisted by a per-line 2-bit reuse counter, incremented on hits and periodically decayed, informing eviction decisions and further adaptively tuning insertion depth. All metadata fits under 64 KiB: 2 bits/line RRPV, 2 bits/line reuse, 10 bits global PSEL, 64 bits for leader set IDs, and 2 bits/set for streaming. This hybrid policy robustly adapts to control, pointer, and streaming phases, outperforming recency-only and SHiP-only policies.",,ChampSim_CRC2/new_policies/005_02_dip_lip_bip_with_streaming_dead_block_detector__dlsd_t07.cc,0.014111458,0.014111458,0%
1394,omnetpp,DIP-LIP+BIP with Streaming Dead-Block Detector (DLSD),"DLSD combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a lightweight streaming dead-block detector, improving adaptability to diverse workloads. DIP set-dueling uses 64 leader sets and a 10-bit PSEL counter to dynamically select between aggressive MRU (LIP) and rare MRU (BIP), balancing recency sensitivity for control-heavy and pointer-chasing apps (astar, mcf, omnetpp). For streaming phases (lbm, milc), a per-set streaming detector identifies regular address strides and triggers distant RRPV insertion and bypass if blocks are likely dead on arrival, reducing cache pollution. Dead-block detection is assisted by a per-line 2-bit reuse counter, incremented on hits and periodically decayed, informing eviction decisions and further adaptively tuning insertion depth. All metadata fits under 64 KiB: 2 bits/line RRPV, 2 bits/line reuse, 10 bits global PSEL, 64 bits for leader set IDs, and 2 bits/set for streaming. This hybrid policy robustly adapts to control, pointer, and streaming phases, outperforming recency-only and SHiP-only policies.",,ChampSim_CRC2/new_policies/005_02_dip_lip_bip_with_streaming_dead_block_detector__dlsd_t07.cc,0.07456054,0.07456054,0%
1395,all,DRRIP + Per-Line Dead-Block Counter (DRRIP-DBC),"DRRIP-DBC combines Dynamic RRIP (SRRIP/BRRIP with set-dueling and a 10-bit PSEL selector) for adaptive insertion depth control, with a compact per-line dead-block approximation to better identify and evict blocks unlikely to be reused. DRRIP adapts between frequent and infrequent MRU insertion based on global workload reuse, improving performance for both streaming (LBM, MILC) and irregular (mcf, omnetpp) phases. Each cache line is augmented with a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing the policy to preferentially evict lines predicted dead even if their RRPV is not maximal. This mechanism improves upon recency-only and SHiP-lite approaches by directly tracking block liveness, reducing pollution and retention of useless blocks. All metadata (2 bits/line RRPV, 2 bits/line dead-counter, 10 bits PSEL, 64 leader sets × 4 bits) fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/005_01_drrip___per_line_dead_block_counter__drrip_dbc_t04.cc,0.418960177,0.418960177,42%
1396,astar,SRRIP + SHiP-lite + Streaming Bypass (SRRIP-SHiP-SB),"This policy combines SRRIP (Static RRIP) with SHiP-lite signature-based insertion control and a lightweight streaming/bypass detector. SHiP-lite uses a compact 6-bit PC signature table (per-set) with 2-bit saturating outcome counters to bias insertion depth: blocks from PCs with frequent hits are inserted at MRU (RRPV=0), while others use SRRIP default (RRPV=2). Additionally, a per-set streaming detector tracks monotonic address deltas; when streaming is detected, new blocks are inserted at distant RRPV (RRPV=3) or bypassed (not cached) to avoid cache pollution. This design improves over DRRIP-DBC by leveraging program context for reuse prediction (SHiP-lite), adaptively responding to streaming phases (LBM, MILC), and reducing retention of useless blocks (mcf, omnetpp). All metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64K entries, and 2 bits/set streaming state.",,ChampSim_CRC2/new_policies/006_01_srrip___ship_lite___streaming_bypass__srrip_ship_sb_t04.cc,0.436110009,0.436110009,0%
1397,lbm,SRRIP + SHiP-lite + Streaming Bypass (SRRIP-SHiP-SB),"This policy combines SRRIP (Static RRIP) with SHiP-lite signature-based insertion control and a lightweight streaming/bypass detector. SHiP-lite uses a compact 6-bit PC signature table (per-set) with 2-bit saturating outcome counters to bias insertion depth: blocks from PCs with frequent hits are inserted at MRU (RRPV=0), while others use SRRIP default (RRPV=2). Additionally, a per-set streaming detector tracks monotonic address deltas; when streaming is detected, new blocks are inserted at distant RRPV (RRPV=3) or bypassed (not cached) to avoid cache pollution. This design improves over DRRIP-DBC by leveraging program context for reuse prediction (SHiP-lite), adaptively responding to streaming phases (LBM, MILC), and reducing retention of useless blocks (mcf, omnetpp). All metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64K entries, and 2 bits/set streaming state.",,ChampSim_CRC2/new_policies/006_01_srrip___ship_lite___streaming_bypass__srrip_ship_sb_t04.cc,0.412394469,0.412394469,0%
1398,mcf,SRRIP + SHiP-lite + Streaming Bypass (SRRIP-SHiP-SB),"This policy combines SRRIP (Static RRIP) with SHiP-lite signature-based insertion control and a lightweight streaming/bypass detector. SHiP-lite uses a compact 6-bit PC signature table (per-set) with 2-bit saturating outcome counters to bias insertion depth: blocks from PCs with frequent hits are inserted at MRU (RRPV=0), while others use SRRIP default (RRPV=2). Additionally, a per-set streaming detector tracks monotonic address deltas; when streaming is detected, new blocks are inserted at distant RRPV (RRPV=3) or bypassed (not cached) to avoid cache pollution. This design improves over DRRIP-DBC by leveraging program context for reuse prediction (SHiP-lite), adaptively responding to streaming phases (LBM, MILC), and reducing retention of useless blocks (mcf, omnetpp). All metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64K entries, and 2 bits/set streaming state.",,ChampSim_CRC2/new_policies/006_01_srrip___ship_lite___streaming_bypass__srrip_ship_sb_t04.cc,0.474916254,0.474916254,0%
1399,milc,SRRIP + SHiP-lite + Streaming Bypass (SRRIP-SHiP-SB),"This policy combines SRRIP (Static RRIP) with SHiP-lite signature-based insertion control and a lightweight streaming/bypass detector. SHiP-lite uses a compact 6-bit PC signature table (per-set) with 2-bit saturating outcome counters to bias insertion depth: blocks from PCs with frequent hits are inserted at MRU (RRPV=0), while others use SRRIP default (RRPV=2). Additionally, a per-set streaming detector tracks monotonic address deltas; when streaming is detected, new blocks are inserted at distant RRPV (RRPV=3) or bypassed (not cached) to avoid cache pollution. This design improves over DRRIP-DBC by leveraging program context for reuse prediction (SHiP-lite), adaptively responding to streaming phases (LBM, MILC), and reducing retention of useless blocks (mcf, omnetpp). All metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64K entries, and 2 bits/set streaming state.",,ChampSim_CRC2/new_policies/006_01_srrip___ship_lite___streaming_bypass__srrip_ship_sb_t04.cc,0.312048777,0.312048777,0%
1400,omnetpp,SRRIP + SHiP-lite + Streaming Bypass (SRRIP-SHiP-SB),"This policy combines SRRIP (Static RRIP) with SHiP-lite signature-based insertion control and a lightweight streaming/bypass detector. SHiP-lite uses a compact 6-bit PC signature table (per-set) with 2-bit saturating outcome counters to bias insertion depth: blocks from PCs with frequent hits are inserted at MRU (RRPV=0), while others use SRRIP default (RRPV=2). Additionally, a per-set streaming detector tracks monotonic address deltas; when streaming is detected, new blocks are inserted at distant RRPV (RRPV=3) or bypassed (not cached) to avoid cache pollution. This design improves over DRRIP-DBC by leveraging program context for reuse prediction (SHiP-lite), adaptively responding to streaming phases (LBM, MILC), and reducing retention of useless blocks (mcf, omnetpp). All metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64K entries, and 2 bits/set streaming state.",,ChampSim_CRC2/new_policies/006_01_srrip___ship_lite___streaming_bypass__srrip_ship_sb_t04.cc,0.453340571,0.453340571,0%
1401,all,SRRIP + SHiP-lite + Streaming Bypass (SRRIP-SHiP-SB),"This policy combines SRRIP (Static RRIP) with SHiP-lite signature-based insertion control and a lightweight streaming/bypass detector. SHiP-lite uses a compact 6-bit PC signature table (per-set) with 2-bit saturating outcome counters to bias insertion depth: blocks from PCs with frequent hits are inserted at MRU (RRPV=0), while others use SRRIP default (RRPV=2). Additionally, a per-set streaming detector tracks monotonic address deltas; when streaming is detected, new blocks are inserted at distant RRPV (RRPV=3) or bypassed (not cached) to avoid cache pollution. This design improves over DRRIP-DBC by leveraging program context for reuse prediction (SHiP-lite), adaptively responding to streaming phases (LBM, MILC), and reducing retention of useless blocks (mcf, omnetpp). All metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64K entries, and 2 bits/set streaming state.",,ChampSim_CRC2/new_policies/006_01_srrip___ship_lite___streaming_bypass__srrip_ship_sb_t04.cc,0.417762016,0.417762016,42%
1402,astar,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) with a lightweight dead-block predictor (DBP) using per-line 2-bit reuse counters and periodic decay. DRRIP uses set-dueling and a global 10-bit PSEL to dynamically choose between SRRIP and BRRIP insertion depths, adapting to workload locality. The dead-block predictor tracks recent reuse for each cache line: lines not reused after fill are marked as ""dead"" and prioritized for eviction. On fills, blocks predicted dead are inserted at distant RRPV (3) or bypassed if streaming is detected. This approach improves over SRRIP-SHiP-SB by directly identifying and evicting dead blocks (beneficial for mcf, omnetpp), while DRRIP adapts insertion depth to workload phase changes (helpful for milc, astar, lbm). Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line DBP counter, 10 bits PSEL, and 64 leader sets.",,ChampSim_CRC2/new_policies/007_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.421729046,0.421729046,0%
1403,lbm,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) with a lightweight dead-block predictor (DBP) using per-line 2-bit reuse counters and periodic decay. DRRIP uses set-dueling and a global 10-bit PSEL to dynamically choose between SRRIP and BRRIP insertion depths, adapting to workload locality. The dead-block predictor tracks recent reuse for each cache line: lines not reused after fill are marked as ""dead"" and prioritized for eviction. On fills, blocks predicted dead are inserted at distant RRPV (3) or bypassed if streaming is detected. This approach improves over SRRIP-SHiP-SB by directly identifying and evicting dead blocks (beneficial for mcf, omnetpp), while DRRIP adapts insertion depth to workload phase changes (helpful for milc, astar, lbm). Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line DBP counter, 10 bits PSEL, and 64 leader sets.",,ChampSim_CRC2/new_policies/007_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.396235378,0.396235378,0%
1404,mcf,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) with a lightweight dead-block predictor (DBP) using per-line 2-bit reuse counters and periodic decay. DRRIP uses set-dueling and a global 10-bit PSEL to dynamically choose between SRRIP and BRRIP insertion depths, adapting to workload locality. The dead-block predictor tracks recent reuse for each cache line: lines not reused after fill are marked as ""dead"" and prioritized for eviction. On fills, blocks predicted dead are inserted at distant RRPV (3) or bypassed if streaming is detected. This approach improves over SRRIP-SHiP-SB by directly identifying and evicting dead blocks (beneficial for mcf, omnetpp), while DRRIP adapts insertion depth to workload phase changes (helpful for milc, astar, lbm). Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line DBP counter, 10 bits PSEL, and 64 leader sets.",,ChampSim_CRC2/new_policies/007_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.466696929,0.466696929,0%
1405,milc,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) with a lightweight dead-block predictor (DBP) using per-line 2-bit reuse counters and periodic decay. DRRIP uses set-dueling and a global 10-bit PSEL to dynamically choose between SRRIP and BRRIP insertion depths, adapting to workload locality. The dead-block predictor tracks recent reuse for each cache line: lines not reused after fill are marked as ""dead"" and prioritized for eviction. On fills, blocks predicted dead are inserted at distant RRPV (3) or bypassed if streaming is detected. This approach improves over SRRIP-SHiP-SB by directly identifying and evicting dead blocks (beneficial for mcf, omnetpp), while DRRIP adapts insertion depth to workload phase changes (helpful for milc, astar, lbm). Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line DBP counter, 10 bits PSEL, and 64 leader sets.",,ChampSim_CRC2/new_policies/007_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.300832024,0.300832024,0%
1406,omnetpp,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) with a lightweight dead-block predictor (DBP) using per-line 2-bit reuse counters and periodic decay. DRRIP uses set-dueling and a global 10-bit PSEL to dynamically choose between SRRIP and BRRIP insertion depths, adapting to workload locality. The dead-block predictor tracks recent reuse for each cache line: lines not reused after fill are marked as ""dead"" and prioritized for eviction. On fills, blocks predicted dead are inserted at distant RRPV (3) or bypassed if streaming is detected. This approach improves over SRRIP-SHiP-SB by directly identifying and evicting dead blocks (beneficial for mcf, omnetpp), while DRRIP adapts insertion depth to workload phase changes (helpful for milc, astar, lbm). Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line DBP counter, 10 bits PSEL, and 64 leader sets.",,ChampSim_CRC2/new_policies/007_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.550596179,0.550596179,0%
1407,astar,DRRIP + SHiP-lite + Dead-Block Bit (DRRIP-SHiP-DB),"This policy combines DRRIP (Dynamic RRIP with set-dueling and a 10-bit PSEL selector), SHiP-lite (PC signature-based insertion depth control), and a per-line dead-block bit for fast victim selection. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths based on leader sets, improving performance across diverse workloads. SHiP-lite leverages compact PC signatures to bias insertion depth for blocks with demonstrated reuse, boosting hit rates for control-dominated and phase-changing workloads (astar, milc, omnetpp). A single dead-block bit per line is set on fill and cleared on hit, allowing immediate selection of dead blocks for eviction, which accelerates victim selection and reduces cache pollution from non-reused blocks (mcf, lbm). All metadata fits within 64 KiB: 2 bits/line RRPV, 1 bit/line dead-block, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64 entries/set, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_01_drrip___ship_lite___dead_block_bit__drrip_ship_db_t04.cc,0.045124665,0.045124665,0%
1408,lbm,DRRIP + SHiP-lite + Dead-Block Bit (DRRIP-SHiP-DB),"This policy combines DRRIP (Dynamic RRIP with set-dueling and a 10-bit PSEL selector), SHiP-lite (PC signature-based insertion depth control), and a per-line dead-block bit for fast victim selection. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths based on leader sets, improving performance across diverse workloads. SHiP-lite leverages compact PC signatures to bias insertion depth for blocks with demonstrated reuse, boosting hit rates for control-dominated and phase-changing workloads (astar, milc, omnetpp). A single dead-block bit per line is set on fill and cleared on hit, allowing immediate selection of dead blocks for eviction, which accelerates victim selection and reduces cache pollution from non-reused blocks (mcf, lbm). All metadata fits within 64 KiB: 2 bits/line RRPV, 1 bit/line dead-block, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64 entries/set, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_01_drrip___ship_lite___dead_block_bit__drrip_ship_db_t04.cc,0.058753172,0.058753172,0%
1409,mcf,DRRIP + SHiP-lite + Dead-Block Bit (DRRIP-SHiP-DB),"This policy combines DRRIP (Dynamic RRIP with set-dueling and a 10-bit PSEL selector), SHiP-lite (PC signature-based insertion depth control), and a per-line dead-block bit for fast victim selection. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths based on leader sets, improving performance across diverse workloads. SHiP-lite leverages compact PC signatures to bias insertion depth for blocks with demonstrated reuse, boosting hit rates for control-dominated and phase-changing workloads (astar, milc, omnetpp). A single dead-block bit per line is set on fill and cleared on hit, allowing immediate selection of dead blocks for eviction, which accelerates victim selection and reduces cache pollution from non-reused blocks (mcf, lbm). All metadata fits within 64 KiB: 2 bits/line RRPV, 1 bit/line dead-block, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64 entries/set, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_01_drrip___ship_lite___dead_block_bit__drrip_ship_db_t04.cc,0.214312084,0.214312084,0%
1410,milc,DRRIP + SHiP-lite + Dead-Block Bit (DRRIP-SHiP-DB),"This policy combines DRRIP (Dynamic RRIP with set-dueling and a 10-bit PSEL selector), SHiP-lite (PC signature-based insertion depth control), and a per-line dead-block bit for fast victim selection. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths based on leader sets, improving performance across diverse workloads. SHiP-lite leverages compact PC signatures to bias insertion depth for blocks with demonstrated reuse, boosting hit rates for control-dominated and phase-changing workloads (astar, milc, omnetpp). A single dead-block bit per line is set on fill and cleared on hit, allowing immediate selection of dead blocks for eviction, which accelerates victim selection and reduces cache pollution from non-reused blocks (mcf, lbm). All metadata fits within 64 KiB: 2 bits/line RRPV, 1 bit/line dead-block, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64 entries/set, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_01_drrip___ship_lite___dead_block_bit__drrip_ship_db_t04.cc,0.009520482,0.009520482,0%
1411,omnetpp,DRRIP + SHiP-lite + Dead-Block Bit (DRRIP-SHiP-DB),"This policy combines DRRIP (Dynamic RRIP with set-dueling and a 10-bit PSEL selector), SHiP-lite (PC signature-based insertion depth control), and a per-line dead-block bit for fast victim selection. DRRIP adaptively chooses between SRRIP and BRRIP insertion depths based on leader sets, improving performance across diverse workloads. SHiP-lite leverages compact PC signatures to bias insertion depth for blocks with demonstrated reuse, boosting hit rates for control-dominated and phase-changing workloads (astar, milc, omnetpp). A single dead-block bit per line is set on fill and cleared on hit, allowing immediate selection of dead blocks for eviction, which accelerates victim selection and reduces cache pollution from non-reused blocks (mcf, lbm). All metadata fits within 64 KiB: 2 bits/line RRPV, 1 bit/line dead-block, 6 bits/set × 2048 sets for SHiP signatures, 2 bits/signature × 64 entries/set, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_01_drrip___ship_lite___dead_block_bit__drrip_ship_db_t04.cc,0.001151215,0.001151215,0%
1412,astar,DRRIP-SHiP-DBP (Dynamic RRIP + SHiP-lite + Dead-Block Prediction),"This policy combines DRRIP (Dynamic RRIP: SRRIP vs BRRIP with set-dueling) for adaptive recency/frequency insertion control, SHiP-lite (compact 6-bit PC signatures with 2-bit outcome counters for context-aware reuse prediction), and a lightweight dead-block predictor (2-bit per-line reuse counters, periodically decayed) to minimize retention of useless cache lines. DRRIP dynamically selects between frequent MRU (SRRIP) and infrequent MRU (BRRIP) insertion depths via 32 set-dueling leader sets and a 10-bit PSEL counter. SHiP-lite augments insertion decisions using PC signatures to promote blocks with demonstrated reuse. The dead-block predictor further refines victim selection by preferentially evicting lines with low reuse counts. This three-way synergy improves performance across diverse workloads: DRRIP adapts to phase changes (MILC, LBM), SHiP-lite exploits program context for reuse (astar, mcf, omnetpp), and dead-block prediction reduces cache pollution in pointer-heavy or streaming phases. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line dead-block, 32 × 6 bits/set SHiP signatures, 2 bits/signature × 2048 × 64 entries, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_02_drrip_ship_dbp__dynamic_rrip___ship_lite___dead_block_prediction_t07.cc,0.084117953,0.084117953,0%
1413,lbm,DRRIP-SHiP-DBP (Dynamic RRIP + SHiP-lite + Dead-Block Prediction),"This policy combines DRRIP (Dynamic RRIP: SRRIP vs BRRIP with set-dueling) for adaptive recency/frequency insertion control, SHiP-lite (compact 6-bit PC signatures with 2-bit outcome counters for context-aware reuse prediction), and a lightweight dead-block predictor (2-bit per-line reuse counters, periodically decayed) to minimize retention of useless cache lines. DRRIP dynamically selects between frequent MRU (SRRIP) and infrequent MRU (BRRIP) insertion depths via 32 set-dueling leader sets and a 10-bit PSEL counter. SHiP-lite augments insertion decisions using PC signatures to promote blocks with demonstrated reuse. The dead-block predictor further refines victim selection by preferentially evicting lines with low reuse counts. This three-way synergy improves performance across diverse workloads: DRRIP adapts to phase changes (MILC, LBM), SHiP-lite exploits program context for reuse (astar, mcf, omnetpp), and dead-block prediction reduces cache pollution in pointer-heavy or streaming phases. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line dead-block, 32 × 6 bits/set SHiP signatures, 2 bits/signature × 2048 × 64 entries, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_02_drrip_ship_dbp__dynamic_rrip___ship_lite___dead_block_prediction_t07.cc,0.085867255,0.085867255,0%
1414,mcf,DRRIP-SHiP-DBP (Dynamic RRIP + SHiP-lite + Dead-Block Prediction),"This policy combines DRRIP (Dynamic RRIP: SRRIP vs BRRIP with set-dueling) for adaptive recency/frequency insertion control, SHiP-lite (compact 6-bit PC signatures with 2-bit outcome counters for context-aware reuse prediction), and a lightweight dead-block predictor (2-bit per-line reuse counters, periodically decayed) to minimize retention of useless cache lines. DRRIP dynamically selects between frequent MRU (SRRIP) and infrequent MRU (BRRIP) insertion depths via 32 set-dueling leader sets and a 10-bit PSEL counter. SHiP-lite augments insertion decisions using PC signatures to promote blocks with demonstrated reuse. The dead-block predictor further refines victim selection by preferentially evicting lines with low reuse counts. This three-way synergy improves performance across diverse workloads: DRRIP adapts to phase changes (MILC, LBM), SHiP-lite exploits program context for reuse (astar, mcf, omnetpp), and dead-block prediction reduces cache pollution in pointer-heavy or streaming phases. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line dead-block, 32 × 6 bits/set SHiP signatures, 2 bits/signature × 2048 × 64 entries, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_02_drrip_ship_dbp__dynamic_rrip___ship_lite___dead_block_prediction_t07.cc,0.11951733,0.11951733,0%
1415,milc,DRRIP-SHiP-DBP (Dynamic RRIP + SHiP-lite + Dead-Block Prediction),"This policy combines DRRIP (Dynamic RRIP: SRRIP vs BRRIP with set-dueling) for adaptive recency/frequency insertion control, SHiP-lite (compact 6-bit PC signatures with 2-bit outcome counters for context-aware reuse prediction), and a lightweight dead-block predictor (2-bit per-line reuse counters, periodically decayed) to minimize retention of useless cache lines. DRRIP dynamically selects between frequent MRU (SRRIP) and infrequent MRU (BRRIP) insertion depths via 32 set-dueling leader sets and a 10-bit PSEL counter. SHiP-lite augments insertion decisions using PC signatures to promote blocks with demonstrated reuse. The dead-block predictor further refines victim selection by preferentially evicting lines with low reuse counts. This three-way synergy improves performance across diverse workloads: DRRIP adapts to phase changes (MILC, LBM), SHiP-lite exploits program context for reuse (astar, mcf, omnetpp), and dead-block prediction reduces cache pollution in pointer-heavy or streaming phases. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line dead-block, 32 × 6 bits/set SHiP signatures, 2 bits/signature × 2048 × 64 entries, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_02_drrip_ship_dbp__dynamic_rrip___ship_lite___dead_block_prediction_t07.cc,0.102569209,0.102569209,0%
1416,omnetpp,DRRIP-SHiP-DBP (Dynamic RRIP + SHiP-lite + Dead-Block Prediction),"This policy combines DRRIP (Dynamic RRIP: SRRIP vs BRRIP with set-dueling) for adaptive recency/frequency insertion control, SHiP-lite (compact 6-bit PC signatures with 2-bit outcome counters for context-aware reuse prediction), and a lightweight dead-block predictor (2-bit per-line reuse counters, periodically decayed) to minimize retention of useless cache lines. DRRIP dynamically selects between frequent MRU (SRRIP) and infrequent MRU (BRRIP) insertion depths via 32 set-dueling leader sets and a 10-bit PSEL counter. SHiP-lite augments insertion decisions using PC signatures to promote blocks with demonstrated reuse. The dead-block predictor further refines victim selection by preferentially evicting lines with low reuse counts. This three-way synergy improves performance across diverse workloads: DRRIP adapts to phase changes (MILC, LBM), SHiP-lite exploits program context for reuse (astar, mcf, omnetpp), and dead-block prediction reduces cache pollution in pointer-heavy or streaming phases. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line dead-block, 32 × 6 bits/set SHiP signatures, 2 bits/signature × 2048 × 64 entries, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/007_02_drrip_ship_dbp__dynamic_rrip___ship_lite___dead_block_prediction_t07.cc,0.042672488,0.042672488,0%
1417,all,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) with a lightweight dead-block predictor (DBP) using per-line 2-bit reuse counters and periodic decay. DRRIP uses set-dueling and a global 10-bit PSEL to dynamically choose between SRRIP and BRRIP insertion depths, adapting to workload locality. The dead-block predictor tracks recent reuse for each cache line: lines not reused after fill are marked as ""dead"" and prioritized for eviction. On fills, blocks predicted dead are inserted at distant RRPV (3) or bypassed if streaming is detected. This approach improves over SRRIP-SHiP-SB by directly identifying and evicting dead blocks (beneficial for mcf, omnetpp), while DRRIP adapts insertion depth to workload phase changes (helpful for milc, astar, lbm). Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 2 bits/line DBP counter, 10 bits PSEL, and 64 leader sets.",,ChampSim_CRC2/new_policies/007_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.427217911,0.427217911,43%
1418,astar,SHiP-Lite with Streaming Bypass (SHiP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with a compact streaming detector to adapt insertion depth and bypass logic per workload phase. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to track block reuse, biasing insertion depth: blocks with frequent reuse are inserted at RRPV=0 (MRU), while predicted dead blocks are inserted at RRPV=3 (LRU). A lightweight streaming detector monitors address deltas per set, and if monotonic streaming is detected, new blocks are bypassed or inserted at distant RRPV, minimizing cache pollution for workloads like lbm and omnetpp. This hybrid approach improves performance across diverse workloads by leveraging code-based reuse prediction (beneficial for mcf, astar, milc) and aggressive streaming bypass for regular access patterns. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 2 bits/signature outcome counter (4096 entries), and 1 bit/set streaming flag.",,ChampSim_CRC2/new_policies/008_01_ship_lite_with_streaming_bypass__ship_sb_t04.cc,0.460802953,0.460802953,0%
1419,lbm,SHiP-Lite with Streaming Bypass (SHiP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with a compact streaming detector to adapt insertion depth and bypass logic per workload phase. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to track block reuse, biasing insertion depth: blocks with frequent reuse are inserted at RRPV=0 (MRU), while predicted dead blocks are inserted at RRPV=3 (LRU). A lightweight streaming detector monitors address deltas per set, and if monotonic streaming is detected, new blocks are bypassed or inserted at distant RRPV, minimizing cache pollution for workloads like lbm and omnetpp. This hybrid approach improves performance across diverse workloads by leveraging code-based reuse prediction (beneficial for mcf, astar, milc) and aggressive streaming bypass for regular access patterns. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 2 bits/signature outcome counter (4096 entries), and 1 bit/set streaming flag.",,ChampSim_CRC2/new_policies/008_01_ship_lite_with_streaming_bypass__ship_sb_t04.cc,0.439858667,0.439858667,0%
1420,mcf,SHiP-Lite with Streaming Bypass (SHiP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with a compact streaming detector to adapt insertion depth and bypass logic per workload phase. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to track block reuse, biasing insertion depth: blocks with frequent reuse are inserted at RRPV=0 (MRU), while predicted dead blocks are inserted at RRPV=3 (LRU). A lightweight streaming detector monitors address deltas per set, and if monotonic streaming is detected, new blocks are bypassed or inserted at distant RRPV, minimizing cache pollution for workloads like lbm and omnetpp. This hybrid approach improves performance across diverse workloads by leveraging code-based reuse prediction (beneficial for mcf, astar, milc) and aggressive streaming bypass for regular access patterns. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 2 bits/signature outcome counter (4096 entries), and 1 bit/set streaming flag.",,ChampSim_CRC2/new_policies/008_01_ship_lite_with_streaming_bypass__ship_sb_t04.cc,0.404981801,0.404981801,0%
1421,milc,SHiP-Lite with Streaming Bypass (SHiP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with a compact streaming detector to adapt insertion depth and bypass logic per workload phase. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to track block reuse, biasing insertion depth: blocks with frequent reuse are inserted at RRPV=0 (MRU), while predicted dead blocks are inserted at RRPV=3 (LRU). A lightweight streaming detector monitors address deltas per set, and if monotonic streaming is detected, new blocks are bypassed or inserted at distant RRPV, minimizing cache pollution for workloads like lbm and omnetpp. This hybrid approach improves performance across diverse workloads by leveraging code-based reuse prediction (beneficial for mcf, astar, milc) and aggressive streaming bypass for regular access patterns. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 2 bits/signature outcome counter (4096 entries), and 1 bit/set streaming flag.",,ChampSim_CRC2/new_policies/008_01_ship_lite_with_streaming_bypass__ship_sb_t04.cc,0.320631513,0.320631513,0%
1422,omnetpp,SHiP-Lite with Streaming Bypass (SHiP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with a compact streaming detector to adapt insertion depth and bypass logic per workload phase. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to track block reuse, biasing insertion depth: blocks with frequent reuse are inserted at RRPV=0 (MRU), while predicted dead blocks are inserted at RRPV=3 (LRU). A lightweight streaming detector monitors address deltas per set, and if monotonic streaming is detected, new blocks are bypassed or inserted at distant RRPV, minimizing cache pollution for workloads like lbm and omnetpp. This hybrid approach improves performance across diverse workloads by leveraging code-based reuse prediction (beneficial for mcf, astar, milc) and aggressive streaming bypass for regular access patterns. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 2 bits/signature outcome counter (4096 entries), and 1 bit/set streaming flag.",,ChampSim_CRC2/new_policies/008_01_ship_lite_with_streaming_bypass__ship_sb_t04.cc,0.514458694,0.514458694,0%
1423,all,SHiP-Lite with Streaming Bypass (SHiP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with a compact streaming detector to adapt insertion depth and bypass logic per workload phase. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to track block reuse, biasing insertion depth: blocks with frequent reuse are inserted at RRPV=0 (MRU), while predicted dead blocks are inserted at RRPV=3 (LRU). A lightweight streaming detector monitors address deltas per set, and if monotonic streaming is detected, new blocks are bypassed or inserted at distant RRPV, minimizing cache pollution for workloads like lbm and omnetpp. This hybrid approach improves performance across diverse workloads by leveraging code-based reuse prediction (beneficial for mcf, astar, milc) and aggressive streaming bypass for regular access patterns. Metadata fits comfortably under 64 KiB: 2 bits/line RRPV, 6 bits/line signature, 2 bits/signature outcome counter (4096 entries), and 1 bit/set streaming flag.",,ChampSim_CRC2/new_policies/008_01_ship_lite_with_streaming_bypass__ship_sb_t04.cc,0.428146725,0.428146725,43%
1424,astar,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"DRRIP-DBP combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact dead-block predictor (DBP) to improve cache performance across diverse workloads. DRRIP adaptively chooses between frequent (SRRIP) and infrequent (BRRIP) insertion depths using a 10-bit PSEL counter and 32 leader sets, optimizing for workloads with varying reuse. To further reduce cache pollution from dead-on-arrival blocks (common in streaming and pointer-chasing workloads like lbm, omnetpp, mcf), a 1-bit per-line dead-block predictor tracks whether a block was reused before eviction. On fill, blocks predicted dead are inserted at distant RRPV (LRU) or bypassed; predicted live blocks follow DRRIP’s insertion policy. This hybrid approach leverages global phase adaptation and local dead-block filtering, outperforming pure RRIP or SHiP-lite in both regular and irregular access patterns. Metadata fits under 64 KiB: 2 bits/line RRPV, 1 bit/line DBP, 10 bits PSEL, 32 leader set flags.",,ChampSim_CRC2/new_policies/009_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.045124665,0.045124665,0%
1425,lbm,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"DRRIP-DBP combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact dead-block predictor (DBP) to improve cache performance across diverse workloads. DRRIP adaptively chooses between frequent (SRRIP) and infrequent (BRRIP) insertion depths using a 10-bit PSEL counter and 32 leader sets, optimizing for workloads with varying reuse. To further reduce cache pollution from dead-on-arrival blocks (common in streaming and pointer-chasing workloads like lbm, omnetpp, mcf), a 1-bit per-line dead-block predictor tracks whether a block was reused before eviction. On fill, blocks predicted dead are inserted at distant RRPV (LRU) or bypassed; predicted live blocks follow DRRIP’s insertion policy. This hybrid approach leverages global phase adaptation and local dead-block filtering, outperforming pure RRIP or SHiP-lite in both regular and irregular access patterns. Metadata fits under 64 KiB: 2 bits/line RRPV, 1 bit/line DBP, 10 bits PSEL, 32 leader set flags.",,ChampSim_CRC2/new_policies/009_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.058753172,0.058753172,0%
1426,mcf,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"DRRIP-DBP combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact dead-block predictor (DBP) to improve cache performance across diverse workloads. DRRIP adaptively chooses between frequent (SRRIP) and infrequent (BRRIP) insertion depths using a 10-bit PSEL counter and 32 leader sets, optimizing for workloads with varying reuse. To further reduce cache pollution from dead-on-arrival blocks (common in streaming and pointer-chasing workloads like lbm, omnetpp, mcf), a 1-bit per-line dead-block predictor tracks whether a block was reused before eviction. On fill, blocks predicted dead are inserted at distant RRPV (LRU) or bypassed; predicted live blocks follow DRRIP’s insertion policy. This hybrid approach leverages global phase adaptation and local dead-block filtering, outperforming pure RRIP or SHiP-lite in both regular and irregular access patterns. Metadata fits under 64 KiB: 2 bits/line RRPV, 1 bit/line DBP, 10 bits PSEL, 32 leader set flags.",,ChampSim_CRC2/new_policies/009_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.214312084,0.214312084,0%
1427,milc,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"DRRIP-DBP combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact dead-block predictor (DBP) to improve cache performance across diverse workloads. DRRIP adaptively chooses between frequent (SRRIP) and infrequent (BRRIP) insertion depths using a 10-bit PSEL counter and 32 leader sets, optimizing for workloads with varying reuse. To further reduce cache pollution from dead-on-arrival blocks (common in streaming and pointer-chasing workloads like lbm, omnetpp, mcf), a 1-bit per-line dead-block predictor tracks whether a block was reused before eviction. On fill, blocks predicted dead are inserted at distant RRPV (LRU) or bypassed; predicted live blocks follow DRRIP’s insertion policy. This hybrid approach leverages global phase adaptation and local dead-block filtering, outperforming pure RRIP or SHiP-lite in both regular and irregular access patterns. Metadata fits under 64 KiB: 2 bits/line RRPV, 1 bit/line DBP, 10 bits PSEL, 32 leader set flags.",,ChampSim_CRC2/new_policies/009_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.009520482,0.009520482,0%
1428,omnetpp,DRRIP-DBP: Dynamic RRIP with Dead-Block Prediction,"DRRIP-DBP combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact dead-block predictor (DBP) to improve cache performance across diverse workloads. DRRIP adaptively chooses between frequent (SRRIP) and infrequent (BRRIP) insertion depths using a 10-bit PSEL counter and 32 leader sets, optimizing for workloads with varying reuse. To further reduce cache pollution from dead-on-arrival blocks (common in streaming and pointer-chasing workloads like lbm, omnetpp, mcf), a 1-bit per-line dead-block predictor tracks whether a block was reused before eviction. On fill, blocks predicted dead are inserted at distant RRPV (LRU) or bypassed; predicted live blocks follow DRRIP’s insertion policy. This hybrid approach leverages global phase adaptation and local dead-block filtering, outperforming pure RRIP or SHiP-lite in both regular and irregular access patterns. Metadata fits under 64 KiB: 2 bits/line RRPV, 1 bit/line DBP, 10 bits PSEL, 32 leader set flags.",,ChampSim_CRC2/new_policies/009_00_drrip_dbp__dynamic_rrip_with_dead_block_prediction_t02.cc,0.001151215,0.001151215,0%
1429,astar,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) with a compact streaming detector and per-line dead-block approximation to adapt insertion and bypass behavior. DRRIP uses a 10-bit PSEL counter and 64 leader sets to select between SRRIP (frequent MRU insertion) and BRRIP (mostly LRU insertion) based on observed hits, adapting to workload phase changes (e.g., mcf, milc, astar). A lightweight streaming detector monitors address deltas per set and bypasses fills for monotonic streams (lbm, omnetpp), minimizing pollution. Additionally, each cache line tracks a 1-bit dead-block flag, set on eviction and cleared on reuse, enabling aggressive bypass for lines predicted dead. This hybrid approach improves performance by combining adaptive insertion depth, streaming bypass, and dead-block approximation, while fitting comfortably under 64 KiB metadata.",,ChampSim_CRC2/new_policies/009_01_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbd_t04.cc,0.448812173,0.448812173,0%
1430,lbm,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) with a compact streaming detector and per-line dead-block approximation to adapt insertion and bypass behavior. DRRIP uses a 10-bit PSEL counter and 64 leader sets to select between SRRIP (frequent MRU insertion) and BRRIP (mostly LRU insertion) based on observed hits, adapting to workload phase changes (e.g., mcf, milc, astar). A lightweight streaming detector monitors address deltas per set and bypasses fills for monotonic streams (lbm, omnetpp), minimizing pollution. Additionally, each cache line tracks a 1-bit dead-block flag, set on eviction and cleared on reuse, enabling aggressive bypass for lines predicted dead. This hybrid approach improves performance by combining adaptive insertion depth, streaming bypass, and dead-block approximation, while fitting comfortably under 64 KiB metadata.",,ChampSim_CRC2/new_policies/009_01_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbd_t04.cc,0.433571727,0.433571727,0%
1431,mcf,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) with a compact streaming detector and per-line dead-block approximation to adapt insertion and bypass behavior. DRRIP uses a 10-bit PSEL counter and 64 leader sets to select between SRRIP (frequent MRU insertion) and BRRIP (mostly LRU insertion) based on observed hits, adapting to workload phase changes (e.g., mcf, milc, astar). A lightweight streaming detector monitors address deltas per set and bypasses fills for monotonic streams (lbm, omnetpp), minimizing pollution. Additionally, each cache line tracks a 1-bit dead-block flag, set on eviction and cleared on reuse, enabling aggressive bypass for lines predicted dead. This hybrid approach improves performance by combining adaptive insertion depth, streaming bypass, and dead-block approximation, while fitting comfortably under 64 KiB metadata.",,ChampSim_CRC2/new_policies/009_01_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbd_t04.cc,0.39798363,0.39798363,0%
1432,milc,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) with a compact streaming detector and per-line dead-block approximation to adapt insertion and bypass behavior. DRRIP uses a 10-bit PSEL counter and 64 leader sets to select between SRRIP (frequent MRU insertion) and BRRIP (mostly LRU insertion) based on observed hits, adapting to workload phase changes (e.g., mcf, milc, astar). A lightweight streaming detector monitors address deltas per set and bypasses fills for monotonic streams (lbm, omnetpp), minimizing pollution. Additionally, each cache line tracks a 1-bit dead-block flag, set on eviction and cleared on reuse, enabling aggressive bypass for lines predicted dead. This hybrid approach improves performance by combining adaptive insertion depth, streaming bypass, and dead-block approximation, while fitting comfortably under 64 KiB metadata.",,ChampSim_CRC2/new_policies/009_01_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbd_t04.cc,0.318393955,0.318393955,0%
1433,omnetpp,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) with a compact streaming detector and per-line dead-block approximation to adapt insertion and bypass behavior. DRRIP uses a 10-bit PSEL counter and 64 leader sets to select between SRRIP (frequent MRU insertion) and BRRIP (mostly LRU insertion) based on observed hits, adapting to workload phase changes (e.g., mcf, milc, astar). A lightweight streaming detector monitors address deltas per set and bypasses fills for monotonic streams (lbm, omnetpp), minimizing pollution. Additionally, each cache line tracks a 1-bit dead-block flag, set on eviction and cleared on reuse, enabling aggressive bypass for lines predicted dead. This hybrid approach improves performance by combining adaptive insertion depth, streaming bypass, and dead-block approximation, while fitting comfortably under 64 KiB metadata.",,ChampSim_CRC2/new_policies/009_01_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbd_t04.cc,0.453441972,0.453441972,0%
1434,astar,DRRIP-DBP (Dynamic Re-reference Interval Prediction with Dead-Block Prediction),"DRRIP-DBP combines dynamic RRIP (SRRIP vs BRRIP) set-dueling for adaptive insertion depth with a compact dead-block predictor (per-line 1-bit reuse counter) to minimize cache pollution. DRRIP uses a 10-bit PSEL counter and 64 leader sets to decide between frequent (SRRIP) and infrequent (BRRIP) insertion, adapting to workload locality and phase changes (beneficial for milc, astar, omnetpp). The dead-block predictor approximates block reuse: on a cache fill, if the block's reuse bit is clear (dead), insertion occurs at the farthest RRPV (LRU), causing fast eviction; if alive, insertion is at MRU. This mechanism prevents long-lived pollution from blocks with little reuse, improving performance for memory-bound workloads (mcf, lbm). The policy is simple and metadata-efficient: 2 bits/line RRPV, 1 bit/line dead-block reuse bit, and a 10-bit global PSEL counter. No PC-based prediction or streaming detector is used, ensuring diversity from prior designs.",,ChampSim_CRC2/new_policies/009_02_drrip_dbp__dynamic_re_reference_interval_prediction_with_dead_block_prediction_t07.cc,0.429999894,0.429999894,0%
1435,lbm,DRRIP-DBP (Dynamic Re-reference Interval Prediction with Dead-Block Prediction),"DRRIP-DBP combines dynamic RRIP (SRRIP vs BRRIP) set-dueling for adaptive insertion depth with a compact dead-block predictor (per-line 1-bit reuse counter) to minimize cache pollution. DRRIP uses a 10-bit PSEL counter and 64 leader sets to decide between frequent (SRRIP) and infrequent (BRRIP) insertion, adapting to workload locality and phase changes (beneficial for milc, astar, omnetpp). The dead-block predictor approximates block reuse: on a cache fill, if the block's reuse bit is clear (dead), insertion occurs at the farthest RRPV (LRU), causing fast eviction; if alive, insertion is at MRU. This mechanism prevents long-lived pollution from blocks with little reuse, improving performance for memory-bound workloads (mcf, lbm). The policy is simple and metadata-efficient: 2 bits/line RRPV, 1 bit/line dead-block reuse bit, and a 10-bit global PSEL counter. No PC-based prediction or streaming detector is used, ensuring diversity from prior designs.",,ChampSim_CRC2/new_policies/009_02_drrip_dbp__dynamic_re_reference_interval_prediction_with_dead_block_prediction_t07.cc,0.408602212,0.408602212,0%
1436,mcf,DRRIP-DBP (Dynamic Re-reference Interval Prediction with Dead-Block Prediction),"DRRIP-DBP combines dynamic RRIP (SRRIP vs BRRIP) set-dueling for adaptive insertion depth with a compact dead-block predictor (per-line 1-bit reuse counter) to minimize cache pollution. DRRIP uses a 10-bit PSEL counter and 64 leader sets to decide between frequent (SRRIP) and infrequent (BRRIP) insertion, adapting to workload locality and phase changes (beneficial for milc, astar, omnetpp). The dead-block predictor approximates block reuse: on a cache fill, if the block's reuse bit is clear (dead), insertion occurs at the farthest RRPV (LRU), causing fast eviction; if alive, insertion is at MRU. This mechanism prevents long-lived pollution from blocks with little reuse, improving performance for memory-bound workloads (mcf, lbm). The policy is simple and metadata-efficient: 2 bits/line RRPV, 1 bit/line dead-block reuse bit, and a 10-bit global PSEL counter. No PC-based prediction or streaming detector is used, ensuring diversity from prior designs.",,ChampSim_CRC2/new_policies/009_02_drrip_dbp__dynamic_re_reference_interval_prediction_with_dead_block_prediction_t07.cc,0.459477502,0.459477502,0%
1437,milc,DRRIP-DBP (Dynamic Re-reference Interval Prediction with Dead-Block Prediction),"DRRIP-DBP combines dynamic RRIP (SRRIP vs BRRIP) set-dueling for adaptive insertion depth with a compact dead-block predictor (per-line 1-bit reuse counter) to minimize cache pollution. DRRIP uses a 10-bit PSEL counter and 64 leader sets to decide between frequent (SRRIP) and infrequent (BRRIP) insertion, adapting to workload locality and phase changes (beneficial for milc, astar, omnetpp). The dead-block predictor approximates block reuse: on a cache fill, if the block's reuse bit is clear (dead), insertion occurs at the farthest RRPV (LRU), causing fast eviction; if alive, insertion is at MRU. This mechanism prevents long-lived pollution from blocks with little reuse, improving performance for memory-bound workloads (mcf, lbm). The policy is simple and metadata-efficient: 2 bits/line RRPV, 1 bit/line dead-block reuse bit, and a 10-bit global PSEL counter. No PC-based prediction or streaming detector is used, ensuring diversity from prior designs.",,ChampSim_CRC2/new_policies/009_02_drrip_dbp__dynamic_re_reference_interval_prediction_with_dead_block_prediction_t07.cc,0.307479525,0.307479525,0%
1438,omnetpp,DRRIP-DBP (Dynamic Re-reference Interval Prediction with Dead-Block Prediction),"DRRIP-DBP combines dynamic RRIP (SRRIP vs BRRIP) set-dueling for adaptive insertion depth with a compact dead-block predictor (per-line 1-bit reuse counter) to minimize cache pollution. DRRIP uses a 10-bit PSEL counter and 64 leader sets to decide between frequent (SRRIP) and infrequent (BRRIP) insertion, adapting to workload locality and phase changes (beneficial for milc, astar, omnetpp). The dead-block predictor approximates block reuse: on a cache fill, if the block's reuse bit is clear (dead), insertion occurs at the farthest RRPV (LRU), causing fast eviction; if alive, insertion is at MRU. This mechanism prevents long-lived pollution from blocks with little reuse, improving performance for memory-bound workloads (mcf, lbm). The policy is simple and metadata-efficient: 2 bits/line RRPV, 1 bit/line dead-block reuse bit, and a 10-bit global PSEL counter. No PC-based prediction or streaming detector is used, ensuring diversity from prior designs.",,ChampSim_CRC2/new_policies/009_02_drrip_dbp__dynamic_re_reference_interval_prediction_with_dead_block_prediction_t07.cc,0.401602138,0.401602138,0%
1439,all,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) with a compact streaming detector and per-line dead-block approximation to adapt insertion and bypass behavior. DRRIP uses a 10-bit PSEL counter and 64 leader sets to select between SRRIP (frequent MRU insertion) and BRRIP (mostly LRU insertion) based on observed hits, adapting to workload phase changes (e.g., mcf, milc, astar). A lightweight streaming detector monitors address deltas per set and bypasses fills for monotonic streams (lbm, omnetpp), minimizing pollution. Additionally, each cache line tracks a 1-bit dead-block flag, set on eviction and cleared on reuse, enabling aggressive bypass for lines predicted dead. This hybrid approach improves performance by combining adaptive insertion depth, streaming bypass, and dead-block approximation, while fitting comfortably under 64 KiB metadata.",,ChampSim_CRC2/new_policies/009_01_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbd_t04.cc,0.410440691,0.410440691,41%
1440,astar,SHiP-Lite with Streaming Bypass and PC-Signature Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a streaming detector and selective bypass. Each cache line tracks a compact 5-bit PC signature, and each signature has a 2-bit outcome counter (global table, 1024 entries) that biases insertion depth: lines accessed by PCs with high reuse are inserted closer to MRU, while those with low reuse are inserted at LRU. A per-set streaming detector monitors monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution for workloads like lbm and omnetpp. This hybrid approach adapts to both control-heavy (astar, mcf, milc) and streaming workloads, improving hit rates by learning reuse patterns at the PC level and avoiding cache pollution from streaming or dead-on-arrival blocks. All metadata fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_pc_signature_insertion__ship_sb_t02.cc,0.459823137,0.459823137,0%
1441,lbm,SHiP-Lite with Streaming Bypass and PC-Signature Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a streaming detector and selective bypass. Each cache line tracks a compact 5-bit PC signature, and each signature has a 2-bit outcome counter (global table, 1024 entries) that biases insertion depth: lines accessed by PCs with high reuse are inserted closer to MRU, while those with low reuse are inserted at LRU. A per-set streaming detector monitors monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution for workloads like lbm and omnetpp. This hybrid approach adapts to both control-heavy (astar, mcf, milc) and streaming workloads, improving hit rates by learning reuse patterns at the PC level and avoiding cache pollution from streaming or dead-on-arrival blocks. All metadata fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_pc_signature_insertion__ship_sb_t02.cc,0.248920793,0.248920793,0%
1442,mcf,SHiP-Lite with Streaming Bypass and PC-Signature Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a streaming detector and selective bypass. Each cache line tracks a compact 5-bit PC signature, and each signature has a 2-bit outcome counter (global table, 1024 entries) that biases insertion depth: lines accessed by PCs with high reuse are inserted closer to MRU, while those with low reuse are inserted at LRU. A per-set streaming detector monitors monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution for workloads like lbm and omnetpp. This hybrid approach adapts to both control-heavy (astar, mcf, milc) and streaming workloads, improving hit rates by learning reuse patterns at the PC level and avoiding cache pollution from streaming or dead-on-arrival blocks. All metadata fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_pc_signature_insertion__ship_sb_t02.cc,0.423545433,0.423545433,0%
1443,milc,SHiP-Lite with Streaming Bypass and PC-Signature Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a streaming detector and selective bypass. Each cache line tracks a compact 5-bit PC signature, and each signature has a 2-bit outcome counter (global table, 1024 entries) that biases insertion depth: lines accessed by PCs with high reuse are inserted closer to MRU, while those with low reuse are inserted at LRU. A per-set streaming detector monitors monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution for workloads like lbm and omnetpp. This hybrid approach adapts to both control-heavy (astar, mcf, milc) and streaming workloads, improving hit rates by learning reuse patterns at the PC level and avoiding cache pollution from streaming or dead-on-arrival blocks. All metadata fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_pc_signature_insertion__ship_sb_t02.cc,0.009357553,0.009357553,0%
1444,omnetpp,SHiP-Lite with Streaming Bypass and PC-Signature Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a streaming detector and selective bypass. Each cache line tracks a compact 5-bit PC signature, and each signature has a 2-bit outcome counter (global table, 1024 entries) that biases insertion depth: lines accessed by PCs with high reuse are inserted closer to MRU, while those with low reuse are inserted at LRU. A per-set streaming detector monitors monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution for workloads like lbm and omnetpp. This hybrid approach adapts to both control-heavy (astar, mcf, milc) and streaming workloads, improving hit rates by learning reuse patterns at the PC level and avoiding cache pollution from streaming or dead-on-arrival blocks. All metadata fits comfortably under 64 KiB.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_pc_signature_insertion__ship_sb_t02.cc,0.223341624,0.223341624,0%
1445,astar,SHiP-Lite with Streaming Bypass and Signature-Based Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a compact streaming detector and selective bypass. Each cache line tracks a 6-bit PC signature and a small 2-bit outcome counter per signature (shared across sets), biasing insertion depth toward MRU for signatures with recent hits and toward LRU for signatures with misses. A per-set streaming detector identifies monotonic address accesses and triggers aggressive bypass (never insert) for streaming sets, minimizing pollution for workloads like lbm and omnetpp. By leveraging program context (PC) to predict reuse and adapting insertion depth, the policy improves hit rate for control-heavy and phase-changing workloads (astar, mcf, milc), while streaming bypass protects against cache pollution. The metadata footprint remains under 64 KiB by sharing signature counters and using compact per-line and per-set structures.",,ChampSim_CRC2/new_policies/010_01_ship_lite_with_streaming_bypass_and_signature_based_insertion__ship_sb_t04.cc,0.14497282,0.14497282,0%
1446,lbm,SHiP-Lite with Streaming Bypass and Signature-Based Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a compact streaming detector and selective bypass. Each cache line tracks a 6-bit PC signature and a small 2-bit outcome counter per signature (shared across sets), biasing insertion depth toward MRU for signatures with recent hits and toward LRU for signatures with misses. A per-set streaming detector identifies monotonic address accesses and triggers aggressive bypass (never insert) for streaming sets, minimizing pollution for workloads like lbm and omnetpp. By leveraging program context (PC) to predict reuse and adapting insertion depth, the policy improves hit rate for control-heavy and phase-changing workloads (astar, mcf, milc), while streaming bypass protects against cache pollution. The metadata footprint remains under 64 KiB by sharing signature counters and using compact per-line and per-set structures.",,ChampSim_CRC2/new_policies/010_01_ship_lite_with_streaming_bypass_and_signature_based_insertion__ship_sb_t04.cc,0.070375116,0.070375116,0%
1447,mcf,SHiP-Lite with Streaming Bypass and Signature-Based Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a compact streaming detector and selective bypass. Each cache line tracks a 6-bit PC signature and a small 2-bit outcome counter per signature (shared across sets), biasing insertion depth toward MRU for signatures with recent hits and toward LRU for signatures with misses. A per-set streaming detector identifies monotonic address accesses and triggers aggressive bypass (never insert) for streaming sets, minimizing pollution for workloads like lbm and omnetpp. By leveraging program context (PC) to predict reuse and adapting insertion depth, the policy improves hit rate for control-heavy and phase-changing workloads (astar, mcf, milc), while streaming bypass protects against cache pollution. The metadata footprint remains under 64 KiB by sharing signature counters and using compact per-line and per-set structures.",,ChampSim_CRC2/new_policies/010_01_ship_lite_with_streaming_bypass_and_signature_based_insertion__ship_sb_t04.cc,0.472739729,0.472739729,0%
1448,milc,SHiP-Lite with Streaming Bypass and Signature-Based Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a compact streaming detector and selective bypass. Each cache line tracks a 6-bit PC signature and a small 2-bit outcome counter per signature (shared across sets), biasing insertion depth toward MRU for signatures with recent hits and toward LRU for signatures with misses. A per-set streaming detector identifies monotonic address accesses and triggers aggressive bypass (never insert) for streaming sets, minimizing pollution for workloads like lbm and omnetpp. By leveraging program context (PC) to predict reuse and adapting insertion depth, the policy improves hit rate for control-heavy and phase-changing workloads (astar, mcf, milc), while streaming bypass protects against cache pollution. The metadata footprint remains under 64 KiB by sharing signature counters and using compact per-line and per-set structures.",,ChampSim_CRC2/new_policies/010_01_ship_lite_with_streaming_bypass_and_signature_based_insertion__ship_sb_t04.cc,0.009726859,0.009726859,0%
1449,omnetpp,SHiP-Lite with Streaming Bypass and Signature-Based Insertion (SHiP-SB),"This policy combines SHiP-lite signature-based insertion depth control with a compact streaming detector and selective bypass. Each cache line tracks a 6-bit PC signature and a small 2-bit outcome counter per signature (shared across sets), biasing insertion depth toward MRU for signatures with recent hits and toward LRU for signatures with misses. A per-set streaming detector identifies monotonic address accesses and triggers aggressive bypass (never insert) for streaming sets, minimizing pollution for workloads like lbm and omnetpp. By leveraging program context (PC) to predict reuse and adapting insertion depth, the policy improves hit rate for control-heavy and phase-changing workloads (astar, mcf, milc), while streaming bypass protects against cache pollution. The metadata footprint remains under 64 KiB by sharing signature counters and using compact per-line and per-set structures.",,ChampSim_CRC2/new_policies/010_01_ship_lite_with_streaming_bypass_and_signature_based_insertion__ship_sb_t04.cc,0.001294371,0.001294371,0%
1450,astar,SHiP-Lite with Streaming-Aware Insertion (SHiP-SA),"SHiP-SA integrates SHiP-lite's PC-based reuse prediction with a lightweight streaming detector to adapt insertion depth according to both temporal locality and streaming behavior. Each cache line maintains a compact 2-bit RRPV (as in RRIP), while a per-set streaming flag detects monotonic or near-monotonic address strides, allowing aggressive insertion at LRU for streaming phases (e.g., lbm, omnetpp) to minimize pollution. For non-streaming accesses, insertion depth is guided by a small PC signature table (6 bits per entry, 2048 entries) tracking recent PCs and their reuse outcomes, biasing insertion toward MRU for PCs with frequent hits (as in SHiP). This hybrid approach improves adaptability: SHiP-lite boosts retention for frequently reused code paths (e.g., astar, milc, mcf), while streaming-aware insertion quickly evicts blocks from streaming phases. The total metadata is ~32 KiB, well under the 64 KiB budget, and the policy is robust to diverse workload phase changes.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_aware_insertion__ship_sa_t07.cc,0.434703185,0.434703185,0%
1451,lbm,SHiP-Lite with Streaming-Aware Insertion (SHiP-SA),"SHiP-SA integrates SHiP-lite's PC-based reuse prediction with a lightweight streaming detector to adapt insertion depth according to both temporal locality and streaming behavior. Each cache line maintains a compact 2-bit RRPV (as in RRIP), while a per-set streaming flag detects monotonic or near-monotonic address strides, allowing aggressive insertion at LRU for streaming phases (e.g., lbm, omnetpp) to minimize pollution. For non-streaming accesses, insertion depth is guided by a small PC signature table (6 bits per entry, 2048 entries) tracking recent PCs and their reuse outcomes, biasing insertion toward MRU for PCs with frequent hits (as in SHiP). This hybrid approach improves adaptability: SHiP-lite boosts retention for frequently reused code paths (e.g., astar, milc, mcf), while streaming-aware insertion quickly evicts blocks from streaming phases. The total metadata is ~32 KiB, well under the 64 KiB budget, and the policy is robust to diverse workload phase changes.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_aware_insertion__ship_sa_t07.cc,0.412280918,0.412280918,0%
1452,mcf,SHiP-Lite with Streaming-Aware Insertion (SHiP-SA),"SHiP-SA integrates SHiP-lite's PC-based reuse prediction with a lightweight streaming detector to adapt insertion depth according to both temporal locality and streaming behavior. Each cache line maintains a compact 2-bit RRPV (as in RRIP), while a per-set streaming flag detects monotonic or near-monotonic address strides, allowing aggressive insertion at LRU for streaming phases (e.g., lbm, omnetpp) to minimize pollution. For non-streaming accesses, insertion depth is guided by a small PC signature table (6 bits per entry, 2048 entries) tracking recent PCs and their reuse outcomes, biasing insertion toward MRU for PCs with frequent hits (as in SHiP). This hybrid approach improves adaptability: SHiP-lite boosts retention for frequently reused code paths (e.g., astar, milc, mcf), while streaming-aware insertion quickly evicts blocks from streaming phases. The total metadata is ~32 KiB, well under the 64 KiB budget, and the policy is robust to diverse workload phase changes.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_aware_insertion__ship_sa_t07.cc,0.474853522,0.474853522,0%
1453,milc,SHiP-Lite with Streaming-Aware Insertion (SHiP-SA),"SHiP-SA integrates SHiP-lite's PC-based reuse prediction with a lightweight streaming detector to adapt insertion depth according to both temporal locality and streaming behavior. Each cache line maintains a compact 2-bit RRPV (as in RRIP), while a per-set streaming flag detects monotonic or near-monotonic address strides, allowing aggressive insertion at LRU for streaming phases (e.g., lbm, omnetpp) to minimize pollution. For non-streaming accesses, insertion depth is guided by a small PC signature table (6 bits per entry, 2048 entries) tracking recent PCs and their reuse outcomes, biasing insertion toward MRU for PCs with frequent hits (as in SHiP). This hybrid approach improves adaptability: SHiP-lite boosts retention for frequently reused code paths (e.g., astar, milc, mcf), while streaming-aware insertion quickly evicts blocks from streaming phases. The total metadata is ~32 KiB, well under the 64 KiB budget, and the policy is robust to diverse workload phase changes.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_aware_insertion__ship_sa_t07.cc,0.312057829,0.312057829,0%
1454,omnetpp,SHiP-Lite with Streaming-Aware Insertion (SHiP-SA),"SHiP-SA integrates SHiP-lite's PC-based reuse prediction with a lightweight streaming detector to adapt insertion depth according to both temporal locality and streaming behavior. Each cache line maintains a compact 2-bit RRPV (as in RRIP), while a per-set streaming flag detects monotonic or near-monotonic address strides, allowing aggressive insertion at LRU for streaming phases (e.g., lbm, omnetpp) to minimize pollution. For non-streaming accesses, insertion depth is guided by a small PC signature table (6 bits per entry, 2048 entries) tracking recent PCs and their reuse outcomes, biasing insertion toward MRU for PCs with frequent hits (as in SHiP). This hybrid approach improves adaptability: SHiP-lite boosts retention for frequently reused code paths (e.g., astar, milc, mcf), while streaming-aware insertion quickly evicts blocks from streaming phases. The total metadata is ~32 KiB, well under the 64 KiB budget, and the policy is robust to diverse workload phase changes.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_aware_insertion__ship_sa_t07.cc,0.621624685,0.621624685,0%
1455,all,SHiP-Lite with Streaming-Aware Insertion (SHiP-SA),"SHiP-SA integrates SHiP-lite's PC-based reuse prediction with a lightweight streaming detector to adapt insertion depth according to both temporal locality and streaming behavior. Each cache line maintains a compact 2-bit RRPV (as in RRIP), while a per-set streaming flag detects monotonic or near-monotonic address strides, allowing aggressive insertion at LRU for streaming phases (e.g., lbm, omnetpp) to minimize pollution. For non-streaming accesses, insertion depth is guided by a small PC signature table (6 bits per entry, 2048 entries) tracking recent PCs and their reuse outcomes, biasing insertion toward MRU for PCs with frequent hits (as in SHiP). This hybrid approach improves adaptability: SHiP-lite boosts retention for frequently reused code paths (e.g., astar, milc, mcf), while streaming-aware insertion quickly evicts blocks from streaming phases. The total metadata is ~32 KiB, well under the 64 KiB budget, and the policy is robust to diverse workload phase changes.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_aware_insertion__ship_sa_t07.cc,0.451104028,0.451104028,45%
1456,astar,DRRIP with Streaming Bypass and Dead-Block Learning (DRRIP-SBDL),"DRRIP-SBDL combines dynamic RRIP (SRRIP/BRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to improve adaptability across diverse workloads. DRRIP set-dueling (using a 10-bit PSEL and 64 leader sets) dynamically selects between SRRIP and BRRIP insertion depths, optimizing for both recency and bursty reuse. A streaming detector (per-set, 1-bit) identifies monotonic access phases and triggers cache bypass for blocks unlikely to be reused (e.g., lbm, omnetpp), reducing pollution. Additionally, each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block likelihood and bias insertion toward LRU for lines with high dead probability. This hybrid approach leverages global phase adaptation, streaming-aware bypass, and local dead-block learning, improving hit rates for both irregular (mcf, astar, milc) and streaming workloads. Total metadata is ~32 KiB (PSEL, leader sets, streaming flags, dead-block counters), well under the 64 KiB budget.",,ChampSim_CRC2/new_policies/011_00_drrip_with_streaming_bypass_and_dead_block_learning__drrip_sbdl_t02.cc,0.366562927,0.366562927,0%
1457,lbm,DRRIP with Streaming Bypass and Dead-Block Learning (DRRIP-SBDL),"DRRIP-SBDL combines dynamic RRIP (SRRIP/BRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to improve adaptability across diverse workloads. DRRIP set-dueling (using a 10-bit PSEL and 64 leader sets) dynamically selects between SRRIP and BRRIP insertion depths, optimizing for both recency and bursty reuse. A streaming detector (per-set, 1-bit) identifies monotonic access phases and triggers cache bypass for blocks unlikely to be reused (e.g., lbm, omnetpp), reducing pollution. Additionally, each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block likelihood and bias insertion toward LRU for lines with high dead probability. This hybrid approach leverages global phase adaptation, streaming-aware bypass, and local dead-block learning, improving hit rates for both irregular (mcf, astar, milc) and streaming workloads. Total metadata is ~32 KiB (PSEL, leader sets, streaming flags, dead-block counters), well under the 64 KiB budget.",,ChampSim_CRC2/new_policies/011_00_drrip_with_streaming_bypass_and_dead_block_learning__drrip_sbdl_t02.cc,0.263975261,0.263975261,0%
1458,mcf,DRRIP with Streaming Bypass and Dead-Block Learning (DRRIP-SBDL),"DRRIP-SBDL combines dynamic RRIP (SRRIP/BRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to improve adaptability across diverse workloads. DRRIP set-dueling (using a 10-bit PSEL and 64 leader sets) dynamically selects between SRRIP and BRRIP insertion depths, optimizing for both recency and bursty reuse. A streaming detector (per-set, 1-bit) identifies monotonic access phases and triggers cache bypass for blocks unlikely to be reused (e.g., lbm, omnetpp), reducing pollution. Additionally, each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block likelihood and bias insertion toward LRU for lines with high dead probability. This hybrid approach leverages global phase adaptation, streaming-aware bypass, and local dead-block learning, improving hit rates for both irregular (mcf, astar, milc) and streaming workloads. Total metadata is ~32 KiB (PSEL, leader sets, streaming flags, dead-block counters), well under the 64 KiB budget.",,ChampSim_CRC2/new_policies/011_00_drrip_with_streaming_bypass_and_dead_block_learning__drrip_sbdl_t02.cc,0.428675305,0.428675305,0%
1459,milc,DRRIP with Streaming Bypass and Dead-Block Learning (DRRIP-SBDL),"DRRIP-SBDL combines dynamic RRIP (SRRIP/BRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to improve adaptability across diverse workloads. DRRIP set-dueling (using a 10-bit PSEL and 64 leader sets) dynamically selects between SRRIP and BRRIP insertion depths, optimizing for both recency and bursty reuse. A streaming detector (per-set, 1-bit) identifies monotonic access phases and triggers cache bypass for blocks unlikely to be reused (e.g., lbm, omnetpp), reducing pollution. Additionally, each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block likelihood and bias insertion toward LRU for lines with high dead probability. This hybrid approach leverages global phase adaptation, streaming-aware bypass, and local dead-block learning, improving hit rates for both irregular (mcf, astar, milc) and streaming workloads. Total metadata is ~32 KiB (PSEL, leader sets, streaming flags, dead-block counters), well under the 64 KiB budget.",,ChampSim_CRC2/new_policies/011_00_drrip_with_streaming_bypass_and_dead_block_learning__drrip_sbdl_t02.cc,0.111653403,0.111653403,0%
1460,omnetpp,DRRIP with Streaming Bypass and Dead-Block Learning (DRRIP-SBDL),"DRRIP-SBDL combines dynamic RRIP (SRRIP/BRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to improve adaptability across diverse workloads. DRRIP set-dueling (using a 10-bit PSEL and 64 leader sets) dynamically selects between SRRIP and BRRIP insertion depths, optimizing for both recency and bursty reuse. A streaming detector (per-set, 1-bit) identifies monotonic access phases and triggers cache bypass for blocks unlikely to be reused (e.g., lbm, omnetpp), reducing pollution. Additionally, each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block likelihood and bias insertion toward LRU for lines with high dead probability. This hybrid approach leverages global phase adaptation, streaming-aware bypass, and local dead-block learning, improving hit rates for both irregular (mcf, astar, milc) and streaming workloads. Total metadata is ~32 KiB (PSEL, leader sets, streaming flags, dead-block counters), well under the 64 KiB budget.",,ChampSim_CRC2/new_policies/011_00_drrip_with_streaming_bypass_and_dead_block_learning__drrip_sbdl_t02.cc,0.74395023,0.74395023,0%
1461,astar,DRRIP with Streaming Bypass and Per-Line Dead-Block Prediction (DRRIP-SDBP),"DRRIP-SDBP combines Dynamic RRIP (SRRIP vs. BRRIP) set-dueling for global adaptability, a streaming detector to identify and bypass cache lines with monotonic access patterns, and a compact per-line dead-block predictor (1-bit per line) to approximate dead blocks for early eviction. DRRIP's set-dueling (using a 10-bit PSEL and 64 leader sets) adapts insertion depth between SRRIP and BRRIP based on workload locality. The streaming detector marks sets with monotonic address strides; in these sets, streaming blocks are bypassed (not cached) to avoid pollution. For non-streaming accesses, the per-line dead-block bit is set on insertion and cleared on reuse; lines predicted dead are prioritized for eviction. This hybrid approach improves performance by aggressively bypassing streaming accesses (e.g., lbm, omnetpp), adapting insertion depth for phase changes (e.g., milc, astar), and leveraging dead-block prediction to evict lines with low reuse (e.g., mcf). Metadata fits well within the 64 KiB budget: 2 bits RRPV/line, 1 bit dead-block/line, 1 bit streaming/set, 32-bit last_addr/set, 10-bit PSEL, and 64 leader set markers.",,ChampSim_CRC2/new_policies/011_01_drrip_with_streaming_bypass_and_per_line_dead_block_prediction__drrip_sdbp_t04.cc,0.045124665,0.045124665,0%
1462,lbm,DRRIP with Streaming Bypass and Per-Line Dead-Block Prediction (DRRIP-SDBP),"DRRIP-SDBP combines Dynamic RRIP (SRRIP vs. BRRIP) set-dueling for global adaptability, a streaming detector to identify and bypass cache lines with monotonic access patterns, and a compact per-line dead-block predictor (1-bit per line) to approximate dead blocks for early eviction. DRRIP's set-dueling (using a 10-bit PSEL and 64 leader sets) adapts insertion depth between SRRIP and BRRIP based on workload locality. The streaming detector marks sets with monotonic address strides; in these sets, streaming blocks are bypassed (not cached) to avoid pollution. For non-streaming accesses, the per-line dead-block bit is set on insertion and cleared on reuse; lines predicted dead are prioritized for eviction. This hybrid approach improves performance by aggressively bypassing streaming accesses (e.g., lbm, omnetpp), adapting insertion depth for phase changes (e.g., milc, astar), and leveraging dead-block prediction to evict lines with low reuse (e.g., mcf). Metadata fits well within the 64 KiB budget: 2 bits RRPV/line, 1 bit dead-block/line, 1 bit streaming/set, 32-bit last_addr/set, 10-bit PSEL, and 64 leader set markers.",,ChampSim_CRC2/new_policies/011_01_drrip_with_streaming_bypass_and_per_line_dead_block_prediction__drrip_sdbp_t04.cc,0.058753172,0.058753172,0%
1463,mcf,DRRIP with Streaming Bypass and Per-Line Dead-Block Prediction (DRRIP-SDBP),"DRRIP-SDBP combines Dynamic RRIP (SRRIP vs. BRRIP) set-dueling for global adaptability, a streaming detector to identify and bypass cache lines with monotonic access patterns, and a compact per-line dead-block predictor (1-bit per line) to approximate dead blocks for early eviction. DRRIP's set-dueling (using a 10-bit PSEL and 64 leader sets) adapts insertion depth between SRRIP and BRRIP based on workload locality. The streaming detector marks sets with monotonic address strides; in these sets, streaming blocks are bypassed (not cached) to avoid pollution. For non-streaming accesses, the per-line dead-block bit is set on insertion and cleared on reuse; lines predicted dead are prioritized for eviction. This hybrid approach improves performance by aggressively bypassing streaming accesses (e.g., lbm, omnetpp), adapting insertion depth for phase changes (e.g., milc, astar), and leveraging dead-block prediction to evict lines with low reuse (e.g., mcf). Metadata fits well within the 64 KiB budget: 2 bits RRPV/line, 1 bit dead-block/line, 1 bit streaming/set, 32-bit last_addr/set, 10-bit PSEL, and 64 leader set markers.",,ChampSim_CRC2/new_policies/011_01_drrip_with_streaming_bypass_and_per_line_dead_block_prediction__drrip_sdbp_t04.cc,0.214312084,0.214312084,0%
1464,milc,DRRIP with Streaming Bypass and Per-Line Dead-Block Prediction (DRRIP-SDBP),"DRRIP-SDBP combines Dynamic RRIP (SRRIP vs. BRRIP) set-dueling for global adaptability, a streaming detector to identify and bypass cache lines with monotonic access patterns, and a compact per-line dead-block predictor (1-bit per line) to approximate dead blocks for early eviction. DRRIP's set-dueling (using a 10-bit PSEL and 64 leader sets) adapts insertion depth between SRRIP and BRRIP based on workload locality. The streaming detector marks sets with monotonic address strides; in these sets, streaming blocks are bypassed (not cached) to avoid pollution. For non-streaming accesses, the per-line dead-block bit is set on insertion and cleared on reuse; lines predicted dead are prioritized for eviction. This hybrid approach improves performance by aggressively bypassing streaming accesses (e.g., lbm, omnetpp), adapting insertion depth for phase changes (e.g., milc, astar), and leveraging dead-block prediction to evict lines with low reuse (e.g., mcf). Metadata fits well within the 64 KiB budget: 2 bits RRPV/line, 1 bit dead-block/line, 1 bit streaming/set, 32-bit last_addr/set, 10-bit PSEL, and 64 leader set markers.",,ChampSim_CRC2/new_policies/011_01_drrip_with_streaming_bypass_and_per_line_dead_block_prediction__drrip_sdbp_t04.cc,0.009520482,0.009520482,0%
1465,omnetpp,DRRIP with Streaming Bypass and Per-Line Dead-Block Prediction (DRRIP-SDBP),"DRRIP-SDBP combines Dynamic RRIP (SRRIP vs. BRRIP) set-dueling for global adaptability, a streaming detector to identify and bypass cache lines with monotonic access patterns, and a compact per-line dead-block predictor (1-bit per line) to approximate dead blocks for early eviction. DRRIP's set-dueling (using a 10-bit PSEL and 64 leader sets) adapts insertion depth between SRRIP and BRRIP based on workload locality. The streaming detector marks sets with monotonic address strides; in these sets, streaming blocks are bypassed (not cached) to avoid pollution. For non-streaming accesses, the per-line dead-block bit is set on insertion and cleared on reuse; lines predicted dead are prioritized for eviction. This hybrid approach improves performance by aggressively bypassing streaming accesses (e.g., lbm, omnetpp), adapting insertion depth for phase changes (e.g., milc, astar), and leveraging dead-block prediction to evict lines with low reuse (e.g., mcf). Metadata fits well within the 64 KiB budget: 2 bits RRPV/line, 1 bit dead-block/line, 1 bit streaming/set, 32-bit last_addr/set, 10-bit PSEL, and 64 leader set markers.",,ChampSim_CRC2/new_policies/011_01_drrip_with_streaming_bypass_and_per_line_dead_block_prediction__drrip_sdbp_t04.cc,0.001151215,0.001151215,0%
1466,astar,DRRIP with Streaming-Bypass and Dead-Block Prediction (DRRIP-SB-DBP),"This policy combines Dynamic RRIP (DRRIP) set-dueling with a compact streaming detector and per-line dead-block prediction for robust adaptation across diverse workloads. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter and 64 leader sets, ensuring generality and good phase response. A lightweight streaming detector flags sets with monotonic access patterns, bypassing (not inserting) blocks during detected streaming phases to prevent pollution (critical for lbm, omnetpp). Additionally, each cache line maintains a tiny dead-block counter (2 bits) that decays over time; lines predicted dead are inserted at distant RRPV or bypassed, while live lines are retained longer. This multi-pronged approach aggressively evicts non-reused and streaming blocks while preserving reusable data for irregular and phase-changing workloads like astar, mcf, milc. Total metadata is well under 64 KiB: 2048 sets × 16 ways × 2 bits dead-counter (~8 KiB), 2048 sets × 1 bit streaming flag (~256 bytes), 2048 sets × 32-bit last_addr (~8 KiB), 10-bit PSEL, and a small leader-set bitmap. This design delivers strong adaptivity, minimizes pollution, and leverages both global and per-line reuse signals.",,ChampSim_CRC2/new_policies/011_02_drrip_with_streaming_bypass_and_dead_block_prediction__drrip_sb_dbp_t07.cc,0.062867652,0.062867652,0%
1467,lbm,DRRIP with Streaming-Bypass and Dead-Block Prediction (DRRIP-SB-DBP),"This policy combines Dynamic RRIP (DRRIP) set-dueling with a compact streaming detector and per-line dead-block prediction for robust adaptation across diverse workloads. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter and 64 leader sets, ensuring generality and good phase response. A lightweight streaming detector flags sets with monotonic access patterns, bypassing (not inserting) blocks during detected streaming phases to prevent pollution (critical for lbm, omnetpp). Additionally, each cache line maintains a tiny dead-block counter (2 bits) that decays over time; lines predicted dead are inserted at distant RRPV or bypassed, while live lines are retained longer. This multi-pronged approach aggressively evicts non-reused and streaming blocks while preserving reusable data for irregular and phase-changing workloads like astar, mcf, milc. Total metadata is well under 64 KiB: 2048 sets × 16 ways × 2 bits dead-counter (~8 KiB), 2048 sets × 1 bit streaming flag (~256 bytes), 2048 sets × 32-bit last_addr (~8 KiB), 10-bit PSEL, and a small leader-set bitmap. This design delivers strong adaptivity, minimizes pollution, and leverages both global and per-line reuse signals.",,ChampSim_CRC2/new_policies/011_02_drrip_with_streaming_bypass_and_dead_block_prediction__drrip_sb_dbp_t07.cc,0.119866313,0.119866313,0%
1468,mcf,DRRIP with Streaming-Bypass and Dead-Block Prediction (DRRIP-SB-DBP),"This policy combines Dynamic RRIP (DRRIP) set-dueling with a compact streaming detector and per-line dead-block prediction for robust adaptation across diverse workloads. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter and 64 leader sets, ensuring generality and good phase response. A lightweight streaming detector flags sets with monotonic access patterns, bypassing (not inserting) blocks during detected streaming phases to prevent pollution (critical for lbm, omnetpp). Additionally, each cache line maintains a tiny dead-block counter (2 bits) that decays over time; lines predicted dead are inserted at distant RRPV or bypassed, while live lines are retained longer. This multi-pronged approach aggressively evicts non-reused and streaming blocks while preserving reusable data for irregular and phase-changing workloads like astar, mcf, milc. Total metadata is well under 64 KiB: 2048 sets × 16 ways × 2 bits dead-counter (~8 KiB), 2048 sets × 1 bit streaming flag (~256 bytes), 2048 sets × 32-bit last_addr (~8 KiB), 10-bit PSEL, and a small leader-set bitmap. This design delivers strong adaptivity, minimizes pollution, and leverages both global and per-line reuse signals.",,ChampSim_CRC2/new_policies/011_02_drrip_with_streaming_bypass_and_dead_block_prediction__drrip_sb_dbp_t07.cc,0.228452639,0.228452639,0%
1469,milc,DRRIP with Streaming-Bypass and Dead-Block Prediction (DRRIP-SB-DBP),"This policy combines Dynamic RRIP (DRRIP) set-dueling with a compact streaming detector and per-line dead-block prediction for robust adaptation across diverse workloads. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter and 64 leader sets, ensuring generality and good phase response. A lightweight streaming detector flags sets with monotonic access patterns, bypassing (not inserting) blocks during detected streaming phases to prevent pollution (critical for lbm, omnetpp). Additionally, each cache line maintains a tiny dead-block counter (2 bits) that decays over time; lines predicted dead are inserted at distant RRPV or bypassed, while live lines are retained longer. This multi-pronged approach aggressively evicts non-reused and streaming blocks while preserving reusable data for irregular and phase-changing workloads like astar, mcf, milc. Total metadata is well under 64 KiB: 2048 sets × 16 ways × 2 bits dead-counter (~8 KiB), 2048 sets × 1 bit streaming flag (~256 bytes), 2048 sets × 32-bit last_addr (~8 KiB), 10-bit PSEL, and a small leader-set bitmap. This design delivers strong adaptivity, minimizes pollution, and leverages both global and per-line reuse signals.",,ChampSim_CRC2/new_policies/011_02_drrip_with_streaming_bypass_and_dead_block_prediction__drrip_sb_dbp_t07.cc,0.022549367,0.022549367,0%
1470,omnetpp,DRRIP with Streaming-Bypass and Dead-Block Prediction (DRRIP-SB-DBP),"This policy combines Dynamic RRIP (DRRIP) set-dueling with a compact streaming detector and per-line dead-block prediction for robust adaptation across diverse workloads. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL counter and 64 leader sets, ensuring generality and good phase response. A lightweight streaming detector flags sets with monotonic access patterns, bypassing (not inserting) blocks during detected streaming phases to prevent pollution (critical for lbm, omnetpp). Additionally, each cache line maintains a tiny dead-block counter (2 bits) that decays over time; lines predicted dead are inserted at distant RRPV or bypassed, while live lines are retained longer. This multi-pronged approach aggressively evicts non-reused and streaming blocks while preserving reusable data for irregular and phase-changing workloads like astar, mcf, milc. Total metadata is well under 64 KiB: 2048 sets × 16 ways × 2 bits dead-counter (~8 KiB), 2048 sets × 1 bit streaming flag (~256 bytes), 2048 sets × 32-bit last_addr (~8 KiB), 10-bit PSEL, and a small leader-set bitmap. This design delivers strong adaptivity, minimizes pollution, and leverages both global and per-line reuse signals.",,ChampSim_CRC2/new_policies/011_02_drrip_with_streaming_bypass_and_dead_block_prediction__drrip_sb_dbp_t07.cc,0.029323169,0.029323169,0%
1471,all,DRRIP with Streaming Bypass and Dead-Block Learning (DRRIP-SBDL),"DRRIP-SBDL combines dynamic RRIP (SRRIP/BRRIP) set-dueling with a lightweight streaming detector and per-line dead-block counters to improve adaptability across diverse workloads. DRRIP set-dueling (using a 10-bit PSEL and 64 leader sets) dynamically selects between SRRIP and BRRIP insertion depths, optimizing for both recency and bursty reuse. A streaming detector (per-set, 1-bit) identifies monotonic access phases and triggers cache bypass for blocks unlikely to be reused (e.g., lbm, omnetpp), reducing pollution. Additionally, each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate dead-block likelihood and bias insertion toward LRU for lines with high dead probability. This hybrid approach leverages global phase adaptation, streaming-aware bypass, and local dead-block learning, improving hit rates for both irregular (mcf, astar, milc) and streaming workloads. Total metadata is ~32 KiB (PSEL, leader sets, streaming flags, dead-block counters), well under the 64 KiB budget.",,ChampSim_CRC2/new_policies/011_00_drrip_with_streaming_bypass_and_dead_block_learning__drrip_sbdl_t02.cc,0.382963425,0.382963425,38%
1472,astar,SHiP-Lite with Streaming Bypass and PC-Signature Guided Insertion (SHiP-Lite-SBPS),"SHiP-Lite-SBPS combines a lightweight SHiP-inspired PC signature table (6-bit signatures, 2-bit outcome counters) with a streaming detector and selective bypass logic to adapt insertion depth for both regular and irregular workloads. Each cache line is tagged with a PC-derived signature; on eviction, the SHiP table updates its outcome counter based on whether the line was reused. Insertions are biased: lines with ""dead"" signatures (low counter) are inserted at LRU, while ""live"" signatures are inserted at MRU. A per-set streaming detector tracks monotonic access patterns and triggers bypass for blocks with dead signatures, minimizing pollution for workloads like lbm and omnetpp. This design improves hit rates for pointer-chasing and phase-changing workloads (mcf, milc, astar) by learning reuse at the PC level, while aggressively bypassing streaming phases. Metadata usage (~32 KiB for SHiP table, streaming flags, per-line signatures/counters) fits well within the 64 KiB budget.",,ChampSim_CRC2/new_policies/012_01_ship_lite_with_streaming_bypass_and_pc_signature_guided_insertion__ship_lite_sbps_t04.cc,0.302609711,0.302609711,0%
1473,lbm,SHiP-Lite with Streaming Bypass and PC-Signature Guided Insertion (SHiP-Lite-SBPS),"SHiP-Lite-SBPS combines a lightweight SHiP-inspired PC signature table (6-bit signatures, 2-bit outcome counters) with a streaming detector and selective bypass logic to adapt insertion depth for both regular and irregular workloads. Each cache line is tagged with a PC-derived signature; on eviction, the SHiP table updates its outcome counter based on whether the line was reused. Insertions are biased: lines with ""dead"" signatures (low counter) are inserted at LRU, while ""live"" signatures are inserted at MRU. A per-set streaming detector tracks monotonic access patterns and triggers bypass for blocks with dead signatures, minimizing pollution for workloads like lbm and omnetpp. This design improves hit rates for pointer-chasing and phase-changing workloads (mcf, milc, astar) by learning reuse at the PC level, while aggressively bypassing streaming phases. Metadata usage (~32 KiB for SHiP table, streaming flags, per-line signatures/counters) fits well within the 64 KiB budget.",,ChampSim_CRC2/new_policies/012_01_ship_lite_with_streaming_bypass_and_pc_signature_guided_insertion__ship_lite_sbps_t04.cc,0.204991701,0.204991701,0%
1474,mcf,SHiP-Lite with Streaming Bypass and PC-Signature Guided Insertion (SHiP-Lite-SBPS),"SHiP-Lite-SBPS combines a lightweight SHiP-inspired PC signature table (6-bit signatures, 2-bit outcome counters) with a streaming detector and selective bypass logic to adapt insertion depth for both regular and irregular workloads. Each cache line is tagged with a PC-derived signature; on eviction, the SHiP table updates its outcome counter based on whether the line was reused. Insertions are biased: lines with ""dead"" signatures (low counter) are inserted at LRU, while ""live"" signatures are inserted at MRU. A per-set streaming detector tracks monotonic access patterns and triggers bypass for blocks with dead signatures, minimizing pollution for workloads like lbm and omnetpp. This design improves hit rates for pointer-chasing and phase-changing workloads (mcf, milc, astar) by learning reuse at the PC level, while aggressively bypassing streaming phases. Metadata usage (~32 KiB for SHiP table, streaming flags, per-line signatures/counters) fits well within the 64 KiB budget.",,ChampSim_CRC2/new_policies/012_01_ship_lite_with_streaming_bypass_and_pc_signature_guided_insertion__ship_lite_sbps_t04.cc,0.507774656,0.507774656,0%
1475,milc,SHiP-Lite with Streaming Bypass and PC-Signature Guided Insertion (SHiP-Lite-SBPS),"SHiP-Lite-SBPS combines a lightweight SHiP-inspired PC signature table (6-bit signatures, 2-bit outcome counters) with a streaming detector and selective bypass logic to adapt insertion depth for both regular and irregular workloads. Each cache line is tagged with a PC-derived signature; on eviction, the SHiP table updates its outcome counter based on whether the line was reused. Insertions are biased: lines with ""dead"" signatures (low counter) are inserted at LRU, while ""live"" signatures are inserted at MRU. A per-set streaming detector tracks monotonic access patterns and triggers bypass for blocks with dead signatures, minimizing pollution for workloads like lbm and omnetpp. This design improves hit rates for pointer-chasing and phase-changing workloads (mcf, milc, astar) by learning reuse at the PC level, while aggressively bypassing streaming phases. Metadata usage (~32 KiB for SHiP table, streaming flags, per-line signatures/counters) fits well within the 64 KiB budget.",,ChampSim_CRC2/new_policies/012_01_ship_lite_with_streaming_bypass_and_pc_signature_guided_insertion__ship_lite_sbps_t04.cc,0.068868259,0.068868259,0%
1476,omnetpp,SHiP-Lite with Streaming Bypass and PC-Signature Guided Insertion (SHiP-Lite-SBPS),"SHiP-Lite-SBPS combines a lightweight SHiP-inspired PC signature table (6-bit signatures, 2-bit outcome counters) with a streaming detector and selective bypass logic to adapt insertion depth for both regular and irregular workloads. Each cache line is tagged with a PC-derived signature; on eviction, the SHiP table updates its outcome counter based on whether the line was reused. Insertions are biased: lines with ""dead"" signatures (low counter) are inserted at LRU, while ""live"" signatures are inserted at MRU. A per-set streaming detector tracks monotonic access patterns and triggers bypass for blocks with dead signatures, minimizing pollution for workloads like lbm and omnetpp. This design improves hit rates for pointer-chasing and phase-changing workloads (mcf, milc, astar) by learning reuse at the PC level, while aggressively bypassing streaming phases. Metadata usage (~32 KiB for SHiP table, streaming flags, per-line signatures/counters) fits well within the 64 KiB budget.",,ChampSim_CRC2/new_policies/012_01_ship_lite_with_streaming_bypass_and_pc_signature_guided_insertion__ship_lite_sbps_t04.cc,0.582304907,0.582304907,0%
1477,all,SHiP-Lite with Streaming Bypass and PC-Signature Guided Insertion (SHiP-Lite-SBPS),"SHiP-Lite-SBPS combines a lightweight SHiP-inspired PC signature table (6-bit signatures, 2-bit outcome counters) with a streaming detector and selective bypass logic to adapt insertion depth for both regular and irregular workloads. Each cache line is tagged with a PC-derived signature; on eviction, the SHiP table updates its outcome counter based on whether the line was reused. Insertions are biased: lines with ""dead"" signatures (low counter) are inserted at LRU, while ""live"" signatures are inserted at MRU. A per-set streaming detector tracks monotonic access patterns and triggers bypass for blocks with dead signatures, minimizing pollution for workloads like lbm and omnetpp. This design improves hit rates for pointer-chasing and phase-changing workloads (mcf, milc, astar) by learning reuse at the PC level, while aggressively bypassing streaming phases. Metadata usage (~32 KiB for SHiP table, streaming flags, per-line signatures/counters) fits well within the 64 KiB budget.",,ChampSim_CRC2/new_policies/012_01_ship_lite_with_streaming_bypass_and_pc_signature_guided_insertion__ship_lite_sbps_t04.cc,0.333309847,0.333309847,33%
1478,astar,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"DRRIP-SBDT combines Dynamic RRIP (SRRIP vs BRRIP set-dueling) with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass strategies for diverse workloads. DRRIP’s set-dueling (using a 10-bit PSEL) dynamically selects between frequent (SRRIP) and infrequent (BRRIP) insertion depths, optimizing for both high-reuse (mcf, milc, astar) and streaming (lbm, omnetpp) phases. A per-set streaming detector flags monotonic accesses, triggering bypass for lines predicted dead via a 1-bit per-line dead-block counter. This dead-block approximation is updated on hits and periodically decayed, allowing the policy to avoid cache pollution during streaming phases while retaining blocks with demonstrated reuse. The metadata footprint (~16 KiB for RRIP, ~2 KiB for dead-block counters, ~256 bytes for streaming flags, ~1 KiB for PSEL/leader sets) fits well under 64 KiB. By combining DRRIP’s adaptive insertion with streaming-aware bypass and dead-block tracking, the policy improves hit rates across irregular, pointer-chasing, and streaming workloads.",,ChampSim_CRC2/new_policies/013_00_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t02.cc,0.429966229,0.429966229,0%
1479,lbm,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"DRRIP-SBDT combines Dynamic RRIP (SRRIP vs BRRIP set-dueling) with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass strategies for diverse workloads. DRRIP’s set-dueling (using a 10-bit PSEL) dynamically selects between frequent (SRRIP) and infrequent (BRRIP) insertion depths, optimizing for both high-reuse (mcf, milc, astar) and streaming (lbm, omnetpp) phases. A per-set streaming detector flags monotonic accesses, triggering bypass for lines predicted dead via a 1-bit per-line dead-block counter. This dead-block approximation is updated on hits and periodically decayed, allowing the policy to avoid cache pollution during streaming phases while retaining blocks with demonstrated reuse. The metadata footprint (~16 KiB for RRIP, ~2 KiB for dead-block counters, ~256 bytes for streaming flags, ~1 KiB for PSEL/leader sets) fits well under 64 KiB. By combining DRRIP’s adaptive insertion with streaming-aware bypass and dead-block tracking, the policy improves hit rates across irregular, pointer-chasing, and streaming workloads.",,ChampSim_CRC2/new_policies/013_00_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t02.cc,0.408802127,0.408802127,0%
1480,mcf,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"DRRIP-SBDT combines Dynamic RRIP (SRRIP vs BRRIP set-dueling) with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass strategies for diverse workloads. DRRIP’s set-dueling (using a 10-bit PSEL) dynamically selects between frequent (SRRIP) and infrequent (BRRIP) insertion depths, optimizing for both high-reuse (mcf, milc, astar) and streaming (lbm, omnetpp) phases. A per-set streaming detector flags monotonic accesses, triggering bypass for lines predicted dead via a 1-bit per-line dead-block counter. This dead-block approximation is updated on hits and periodically decayed, allowing the policy to avoid cache pollution during streaming phases while retaining blocks with demonstrated reuse. The metadata footprint (~16 KiB for RRIP, ~2 KiB for dead-block counters, ~256 bytes for streaming flags, ~1 KiB for PSEL/leader sets) fits well under 64 KiB. By combining DRRIP’s adaptive insertion with streaming-aware bypass and dead-block tracking, the policy improves hit rates across irregular, pointer-chasing, and streaming workloads.",,ChampSim_CRC2/new_policies/013_00_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t02.cc,0.459597934,0.459597934,0%
1481,milc,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"DRRIP-SBDT combines Dynamic RRIP (SRRIP vs BRRIP set-dueling) with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass strategies for diverse workloads. DRRIP’s set-dueling (using a 10-bit PSEL) dynamically selects between frequent (SRRIP) and infrequent (BRRIP) insertion depths, optimizing for both high-reuse (mcf, milc, astar) and streaming (lbm, omnetpp) phases. A per-set streaming detector flags monotonic accesses, triggering bypass for lines predicted dead via a 1-bit per-line dead-block counter. This dead-block approximation is updated on hits and periodically decayed, allowing the policy to avoid cache pollution during streaming phases while retaining blocks with demonstrated reuse. The metadata footprint (~16 KiB for RRIP, ~2 KiB for dead-block counters, ~256 bytes for streaming flags, ~1 KiB for PSEL/leader sets) fits well under 64 KiB. By combining DRRIP’s adaptive insertion with streaming-aware bypass and dead-block tracking, the policy improves hit rates across irregular, pointer-chasing, and streaming workloads.",,ChampSim_CRC2/new_policies/013_00_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t02.cc,0.307760125,0.307760125,0%
1482,omnetpp,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"DRRIP-SBDT combines Dynamic RRIP (SRRIP vs BRRIP set-dueling) with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass strategies for diverse workloads. DRRIP’s set-dueling (using a 10-bit PSEL) dynamically selects between frequent (SRRIP) and infrequent (BRRIP) insertion depths, optimizing for both high-reuse (mcf, milc, astar) and streaming (lbm, omnetpp) phases. A per-set streaming detector flags monotonic accesses, triggering bypass for lines predicted dead via a 1-bit per-line dead-block counter. This dead-block approximation is updated on hits and periodically decayed, allowing the policy to avoid cache pollution during streaming phases while retaining blocks with demonstrated reuse. The metadata footprint (~16 KiB for RRIP, ~2 KiB for dead-block counters, ~256 bytes for streaming flags, ~1 KiB for PSEL/leader sets) fits well under 64 KiB. By combining DRRIP’s adaptive insertion with streaming-aware bypass and dead-block tracking, the policy improves hit rates across irregular, pointer-chasing, and streaming workloads.",,ChampSim_CRC2/new_policies/013_00_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t02.cc,0.450143453,0.450143453,0%
1483,astar,DRRIP with Streaming-Aware Dead-Block Bypass (DRRIP-SADB),"DRRIP-SADB combines Dynamic RRIP (DRRIP) set-dueling for adaptive insertion depth with a lightweight streaming detector and per-line dead-block approximation. DRRIP uses set-dueling with a small PSEL counter to dynamically select between SRRIP (aggressive insertion) and BRRIP (conservative insertion), adapting to workload locality. To further reduce cache pollution from streaming and pointer-chasing phases (as in lbm, omnetpp, mcf), a per-set streaming detector flags monotonic address strides, while a tiny per-line 2-bit reuse counter approximates dead blocks. Lines identified as dead (reuse counter=0) during streaming phases are bypassed (inserted at LRU or not cached), minimizing pollution from non-reusable data. This design improves hit rates for mixed-phase workloads (milc, astar) by adapting insertion depth and actively bypassing streaming/dead blocks, while remaining metadata-efficient (~32 KiB for RRIP, PSEL, streaming flags, and dead-block counters).",,ChampSim_CRC2/new_policies/013_01_drrip_with_streaming_aware_dead_block_bypass__drrip_sadb_t04.cc,0.429870551,0.429870551,0%
1484,lbm,DRRIP with Streaming-Aware Dead-Block Bypass (DRRIP-SADB),"DRRIP-SADB combines Dynamic RRIP (DRRIP) set-dueling for adaptive insertion depth with a lightweight streaming detector and per-line dead-block approximation. DRRIP uses set-dueling with a small PSEL counter to dynamically select between SRRIP (aggressive insertion) and BRRIP (conservative insertion), adapting to workload locality. To further reduce cache pollution from streaming and pointer-chasing phases (as in lbm, omnetpp, mcf), a per-set streaming detector flags monotonic address strides, while a tiny per-line 2-bit reuse counter approximates dead blocks. Lines identified as dead (reuse counter=0) during streaming phases are bypassed (inserted at LRU or not cached), minimizing pollution from non-reusable data. This design improves hit rates for mixed-phase workloads (milc, astar) by adapting insertion depth and actively bypassing streaming/dead blocks, while remaining metadata-efficient (~32 KiB for RRIP, PSEL, streaming flags, and dead-block counters).",,ChampSim_CRC2/new_policies/013_01_drrip_with_streaming_aware_dead_block_bypass__drrip_sadb_t04.cc,0.408662426,0.408662426,0%
1485,mcf,DRRIP with Streaming-Aware Dead-Block Bypass (DRRIP-SADB),"DRRIP-SADB combines Dynamic RRIP (DRRIP) set-dueling for adaptive insertion depth with a lightweight streaming detector and per-line dead-block approximation. DRRIP uses set-dueling with a small PSEL counter to dynamically select between SRRIP (aggressive insertion) and BRRIP (conservative insertion), adapting to workload locality. To further reduce cache pollution from streaming and pointer-chasing phases (as in lbm, omnetpp, mcf), a per-set streaming detector flags monotonic address strides, while a tiny per-line 2-bit reuse counter approximates dead blocks. Lines identified as dead (reuse counter=0) during streaming phases are bypassed (inserted at LRU or not cached), minimizing pollution from non-reusable data. This design improves hit rates for mixed-phase workloads (milc, astar) by adapting insertion depth and actively bypassing streaming/dead blocks, while remaining metadata-efficient (~32 KiB for RRIP, PSEL, streaming flags, and dead-block counters).",,ChampSim_CRC2/new_policies/013_01_drrip_with_streaming_aware_dead_block_bypass__drrip_sadb_t04.cc,0.459727641,0.459727641,0%
1486,milc,DRRIP with Streaming-Aware Dead-Block Bypass (DRRIP-SADB),"DRRIP-SADB combines Dynamic RRIP (DRRIP) set-dueling for adaptive insertion depth with a lightweight streaming detector and per-line dead-block approximation. DRRIP uses set-dueling with a small PSEL counter to dynamically select between SRRIP (aggressive insertion) and BRRIP (conservative insertion), adapting to workload locality. To further reduce cache pollution from streaming and pointer-chasing phases (as in lbm, omnetpp, mcf), a per-set streaming detector flags monotonic address strides, while a tiny per-line 2-bit reuse counter approximates dead blocks. Lines identified as dead (reuse counter=0) during streaming phases are bypassed (inserted at LRU or not cached), minimizing pollution from non-reusable data. This design improves hit rates for mixed-phase workloads (milc, astar) by adapting insertion depth and actively bypassing streaming/dead blocks, while remaining metadata-efficient (~32 KiB for RRIP, PSEL, streaming flags, and dead-block counters).",,ChampSim_CRC2/new_policies/013_01_drrip_with_streaming_aware_dead_block_bypass__drrip_sadb_t04.cc,0.307812624,0.307812624,0%
1487,omnetpp,DRRIP with Streaming-Aware Dead-Block Bypass (DRRIP-SADB),"DRRIP-SADB combines Dynamic RRIP (DRRIP) set-dueling for adaptive insertion depth with a lightweight streaming detector and per-line dead-block approximation. DRRIP uses set-dueling with a small PSEL counter to dynamically select between SRRIP (aggressive insertion) and BRRIP (conservative insertion), adapting to workload locality. To further reduce cache pollution from streaming and pointer-chasing phases (as in lbm, omnetpp, mcf), a per-set streaming detector flags monotonic address strides, while a tiny per-line 2-bit reuse counter approximates dead blocks. Lines identified as dead (reuse counter=0) during streaming phases are bypassed (inserted at LRU or not cached), minimizing pollution from non-reusable data. This design improves hit rates for mixed-phase workloads (milc, astar) by adapting insertion depth and actively bypassing streaming/dead blocks, while remaining metadata-efficient (~32 KiB for RRIP, PSEL, streaming flags, and dead-block counters).",,ChampSim_CRC2/new_policies/013_01_drrip_with_streaming_aware_dead_block_bypass__drrip_sadb_t04.cc,0.447131243,0.447131243,0%
1488,all,DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"DRRIP-SBDT combines Dynamic RRIP (SRRIP vs BRRIP set-dueling) with a lightweight streaming detector and per-line dead-block counters to adapt insertion and bypass strategies for diverse workloads. DRRIP’s set-dueling (using a 10-bit PSEL) dynamically selects between frequent (SRRIP) and infrequent (BRRIP) insertion depths, optimizing for both high-reuse (mcf, milc, astar) and streaming (lbm, omnetpp) phases. A per-set streaming detector flags monotonic accesses, triggering bypass for lines predicted dead via a 1-bit per-line dead-block counter. This dead-block approximation is updated on hits and periodically decayed, allowing the policy to avoid cache pollution during streaming phases while retaining blocks with demonstrated reuse. The metadata footprint (~16 KiB for RRIP, ~2 KiB for dead-block counters, ~256 bytes for streaming flags, ~1 KiB for PSEL/leader sets) fits well under 64 KiB. By combining DRRIP’s adaptive insertion with streaming-aware bypass and dead-block tracking, the policy improves hit rates across irregular, pointer-chasing, and streaming workloads.",,ChampSim_CRC2/new_policies/013_00_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t02.cc,0.411253974,0.411253974,41%
1489,astar,SHiP-Lite with Streaming Bypass (SHiP-LSB),"SHiP-LSB augments RRIP by using lightweight PC-based signatures and outcome counters to bias insertion depth toward lines with demonstrated reuse, while integrating a streaming detector to bypass cache pollution during monotonic access phases. Each cache line tracks a 6-bit signature (from PC) and a shared 2-bit counter table (256 entries), incremented on hits and decayed periodically. On misses, lines with high signature confidence are inserted at MRU (RRPV=0), others at LRU (RRPV=3). A per-set streaming flag detects near-monotonic address strides and triggers bypass for lines with low signature confidence. This approach improves hit rates for pointer-chasing and phase-changing workloads (e.g., mcf, milc, astar) by learning reuse, while actively avoiding pollution from streaming phases (lbm, omnetpp). Metadata footprint is ~16 KiB (RRIP), ~3 KiB (signatures), ~1 KiB (counters), ~256 bytes (streaming flags), well under 64 KiB.",,ChampSim_CRC2/new_policies/014_01_ship_lite_with_streaming_bypass__ship_lsb_t04.cc,0.211284887,0.211284887,0%
1490,lbm,SHiP-Lite with Streaming Bypass (SHiP-LSB),"SHiP-LSB augments RRIP by using lightweight PC-based signatures and outcome counters to bias insertion depth toward lines with demonstrated reuse, while integrating a streaming detector to bypass cache pollution during monotonic access phases. Each cache line tracks a 6-bit signature (from PC) and a shared 2-bit counter table (256 entries), incremented on hits and decayed periodically. On misses, lines with high signature confidence are inserted at MRU (RRPV=0), others at LRU (RRPV=3). A per-set streaming flag detects near-monotonic address strides and triggers bypass for lines with low signature confidence. This approach improves hit rates for pointer-chasing and phase-changing workloads (e.g., mcf, milc, astar) by learning reuse, while actively avoiding pollution from streaming phases (lbm, omnetpp). Metadata footprint is ~16 KiB (RRIP), ~3 KiB (signatures), ~1 KiB (counters), ~256 bytes (streaming flags), well under 64 KiB.",,ChampSim_CRC2/new_policies/014_01_ship_lite_with_streaming_bypass__ship_lsb_t04.cc,0.088403227,0.088403227,0%
1491,mcf,SHiP-Lite with Streaming Bypass (SHiP-LSB),"SHiP-LSB augments RRIP by using lightweight PC-based signatures and outcome counters to bias insertion depth toward lines with demonstrated reuse, while integrating a streaming detector to bypass cache pollution during monotonic access phases. Each cache line tracks a 6-bit signature (from PC) and a shared 2-bit counter table (256 entries), incremented on hits and decayed periodically. On misses, lines with high signature confidence are inserted at MRU (RRPV=0), others at LRU (RRPV=3). A per-set streaming flag detects near-monotonic address strides and triggers bypass for lines with low signature confidence. This approach improves hit rates for pointer-chasing and phase-changing workloads (e.g., mcf, milc, astar) by learning reuse, while actively avoiding pollution from streaming phases (lbm, omnetpp). Metadata footprint is ~16 KiB (RRIP), ~3 KiB (signatures), ~1 KiB (counters), ~256 bytes (streaming flags), well under 64 KiB.",,ChampSim_CRC2/new_policies/014_01_ship_lite_with_streaming_bypass__ship_lsb_t04.cc,0.509522055,0.509522055,0%
1492,milc,SHiP-Lite with Streaming Bypass (SHiP-LSB),"SHiP-LSB augments RRIP by using lightweight PC-based signatures and outcome counters to bias insertion depth toward lines with demonstrated reuse, while integrating a streaming detector to bypass cache pollution during monotonic access phases. Each cache line tracks a 6-bit signature (from PC) and a shared 2-bit counter table (256 entries), incremented on hits and decayed periodically. On misses, lines with high signature confidence are inserted at MRU (RRPV=0), others at LRU (RRPV=3). A per-set streaming flag detects near-monotonic address strides and triggers bypass for lines with low signature confidence. This approach improves hit rates for pointer-chasing and phase-changing workloads (e.g., mcf, milc, astar) by learning reuse, while actively avoiding pollution from streaming phases (lbm, omnetpp). Metadata footprint is ~16 KiB (RRIP), ~3 KiB (signatures), ~1 KiB (counters), ~256 bytes (streaming flags), well under 64 KiB.",,ChampSim_CRC2/new_policies/014_01_ship_lite_with_streaming_bypass__ship_lsb_t04.cc,0.009714186,0.009714186,0%
1493,omnetpp,SHiP-Lite with Streaming Bypass (SHiP-LSB),"SHiP-LSB augments RRIP by using lightweight PC-based signatures and outcome counters to bias insertion depth toward lines with demonstrated reuse, while integrating a streaming detector to bypass cache pollution during monotonic access phases. Each cache line tracks a 6-bit signature (from PC) and a shared 2-bit counter table (256 entries), incremented on hits and decayed periodically. On misses, lines with high signature confidence are inserted at MRU (RRPV=0), others at LRU (RRPV=3). A per-set streaming flag detects near-monotonic address strides and triggers bypass for lines with low signature confidence. This approach improves hit rates for pointer-chasing and phase-changing workloads (e.g., mcf, milc, astar) by learning reuse, while actively avoiding pollution from streaming phases (lbm, omnetpp). Metadata footprint is ~16 KiB (RRIP), ~3 KiB (signatures), ~1 KiB (counters), ~256 bytes (streaming flags), well under 64 KiB.",,ChampSim_CRC2/new_policies/014_01_ship_lite_with_streaming_bypass__ship_lsb_t04.cc,0.002189097,0.002189097,0%
1494,astar,SHiP-Lite with Streaming-Aware Insertion (SHiP-Lite-SA),"SHiP-Lite-SA combines lightweight PC-based reuse prediction (SHiP-Lite) with a per-set streaming detector to dynamically adapt insertion depth for each cache block. SHiP-Lite maintains a compact table of 4-bit PC signatures per block and 2-bit outcome counters to estimate the likelihood of reuse, biasing insertion toward MRU for blocks with positive history and toward LRU for blocks with negative or unknown history. A per-set 1-bit streaming detector flags monotonic address patterns and, in streaming phases, forces insertion at LRU to minimize pollution. This hybrid approach improves hit rates across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by leveraging code locality (SHiP-Lite) and memory stride awareness (streaming detector) to select insertion depths. The metadata fits well under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~256 bytes for streaming flags, and standard RRIP bits. By combining SHiP-Lite’s code-centric reuse tracking with streaming-aware insertion, the policy avoids cache pollution during streaming while retaining blocks with observed reuse, delivering robust performance gains over DRRIP-SBDT.",,ChampSim_CRC2/new_policies/014_02_ship_lite_with_streaming_aware_insertion__ship_lite_sa_t07.cc,0.396417738,0.396417738,0%
1495,lbm,SHiP-Lite with Streaming-Aware Insertion (SHiP-Lite-SA),"SHiP-Lite-SA combines lightweight PC-based reuse prediction (SHiP-Lite) with a per-set streaming detector to dynamically adapt insertion depth for each cache block. SHiP-Lite maintains a compact table of 4-bit PC signatures per block and 2-bit outcome counters to estimate the likelihood of reuse, biasing insertion toward MRU for blocks with positive history and toward LRU for blocks with negative or unknown history. A per-set 1-bit streaming detector flags monotonic address patterns and, in streaming phases, forces insertion at LRU to minimize pollution. This hybrid approach improves hit rates across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by leveraging code locality (SHiP-Lite) and memory stride awareness (streaming detector) to select insertion depths. The metadata fits well under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~256 bytes for streaming flags, and standard RRIP bits. By combining SHiP-Lite’s code-centric reuse tracking with streaming-aware insertion, the policy avoids cache pollution during streaming while retaining blocks with observed reuse, delivering robust performance gains over DRRIP-SBDT.",,ChampSim_CRC2/new_policies/014_02_ship_lite_with_streaming_aware_insertion__ship_lite_sa_t07.cc,0.279046925,0.279046925,0%
1496,mcf,SHiP-Lite with Streaming-Aware Insertion (SHiP-Lite-SA),"SHiP-Lite-SA combines lightweight PC-based reuse prediction (SHiP-Lite) with a per-set streaming detector to dynamically adapt insertion depth for each cache block. SHiP-Lite maintains a compact table of 4-bit PC signatures per block and 2-bit outcome counters to estimate the likelihood of reuse, biasing insertion toward MRU for blocks with positive history and toward LRU for blocks with negative or unknown history. A per-set 1-bit streaming detector flags monotonic address patterns and, in streaming phases, forces insertion at LRU to minimize pollution. This hybrid approach improves hit rates across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by leveraging code locality (SHiP-Lite) and memory stride awareness (streaming detector) to select insertion depths. The metadata fits well under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~256 bytes for streaming flags, and standard RRIP bits. By combining SHiP-Lite’s code-centric reuse tracking with streaming-aware insertion, the policy avoids cache pollution during streaming while retaining blocks with observed reuse, delivering robust performance gains over DRRIP-SBDT.",,ChampSim_CRC2/new_policies/014_02_ship_lite_with_streaming_aware_insertion__ship_lite_sa_t07.cc,0.492395882,0.492395882,0%
1497,milc,SHiP-Lite with Streaming-Aware Insertion (SHiP-Lite-SA),"SHiP-Lite-SA combines lightweight PC-based reuse prediction (SHiP-Lite) with a per-set streaming detector to dynamically adapt insertion depth for each cache block. SHiP-Lite maintains a compact table of 4-bit PC signatures per block and 2-bit outcome counters to estimate the likelihood of reuse, biasing insertion toward MRU for blocks with positive history and toward LRU for blocks with negative or unknown history. A per-set 1-bit streaming detector flags monotonic address patterns and, in streaming phases, forces insertion at LRU to minimize pollution. This hybrid approach improves hit rates across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by leveraging code locality (SHiP-Lite) and memory stride awareness (streaming detector) to select insertion depths. The metadata fits well under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~256 bytes for streaming flags, and standard RRIP bits. By combining SHiP-Lite’s code-centric reuse tracking with streaming-aware insertion, the policy avoids cache pollution during streaming while retaining blocks with observed reuse, delivering robust performance gains over DRRIP-SBDT.",,ChampSim_CRC2/new_policies/014_02_ship_lite_with_streaming_aware_insertion__ship_lite_sa_t07.cc,0.164096613,0.164096613,0%
1498,omnetpp,SHiP-Lite with Streaming-Aware Insertion (SHiP-Lite-SA),"SHiP-Lite-SA combines lightweight PC-based reuse prediction (SHiP-Lite) with a per-set streaming detector to dynamically adapt insertion depth for each cache block. SHiP-Lite maintains a compact table of 4-bit PC signatures per block and 2-bit outcome counters to estimate the likelihood of reuse, biasing insertion toward MRU for blocks with positive history and toward LRU for blocks with negative or unknown history. A per-set 1-bit streaming detector flags monotonic address patterns and, in streaming phases, forces insertion at LRU to minimize pollution. This hybrid approach improves hit rates across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by leveraging code locality (SHiP-Lite) and memory stride awareness (streaming detector) to select insertion depths. The metadata fits well under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~256 bytes for streaming flags, and standard RRIP bits. By combining SHiP-Lite’s code-centric reuse tracking with streaming-aware insertion, the policy avoids cache pollution during streaming while retaining blocks with observed reuse, delivering robust performance gains over DRRIP-SBDT.",,ChampSim_CRC2/new_policies/014_02_ship_lite_with_streaming_aware_insertion__ship_lite_sa_t07.cc,0.432791931,0.432791931,0%
1499,all,SHiP-Lite with Streaming-Aware Insertion (SHiP-Lite-SA),"SHiP-Lite-SA combines lightweight PC-based reuse prediction (SHiP-Lite) with a per-set streaming detector to dynamically adapt insertion depth for each cache block. SHiP-Lite maintains a compact table of 4-bit PC signatures per block and 2-bit outcome counters to estimate the likelihood of reuse, biasing insertion toward MRU for blocks with positive history and toward LRU for blocks with negative or unknown history. A per-set 1-bit streaming detector flags monotonic address patterns and, in streaming phases, forces insertion at LRU to minimize pollution. This hybrid approach improves hit rates across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by leveraging code locality (SHiP-Lite) and memory stride awareness (streaming detector) to select insertion depths. The metadata fits well under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~256 bytes for streaming flags, and standard RRIP bits. By combining SHiP-Lite’s code-centric reuse tracking with streaming-aware insertion, the policy avoids cache pollution during streaming while retaining blocks with observed reuse, delivering robust performance gains over DRRIP-SBDT.",,ChampSim_CRC2/new_policies/014_02_ship_lite_with_streaming_aware_insertion__ship_lite_sa_t07.cc,0.352949818,0.352949818,35%
1500,astar,SHiP-Lite with Dead-Block Decay and Adaptive Bypass (SHiP-Lite-DBA),"SHiP-Lite-DBA combines lightweight PC-based reuse prediction (SHiP-Lite) with per-block dead-block approximation and a compact streaming detector to adapt insertion and bypass behavior. Each cache block tracks a 2-bit dead-block counter that decays periodically, approximating non-reuse and enabling selective bypass for blocks predicted dead. SHiP-Lite’s 4-bit PC signatures and 2-bit outcome counters bias insertion depth toward MRU for blocks with positive history. A per-set streaming detector flags monotonic access phases, forcing insertion at LRU and bypassing blocks with high dead-block probability. This hybrid approach improves performance across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by combining code-centric reuse, dead-block filtering, and streaming-aware insertion. Metadata fits under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~8 KiB for dead-block counters, ~256 bytes for streaming flags, and standard RRIP bits. By actively bypassing predicted-dead blocks and adapting insertion depth, SHiP-Lite-DBA reduces pollution and retains blocks with observed reuse, outperforming prior policies.",,ChampSim_CRC2/new_policies/015_00_ship_lite_with_dead_block_decay_and_adaptive_bypass__ship_lite_dba_t02.cc,0.351285986,0.351285986,0%
1501,lbm,SHiP-Lite with Dead-Block Decay and Adaptive Bypass (SHiP-Lite-DBA),"SHiP-Lite-DBA combines lightweight PC-based reuse prediction (SHiP-Lite) with per-block dead-block approximation and a compact streaming detector to adapt insertion and bypass behavior. Each cache block tracks a 2-bit dead-block counter that decays periodically, approximating non-reuse and enabling selective bypass for blocks predicted dead. SHiP-Lite’s 4-bit PC signatures and 2-bit outcome counters bias insertion depth toward MRU for blocks with positive history. A per-set streaming detector flags monotonic access phases, forcing insertion at LRU and bypassing blocks with high dead-block probability. This hybrid approach improves performance across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by combining code-centric reuse, dead-block filtering, and streaming-aware insertion. Metadata fits under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~8 KiB for dead-block counters, ~256 bytes for streaming flags, and standard RRIP bits. By actively bypassing predicted-dead blocks and adapting insertion depth, SHiP-Lite-DBA reduces pollution and retains blocks with observed reuse, outperforming prior policies.",,ChampSim_CRC2/new_policies/015_00_ship_lite_with_dead_block_decay_and_adaptive_bypass__ship_lite_dba_t02.cc,0.259783837,0.259783837,0%
1502,mcf,SHiP-Lite with Dead-Block Decay and Adaptive Bypass (SHiP-Lite-DBA),"SHiP-Lite-DBA combines lightweight PC-based reuse prediction (SHiP-Lite) with per-block dead-block approximation and a compact streaming detector to adapt insertion and bypass behavior. Each cache block tracks a 2-bit dead-block counter that decays periodically, approximating non-reuse and enabling selective bypass for blocks predicted dead. SHiP-Lite’s 4-bit PC signatures and 2-bit outcome counters bias insertion depth toward MRU for blocks with positive history. A per-set streaming detector flags monotonic access phases, forcing insertion at LRU and bypassing blocks with high dead-block probability. This hybrid approach improves performance across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by combining code-centric reuse, dead-block filtering, and streaming-aware insertion. Metadata fits under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~8 KiB for dead-block counters, ~256 bytes for streaming flags, and standard RRIP bits. By actively bypassing predicted-dead blocks and adapting insertion depth, SHiP-Lite-DBA reduces pollution and retains blocks with observed reuse, outperforming prior policies.",,ChampSim_CRC2/new_policies/015_00_ship_lite_with_dead_block_decay_and_adaptive_bypass__ship_lite_dba_t02.cc,0.49088805,0.49088805,0%
1503,milc,SHiP-Lite with Dead-Block Decay and Adaptive Bypass (SHiP-Lite-DBA),"SHiP-Lite-DBA combines lightweight PC-based reuse prediction (SHiP-Lite) with per-block dead-block approximation and a compact streaming detector to adapt insertion and bypass behavior. Each cache block tracks a 2-bit dead-block counter that decays periodically, approximating non-reuse and enabling selective bypass for blocks predicted dead. SHiP-Lite’s 4-bit PC signatures and 2-bit outcome counters bias insertion depth toward MRU for blocks with positive history. A per-set streaming detector flags monotonic access phases, forcing insertion at LRU and bypassing blocks with high dead-block probability. This hybrid approach improves performance across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by combining code-centric reuse, dead-block filtering, and streaming-aware insertion. Metadata fits under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~8 KiB for dead-block counters, ~256 bytes for streaming flags, and standard RRIP bits. By actively bypassing predicted-dead blocks and adapting insertion depth, SHiP-Lite-DBA reduces pollution and retains blocks with observed reuse, outperforming prior policies.",,ChampSim_CRC2/new_policies/015_00_ship_lite_with_dead_block_decay_and_adaptive_bypass__ship_lite_dba_t02.cc,0.062640753,0.062640753,0%
1504,omnetpp,SHiP-Lite with Dead-Block Decay and Adaptive Bypass (SHiP-Lite-DBA),"SHiP-Lite-DBA combines lightweight PC-based reuse prediction (SHiP-Lite) with per-block dead-block approximation and a compact streaming detector to adapt insertion and bypass behavior. Each cache block tracks a 2-bit dead-block counter that decays periodically, approximating non-reuse and enabling selective bypass for blocks predicted dead. SHiP-Lite’s 4-bit PC signatures and 2-bit outcome counters bias insertion depth toward MRU for blocks with positive history. A per-set streaming detector flags monotonic access phases, forcing insertion at LRU and bypassing blocks with high dead-block probability. This hybrid approach improves performance across irregular (mcf, milc, astar), streaming (lbm, omnetpp), and phase-changing workloads by combining code-centric reuse, dead-block filtering, and streaming-aware insertion. Metadata fits under 64 KiB: ~16 KiB for signatures, ~2 KiB for counters, ~8 KiB for dead-block counters, ~256 bytes for streaming flags, and standard RRIP bits. By actively bypassing predicted-dead blocks and adapting insertion depth, SHiP-Lite-DBA reduces pollution and retains blocks with observed reuse, outperforming prior policies.",,ChampSim_CRC2/new_policies/015_00_ship_lite_with_dead_block_decay_and_adaptive_bypass__ship_lite_dba_t02.cc,0.363224794,0.363224794,0%
1505,astar,Hybrid DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"This policy combines DRRIP’s set-dueling adaptive insertion (SRRIP/BRRIP) with a per-set streaming detector and a lightweight dead-block tracker. DRRIP dynamically chooses between aggressive (SRRIP) and conservative (BRRIP) insertion depths using a small PSEL counter and leader sets. The streaming detector flags sets with near-monotonic address strides, and for these, the policy bypasses the cache on insert (i.e., does not allocate on miss) to avoid pollution from streaming phases (e.g., lbm, omnetpp). Additionally, a tiny per-block dead-block counter tracks blocks that are never reused before eviction, biasing future insertions toward LRU for dead-prone lines. This hybrid approach improves performance by adaptively tuning insertion depth for phase changes (milc, astar), bypassing streaming accesses, and reducing dead-block pollution (mcf), while keeping metadata below 64 KiB. The combination addresses the diversity requirement by changing both the insertion policy (DRRIP set-dueling) and the bypass logic (streaming detector with allocation suppression).",,ChampSim_CRC2/new_policies/015_01_hybrid_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t04.cc,0.426740634,0.426740634,0%
1506,lbm,Hybrid DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"This policy combines DRRIP’s set-dueling adaptive insertion (SRRIP/BRRIP) with a per-set streaming detector and a lightweight dead-block tracker. DRRIP dynamically chooses between aggressive (SRRIP) and conservative (BRRIP) insertion depths using a small PSEL counter and leader sets. The streaming detector flags sets with near-monotonic address strides, and for these, the policy bypasses the cache on insert (i.e., does not allocate on miss) to avoid pollution from streaming phases (e.g., lbm, omnetpp). Additionally, a tiny per-block dead-block counter tracks blocks that are never reused before eviction, biasing future insertions toward LRU for dead-prone lines. This hybrid approach improves performance by adaptively tuning insertion depth for phase changes (milc, astar), bypassing streaming accesses, and reducing dead-block pollution (mcf), while keeping metadata below 64 KiB. The combination addresses the diversity requirement by changing both the insertion policy (DRRIP set-dueling) and the bypass logic (streaming detector with allocation suppression).",,ChampSim_CRC2/new_policies/015_01_hybrid_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t04.cc,0.403380413,0.403380413,0%
1507,mcf,Hybrid DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"This policy combines DRRIP’s set-dueling adaptive insertion (SRRIP/BRRIP) with a per-set streaming detector and a lightweight dead-block tracker. DRRIP dynamically chooses between aggressive (SRRIP) and conservative (BRRIP) insertion depths using a small PSEL counter and leader sets. The streaming detector flags sets with near-monotonic address strides, and for these, the policy bypasses the cache on insert (i.e., does not allocate on miss) to avoid pollution from streaming phases (e.g., lbm, omnetpp). Additionally, a tiny per-block dead-block counter tracks blocks that are never reused before eviction, biasing future insertions toward LRU for dead-prone lines. This hybrid approach improves performance by adaptively tuning insertion depth for phase changes (milc, astar), bypassing streaming accesses, and reducing dead-block pollution (mcf), while keeping metadata below 64 KiB. The combination addresses the diversity requirement by changing both the insertion policy (DRRIP set-dueling) and the bypass logic (streaming detector with allocation suppression).",,ChampSim_CRC2/new_policies/015_01_hybrid_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t04.cc,0.45758396,0.45758396,0%
1508,milc,Hybrid DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"This policy combines DRRIP’s set-dueling adaptive insertion (SRRIP/BRRIP) with a per-set streaming detector and a lightweight dead-block tracker. DRRIP dynamically chooses between aggressive (SRRIP) and conservative (BRRIP) insertion depths using a small PSEL counter and leader sets. The streaming detector flags sets with near-monotonic address strides, and for these, the policy bypasses the cache on insert (i.e., does not allocate on miss) to avoid pollution from streaming phases (e.g., lbm, omnetpp). Additionally, a tiny per-block dead-block counter tracks blocks that are never reused before eviction, biasing future insertions toward LRU for dead-prone lines. This hybrid approach improves performance by adaptively tuning insertion depth for phase changes (milc, astar), bypassing streaming accesses, and reducing dead-block pollution (mcf), while keeping metadata below 64 KiB. The combination addresses the diversity requirement by changing both the insertion policy (DRRIP set-dueling) and the bypass logic (streaming detector with allocation suppression).",,ChampSim_CRC2/new_policies/015_01_hybrid_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t04.cc,0.302320108,0.302320108,0%
1509,omnetpp,Hybrid DRRIP with Streaming Bypass and Dead-Block Tracking (DRRIP-SBDT),"This policy combines DRRIP’s set-dueling adaptive insertion (SRRIP/BRRIP) with a per-set streaming detector and a lightweight dead-block tracker. DRRIP dynamically chooses between aggressive (SRRIP) and conservative (BRRIP) insertion depths using a small PSEL counter and leader sets. The streaming detector flags sets with near-monotonic address strides, and for these, the policy bypasses the cache on insert (i.e., does not allocate on miss) to avoid pollution from streaming phases (e.g., lbm, omnetpp). Additionally, a tiny per-block dead-block counter tracks blocks that are never reused before eviction, biasing future insertions toward LRU for dead-prone lines. This hybrid approach improves performance by adaptively tuning insertion depth for phase changes (milc, astar), bypassing streaming accesses, and reducing dead-block pollution (mcf), while keeping metadata below 64 KiB. The combination addresses the diversity requirement by changing both the insertion policy (DRRIP set-dueling) and the bypass logic (streaming detector with allocation suppression).",,ChampSim_CRC2/new_policies/015_01_hybrid_drrip_with_streaming_bypass_and_dead_block_tracking__drrip_sbdt_t04.cc,0.448986287,0.448986287,0%
1510,astar,SRRIP-DBI (Static RRIP with Dead Block Insertion),"SRRIP-DBI augments Static RRIP with a dead-block approximation to improve cache performance across diverse workloads. Each cache line tracks a tiny 2-bit dead-counter, which is incremented on misses and decayed periodically. When a block’s dead-counter indicates frequent eviction without reuse, new inserts are forced at LRU, reducing pollution from dead-on-arrival data (common in streaming and pointer-chasing workloads like lbm, mcf, and omnetpp). Otherwise, SRRIP inserts at medium RRPV (2) for balanced retention. No PC or address signatures are used—prediction is entirely per-line and usage-based—resulting in robust adaptation to irregular, phase-changing, and streaming access patterns. The metadata (2-bit RRPV, 2-bit dead-counter per block) fits comfortably within 64 KiB. This mechanism improves over SHiP-Lite-SA by more directly detecting blocks that never get reused and preventing them from polluting the cache, while maintaining low complexity and high coverage.",,ChampSim_CRC2/new_policies/015_02_srrip_dbi__static_rrip_with_dead_block_insertion_t07.cc,0.433293704,0.433293704,0%
1511,lbm,SRRIP-DBI (Static RRIP with Dead Block Insertion),"SRRIP-DBI augments Static RRIP with a dead-block approximation to improve cache performance across diverse workloads. Each cache line tracks a tiny 2-bit dead-counter, which is incremented on misses and decayed periodically. When a block’s dead-counter indicates frequent eviction without reuse, new inserts are forced at LRU, reducing pollution from dead-on-arrival data (common in streaming and pointer-chasing workloads like lbm, mcf, and omnetpp). Otherwise, SRRIP inserts at medium RRPV (2) for balanced retention. No PC or address signatures are used—prediction is entirely per-line and usage-based—resulting in robust adaptation to irregular, phase-changing, and streaming access patterns. The metadata (2-bit RRPV, 2-bit dead-counter per block) fits comfortably within 64 KiB. This mechanism improves over SHiP-Lite-SA by more directly detecting blocks that never get reused and preventing them from polluting the cache, while maintaining low complexity and high coverage.",,ChampSim_CRC2/new_policies/015_02_srrip_dbi__static_rrip_with_dead_block_insertion_t07.cc,0.413577291,0.413577291,0%
1512,mcf,SRRIP-DBI (Static RRIP with Dead Block Insertion),"SRRIP-DBI augments Static RRIP with a dead-block approximation to improve cache performance across diverse workloads. Each cache line tracks a tiny 2-bit dead-counter, which is incremented on misses and decayed periodically. When a block’s dead-counter indicates frequent eviction without reuse, new inserts are forced at LRU, reducing pollution from dead-on-arrival data (common in streaming and pointer-chasing workloads like lbm, mcf, and omnetpp). Otherwise, SRRIP inserts at medium RRPV (2) for balanced retention. No PC or address signatures are used—prediction is entirely per-line and usage-based—resulting in robust adaptation to irregular, phase-changing, and streaming access patterns. The metadata (2-bit RRPV, 2-bit dead-counter per block) fits comfortably within 64 KiB. This mechanism improves over SHiP-Lite-SA by more directly detecting blocks that never get reused and preventing them from polluting the cache, while maintaining low complexity and high coverage.",,ChampSim_CRC2/new_policies/015_02_srrip_dbi__static_rrip_with_dead_block_insertion_t07.cc,0.461048695,0.461048695,0%
1513,milc,SRRIP-DBI (Static RRIP with Dead Block Insertion),"SRRIP-DBI augments Static RRIP with a dead-block approximation to improve cache performance across diverse workloads. Each cache line tracks a tiny 2-bit dead-counter, which is incremented on misses and decayed periodically. When a block’s dead-counter indicates frequent eviction without reuse, new inserts are forced at LRU, reducing pollution from dead-on-arrival data (common in streaming and pointer-chasing workloads like lbm, mcf, and omnetpp). Otherwise, SRRIP inserts at medium RRPV (2) for balanced retention. No PC or address signatures are used—prediction is entirely per-line and usage-based—resulting in robust adaptation to irregular, phase-changing, and streaming access patterns. The metadata (2-bit RRPV, 2-bit dead-counter per block) fits comfortably within 64 KiB. This mechanism improves over SHiP-Lite-SA by more directly detecting blocks that never get reused and preventing them from polluting the cache, while maintaining low complexity and high coverage.",,ChampSim_CRC2/new_policies/015_02_srrip_dbi__static_rrip_with_dead_block_insertion_t07.cc,0.311254046,0.311254046,0%
1514,omnetpp,SRRIP-DBI (Static RRIP with Dead Block Insertion),"SRRIP-DBI augments Static RRIP with a dead-block approximation to improve cache performance across diverse workloads. Each cache line tracks a tiny 2-bit dead-counter, which is incremented on misses and decayed periodically. When a block’s dead-counter indicates frequent eviction without reuse, new inserts are forced at LRU, reducing pollution from dead-on-arrival data (common in streaming and pointer-chasing workloads like lbm, mcf, and omnetpp). Otherwise, SRRIP inserts at medium RRPV (2) for balanced retention. No PC or address signatures are used—prediction is entirely per-line and usage-based—resulting in robust adaptation to irregular, phase-changing, and streaming access patterns. The metadata (2-bit RRPV, 2-bit dead-counter per block) fits comfortably within 64 KiB. This mechanism improves over SHiP-Lite-SA by more directly detecting blocks that never get reused and preventing them from polluting the cache, while maintaining low complexity and high coverage.",,ChampSim_CRC2/new_policies/015_02_srrip_dbi__static_rrip_with_dead_block_insertion_t07.cc,0.453173557,0.453173557,0%
1515,all,SRRIP-DBI (Static RRIP with Dead Block Insertion),"SRRIP-DBI augments Static RRIP with a dead-block approximation to improve cache performance across diverse workloads. Each cache line tracks a tiny 2-bit dead-counter, which is incremented on misses and decayed periodically. When a block’s dead-counter indicates frequent eviction without reuse, new inserts are forced at LRU, reducing pollution from dead-on-arrival data (common in streaming and pointer-chasing workloads like lbm, mcf, and omnetpp). Otherwise, SRRIP inserts at medium RRPV (2) for balanced retention. No PC or address signatures are used—prediction is entirely per-line and usage-based—resulting in robust adaptation to irregular, phase-changing, and streaming access patterns. The metadata (2-bit RRPV, 2-bit dead-counter per block) fits comfortably within 64 KiB. This mechanism improves over SHiP-Lite-SA by more directly detecting blocks that never get reused and preventing them from polluting the cache, while maintaining low complexity and high coverage.",,ChampSim_CRC2/new_policies/015_02_srrip_dbi__static_rrip_with_dead_block_insertion_t07.cc,0.414469459,0.414469459,41%
1516,astar,SHiP-Lite-DRRIP with Streaming Bypass,"This policy combines SHiP-Lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) insertion control and a lightweight streaming detector to robustly adapt to diverse workload behaviors. SHiP-Lite uses 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, learning which instructions produce cache-friendly blocks. DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths, using a 10-bit PSEL selector and 64 leader sets. Additionally, a streaming detector observes monotonic address deltas within sets; when detected, it forces blocks to be inserted at distant RRPV (3) or bypasses them, minimizing pollution from streaming phases (e.g., LBM, MCF). This hybrid approach improves over SRRIP-DBI by leveraging instruction context, dynamic insertion tuning, and streaming avoidance, all within 64 KiB metadata. The policy adapts to both regular and irregular access patterns, phase changes, and pointer-chasing behaviors, yielding higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/016_01_ship_lite_drrip_with_streaming_bypass_t04.cc,0.305627117,0.305627117,0%
1517,lbm,SHiP-Lite-DRRIP with Streaming Bypass,"This policy combines SHiP-Lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) insertion control and a lightweight streaming detector to robustly adapt to diverse workload behaviors. SHiP-Lite uses 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, learning which instructions produce cache-friendly blocks. DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths, using a 10-bit PSEL selector and 64 leader sets. Additionally, a streaming detector observes monotonic address deltas within sets; when detected, it forces blocks to be inserted at distant RRPV (3) or bypasses them, minimizing pollution from streaming phases (e.g., LBM, MCF). This hybrid approach improves over SRRIP-DBI by leveraging instruction context, dynamic insertion tuning, and streaming avoidance, all within 64 KiB metadata. The policy adapts to both regular and irregular access patterns, phase changes, and pointer-chasing behaviors, yielding higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/016_01_ship_lite_drrip_with_streaming_bypass_t04.cc,0.224334263,0.224334263,0%
1518,mcf,SHiP-Lite-DRRIP with Streaming Bypass,"This policy combines SHiP-Lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) insertion control and a lightweight streaming detector to robustly adapt to diverse workload behaviors. SHiP-Lite uses 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, learning which instructions produce cache-friendly blocks. DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths, using a 10-bit PSEL selector and 64 leader sets. Additionally, a streaming detector observes monotonic address deltas within sets; when detected, it forces blocks to be inserted at distant RRPV (3) or bypasses them, minimizing pollution from streaming phases (e.g., LBM, MCF). This hybrid approach improves over SRRIP-DBI by leveraging instruction context, dynamic insertion tuning, and streaming avoidance, all within 64 KiB metadata. The policy adapts to both regular and irregular access patterns, phase changes, and pointer-chasing behaviors, yielding higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/016_01_ship_lite_drrip_with_streaming_bypass_t04.cc,0.513056154,0.513056154,0%
1519,milc,SHiP-Lite-DRRIP with Streaming Bypass,"This policy combines SHiP-Lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) insertion control and a lightweight streaming detector to robustly adapt to diverse workload behaviors. SHiP-Lite uses 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, learning which instructions produce cache-friendly blocks. DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths, using a 10-bit PSEL selector and 64 leader sets. Additionally, a streaming detector observes monotonic address deltas within sets; when detected, it forces blocks to be inserted at distant RRPV (3) or bypasses them, minimizing pollution from streaming phases (e.g., LBM, MCF). This hybrid approach improves over SRRIP-DBI by leveraging instruction context, dynamic insertion tuning, and streaming avoidance, all within 64 KiB metadata. The policy adapts to both regular and irregular access patterns, phase changes, and pointer-chasing behaviors, yielding higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/016_01_ship_lite_drrip_with_streaming_bypass_t04.cc,0.030107461,0.030107461,0%
1520,omnetpp,SHiP-Lite-DRRIP with Streaming Bypass,"This policy combines SHiP-Lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) insertion control and a lightweight streaming detector to robustly adapt to diverse workload behaviors. SHiP-Lite uses 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, learning which instructions produce cache-friendly blocks. DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths, using a 10-bit PSEL selector and 64 leader sets. Additionally, a streaming detector observes monotonic address deltas within sets; when detected, it forces blocks to be inserted at distant RRPV (3) or bypasses them, minimizing pollution from streaming phases (e.g., LBM, MCF). This hybrid approach improves over SRRIP-DBI by leveraging instruction context, dynamic insertion tuning, and streaming avoidance, all within 64 KiB metadata. The policy adapts to both regular and irregular access patterns, phase changes, and pointer-chasing behaviors, yielding higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/016_01_ship_lite_drrip_with_streaming_bypass_t04.cc,0.001556824,0.001556824,0%
1521,astar,SHiP-Lite-DRRIP with Streaming Bypass (SHiP-Lite-SB),"SHiP-Lite-SB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth control, augmented by a compact streaming detector that identifies monotonic address patterns and bypasses cache insertion for matching accesses. Each block is tagged with a 6-bit PC signature and a 2-bit outcome counter, allowing the policy to learn which PCs yield useful cache lines and bias their insertion depth accordingly (MRU for “hot” PCs, LRU for “cold”). DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths to track workload phase shifts. A small per-set streaming detector monitors recent address deltas: if most accesses show near-monotonic strides (typical of lbm, streaming phases in milc, or pointer chasing in mcf/omnetpp), blocks are bypassed or inserted at distant RRPV to avoid pollution. This policy adapts to both control-dominated and streaming workloads, improving performance by reducing dead-on-arrival blocks and retaining useful lines. Total metadata: 6-bit PC signature + 2-bit outcome per block, 2-bit RRPV per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/016_02_ship_lite_drrip_with_streaming_bypass__ship_lite_sb_t07.cc,0.431268515,0.431268515,0%
1522,lbm,SHiP-Lite-DRRIP with Streaming Bypass (SHiP-Lite-SB),"SHiP-Lite-SB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth control, augmented by a compact streaming detector that identifies monotonic address patterns and bypasses cache insertion for matching accesses. Each block is tagged with a 6-bit PC signature and a 2-bit outcome counter, allowing the policy to learn which PCs yield useful cache lines and bias their insertion depth accordingly (MRU for “hot” PCs, LRU for “cold”). DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths to track workload phase shifts. A small per-set streaming detector monitors recent address deltas: if most accesses show near-monotonic strides (typical of lbm, streaming phases in milc, or pointer chasing in mcf/omnetpp), blocks are bypassed or inserted at distant RRPV to avoid pollution. This policy adapts to both control-dominated and streaming workloads, improving performance by reducing dead-on-arrival blocks and retaining useful lines. Total metadata: 6-bit PC signature + 2-bit outcome per block, 2-bit RRPV per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/016_02_ship_lite_drrip_with_streaming_bypass__ship_lite_sb_t07.cc,0.410652576,0.410652576,0%
1523,mcf,SHiP-Lite-DRRIP with Streaming Bypass (SHiP-Lite-SB),"SHiP-Lite-SB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth control, augmented by a compact streaming detector that identifies monotonic address patterns and bypasses cache insertion for matching accesses. Each block is tagged with a 6-bit PC signature and a 2-bit outcome counter, allowing the policy to learn which PCs yield useful cache lines and bias their insertion depth accordingly (MRU for “hot” PCs, LRU for “cold”). DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths to track workload phase shifts. A small per-set streaming detector monitors recent address deltas: if most accesses show near-monotonic strides (typical of lbm, streaming phases in milc, or pointer chasing in mcf/omnetpp), blocks are bypassed or inserted at distant RRPV to avoid pollution. This policy adapts to both control-dominated and streaming workloads, improving performance by reducing dead-on-arrival blocks and retaining useful lines. Total metadata: 6-bit PC signature + 2-bit outcome per block, 2-bit RRPV per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/016_02_ship_lite_drrip_with_streaming_bypass__ship_lite_sb_t07.cc,0.476428384,0.476428384,0%
1524,milc,SHiP-Lite-DRRIP with Streaming Bypass (SHiP-Lite-SB),"SHiP-Lite-SB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth control, augmented by a compact streaming detector that identifies monotonic address patterns and bypasses cache insertion for matching accesses. Each block is tagged with a 6-bit PC signature and a 2-bit outcome counter, allowing the policy to learn which PCs yield useful cache lines and bias their insertion depth accordingly (MRU for “hot” PCs, LRU for “cold”). DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths to track workload phase shifts. A small per-set streaming detector monitors recent address deltas: if most accesses show near-monotonic strides (typical of lbm, streaming phases in milc, or pointer chasing in mcf/omnetpp), blocks are bypassed or inserted at distant RRPV to avoid pollution. This policy adapts to both control-dominated and streaming workloads, improving performance by reducing dead-on-arrival blocks and retaining useful lines. Total metadata: 6-bit PC signature + 2-bit outcome per block, 2-bit RRPV per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/016_02_ship_lite_drrip_with_streaming_bypass__ship_lite_sb_t07.cc,0.31150206,0.31150206,0%
1525,omnetpp,SHiP-Lite-DRRIP with Streaming Bypass (SHiP-Lite-SB),"SHiP-Lite-SB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth control, augmented by a compact streaming detector that identifies monotonic address patterns and bypasses cache insertion for matching accesses. Each block is tagged with a 6-bit PC signature and a 2-bit outcome counter, allowing the policy to learn which PCs yield useful cache lines and bias their insertion depth accordingly (MRU for “hot” PCs, LRU for “cold”). DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths to track workload phase shifts. A small per-set streaming detector monitors recent address deltas: if most accesses show near-monotonic strides (typical of lbm, streaming phases in milc, or pointer chasing in mcf/omnetpp), blocks are bypassed or inserted at distant RRPV to avoid pollution. This policy adapts to both control-dominated and streaming workloads, improving performance by reducing dead-on-arrival blocks and retaining useful lines. Total metadata: 6-bit PC signature + 2-bit outcome per block, 2-bit RRPV per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/016_02_ship_lite_drrip_with_streaming_bypass__ship_lite_sb_t07.cc,0.608078687,0.608078687,0%
1526,all,SHiP-Lite-DRRIP with Streaming Bypass (SHiP-Lite-SB),"SHiP-Lite-SB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth control, augmented by a compact streaming detector that identifies monotonic address patterns and bypasses cache insertion for matching accesses. Each block is tagged with a 6-bit PC signature and a 2-bit outcome counter, allowing the policy to learn which PCs yield useful cache lines and bias their insertion depth accordingly (MRU for “hot” PCs, LRU for “cold”). DRRIP set-dueling dynamically chooses between SRRIP and BRRIP insertion depths to track workload phase shifts. A small per-set streaming detector monitors recent address deltas: if most accesses show near-monotonic strides (typical of lbm, streaming phases in milc, or pointer chasing in mcf/omnetpp), blocks are bypassed or inserted at distant RRPV to avoid pollution. This policy adapts to both control-dominated and streaming workloads, improving performance by reducing dead-on-arrival blocks and retaining useful lines. Total metadata: 6-bit PC signature + 2-bit outcome per block, 2-bit RRPV per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/016_02_ship_lite_drrip_with_streaming_bypass__ship_lite_sb_t07.cc,0.447586045,0.447586045,45%
1527,astar,SHiP-Lite with Dead Block Prediction and DIP Streaming Bypass (SHiP-Lite-DBP-DIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with per-block dead block prediction and a DIP-style (LIP/BIP) insertion depth controller, augmented by a streaming bypass mechanism. Each cache block tracks a 2-bit dead block counter that is periodically decayed, allowing the policy to identify lines that are likely dead-on-arrival and bias their insertion depth or bypass them. DIP set-dueling dynamically chooses between LIP (always insert at LRU) and BIP (insert at MRU with low probability) to adapt to phase changes, improving retention for control-dominated workloads and reducing pollution for streaming phases. The streaming detector monitors monotonic address strides per set and triggers bypass or distant insertion when streaming is detected. This hybrid approach leverages PC signatures for reuse, dead block prediction for early eviction, and DIP for adaptive insertion, resulting in improved performance across diverse workloads. Metadata: 6-bit PC signature + 2-bit outcome + 2-bit dead block counter per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/017_00_ship_lite_with_dead_block_prediction_and_dip_streaming_bypass__ship_lite_dbp_dip_sb_t02.cc,0.195064778,0.195064778,0%
1528,lbm,SHiP-Lite with Dead Block Prediction and DIP Streaming Bypass (SHiP-Lite-DBP-DIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with per-block dead block prediction and a DIP-style (LIP/BIP) insertion depth controller, augmented by a streaming bypass mechanism. Each cache block tracks a 2-bit dead block counter that is periodically decayed, allowing the policy to identify lines that are likely dead-on-arrival and bias their insertion depth or bypass them. DIP set-dueling dynamically chooses between LIP (always insert at LRU) and BIP (insert at MRU with low probability) to adapt to phase changes, improving retention for control-dominated workloads and reducing pollution for streaming phases. The streaming detector monitors monotonic address strides per set and triggers bypass or distant insertion when streaming is detected. This hybrid approach leverages PC signatures for reuse, dead block prediction for early eviction, and DIP for adaptive insertion, resulting in improved performance across diverse workloads. Metadata: 6-bit PC signature + 2-bit outcome + 2-bit dead block counter per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/017_00_ship_lite_with_dead_block_prediction_and_dip_streaming_bypass__ship_lite_dbp_dip_sb_t02.cc,0.107529405,0.107529405,0%
1529,mcf,SHiP-Lite with Dead Block Prediction and DIP Streaming Bypass (SHiP-Lite-DBP-DIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with per-block dead block prediction and a DIP-style (LIP/BIP) insertion depth controller, augmented by a streaming bypass mechanism. Each cache block tracks a 2-bit dead block counter that is periodically decayed, allowing the policy to identify lines that are likely dead-on-arrival and bias their insertion depth or bypass them. DIP set-dueling dynamically chooses between LIP (always insert at LRU) and BIP (insert at MRU with low probability) to adapt to phase changes, improving retention for control-dominated workloads and reducing pollution for streaming phases. The streaming detector monitors monotonic address strides per set and triggers bypass or distant insertion when streaming is detected. This hybrid approach leverages PC signatures for reuse, dead block prediction for early eviction, and DIP for adaptive insertion, resulting in improved performance across diverse workloads. Metadata: 6-bit PC signature + 2-bit outcome + 2-bit dead block counter per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/017_00_ship_lite_with_dead_block_prediction_and_dip_streaming_bypass__ship_lite_dbp_dip_sb_t02.cc,0.514708664,0.514708664,0%
1530,milc,SHiP-Lite with Dead Block Prediction and DIP Streaming Bypass (SHiP-Lite-DBP-DIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with per-block dead block prediction and a DIP-style (LIP/BIP) insertion depth controller, augmented by a streaming bypass mechanism. Each cache block tracks a 2-bit dead block counter that is periodically decayed, allowing the policy to identify lines that are likely dead-on-arrival and bias their insertion depth or bypass them. DIP set-dueling dynamically chooses between LIP (always insert at LRU) and BIP (insert at MRU with low probability) to adapt to phase changes, improving retention for control-dominated workloads and reducing pollution for streaming phases. The streaming detector monitors monotonic address strides per set and triggers bypass or distant insertion when streaming is detected. This hybrid approach leverages PC signatures for reuse, dead block prediction for early eviction, and DIP for adaptive insertion, resulting in improved performance across diverse workloads. Metadata: 6-bit PC signature + 2-bit outcome + 2-bit dead block counter per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/017_00_ship_lite_with_dead_block_prediction_and_dip_streaming_bypass__ship_lite_dbp_dip_sb_t02.cc,0.01012875,0.01012875,0%
1531,omnetpp,SHiP-Lite with Dead Block Prediction and DIP Streaming Bypass (SHiP-Lite-DBP-DIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with per-block dead block prediction and a DIP-style (LIP/BIP) insertion depth controller, augmented by a streaming bypass mechanism. Each cache block tracks a 2-bit dead block counter that is periodically decayed, allowing the policy to identify lines that are likely dead-on-arrival and bias their insertion depth or bypass them. DIP set-dueling dynamically chooses between LIP (always insert at LRU) and BIP (insert at MRU with low probability) to adapt to phase changes, improving retention for control-dominated workloads and reducing pollution for streaming phases. The streaming detector monitors monotonic address strides per set and triggers bypass or distant insertion when streaming is detected. This hybrid approach leverages PC signatures for reuse, dead block prediction for early eviction, and DIP for adaptive insertion, resulting in improved performance across diverse workloads. Metadata: 6-bit PC signature + 2-bit outcome + 2-bit dead block counter per block, 10-bit PSEL, 64 leader set bits, and per-set streaming state—well within 64 KiB.",,ChampSim_CRC2/new_policies/017_00_ship_lite_with_dead_block_prediction_and_dip_streaming_bypass__ship_lite_dbp_dip_sb_t02.cc,0.010611456,0.010611456,0%
1532,astar,SHiP-Lite-LIP with Streaming Dead-Block Bypass (SHiP-Lite-LIP-SDB),"SHiP-Lite-LIP-SDB combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy, using set-dueling to dynamically choose between LIP (always insert at LRU) and BIP (insert at MRU with low probability). Critically, it introduces a per-block dead-block counter (2 bits) that approximates block reusability: blocks not reused before eviction are flagged as ""dead,"" and their PC signatures are penalized in the SHiP table. A compact streaming detector tracks monotonic address strides per set; when streaming is detected, blocks are bypassed entirely unless their PC signature is ""hot"" or their dead-block counter is low. This design improves performance by aggressively filtering streaming and dead-on-arrival blocks, while dynamically adapting insertion depth to workload phase changes. Metadata fits within 64 KiB: 6-bit PC signature + 2-bit dead-block counter per block, 2-bit outcome per SHiP table entry, 2-bit DIP PSEL, 64 leader set bits, and per-set streaming state.",,ChampSim_CRC2/new_policies/017_01_ship_lite_lip_with_streaming_dead_block_bypass__ship_lite_lip_sdb_t04.cc,0.459908184,0.459908184,0%
1533,lbm,SHiP-Lite-LIP with Streaming Dead-Block Bypass (SHiP-Lite-LIP-SDB),"SHiP-Lite-LIP-SDB combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy, using set-dueling to dynamically choose between LIP (always insert at LRU) and BIP (insert at MRU with low probability). Critically, it introduces a per-block dead-block counter (2 bits) that approximates block reusability: blocks not reused before eviction are flagged as ""dead,"" and their PC signatures are penalized in the SHiP table. A compact streaming detector tracks monotonic address strides per set; when streaming is detected, blocks are bypassed entirely unless their PC signature is ""hot"" or their dead-block counter is low. This design improves performance by aggressively filtering streaming and dead-on-arrival blocks, while dynamically adapting insertion depth to workload phase changes. Metadata fits within 64 KiB: 6-bit PC signature + 2-bit dead-block counter per block, 2-bit outcome per SHiP table entry, 2-bit DIP PSEL, 64 leader set bits, and per-set streaming state.",,ChampSim_CRC2/new_policies/017_01_ship_lite_lip_with_streaming_dead_block_bypass__ship_lite_lip_sdb_t04.cc,0.227423698,0.227423698,0%
1534,mcf,SHiP-Lite-LIP with Streaming Dead-Block Bypass (SHiP-Lite-LIP-SDB),"SHiP-Lite-LIP-SDB combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy, using set-dueling to dynamically choose between LIP (always insert at LRU) and BIP (insert at MRU with low probability). Critically, it introduces a per-block dead-block counter (2 bits) that approximates block reusability: blocks not reused before eviction are flagged as ""dead,"" and their PC signatures are penalized in the SHiP table. A compact streaming detector tracks monotonic address strides per set; when streaming is detected, blocks are bypassed entirely unless their PC signature is ""hot"" or their dead-block counter is low. This design improves performance by aggressively filtering streaming and dead-on-arrival blocks, while dynamically adapting insertion depth to workload phase changes. Metadata fits within 64 KiB: 6-bit PC signature + 2-bit dead-block counter per block, 2-bit outcome per SHiP table entry, 2-bit DIP PSEL, 64 leader set bits, and per-set streaming state.",,ChampSim_CRC2/new_policies/017_01_ship_lite_lip_with_streaming_dead_block_bypass__ship_lite_lip_sdb_t04.cc,0.40299989,0.40299989,0%
1535,milc,SHiP-Lite-LIP with Streaming Dead-Block Bypass (SHiP-Lite-LIP-SDB),"SHiP-Lite-LIP-SDB combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy, using set-dueling to dynamically choose between LIP (always insert at LRU) and BIP (insert at MRU with low probability). Critically, it introduces a per-block dead-block counter (2 bits) that approximates block reusability: blocks not reused before eviction are flagged as ""dead,"" and their PC signatures are penalized in the SHiP table. A compact streaming detector tracks monotonic address strides per set; when streaming is detected, blocks are bypassed entirely unless their PC signature is ""hot"" or their dead-block counter is low. This design improves performance by aggressively filtering streaming and dead-on-arrival blocks, while dynamically adapting insertion depth to workload phase changes. Metadata fits within 64 KiB: 6-bit PC signature + 2-bit dead-block counter per block, 2-bit outcome per SHiP table entry, 2-bit DIP PSEL, 64 leader set bits, and per-set streaming state.",,ChampSim_CRC2/new_policies/017_01_ship_lite_lip_with_streaming_dead_block_bypass__ship_lite_lip_sdb_t04.cc,0.013801893,0.013801893,0%
1536,omnetpp,SHiP-Lite-LIP with Streaming Dead-Block Bypass (SHiP-Lite-LIP-SDB),"SHiP-Lite-LIP-SDB combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy, using set-dueling to dynamically choose between LIP (always insert at LRU) and BIP (insert at MRU with low probability). Critically, it introduces a per-block dead-block counter (2 bits) that approximates block reusability: blocks not reused before eviction are flagged as ""dead,"" and their PC signatures are penalized in the SHiP table. A compact streaming detector tracks monotonic address strides per set; when streaming is detected, blocks are bypassed entirely unless their PC signature is ""hot"" or their dead-block counter is low. This design improves performance by aggressively filtering streaming and dead-on-arrival blocks, while dynamically adapting insertion depth to workload phase changes. Metadata fits within 64 KiB: 6-bit PC signature + 2-bit dead-block counter per block, 2-bit outcome per SHiP table entry, 2-bit DIP PSEL, 64 leader set bits, and per-set streaming state.",,ChampSim_CRC2/new_policies/017_01_ship_lite_lip_with_streaming_dead_block_bypass__ship_lite_lip_sdb_t04.cc,0.397671353,0.397671353,0%
1537,astar,DIP-SHiP Hybrid with Dead-Block Decay (DIP-SHiP-DBD),"DIP-SHiP-DBD blends DIP’s lightweight set-dueling between LIP and BIP insertion policies with SHiP-lite’s 6-bit PC signature-based reuse prediction and per-block dead-block approximation using 1-bit reuse counters. Instead of a streaming detector, it leverages periodic decay of reuse counters to approximate dead-on-arrival blocks, bypassing cache insertion for lines that show repeated non-reuse. Upon insertion, PC-based prediction biases insertion depth: “hot” signatures are inserted at MRU, while “cold” use the current DIP-selected policy (LIP/BIP). Per-block reuse counters are reset on hits and decayed every N accesses to quickly identify dead regions, mitigating cache pollution from pointer-chasing and streaming phases (e.g., mcf, lbm). DIP set-dueling with a 10-bit PSEL selector adapts insertion policy to phase changes in workloads, balancing between retaining useful lines and minimizing dead blocks. Metadata fits within 64 KiB: 6-bit PC sig + 1-bit reuse per block, 2-bit PSEL, 64 leader set bits, and 64-entry SHiP table (2 bits per sig).",,ChampSim_CRC2/new_policies/017_02_dip_ship_hybrid_with_dead_block_decay__dip_ship_dbd_t07.cc,0.022336446,0.022336446,0%
1538,lbm,DIP-SHiP Hybrid with Dead-Block Decay (DIP-SHiP-DBD),"DIP-SHiP-DBD blends DIP’s lightweight set-dueling between LIP and BIP insertion policies with SHiP-lite’s 6-bit PC signature-based reuse prediction and per-block dead-block approximation using 1-bit reuse counters. Instead of a streaming detector, it leverages periodic decay of reuse counters to approximate dead-on-arrival blocks, bypassing cache insertion for lines that show repeated non-reuse. Upon insertion, PC-based prediction biases insertion depth: “hot” signatures are inserted at MRU, while “cold” use the current DIP-selected policy (LIP/BIP). Per-block reuse counters are reset on hits and decayed every N accesses to quickly identify dead regions, mitigating cache pollution from pointer-chasing and streaming phases (e.g., mcf, lbm). DIP set-dueling with a 10-bit PSEL selector adapts insertion policy to phase changes in workloads, balancing between retaining useful lines and minimizing dead blocks. Metadata fits within 64 KiB: 6-bit PC sig + 1-bit reuse per block, 2-bit PSEL, 64 leader set bits, and 64-entry SHiP table (2 bits per sig).",,ChampSim_CRC2/new_policies/017_02_dip_ship_hybrid_with_dead_block_decay__dip_ship_dbd_t07.cc,0.034156136,0.034156136,0%
1539,mcf,DIP-SHiP Hybrid with Dead-Block Decay (DIP-SHiP-DBD),"DIP-SHiP-DBD blends DIP’s lightweight set-dueling between LIP and BIP insertion policies with SHiP-lite’s 6-bit PC signature-based reuse prediction and per-block dead-block approximation using 1-bit reuse counters. Instead of a streaming detector, it leverages periodic decay of reuse counters to approximate dead-on-arrival blocks, bypassing cache insertion for lines that show repeated non-reuse. Upon insertion, PC-based prediction biases insertion depth: “hot” signatures are inserted at MRU, while “cold” use the current DIP-selected policy (LIP/BIP). Per-block reuse counters are reset on hits and decayed every N accesses to quickly identify dead regions, mitigating cache pollution from pointer-chasing and streaming phases (e.g., mcf, lbm). DIP set-dueling with a 10-bit PSEL selector adapts insertion policy to phase changes in workloads, balancing between retaining useful lines and minimizing dead blocks. Metadata fits within 64 KiB: 6-bit PC sig + 1-bit reuse per block, 2-bit PSEL, 64 leader set bits, and 64-entry SHiP table (2 bits per sig).",,ChampSim_CRC2/new_policies/017_02_dip_ship_hybrid_with_dead_block_decay__dip_ship_dbd_t07.cc,0.070344035,0.070344035,0%
1540,milc,DIP-SHiP Hybrid with Dead-Block Decay (DIP-SHiP-DBD),"DIP-SHiP-DBD blends DIP’s lightweight set-dueling between LIP and BIP insertion policies with SHiP-lite’s 6-bit PC signature-based reuse prediction and per-block dead-block approximation using 1-bit reuse counters. Instead of a streaming detector, it leverages periodic decay of reuse counters to approximate dead-on-arrival blocks, bypassing cache insertion for lines that show repeated non-reuse. Upon insertion, PC-based prediction biases insertion depth: “hot” signatures are inserted at MRU, while “cold” use the current DIP-selected policy (LIP/BIP). Per-block reuse counters are reset on hits and decayed every N accesses to quickly identify dead regions, mitigating cache pollution from pointer-chasing and streaming phases (e.g., mcf, lbm). DIP set-dueling with a 10-bit PSEL selector adapts insertion policy to phase changes in workloads, balancing between retaining useful lines and minimizing dead blocks. Metadata fits within 64 KiB: 6-bit PC sig + 1-bit reuse per block, 2-bit PSEL, 64 leader set bits, and 64-entry SHiP table (2 bits per sig).",,ChampSim_CRC2/new_policies/017_02_dip_ship_hybrid_with_dead_block_decay__dip_ship_dbd_t07.cc,0.012846043,0.012846043,0%
1541,omnetpp,DIP-SHiP Hybrid with Dead-Block Decay (DIP-SHiP-DBD),"DIP-SHiP-DBD blends DIP’s lightweight set-dueling between LIP and BIP insertion policies with SHiP-lite’s 6-bit PC signature-based reuse prediction and per-block dead-block approximation using 1-bit reuse counters. Instead of a streaming detector, it leverages periodic decay of reuse counters to approximate dead-on-arrival blocks, bypassing cache insertion for lines that show repeated non-reuse. Upon insertion, PC-based prediction biases insertion depth: “hot” signatures are inserted at MRU, while “cold” use the current DIP-selected policy (LIP/BIP). Per-block reuse counters are reset on hits and decayed every N accesses to quickly identify dead regions, mitigating cache pollution from pointer-chasing and streaming phases (e.g., mcf, lbm). DIP set-dueling with a 10-bit PSEL selector adapts insertion policy to phase changes in workloads, balancing between retaining useful lines and minimizing dead blocks. Metadata fits within 64 KiB: 6-bit PC sig + 1-bit reuse per block, 2-bit PSEL, 64 leader set bits, and 64-entry SHiP table (2 bits per sig).",,ChampSim_CRC2/new_policies/017_02_dip_ship_hybrid_with_dead_block_decay__dip_ship_dbd_t07.cc,0.002892949,0.002892949,0%
1542,all,SHiP-Lite-LIP with Streaming Dead-Block Bypass (SHiP-Lite-LIP-SDB),"SHiP-Lite-LIP-SDB combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy, using set-dueling to dynamically choose between LIP (always insert at LRU) and BIP (insert at MRU with low probability). Critically, it introduces a per-block dead-block counter (2 bits) that approximates block reusability: blocks not reused before eviction are flagged as ""dead,"" and their PC signatures are penalized in the SHiP table. A compact streaming detector tracks monotonic address strides per set; when streaming is detected, blocks are bypassed entirely unless their PC signature is ""hot"" or their dead-block counter is low. This design improves performance by aggressively filtering streaming and dead-on-arrival blocks, while dynamically adapting insertion depth to workload phase changes. Metadata fits within 64 KiB: 6-bit PC signature + 2-bit dead-block counter per block, 2-bit outcome per SHiP table entry, 2-bit DIP PSEL, 64 leader set bits, and per-set streaming state.",,ChampSim_CRC2/new_policies/017_01_ship_lite_lip_with_streaming_dead_block_bypass__ship_lite_lip_sdb_t04.cc,0.300361004,0.300361004,30%
1543,astar,SRRIP-PC-Streaming Hybrid (SRRIP-PCS),"SRRIP-PCS combines classic SRRIP (Static RRIP) insertion depth control with a compact PC-based streaming detector to adaptively bypass cache lines likely to be dead-on-arrival. Instead of using SHiP's PC signature table, it maintains a 4-bit streaming score per PC (indexed by a 64-entry table), incremented when accesses from a PC show monotonic strides and decremented otherwise. When a PC's streaming score is high, blocks from that PC are inserted at distant RRPV (max) or bypassed entirely. Otherwise, blocks are inserted at SRRIP's default depth (RRPV=2). This mechanism allows the policy to aggressively filter streaming accesses (LBM, mcf, omnetpp) while retaining blocks from PCs with proven reuse (astar, milc). The metadata fits within 64 KiB: 4-bit streaming score per PC (64 entries), 2-bit RRPV per block, and per-set last address/stride for streaming detection. The policy is materially different from SHiP-Lite-LIP-SDB by changing the prediction source (streaming score per PC, not outcome), insertion depth (SRRIP, not DIP), and bypass logic (PC streaming, not per-set).",,ChampSim_CRC2/new_policies/018_01_srrip_pc_streaming_hybrid__srrip_pcs_t04.cc,0.433293704,0.433293704,0%
1544,lbm,SRRIP-PC-Streaming Hybrid (SRRIP-PCS),"SRRIP-PCS combines classic SRRIP (Static RRIP) insertion depth control with a compact PC-based streaming detector to adaptively bypass cache lines likely to be dead-on-arrival. Instead of using SHiP's PC signature table, it maintains a 4-bit streaming score per PC (indexed by a 64-entry table), incremented when accesses from a PC show monotonic strides and decremented otherwise. When a PC's streaming score is high, blocks from that PC are inserted at distant RRPV (max) or bypassed entirely. Otherwise, blocks are inserted at SRRIP's default depth (RRPV=2). This mechanism allows the policy to aggressively filter streaming accesses (LBM, mcf, omnetpp) while retaining blocks from PCs with proven reuse (astar, milc). The metadata fits within 64 KiB: 4-bit streaming score per PC (64 entries), 2-bit RRPV per block, and per-set last address/stride for streaming detection. The policy is materially different from SHiP-Lite-LIP-SDB by changing the prediction source (streaming score per PC, not outcome), insertion depth (SRRIP, not DIP), and bypass logic (PC streaming, not per-set).",,ChampSim_CRC2/new_policies/018_01_srrip_pc_streaming_hybrid__srrip_pcs_t04.cc,0.413577291,0.413577291,0%
1545,mcf,SRRIP-PC-Streaming Hybrid (SRRIP-PCS),"SRRIP-PCS combines classic SRRIP (Static RRIP) insertion depth control with a compact PC-based streaming detector to adaptively bypass cache lines likely to be dead-on-arrival. Instead of using SHiP's PC signature table, it maintains a 4-bit streaming score per PC (indexed by a 64-entry table), incremented when accesses from a PC show monotonic strides and decremented otherwise. When a PC's streaming score is high, blocks from that PC are inserted at distant RRPV (max) or bypassed entirely. Otherwise, blocks are inserted at SRRIP's default depth (RRPV=2). This mechanism allows the policy to aggressively filter streaming accesses (LBM, mcf, omnetpp) while retaining blocks from PCs with proven reuse (astar, milc). The metadata fits within 64 KiB: 4-bit streaming score per PC (64 entries), 2-bit RRPV per block, and per-set last address/stride for streaming detection. The policy is materially different from SHiP-Lite-LIP-SDB by changing the prediction source (streaming score per PC, not outcome), insertion depth (SRRIP, not DIP), and bypass logic (PC streaming, not per-set).",,ChampSim_CRC2/new_policies/018_01_srrip_pc_streaming_hybrid__srrip_pcs_t04.cc,0.461048695,0.461048695,0%
1546,milc,SRRIP-PC-Streaming Hybrid (SRRIP-PCS),"SRRIP-PCS combines classic SRRIP (Static RRIP) insertion depth control with a compact PC-based streaming detector to adaptively bypass cache lines likely to be dead-on-arrival. Instead of using SHiP's PC signature table, it maintains a 4-bit streaming score per PC (indexed by a 64-entry table), incremented when accesses from a PC show monotonic strides and decremented otherwise. When a PC's streaming score is high, blocks from that PC are inserted at distant RRPV (max) or bypassed entirely. Otherwise, blocks are inserted at SRRIP's default depth (RRPV=2). This mechanism allows the policy to aggressively filter streaming accesses (LBM, mcf, omnetpp) while retaining blocks from PCs with proven reuse (astar, milc). The metadata fits within 64 KiB: 4-bit streaming score per PC (64 entries), 2-bit RRPV per block, and per-set last address/stride for streaming detection. The policy is materially different from SHiP-Lite-LIP-SDB by changing the prediction source (streaming score per PC, not outcome), insertion depth (SRRIP, not DIP), and bypass logic (PC streaming, not per-set).",,ChampSim_CRC2/new_policies/018_01_srrip_pc_streaming_hybrid__srrip_pcs_t04.cc,0.311254046,0.311254046,0%
1547,omnetpp,SRRIP-PC-Streaming Hybrid (SRRIP-PCS),"SRRIP-PCS combines classic SRRIP (Static RRIP) insertion depth control with a compact PC-based streaming detector to adaptively bypass cache lines likely to be dead-on-arrival. Instead of using SHiP's PC signature table, it maintains a 4-bit streaming score per PC (indexed by a 64-entry table), incremented when accesses from a PC show monotonic strides and decremented otherwise. When a PC's streaming score is high, blocks from that PC are inserted at distant RRPV (max) or bypassed entirely. Otherwise, blocks are inserted at SRRIP's default depth (RRPV=2). This mechanism allows the policy to aggressively filter streaming accesses (LBM, mcf, omnetpp) while retaining blocks from PCs with proven reuse (astar, milc). The metadata fits within 64 KiB: 4-bit streaming score per PC (64 entries), 2-bit RRPV per block, and per-set last address/stride for streaming detection. The policy is materially different from SHiP-Lite-LIP-SDB by changing the prediction source (streaming score per PC, not outcome), insertion depth (SRRIP, not DIP), and bypass logic (PC streaming, not per-set).",,ChampSim_CRC2/new_policies/018_01_srrip_pc_streaming_hybrid__srrip_pcs_t04.cc,0.453173557,0.453173557,0%
1548,astar,SRRIP-X: PC-Temporal Adaptive Replacement with Lightweight Streaming Bypass,"SRRIP-X combines a PC-temporal signature predictor with SRRIP/BRRIP set-dueling to adapt insertion depth and bypass logic. Instead of only using the PC, it hashes both PC and recent access timestamp (low bits of cycle count) into a compact signature (6 bits), which allows the policy to distinguish phase changes and temporal locality. It maintains a 2-bit outcome counter per signature that guides insertion depth: blocks with ""hot"" signatures (counter ≥ 2) are inserted at MRU (RRPV=0), otherwise at distant RRPV (2/3). Streaming detection uses a 2-bit stride monotonicity counter per set, and when streaming is detected, all blocks except those with ""hot"" signatures are bypassed (not inserted). Set-dueling between SRRIP (standard distant insert) and BRRIP (rare MRU insert) is managed with 32 leader sets and a 10-bit PSEL to track global best policy. The combination of temporal-PC signatures and adaptive insertion/bypass logic improves reuse capture for control/phase-dominated workloads (astar, milc, omnetpp) while mitigating cache pollution and streaming misses in regular-access workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 10-bit PSEL.",,ChampSim_CRC2/new_policies/018_02_srrip_x__pc_temporal_adaptive_replacement_with_lightweight_streaming_bypass_t07.cc,0.434577386,0.434577386,0%
1549,lbm,SRRIP-X: PC-Temporal Adaptive Replacement with Lightweight Streaming Bypass,"SRRIP-X combines a PC-temporal signature predictor with SRRIP/BRRIP set-dueling to adapt insertion depth and bypass logic. Instead of only using the PC, it hashes both PC and recent access timestamp (low bits of cycle count) into a compact signature (6 bits), which allows the policy to distinguish phase changes and temporal locality. It maintains a 2-bit outcome counter per signature that guides insertion depth: blocks with ""hot"" signatures (counter ≥ 2) are inserted at MRU (RRPV=0), otherwise at distant RRPV (2/3). Streaming detection uses a 2-bit stride monotonicity counter per set, and when streaming is detected, all blocks except those with ""hot"" signatures are bypassed (not inserted). Set-dueling between SRRIP (standard distant insert) and BRRIP (rare MRU insert) is managed with 32 leader sets and a 10-bit PSEL to track global best policy. The combination of temporal-PC signatures and adaptive insertion/bypass logic improves reuse capture for control/phase-dominated workloads (astar, milc, omnetpp) while mitigating cache pollution and streaming misses in regular-access workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 10-bit PSEL.",,ChampSim_CRC2/new_policies/018_02_srrip_x__pc_temporal_adaptive_replacement_with_lightweight_streaming_bypass_t07.cc,0.413251778,0.413251778,0%
1550,mcf,SRRIP-X: PC-Temporal Adaptive Replacement with Lightweight Streaming Bypass,"SRRIP-X combines a PC-temporal signature predictor with SRRIP/BRRIP set-dueling to adapt insertion depth and bypass logic. Instead of only using the PC, it hashes both PC and recent access timestamp (low bits of cycle count) into a compact signature (6 bits), which allows the policy to distinguish phase changes and temporal locality. It maintains a 2-bit outcome counter per signature that guides insertion depth: blocks with ""hot"" signatures (counter ≥ 2) are inserted at MRU (RRPV=0), otherwise at distant RRPV (2/3). Streaming detection uses a 2-bit stride monotonicity counter per set, and when streaming is detected, all blocks except those with ""hot"" signatures are bypassed (not inserted). Set-dueling between SRRIP (standard distant insert) and BRRIP (rare MRU insert) is managed with 32 leader sets and a 10-bit PSEL to track global best policy. The combination of temporal-PC signatures and adaptive insertion/bypass logic improves reuse capture for control/phase-dominated workloads (astar, milc, omnetpp) while mitigating cache pollution and streaming misses in regular-access workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 10-bit PSEL.",,ChampSim_CRC2/new_policies/018_02_srrip_x__pc_temporal_adaptive_replacement_with_lightweight_streaming_bypass_t07.cc,0.431524602,0.431524602,0%
1551,milc,SRRIP-X: PC-Temporal Adaptive Replacement with Lightweight Streaming Bypass,"SRRIP-X combines a PC-temporal signature predictor with SRRIP/BRRIP set-dueling to adapt insertion depth and bypass logic. Instead of only using the PC, it hashes both PC and recent access timestamp (low bits of cycle count) into a compact signature (6 bits), which allows the policy to distinguish phase changes and temporal locality. It maintains a 2-bit outcome counter per signature that guides insertion depth: blocks with ""hot"" signatures (counter ≥ 2) are inserted at MRU (RRPV=0), otherwise at distant RRPV (2/3). Streaming detection uses a 2-bit stride monotonicity counter per set, and when streaming is detected, all blocks except those with ""hot"" signatures are bypassed (not inserted). Set-dueling between SRRIP (standard distant insert) and BRRIP (rare MRU insert) is managed with 32 leader sets and a 10-bit PSEL to track global best policy. The combination of temporal-PC signatures and adaptive insertion/bypass logic improves reuse capture for control/phase-dominated workloads (astar, milc, omnetpp) while mitigating cache pollution and streaming misses in regular-access workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 10-bit PSEL.",,ChampSim_CRC2/new_policies/018_02_srrip_x__pc_temporal_adaptive_replacement_with_lightweight_streaming_bypass_t07.cc,0.308712354,0.308712354,0%
1552,omnetpp,SRRIP-X: PC-Temporal Adaptive Replacement with Lightweight Streaming Bypass,"SRRIP-X combines a PC-temporal signature predictor with SRRIP/BRRIP set-dueling to adapt insertion depth and bypass logic. Instead of only using the PC, it hashes both PC and recent access timestamp (low bits of cycle count) into a compact signature (6 bits), which allows the policy to distinguish phase changes and temporal locality. It maintains a 2-bit outcome counter per signature that guides insertion depth: blocks with ""hot"" signatures (counter ≥ 2) are inserted at MRU (RRPV=0), otherwise at distant RRPV (2/3). Streaming detection uses a 2-bit stride monotonicity counter per set, and when streaming is detected, all blocks except those with ""hot"" signatures are bypassed (not inserted). Set-dueling between SRRIP (standard distant insert) and BRRIP (rare MRU insert) is managed with 32 leader sets and a 10-bit PSEL to track global best policy. The combination of temporal-PC signatures and adaptive insertion/bypass logic improves reuse capture for control/phase-dominated workloads (astar, milc, omnetpp) while mitigating cache pollution and streaming misses in regular-access workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 10-bit PSEL.",,ChampSim_CRC2/new_policies/018_02_srrip_x__pc_temporal_adaptive_replacement_with_lightweight_streaming_bypass_t07.cc,0.631227968,0.631227968,0%
1553,all,SRRIP-X: PC-Temporal Adaptive Replacement with Lightweight Streaming Bypass,"SRRIP-X combines a PC-temporal signature predictor with SRRIP/BRRIP set-dueling to adapt insertion depth and bypass logic. Instead of only using the PC, it hashes both PC and recent access timestamp (low bits of cycle count) into a compact signature (6 bits), which allows the policy to distinguish phase changes and temporal locality. It maintains a 2-bit outcome counter per signature that guides insertion depth: blocks with ""hot"" signatures (counter ≥ 2) are inserted at MRU (RRPV=0), otherwise at distant RRPV (2/3). Streaming detection uses a 2-bit stride monotonicity counter per set, and when streaming is detected, all blocks except those with ""hot"" signatures are bypassed (not inserted). Set-dueling between SRRIP (standard distant insert) and BRRIP (rare MRU insert) is managed with 32 leader sets and a 10-bit PSEL to track global best policy. The combination of temporal-PC signatures and adaptive insertion/bypass logic improves reuse capture for control/phase-dominated workloads (astar, milc, omnetpp) while mitigating cache pollution and streaming misses in regular-access workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 10-bit PSEL.",,ChampSim_CRC2/new_policies/018_02_srrip_x__pc_temporal_adaptive_replacement_with_lightweight_streaming_bypass_t07.cc,0.443858818,0.443858818,44%
1554,astar,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with per-block dead-block approximation and a streaming bypass detector. On each insertion, the policy consults both the SHiP outcome and a tiny per-block reuse counter: blocks with ""hot"" signatures or recent reuse are inserted at MRU (RRPV=0), while others are inserted at distant RRPV (2). Streaming sets (detected via monotonic stride counter) bypass all blocks except those with hot signatures or recent reuse. Dead-block counters are periodically decayed to avoid stale reuse bias. This hybrid approach improves performance by capturing both control-flow reuse (astar, milc, omnetpp) and irregular pointer-chasing (mcf), while aggressively bypassing streaming pollution in regular workloads (lbm). Metadata fits within 64 KiB: 6-bit signatures, 2-bit SHiP counters, 2-bit dead-block counters per line, 2-bit streaming counters per set, and 10-bit PSEL for SRRIP/BRRIP set-dueling.",,ChampSim_CRC2/new_policies/019_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.429929021,0.429929021,0%
1555,lbm,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with per-block dead-block approximation and a streaming bypass detector. On each insertion, the policy consults both the SHiP outcome and a tiny per-block reuse counter: blocks with ""hot"" signatures or recent reuse are inserted at MRU (RRPV=0), while others are inserted at distant RRPV (2). Streaming sets (detected via monotonic stride counter) bypass all blocks except those with hot signatures or recent reuse. Dead-block counters are periodically decayed to avoid stale reuse bias. This hybrid approach improves performance by capturing both control-flow reuse (astar, milc, omnetpp) and irregular pointer-chasing (mcf), while aggressively bypassing streaming pollution in regular workloads (lbm). Metadata fits within 64 KiB: 6-bit signatures, 2-bit SHiP counters, 2-bit dead-block counters per line, 2-bit streaming counters per set, and 10-bit PSEL for SRRIP/BRRIP set-dueling.",,ChampSim_CRC2/new_policies/019_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.413282841,0.413282841,0%
1556,mcf,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with per-block dead-block approximation and a streaming bypass detector. On each insertion, the policy consults both the SHiP outcome and a tiny per-block reuse counter: blocks with ""hot"" signatures or recent reuse are inserted at MRU (RRPV=0), while others are inserted at distant RRPV (2). Streaming sets (detected via monotonic stride counter) bypass all blocks except those with hot signatures or recent reuse. Dead-block counters are periodically decayed to avoid stale reuse bias. This hybrid approach improves performance by capturing both control-flow reuse (astar, milc, omnetpp) and irregular pointer-chasing (mcf), while aggressively bypassing streaming pollution in regular workloads (lbm). Metadata fits within 64 KiB: 6-bit signatures, 2-bit SHiP counters, 2-bit dead-block counters per line, 2-bit streaming counters per set, and 10-bit PSEL for SRRIP/BRRIP set-dueling.",,ChampSim_CRC2/new_policies/019_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.465470138,0.465470138,0%
1557,milc,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with per-block dead-block approximation and a streaming bypass detector. On each insertion, the policy consults both the SHiP outcome and a tiny per-block reuse counter: blocks with ""hot"" signatures or recent reuse are inserted at MRU (RRPV=0), while others are inserted at distant RRPV (2). Streaming sets (detected via monotonic stride counter) bypass all blocks except those with hot signatures or recent reuse. Dead-block counters are periodically decayed to avoid stale reuse bias. This hybrid approach improves performance by capturing both control-flow reuse (astar, milc, omnetpp) and irregular pointer-chasing (mcf), while aggressively bypassing streaming pollution in regular workloads (lbm). Metadata fits within 64 KiB: 6-bit signatures, 2-bit SHiP counters, 2-bit dead-block counters per line, 2-bit streaming counters per set, and 10-bit PSEL for SRRIP/BRRIP set-dueling.",,ChampSim_CRC2/new_policies/019_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.308612787,0.308612787,0%
1558,omnetpp,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with per-block dead-block approximation and a streaming bypass detector. On each insertion, the policy consults both the SHiP outcome and a tiny per-block reuse counter: blocks with ""hot"" signatures or recent reuse are inserted at MRU (RRPV=0), while others are inserted at distant RRPV (2). Streaming sets (detected via monotonic stride counter) bypass all blocks except those with hot signatures or recent reuse. Dead-block counters are periodically decayed to avoid stale reuse bias. This hybrid approach improves performance by capturing both control-flow reuse (astar, milc, omnetpp) and irregular pointer-chasing (mcf), while aggressively bypassing streaming pollution in regular workloads (lbm). Metadata fits within 64 KiB: 6-bit signatures, 2-bit SHiP counters, 2-bit dead-block counters per line, 2-bit streaming counters per set, and 10-bit PSEL for SRRIP/BRRIP set-dueling.",,ChampSim_CRC2/new_policies/019_00_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t02.cc,0.649241579,0.649241579,0%
1559,astar,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse flag), and a streaming detector for bypass. On insertion, the policy consults both the SHiP signature outcome and the dead-block flag: blocks predicted as ""dead"" (not reused in their last residency) are inserted at distant RRPV, while ""hot"" signatures and reused blocks are inserted at MRU. The streaming detector uses a 2-bit monotonicity counter per set to identify regular access patterns (as in LBM/mcf), and bypasses insertion for blocks with cold signatures during streaming phases. This hybrid approach improves prediction of block reuse for control/phase-dominated workloads (astar, milc, omnetpp) and reduces pollution from streaming or dead blocks in regular workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 1-bit dead-block flags per line.",,ChampSim_CRC2/new_policies/019_01_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t04.cc,0.450808126,0.450808126,0%
1560,lbm,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse flag), and a streaming detector for bypass. On insertion, the policy consults both the SHiP signature outcome and the dead-block flag: blocks predicted as ""dead"" (not reused in their last residency) are inserted at distant RRPV, while ""hot"" signatures and reused blocks are inserted at MRU. The streaming detector uses a 2-bit monotonicity counter per set to identify regular access patterns (as in LBM/mcf), and bypasses insertion for blocks with cold signatures during streaming phases. This hybrid approach improves prediction of block reuse for control/phase-dominated workloads (astar, milc, omnetpp) and reduces pollution from streaming or dead blocks in regular workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 1-bit dead-block flags per line.",,ChampSim_CRC2/new_policies/019_01_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t04.cc,0.431385054,0.431385054,0%
1561,mcf,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse flag), and a streaming detector for bypass. On insertion, the policy consults both the SHiP signature outcome and the dead-block flag: blocks predicted as ""dead"" (not reused in their last residency) are inserted at distant RRPV, while ""hot"" signatures and reused blocks are inserted at MRU. The streaming detector uses a 2-bit monotonicity counter per set to identify regular access patterns (as in LBM/mcf), and bypasses insertion for blocks with cold signatures during streaming phases. This hybrid approach improves prediction of block reuse for control/phase-dominated workloads (astar, milc, omnetpp) and reduces pollution from streaming or dead blocks in regular workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 1-bit dead-block flags per line.",,ChampSim_CRC2/new_policies/019_01_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t04.cc,0.428036239,0.428036239,0%
1562,milc,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse flag), and a streaming detector for bypass. On insertion, the policy consults both the SHiP signature outcome and the dead-block flag: blocks predicted as ""dead"" (not reused in their last residency) are inserted at distant RRPV, while ""hot"" signatures and reused blocks are inserted at MRU. The streaming detector uses a 2-bit monotonicity counter per set to identify regular access patterns (as in LBM/mcf), and bypasses insertion for blocks with cold signatures during streaming phases. This hybrid approach improves prediction of block reuse for control/phase-dominated workloads (astar, milc, omnetpp) and reduces pollution from streaming or dead blocks in regular workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 1-bit dead-block flags per line.",,ChampSim_CRC2/new_policies/019_01_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t04.cc,0.31032173,0.31032173,0%
1563,omnetpp,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"SHiP-DB-SB combines a SHiP-lite predictor (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse flag), and a streaming detector for bypass. On insertion, the policy consults both the SHiP signature outcome and the dead-block flag: blocks predicted as ""dead"" (not reused in their last residency) are inserted at distant RRPV, while ""hot"" signatures and reused blocks are inserted at MRU. The streaming detector uses a 2-bit monotonicity counter per set to identify regular access patterns (as in LBM/mcf), and bypasses insertion for blocks with cold signatures during streaming phases. This hybrid approach improves prediction of block reuse for control/phase-dominated workloads (astar, milc, omnetpp) and reduces pollution from streaming or dead blocks in regular workloads (lbm, mcf). Metadata fits within 64 KiB using 6-bit signatures, 2-bit outcome counters, 2-bit streaming counters, and 1-bit dead-block flags per line.",,ChampSim_CRC2/new_policies/019_01_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t04.cc,0.617455309,0.617455309,0%
1564,astar,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"This policy combines a classic SHiP-lite (Signature-based Hit Predictor) approach using a compact PC-only signature (5 bits, 32 entries) with per-block dead-block prediction and a streaming bypass detector. SHiP-lite tracks temporal reuse per PC signature: blocks from ""hot"" signatures (counter≥2) are inserted at MRU (RRPV=0), others at RRPV=2. In parallel, each cache block maintains a 2-bit dead-block counter (incremented on misses, reset on hits); blocks deemed ""dead"" (counter=3) are prioritized for eviction. Streaming is detected per-set via a lightweight stride monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (RRPV=3 on insert). This hybrid approach improves hit rates for control/phase-dominated workloads (astar, milc, omnetpp) by keeping hot blocks, reduces pollution on regular/streaming workloads (lbm, mcf) by discarding dead blocks and bypassing cold streams, and adapts to phase changes. Metadata fits within 64 KiB: 5-bit signature per block, 2-bit SHiP counter (32 entries), 2-bit dead-block counter per block, 2-bit monotonicity per set.",,ChampSim_CRC2/new_policies/019_02_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t07.cc,0.429758926,0.429758926,0%
1565,lbm,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"This policy combines a classic SHiP-lite (Signature-based Hit Predictor) approach using a compact PC-only signature (5 bits, 32 entries) with per-block dead-block prediction and a streaming bypass detector. SHiP-lite tracks temporal reuse per PC signature: blocks from ""hot"" signatures (counter≥2) are inserted at MRU (RRPV=0), others at RRPV=2. In parallel, each cache block maintains a 2-bit dead-block counter (incremented on misses, reset on hits); blocks deemed ""dead"" (counter=3) are prioritized for eviction. Streaming is detected per-set via a lightweight stride monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (RRPV=3 on insert). This hybrid approach improves hit rates for control/phase-dominated workloads (astar, milc, omnetpp) by keeping hot blocks, reduces pollution on regular/streaming workloads (lbm, mcf) by discarding dead blocks and bypassing cold streams, and adapts to phase changes. Metadata fits within 64 KiB: 5-bit signature per block, 2-bit SHiP counter (32 entries), 2-bit dead-block counter per block, 2-bit monotonicity per set.",,ChampSim_CRC2/new_policies/019_02_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t07.cc,0.412985715,0.412985715,0%
1566,mcf,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"This policy combines a classic SHiP-lite (Signature-based Hit Predictor) approach using a compact PC-only signature (5 bits, 32 entries) with per-block dead-block prediction and a streaming bypass detector. SHiP-lite tracks temporal reuse per PC signature: blocks from ""hot"" signatures (counter≥2) are inserted at MRU (RRPV=0), others at RRPV=2. In parallel, each cache block maintains a 2-bit dead-block counter (incremented on misses, reset on hits); blocks deemed ""dead"" (counter=3) are prioritized for eviction. Streaming is detected per-set via a lightweight stride monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (RRPV=3 on insert). This hybrid approach improves hit rates for control/phase-dominated workloads (astar, milc, omnetpp) by keeping hot blocks, reduces pollution on regular/streaming workloads (lbm, mcf) by discarding dead blocks and bypassing cold streams, and adapts to phase changes. Metadata fits within 64 KiB: 5-bit signature per block, 2-bit SHiP counter (32 entries), 2-bit dead-block counter per block, 2-bit monotonicity per set.",,ChampSim_CRC2/new_policies/019_02_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t07.cc,0.467728501,0.467728501,0%
1567,milc,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"This policy combines a classic SHiP-lite (Signature-based Hit Predictor) approach using a compact PC-only signature (5 bits, 32 entries) with per-block dead-block prediction and a streaming bypass detector. SHiP-lite tracks temporal reuse per PC signature: blocks from ""hot"" signatures (counter≥2) are inserted at MRU (RRPV=0), others at RRPV=2. In parallel, each cache block maintains a 2-bit dead-block counter (incremented on misses, reset on hits); blocks deemed ""dead"" (counter=3) are prioritized for eviction. Streaming is detected per-set via a lightweight stride monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (RRPV=3 on insert). This hybrid approach improves hit rates for control/phase-dominated workloads (astar, milc, omnetpp) by keeping hot blocks, reduces pollution on regular/streaming workloads (lbm, mcf) by discarding dead blocks and bypassing cold streams, and adapts to phase changes. Metadata fits within 64 KiB: 5-bit signature per block, 2-bit SHiP counter (32 entries), 2-bit dead-block counter per block, 2-bit monotonicity per set.",,ChampSim_CRC2/new_policies/019_02_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t07.cc,0.309371311,0.309371311,0%
1568,omnetpp,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"This policy combines a classic SHiP-lite (Signature-based Hit Predictor) approach using a compact PC-only signature (5 bits, 32 entries) with per-block dead-block prediction and a streaming bypass detector. SHiP-lite tracks temporal reuse per PC signature: blocks from ""hot"" signatures (counter≥2) are inserted at MRU (RRPV=0), others at RRPV=2. In parallel, each cache block maintains a 2-bit dead-block counter (incremented on misses, reset on hits); blocks deemed ""dead"" (counter=3) are prioritized for eviction. Streaming is detected per-set via a lightweight stride monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (RRPV=3 on insert). This hybrid approach improves hit rates for control/phase-dominated workloads (astar, milc, omnetpp) by keeping hot blocks, reduces pollution on regular/streaming workloads (lbm, mcf) by discarding dead blocks and bypassing cold streams, and adapts to phase changes. Metadata fits within 64 KiB: 5-bit signature per block, 2-bit SHiP counter (32 entries), 2-bit dead-block counter per block, 2-bit monotonicity per set.",,ChampSim_CRC2/new_policies/019_02_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t07.cc,0.672551908,0.672551908,0%
1569,all,SHiP-DeadBlock Hybrid with Streaming Bypass (SHiP-DB-SB),"This policy combines a classic SHiP-lite (Signature-based Hit Predictor) approach using a compact PC-only signature (5 bits, 32 entries) with per-block dead-block prediction and a streaming bypass detector. SHiP-lite tracks temporal reuse per PC signature: blocks from ""hot"" signatures (counter≥2) are inserted at MRU (RRPV=0), others at RRPV=2. In parallel, each cache block maintains a 2-bit dead-block counter (incremented on misses, reset on hits); blocks deemed ""dead"" (counter=3) are prioritized for eviction. Streaming is detected per-set via a lightweight stride monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (RRPV=3 on insert). This hybrid approach improves hit rates for control/phase-dominated workloads (astar, milc, omnetpp) by keeping hot blocks, reduces pollution on regular/streaming workloads (lbm, mcf) by discarding dead blocks and bypassing cold streams, and adapts to phase changes. Metadata fits within 64 KiB: 5-bit signature per block, 2-bit SHiP counter (32 entries), 2-bit dead-block counter per block, 2-bit monotonicity per set.",,ChampSim_CRC2/new_policies/019_02_ship_deadblock_hybrid_with_streaming_bypass__ship_db_sb_t07.cc,0.458479273,0.458479273,46%
1570,astar,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL selector and 32 leader sets, enabling robust adaptation to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for blocks from hot code paths. An adaptive streaming detector tracks monotonic strides per set and triggers bypass for cold signatures only when streaming is detected, reducing pollution in regular/streaming workloads (lbm, mcf) while retaining hot blocks for control/phase-dominated workloads (astar, milc, omnetpp). Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 32 leader set IDs, and 2-bit monotonicity per set, all fitting within 64 KiB. This design improves hit rates by combining adaptive insertion depth, code-based reuse prediction, and streaming-aware bypass.",,ChampSim_CRC2/new_policies/020_00_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t02.cc,0.295207055,0.295207055,0%
1571,lbm,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL selector and 32 leader sets, enabling robust adaptation to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for blocks from hot code paths. An adaptive streaming detector tracks monotonic strides per set and triggers bypass for cold signatures only when streaming is detected, reducing pollution in regular/streaming workloads (lbm, mcf) while retaining hot blocks for control/phase-dominated workloads (astar, milc, omnetpp). Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 32 leader set IDs, and 2-bit monotonicity per set, all fitting within 64 KiB. This design improves hit rates by combining adaptive insertion depth, code-based reuse prediction, and streaming-aware bypass.",,ChampSim_CRC2/new_policies/020_00_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t02.cc,0.160417262,0.160417262,0%
1572,mcf,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL selector and 32 leader sets, enabling robust adaptation to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for blocks from hot code paths. An adaptive streaming detector tracks monotonic strides per set and triggers bypass for cold signatures only when streaming is detected, reducing pollution in regular/streaming workloads (lbm, mcf) while retaining hot blocks for control/phase-dominated workloads (astar, milc, omnetpp). Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 32 leader set IDs, and 2-bit monotonicity per set, all fitting within 64 KiB. This design improves hit rates by combining adaptive insertion depth, code-based reuse prediction, and streaming-aware bypass.",,ChampSim_CRC2/new_policies/020_00_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t02.cc,0.461292797,0.461292797,0%
1573,milc,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL selector and 32 leader sets, enabling robust adaptation to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for blocks from hot code paths. An adaptive streaming detector tracks monotonic strides per set and triggers bypass for cold signatures only when streaming is detected, reducing pollution in regular/streaming workloads (lbm, mcf) while retaining hot blocks for control/phase-dominated workloads (astar, milc, omnetpp). Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 32 leader set IDs, and 2-bit monotonicity per set, all fitting within 64 KiB. This design improves hit rates by combining adaptive insertion depth, code-based reuse prediction, and streaming-aware bypass.",,ChampSim_CRC2/new_policies/020_00_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t02.cc,0.069034809,0.069034809,0%
1574,omnetpp,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy fuses DRRIP (Dynamic RRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using a 10-bit PSEL selector and 32 leader sets, enabling robust adaptation to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for blocks from hot code paths. An adaptive streaming detector tracks monotonic strides per set and triggers bypass for cold signatures only when streaming is detected, reducing pollution in regular/streaming workloads (lbm, mcf) while retaining hot blocks for control/phase-dominated workloads (astar, milc, omnetpp). Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 32 leader set IDs, and 2-bit monotonicity per set, all fitting within 64 KiB. This design improves hit rates by combining adaptive insertion depth, code-based reuse prediction, and streaming-aware bypass.",,ChampSim_CRC2/new_policies/020_00_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t02.cc,0.61231964,0.61231964,0%
1575,astar,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy integrates Dynamic RRIP (DRRIP) set-dueling with a streamlined SHiP-lite predictor and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using 64 leader sets and a 10-bit PSEL counter, adapting to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-dominated or phase-changing workloads. A per-set streaming detector tracks monotonic address strides, and if streaming is detected, blocks from cold signatures are bypassed (inserted at distant RRPV=3). This hybrid approach leverages DRRIP's global adaptability for regular/irregular workloads, SHiP's fine-grained reuse for control/phase workloads, and streaming bypass to reduce pollution for memory-bound or streaming workloads. Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 64 leader set markers, and 2-bit streaming counter per set—totaling under 64 KiB.",,ChampSim_CRC2/new_policies/020_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t04.cc,0.424568385,0.424568385,0%
1576,lbm,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy integrates Dynamic RRIP (DRRIP) set-dueling with a streamlined SHiP-lite predictor and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using 64 leader sets and a 10-bit PSEL counter, adapting to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-dominated or phase-changing workloads. A per-set streaming detector tracks monotonic address strides, and if streaming is detected, blocks from cold signatures are bypassed (inserted at distant RRPV=3). This hybrid approach leverages DRRIP's global adaptability for regular/irregular workloads, SHiP's fine-grained reuse for control/phase workloads, and streaming bypass to reduce pollution for memory-bound or streaming workloads. Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 64 leader set markers, and 2-bit streaming counter per set—totaling under 64 KiB.",,ChampSim_CRC2/new_policies/020_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t04.cc,0.383582358,0.383582358,0%
1577,mcf,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy integrates Dynamic RRIP (DRRIP) set-dueling with a streamlined SHiP-lite predictor and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using 64 leader sets and a 10-bit PSEL counter, adapting to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-dominated or phase-changing workloads. A per-set streaming detector tracks monotonic address strides, and if streaming is detected, blocks from cold signatures are bypassed (inserted at distant RRPV=3). This hybrid approach leverages DRRIP's global adaptability for regular/irregular workloads, SHiP's fine-grained reuse for control/phase workloads, and streaming bypass to reduce pollution for memory-bound or streaming workloads. Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 64 leader set markers, and 2-bit streaming counter per set—totaling under 64 KiB.",,ChampSim_CRC2/new_policies/020_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t04.cc,0.496717732,0.496717732,0%
1578,milc,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy integrates Dynamic RRIP (DRRIP) set-dueling with a streamlined SHiP-lite predictor and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using 64 leader sets and a 10-bit PSEL counter, adapting to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-dominated or phase-changing workloads. A per-set streaming detector tracks monotonic address strides, and if streaming is detected, blocks from cold signatures are bypassed (inserted at distant RRPV=3). This hybrid approach leverages DRRIP's global adaptability for regular/irregular workloads, SHiP's fine-grained reuse for control/phase workloads, and streaming bypass to reduce pollution for memory-bound or streaming workloads. Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 64 leader set markers, and 2-bit streaming counter per set—totaling under 64 KiB.",,ChampSim_CRC2/new_policies/020_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t04.cc,0.300716163,0.300716163,0%
1579,omnetpp,DRRIP-SHiP Hybrid with Adaptive Streaming Bypass (DRRIP-SHiP-ASB),"This policy integrates Dynamic RRIP (DRRIP) set-dueling with a streamlined SHiP-lite predictor and an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP and BRRIP insertion depths using 64 leader sets and a 10-bit PSEL counter, adapting to workload locality. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-dominated or phase-changing workloads. A per-set streaming detector tracks monotonic address strides, and if streaming is detected, blocks from cold signatures are bypassed (inserted at distant RRPV=3). This hybrid approach leverages DRRIP's global adaptability for regular/irregular workloads, SHiP's fine-grained reuse for control/phase workloads, and streaming bypass to reduce pollution for memory-bound or streaming workloads. Metadata is compact: 2-bit RRPV per block, 5-bit signature per block, 2-bit SHiP counter (32 entries), 10-bit PSEL, 64 leader set markers, and 2-bit streaming counter per set—totaling under 64 KiB.",,ChampSim_CRC2/new_policies/020_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__drrip_ship_asb_t04.cc,0.601756029,0.601756029,0%
1580,astar,SHiP-BRRIP Adaptive with Streaming Bypass (SHiP-BRRIP-SB),"This policy integrates SHiP-lite's PC-based reuse prediction with dynamic BRRIP (Bimodal RRIP) insertion depth control, set-dueling for global adaptivity, and streaming-based bypass. A compact 5-bit PC signature per block with a 2-bit outcome counter biases insertion depth: hot signatures insert at MRU (RRPV=0), cold at BRRIP depth (mostly distant, RRPV=2/3). Set-dueling across 32 leader sets tracks the relative hit rate of SRRIP vs BRRIP via a 10-bit PSEL selector, adapting insertion policy globally for changing phase behavior (e.g., milc, omnetpp). Streaming is detected per-set with a 2-bit monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (inserted as LRU, RRPV=3). This design improves upon the previous by using global phase-aware insertion (BRRIP/SRRIP) instead of only local SHiP, more aggressively bypassing streaming pollution, and reuses compact metadata (PC signature, PSEL, monotonicity) to fit within 64 KiB. The hybrid approach increases hit rate for control-dominated and phase-changing workloads and reduces pollution for regular streaming and memory-bound ones.",,ChampSim_CRC2/new_policies/020_02_ship_brrip_adaptive_with_streaming_bypass__ship_brrip_sb_t07.cc,0.432127847,0.432127847,0%
1581,lbm,SHiP-BRRIP Adaptive with Streaming Bypass (SHiP-BRRIP-SB),"This policy integrates SHiP-lite's PC-based reuse prediction with dynamic BRRIP (Bimodal RRIP) insertion depth control, set-dueling for global adaptivity, and streaming-based bypass. A compact 5-bit PC signature per block with a 2-bit outcome counter biases insertion depth: hot signatures insert at MRU (RRPV=0), cold at BRRIP depth (mostly distant, RRPV=2/3). Set-dueling across 32 leader sets tracks the relative hit rate of SRRIP vs BRRIP via a 10-bit PSEL selector, adapting insertion policy globally for changing phase behavior (e.g., milc, omnetpp). Streaming is detected per-set with a 2-bit monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (inserted as LRU, RRPV=3). This design improves upon the previous by using global phase-aware insertion (BRRIP/SRRIP) instead of only local SHiP, more aggressively bypassing streaming pollution, and reuses compact metadata (PC signature, PSEL, monotonicity) to fit within 64 KiB. The hybrid approach increases hit rate for control-dominated and phase-changing workloads and reduces pollution for regular streaming and memory-bound ones.",,ChampSim_CRC2/new_policies/020_02_ship_brrip_adaptive_with_streaming_bypass__ship_brrip_sb_t07.cc,0.410580661,0.410580661,0%
1582,mcf,SHiP-BRRIP Adaptive with Streaming Bypass (SHiP-BRRIP-SB),"This policy integrates SHiP-lite's PC-based reuse prediction with dynamic BRRIP (Bimodal RRIP) insertion depth control, set-dueling for global adaptivity, and streaming-based bypass. A compact 5-bit PC signature per block with a 2-bit outcome counter biases insertion depth: hot signatures insert at MRU (RRPV=0), cold at BRRIP depth (mostly distant, RRPV=2/3). Set-dueling across 32 leader sets tracks the relative hit rate of SRRIP vs BRRIP via a 10-bit PSEL selector, adapting insertion policy globally for changing phase behavior (e.g., milc, omnetpp). Streaming is detected per-set with a 2-bit monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (inserted as LRU, RRPV=3). This design improves upon the previous by using global phase-aware insertion (BRRIP/SRRIP) instead of only local SHiP, more aggressively bypassing streaming pollution, and reuses compact metadata (PC signature, PSEL, monotonicity) to fit within 64 KiB. The hybrid approach increases hit rate for control-dominated and phase-changing workloads and reduces pollution for regular streaming and memory-bound ones.",,ChampSim_CRC2/new_policies/020_02_ship_brrip_adaptive_with_streaming_bypass__ship_brrip_sb_t07.cc,0.465545516,0.465545516,0%
1583,milc,SHiP-BRRIP Adaptive with Streaming Bypass (SHiP-BRRIP-SB),"This policy integrates SHiP-lite's PC-based reuse prediction with dynamic BRRIP (Bimodal RRIP) insertion depth control, set-dueling for global adaptivity, and streaming-based bypass. A compact 5-bit PC signature per block with a 2-bit outcome counter biases insertion depth: hot signatures insert at MRU (RRPV=0), cold at BRRIP depth (mostly distant, RRPV=2/3). Set-dueling across 32 leader sets tracks the relative hit rate of SRRIP vs BRRIP via a 10-bit PSEL selector, adapting insertion policy globally for changing phase behavior (e.g., milc, omnetpp). Streaming is detected per-set with a 2-bit monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (inserted as LRU, RRPV=3). This design improves upon the previous by using global phase-aware insertion (BRRIP/SRRIP) instead of only local SHiP, more aggressively bypassing streaming pollution, and reuses compact metadata (PC signature, PSEL, monotonicity) to fit within 64 KiB. The hybrid approach increases hit rate for control-dominated and phase-changing workloads and reduces pollution for regular streaming and memory-bound ones.",,ChampSim_CRC2/new_policies/020_02_ship_brrip_adaptive_with_streaming_bypass__ship_brrip_sb_t07.cc,0.308667096,0.308667096,0%
1584,omnetpp,SHiP-BRRIP Adaptive with Streaming Bypass (SHiP-BRRIP-SB),"This policy integrates SHiP-lite's PC-based reuse prediction with dynamic BRRIP (Bimodal RRIP) insertion depth control, set-dueling for global adaptivity, and streaming-based bypass. A compact 5-bit PC signature per block with a 2-bit outcome counter biases insertion depth: hot signatures insert at MRU (RRPV=0), cold at BRRIP depth (mostly distant, RRPV=2/3). Set-dueling across 32 leader sets tracks the relative hit rate of SRRIP vs BRRIP via a 10-bit PSEL selector, adapting insertion policy globally for changing phase behavior (e.g., milc, omnetpp). Streaming is detected per-set with a 2-bit monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (inserted as LRU, RRPV=3). This design improves upon the previous by using global phase-aware insertion (BRRIP/SRRIP) instead of only local SHiP, more aggressively bypassing streaming pollution, and reuses compact metadata (PC signature, PSEL, monotonicity) to fit within 64 KiB. The hybrid approach increases hit rate for control-dominated and phase-changing workloads and reduces pollution for regular streaming and memory-bound ones.",,ChampSim_CRC2/new_policies/020_02_ship_brrip_adaptive_with_streaming_bypass__ship_brrip_sb_t07.cc,0.766705835,0.766705835,0%
1585,all,SHiP-BRRIP Adaptive with Streaming Bypass (SHiP-BRRIP-SB),"This policy integrates SHiP-lite's PC-based reuse prediction with dynamic BRRIP (Bimodal RRIP) insertion depth control, set-dueling for global adaptivity, and streaming-based bypass. A compact 5-bit PC signature per block with a 2-bit outcome counter biases insertion depth: hot signatures insert at MRU (RRPV=0), cold at BRRIP depth (mostly distant, RRPV=2/3). Set-dueling across 32 leader sets tracks the relative hit rate of SRRIP vs BRRIP via a 10-bit PSEL selector, adapting insertion policy globally for changing phase behavior (e.g., milc, omnetpp). Streaming is detected per-set with a 2-bit monotonicity counter, and if streaming is detected, blocks from cold signatures are bypassed (inserted as LRU, RRPV=3). This design improves upon the previous by using global phase-aware insertion (BRRIP/SRRIP) instead of only local SHiP, more aggressively bypassing streaming pollution, and reuses compact metadata (PC signature, PSEL, monotonicity) to fit within 64 KiB. The hybrid approach increases hit rate for control-dominated and phase-changing workloads and reduces pollution for regular streaming and memory-bound ones.",,ChampSim_CRC2/new_policies/020_02_ship_brrip_adaptive_with_streaming_bypass__ship_brrip_sb_t07.cc,0.476725391,0.476725391,48%
1586,astar,SHiP-DRRIP with Dead-Block Decay and Streaming Bypass (SHiP-DRRIP-DBSB),"This policy combines SHiP-lite's PC-based reuse prediction with DRRIP (Dynamic RRIP) insertion depth control, set-dueling for global adaptivity, and a compact dead-block approximation per cache line. Instead of streaming detection via monotonic counters, it uses a 1-bit dead-block predictor per line that is periodically decayed, allowing the policy to bypass insertion for blocks predicted dead (i.e., not reused recently). DRRIP set-dueling (SRRIP vs BRRIP) is controlled by a 10-bit PSEL, and SHiP signatures bias insertion depth: hot signatures insert at MRU, cold at distant. Dead-block lines are inserted as LRU (RRPV=3) or bypassed. This approach improves performance by more precisely identifying non-reusable blocks (especially in streaming and pointer-chasing workloads like lbm, mcf, omnetpp), while retaining phase adaptivity and compact metadata. The dead-block predictor replaces the previous streaming detector, reducing false positives and improving hit rate for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/021_00_ship_drrip_with_dead_block_decay_and_streaming_bypass__ship_drrip_dbsb_t02.cc,0.045338169,0.045338169,0%
1587,lbm,SHiP-DRRIP with Dead-Block Decay and Streaming Bypass (SHiP-DRRIP-DBSB),"This policy combines SHiP-lite's PC-based reuse prediction with DRRIP (Dynamic RRIP) insertion depth control, set-dueling for global adaptivity, and a compact dead-block approximation per cache line. Instead of streaming detection via monotonic counters, it uses a 1-bit dead-block predictor per line that is periodically decayed, allowing the policy to bypass insertion for blocks predicted dead (i.e., not reused recently). DRRIP set-dueling (SRRIP vs BRRIP) is controlled by a 10-bit PSEL, and SHiP signatures bias insertion depth: hot signatures insert at MRU, cold at distant. Dead-block lines are inserted as LRU (RRPV=3) or bypassed. This approach improves performance by more precisely identifying non-reusable blocks (especially in streaming and pointer-chasing workloads like lbm, mcf, omnetpp), while retaining phase adaptivity and compact metadata. The dead-block predictor replaces the previous streaming detector, reducing false positives and improving hit rate for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/021_00_ship_drrip_with_dead_block_decay_and_streaming_bypass__ship_drrip_dbsb_t02.cc,0.058887541,0.058887541,0%
1588,mcf,SHiP-DRRIP with Dead-Block Decay and Streaming Bypass (SHiP-DRRIP-DBSB),"This policy combines SHiP-lite's PC-based reuse prediction with DRRIP (Dynamic RRIP) insertion depth control, set-dueling for global adaptivity, and a compact dead-block approximation per cache line. Instead of streaming detection via monotonic counters, it uses a 1-bit dead-block predictor per line that is periodically decayed, allowing the policy to bypass insertion for blocks predicted dead (i.e., not reused recently). DRRIP set-dueling (SRRIP vs BRRIP) is controlled by a 10-bit PSEL, and SHiP signatures bias insertion depth: hot signatures insert at MRU, cold at distant. Dead-block lines are inserted as LRU (RRPV=3) or bypassed. This approach improves performance by more precisely identifying non-reusable blocks (especially in streaming and pointer-chasing workloads like lbm, mcf, omnetpp), while retaining phase adaptivity and compact metadata. The dead-block predictor replaces the previous streaming detector, reducing false positives and improving hit rate for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/021_00_ship_drrip_with_dead_block_decay_and_streaming_bypass__ship_drrip_dbsb_t02.cc,0.352089046,0.352089046,0%
1589,milc,SHiP-DRRIP with Dead-Block Decay and Streaming Bypass (SHiP-DRRIP-DBSB),"This policy combines SHiP-lite's PC-based reuse prediction with DRRIP (Dynamic RRIP) insertion depth control, set-dueling for global adaptivity, and a compact dead-block approximation per cache line. Instead of streaming detection via monotonic counters, it uses a 1-bit dead-block predictor per line that is periodically decayed, allowing the policy to bypass insertion for blocks predicted dead (i.e., not reused recently). DRRIP set-dueling (SRRIP vs BRRIP) is controlled by a 10-bit PSEL, and SHiP signatures bias insertion depth: hot signatures insert at MRU, cold at distant. Dead-block lines are inserted as LRU (RRPV=3) or bypassed. This approach improves performance by more precisely identifying non-reusable blocks (especially in streaming and pointer-chasing workloads like lbm, mcf, omnetpp), while retaining phase adaptivity and compact metadata. The dead-block predictor replaces the previous streaming detector, reducing false positives and improving hit rate for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/021_00_ship_drrip_with_dead_block_decay_and_streaming_bypass__ship_drrip_dbsb_t02.cc,0.009529534,0.009529534,0%
1590,omnetpp,SHiP-DRRIP with Dead-Block Decay and Streaming Bypass (SHiP-DRRIP-DBSB),"This policy combines SHiP-lite's PC-based reuse prediction with DRRIP (Dynamic RRIP) insertion depth control, set-dueling for global adaptivity, and a compact dead-block approximation per cache line. Instead of streaming detection via monotonic counters, it uses a 1-bit dead-block predictor per line that is periodically decayed, allowing the policy to bypass insertion for blocks predicted dead (i.e., not reused recently). DRRIP set-dueling (SRRIP vs BRRIP) is controlled by a 10-bit PSEL, and SHiP signatures bias insertion depth: hot signatures insert at MRU, cold at distant. Dead-block lines are inserted as LRU (RRPV=3) or bypassed. This approach improves performance by more precisely identifying non-reusable blocks (especially in streaming and pointer-chasing workloads like lbm, mcf, omnetpp), while retaining phase adaptivity and compact metadata. The dead-block predictor replaces the previous streaming detector, reducing false positives and improving hit rate for irregular and phase-changing workloads.",,ChampSim_CRC2/new_policies/021_00_ship_drrip_with_dead_block_decay_and_streaming_bypass__ship_drrip_dbsb_t02.cc,0.001151215,0.001151215,0%
1591,astar,SHiP-DeadBlock Adaptive with Streaming LIP Bypass (SHiP-DB-LIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to better estimate block liveness, and introduces a streaming-aware LIP-style bypass for highly monotonic sets. Insertion depth is determined by both SHiP outcome and dead-block score: blocks predicted dead or streaming are inserted at LRU (RRPV=3), while hot blocks get MRU (RRPV=0). Streaming detection is enhanced by tracking both stride monotonicity and dead-block prevalence in the set. Set-dueling (SRRIP vs LIP) is managed by a 10-bit global PSEL, with 32 leader sets per policy. This hybrid approach improves phase adaptivity (milc, omnetpp), reduces pollution from streaming (lbm), and more aggressively evicts dead blocks (mcf, astar), while keeping metadata under 64 KiB by using compact 2-bit counters and 5-bit signatures. The diversity comes from the addition of per-block dead-block counters and LIP-style insertion for streaming sets.",,ChampSim_CRC2/new_policies/021_01_ship_deadblock_adaptive_with_streaming_lip_bypass__ship_db_lip_sb_t04.cc,0.337486479,0.337486479,0%
1592,lbm,SHiP-DeadBlock Adaptive with Streaming LIP Bypass (SHiP-DB-LIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to better estimate block liveness, and introduces a streaming-aware LIP-style bypass for highly monotonic sets. Insertion depth is determined by both SHiP outcome and dead-block score: blocks predicted dead or streaming are inserted at LRU (RRPV=3), while hot blocks get MRU (RRPV=0). Streaming detection is enhanced by tracking both stride monotonicity and dead-block prevalence in the set. Set-dueling (SRRIP vs LIP) is managed by a 10-bit global PSEL, with 32 leader sets per policy. This hybrid approach improves phase adaptivity (milc, omnetpp), reduces pollution from streaming (lbm), and more aggressively evicts dead blocks (mcf, astar), while keeping metadata under 64 KiB by using compact 2-bit counters and 5-bit signatures. The diversity comes from the addition of per-block dead-block counters and LIP-style insertion for streaming sets.",,ChampSim_CRC2/new_policies/021_01_ship_deadblock_adaptive_with_streaming_lip_bypass__ship_db_lip_sb_t04.cc,0.242148452,0.242148452,0%
1593,mcf,SHiP-DeadBlock Adaptive with Streaming LIP Bypass (SHiP-DB-LIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to better estimate block liveness, and introduces a streaming-aware LIP-style bypass for highly monotonic sets. Insertion depth is determined by both SHiP outcome and dead-block score: blocks predicted dead or streaming are inserted at LRU (RRPV=3), while hot blocks get MRU (RRPV=0). Streaming detection is enhanced by tracking both stride monotonicity and dead-block prevalence in the set. Set-dueling (SRRIP vs LIP) is managed by a 10-bit global PSEL, with 32 leader sets per policy. This hybrid approach improves phase adaptivity (milc, omnetpp), reduces pollution from streaming (lbm), and more aggressively evicts dead blocks (mcf, astar), while keeping metadata under 64 KiB by using compact 2-bit counters and 5-bit signatures. The diversity comes from the addition of per-block dead-block counters and LIP-style insertion for streaming sets.",,ChampSim_CRC2/new_policies/021_01_ship_deadblock_adaptive_with_streaming_lip_bypass__ship_db_lip_sb_t04.cc,0.402059386,0.402059386,0%
1594,milc,SHiP-DeadBlock Adaptive with Streaming LIP Bypass (SHiP-DB-LIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to better estimate block liveness, and introduces a streaming-aware LIP-style bypass for highly monotonic sets. Insertion depth is determined by both SHiP outcome and dead-block score: blocks predicted dead or streaming are inserted at LRU (RRPV=3), while hot blocks get MRU (RRPV=0). Streaming detection is enhanced by tracking both stride monotonicity and dead-block prevalence in the set. Set-dueling (SRRIP vs LIP) is managed by a 10-bit global PSEL, with 32 leader sets per policy. This hybrid approach improves phase adaptivity (milc, omnetpp), reduces pollution from streaming (lbm), and more aggressively evicts dead blocks (mcf, astar), while keeping metadata under 64 KiB by using compact 2-bit counters and 5-bit signatures. The diversity comes from the addition of per-block dead-block counters and LIP-style insertion for streaming sets.",,ChampSim_CRC2/new_policies/021_01_ship_deadblock_adaptive_with_streaming_lip_bypass__ship_db_lip_sb_t04.cc,0.080953967,0.080953967,0%
1595,omnetpp,SHiP-DeadBlock Adaptive with Streaming LIP Bypass (SHiP-DB-LIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to better estimate block liveness, and introduces a streaming-aware LIP-style bypass for highly monotonic sets. Insertion depth is determined by both SHiP outcome and dead-block score: blocks predicted dead or streaming are inserted at LRU (RRPV=3), while hot blocks get MRU (RRPV=0). Streaming detection is enhanced by tracking both stride monotonicity and dead-block prevalence in the set. Set-dueling (SRRIP vs LIP) is managed by a 10-bit global PSEL, with 32 leader sets per policy. This hybrid approach improves phase adaptivity (milc, omnetpp), reduces pollution from streaming (lbm), and more aggressively evicts dead blocks (mcf, astar), while keeping metadata under 64 KiB by using compact 2-bit counters and 5-bit signatures. The diversity comes from the addition of per-block dead-block counters and LIP-style insertion for streaming sets.",,ChampSim_CRC2/new_policies/021_01_ship_deadblock_adaptive_with_streaming_lip_bypass__ship_db_lip_sb_t04.cc,0.763121007,0.763121007,0%
1596,astar,SHiP-Deadblock DRRIP with Streaming Adaptive Bypass (SHiP-DB-DRRIP-SA),"This policy fuses SHiP-lite PC-based reuse prediction with a tiny per-block dead-block detector (1-bit), using DRRIP (SRRIP/BRRIP) set-dueling for global adaptivity. Streaming detection is enhanced by tracking near-monotonic address deltas and reuses a compact 2-bit per-set streaming counter. Dead-block bits are updated on eviction and periodically decayed. If a block’s dead-bit is set or the streaming detector triggers, the block is bypassed (inserted at LRU). Otherwise, insertion depth is determined by SHiP-hotness and DRRIP-dueling: hot signatures get MRU, cold get distant, with global PSEL adapting between SRRIP and BRRIP. This hybrid approach boosts hit rates for control-dominated and phase-changing workloads (via SHiP and DRRIP), curbs pollution from streaming and memory-bound phases (via adaptive bypass and dead-block detection), and fits within 64 KiB metadata by using compact dead-bit arrays and counters.",,ChampSim_CRC2/new_policies/021_02_ship_deadblock_drrip_with_streaming_adaptive_bypass__ship_db_drrip_sa_t07.cc,0.045124665,0.045124665,0%
1597,lbm,SHiP-Deadblock DRRIP with Streaming Adaptive Bypass (SHiP-DB-DRRIP-SA),"This policy fuses SHiP-lite PC-based reuse prediction with a tiny per-block dead-block detector (1-bit), using DRRIP (SRRIP/BRRIP) set-dueling for global adaptivity. Streaming detection is enhanced by tracking near-monotonic address deltas and reuses a compact 2-bit per-set streaming counter. Dead-block bits are updated on eviction and periodically decayed. If a block’s dead-bit is set or the streaming detector triggers, the block is bypassed (inserted at LRU). Otherwise, insertion depth is determined by SHiP-hotness and DRRIP-dueling: hot signatures get MRU, cold get distant, with global PSEL adapting between SRRIP and BRRIP. This hybrid approach boosts hit rates for control-dominated and phase-changing workloads (via SHiP and DRRIP), curbs pollution from streaming and memory-bound phases (via adaptive bypass and dead-block detection), and fits within 64 KiB metadata by using compact dead-bit arrays and counters.",,ChampSim_CRC2/new_policies/021_02_ship_deadblock_drrip_with_streaming_adaptive_bypass__ship_db_drrip_sa_t07.cc,0.058753172,0.058753172,0%
1598,mcf,SHiP-Deadblock DRRIP with Streaming Adaptive Bypass (SHiP-DB-DRRIP-SA),"This policy fuses SHiP-lite PC-based reuse prediction with a tiny per-block dead-block detector (1-bit), using DRRIP (SRRIP/BRRIP) set-dueling for global adaptivity. Streaming detection is enhanced by tracking near-monotonic address deltas and reuses a compact 2-bit per-set streaming counter. Dead-block bits are updated on eviction and periodically decayed. If a block’s dead-bit is set or the streaming detector triggers, the block is bypassed (inserted at LRU). Otherwise, insertion depth is determined by SHiP-hotness and DRRIP-dueling: hot signatures get MRU, cold get distant, with global PSEL adapting between SRRIP and BRRIP. This hybrid approach boosts hit rates for control-dominated and phase-changing workloads (via SHiP and DRRIP), curbs pollution from streaming and memory-bound phases (via adaptive bypass and dead-block detection), and fits within 64 KiB metadata by using compact dead-bit arrays and counters.",,ChampSim_CRC2/new_policies/021_02_ship_deadblock_drrip_with_streaming_adaptive_bypass__ship_db_drrip_sa_t07.cc,0.214312084,0.214312084,0%
1599,milc,SHiP-Deadblock DRRIP with Streaming Adaptive Bypass (SHiP-DB-DRRIP-SA),"This policy fuses SHiP-lite PC-based reuse prediction with a tiny per-block dead-block detector (1-bit), using DRRIP (SRRIP/BRRIP) set-dueling for global adaptivity. Streaming detection is enhanced by tracking near-monotonic address deltas and reuses a compact 2-bit per-set streaming counter. Dead-block bits are updated on eviction and periodically decayed. If a block’s dead-bit is set or the streaming detector triggers, the block is bypassed (inserted at LRU). Otherwise, insertion depth is determined by SHiP-hotness and DRRIP-dueling: hot signatures get MRU, cold get distant, with global PSEL adapting between SRRIP and BRRIP. This hybrid approach boosts hit rates for control-dominated and phase-changing workloads (via SHiP and DRRIP), curbs pollution from streaming and memory-bound phases (via adaptive bypass and dead-block detection), and fits within 64 KiB metadata by using compact dead-bit arrays and counters.",,ChampSim_CRC2/new_policies/021_02_ship_deadblock_drrip_with_streaming_adaptive_bypass__ship_db_drrip_sa_t07.cc,0.009520482,0.009520482,0%
1600,omnetpp,SHiP-Deadblock DRRIP with Streaming Adaptive Bypass (SHiP-DB-DRRIP-SA),"This policy fuses SHiP-lite PC-based reuse prediction with a tiny per-block dead-block detector (1-bit), using DRRIP (SRRIP/BRRIP) set-dueling for global adaptivity. Streaming detection is enhanced by tracking near-monotonic address deltas and reuses a compact 2-bit per-set streaming counter. Dead-block bits are updated on eviction and periodically decayed. If a block’s dead-bit is set or the streaming detector triggers, the block is bypassed (inserted at LRU). Otherwise, insertion depth is determined by SHiP-hotness and DRRIP-dueling: hot signatures get MRU, cold get distant, with global PSEL adapting between SRRIP and BRRIP. This hybrid approach boosts hit rates for control-dominated and phase-changing workloads (via SHiP and DRRIP), curbs pollution from streaming and memory-bound phases (via adaptive bypass and dead-block detection), and fits within 64 KiB metadata by using compact dead-bit arrays and counters.",,ChampSim_CRC2/new_policies/021_02_ship_deadblock_drrip_with_streaming_adaptive_bypass__ship_db_drrip_sa_t07.cc,0.001151215,0.001151215,0%
1601,all,SHiP-DeadBlock Adaptive with Streaming LIP Bypass (SHiP-DB-LIP-SB),"This policy combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to better estimate block liveness, and introduces a streaming-aware LIP-style bypass for highly monotonic sets. Insertion depth is determined by both SHiP outcome and dead-block score: blocks predicted dead or streaming are inserted at LRU (RRPV=3), while hot blocks get MRU (RRPV=0). Streaming detection is enhanced by tracking both stride monotonicity and dead-block prevalence in the set. Set-dueling (SRRIP vs LIP) is managed by a 10-bit global PSEL, with 32 leader sets per policy. This hybrid approach improves phase adaptivity (milc, omnetpp), reduces pollution from streaming (lbm), and more aggressively evicts dead blocks (mcf, astar), while keeping metadata under 64 KiB by using compact 2-bit counters and 5-bit signatures. The diversity comes from the addition of per-block dead-block counters and LIP-style insertion for streaming sets.",,ChampSim_CRC2/new_policies/021_01_ship_deadblock_adaptive_with_streaming_lip_bypass__ship_db_lip_sb_t04.cc,0.365153858,0.365153858,37%
1602,astar,DRRIP-BIP with Streaming Bypass and Signature-Guided Insertion (DRRIP-BIP-SB-SIG),"This policy combines DRRIP (Dynamic RRIP) with BIP (Bimodal Insertion Policy) set-dueling, a lightweight streaming detector for monotonic access patterns, and a compact PC signature table to bias insertion depth. DRRIP adaptively chooses between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets, while BIP occasionally inserts at MRU to retain blocks with potential reuse. Streaming sets are detected via stride monotonicity and bypassed (not inserted) to avoid pollution from workloads like lbm. For non-streaming sets, insertion depth is further biased by a 2-bit outcome counter indexed by a 5-bit PC signature: hot signatures get MRU, others get distant RRPV. This hybrid approach improves adaptivity to phase changes (milc, omnetpp), reduces pollution from streaming (lbm), and leverages signature-guided insertion for control-dominated workloads (astar, mcf). All metadata fits within 64 KiB by using 2-bit RRPV, 2-bit outcome counters, and compact streaming/leader set bits.",,ChampSim_CRC2/new_policies/022_00_drrip_bip_with_streaming_bypass_and_signature_guided_insertion__drrip_bip_sb_sig_t02.cc,0.432173915,0.432173915,0%
1603,lbm,DRRIP-BIP with Streaming Bypass and Signature-Guided Insertion (DRRIP-BIP-SB-SIG),"This policy combines DRRIP (Dynamic RRIP) with BIP (Bimodal Insertion Policy) set-dueling, a lightweight streaming detector for monotonic access patterns, and a compact PC signature table to bias insertion depth. DRRIP adaptively chooses between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets, while BIP occasionally inserts at MRU to retain blocks with potential reuse. Streaming sets are detected via stride monotonicity and bypassed (not inserted) to avoid pollution from workloads like lbm. For non-streaming sets, insertion depth is further biased by a 2-bit outcome counter indexed by a 5-bit PC signature: hot signatures get MRU, others get distant RRPV. This hybrid approach improves adaptivity to phase changes (milc, omnetpp), reduces pollution from streaming (lbm), and leverages signature-guided insertion for control-dominated workloads (astar, mcf). All metadata fits within 64 KiB by using 2-bit RRPV, 2-bit outcome counters, and compact streaming/leader set bits.",,ChampSim_CRC2/new_policies/022_00_drrip_bip_with_streaming_bypass_and_signature_guided_insertion__drrip_bip_sb_sig_t02.cc,0.413805503,0.413805503,0%
1604,mcf,DRRIP-BIP with Streaming Bypass and Signature-Guided Insertion (DRRIP-BIP-SB-SIG),"This policy combines DRRIP (Dynamic RRIP) with BIP (Bimodal Insertion Policy) set-dueling, a lightweight streaming detector for monotonic access patterns, and a compact PC signature table to bias insertion depth. DRRIP adaptively chooses between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets, while BIP occasionally inserts at MRU to retain blocks with potential reuse. Streaming sets are detected via stride monotonicity and bypassed (not inserted) to avoid pollution from workloads like lbm. For non-streaming sets, insertion depth is further biased by a 2-bit outcome counter indexed by a 5-bit PC signature: hot signatures get MRU, others get distant RRPV. This hybrid approach improves adaptivity to phase changes (milc, omnetpp), reduces pollution from streaming (lbm), and leverages signature-guided insertion for control-dominated workloads (astar, mcf). All metadata fits within 64 KiB by using 2-bit RRPV, 2-bit outcome counters, and compact streaming/leader set bits.",,ChampSim_CRC2/new_policies/022_00_drrip_bip_with_streaming_bypass_and_signature_guided_insertion__drrip_bip_sb_sig_t02.cc,0.465234405,0.465234405,0%
1605,milc,DRRIP-BIP with Streaming Bypass and Signature-Guided Insertion (DRRIP-BIP-SB-SIG),"This policy combines DRRIP (Dynamic RRIP) with BIP (Bimodal Insertion Policy) set-dueling, a lightweight streaming detector for monotonic access patterns, and a compact PC signature table to bias insertion depth. DRRIP adaptively chooses between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets, while BIP occasionally inserts at MRU to retain blocks with potential reuse. Streaming sets are detected via stride monotonicity and bypassed (not inserted) to avoid pollution from workloads like lbm. For non-streaming sets, insertion depth is further biased by a 2-bit outcome counter indexed by a 5-bit PC signature: hot signatures get MRU, others get distant RRPV. This hybrid approach improves adaptivity to phase changes (milc, omnetpp), reduces pollution from streaming (lbm), and leverages signature-guided insertion for control-dominated workloads (astar, mcf). All metadata fits within 64 KiB by using 2-bit RRPV, 2-bit outcome counters, and compact streaming/leader set bits.",,ChampSim_CRC2/new_policies/022_00_drrip_bip_with_streaming_bypass_and_signature_guided_insertion__drrip_bip_sb_sig_t02.cc,0.31194921,0.31194921,0%
1606,omnetpp,DRRIP-BIP with Streaming Bypass and Signature-Guided Insertion (DRRIP-BIP-SB-SIG),"This policy combines DRRIP (Dynamic RRIP) with BIP (Bimodal Insertion Policy) set-dueling, a lightweight streaming detector for monotonic access patterns, and a compact PC signature table to bias insertion depth. DRRIP adaptively chooses between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets, while BIP occasionally inserts at MRU to retain blocks with potential reuse. Streaming sets are detected via stride monotonicity and bypassed (not inserted) to avoid pollution from workloads like lbm. For non-streaming sets, insertion depth is further biased by a 2-bit outcome counter indexed by a 5-bit PC signature: hot signatures get MRU, others get distant RRPV. This hybrid approach improves adaptivity to phase changes (milc, omnetpp), reduces pollution from streaming (lbm), and leverages signature-guided insertion for control-dominated workloads (astar, mcf). All metadata fits within 64 KiB by using 2-bit RRPV, 2-bit outcome counters, and compact streaming/leader set bits.",,ChampSim_CRC2/new_policies/022_00_drrip_bip_with_streaming_bypass_and_signature_guided_insertion__drrip_bip_sb_sig_t02.cc,0.646986895,0.646986895,0%
1607,astar,BRRIP-SHiP Streaming Bypass with BIP Leader Sets (BRRIP-SHiP-SBIP),"This policy combines BRRIP (Bimodal RRIP) as the default insertion depth controller with SHiP-lite's PC-based reuse prediction to bias insertion for hot blocks, and introduces a streaming detector that can bypass cache insertion entirely for strongly monotonic sets. Instead of the previous dead-block counter, we use BIP-style leader sets to guide global insertion depth selection, improving adaptivity for workloads with mixed spatial/temporal locality. BRRIP's rare MRU insertion reduces cache pollution from streaming (lbm, milc), while SHiP's hot signatures allow frequent reuse for pointer-chasing (mcf, omnetpp). The streaming detector uses a compact per-set stride counter to trigger bypass for sets with high monotonicity, further reducing pollution. Metadata is kept under 64 KiB by using 2-bit RRPV, 5-bit SHiP signatures, 2-bit outcome counters, and 2 bits per-set for streaming detection. This materially changes the insertion depth control and streaming/bypass logic, improving performance diversity across all workloads.",,ChampSim_CRC2/new_policies/022_01_brrip_ship_streaming_bypass_with_bip_leader_sets__brrip_ship_sbip_t04.cc,0.235630555,0.235630555,0%
1608,lbm,BRRIP-SHiP Streaming Bypass with BIP Leader Sets (BRRIP-SHiP-SBIP),"This policy combines BRRIP (Bimodal RRIP) as the default insertion depth controller with SHiP-lite's PC-based reuse prediction to bias insertion for hot blocks, and introduces a streaming detector that can bypass cache insertion entirely for strongly monotonic sets. Instead of the previous dead-block counter, we use BIP-style leader sets to guide global insertion depth selection, improving adaptivity for workloads with mixed spatial/temporal locality. BRRIP's rare MRU insertion reduces cache pollution from streaming (lbm, milc), while SHiP's hot signatures allow frequent reuse for pointer-chasing (mcf, omnetpp). The streaming detector uses a compact per-set stride counter to trigger bypass for sets with high monotonicity, further reducing pollution. Metadata is kept under 64 KiB by using 2-bit RRPV, 5-bit SHiP signatures, 2-bit outcome counters, and 2 bits per-set for streaming detection. This materially changes the insertion depth control and streaming/bypass logic, improving performance diversity across all workloads.",,ChampSim_CRC2/new_policies/022_01_brrip_ship_streaming_bypass_with_bip_leader_sets__brrip_ship_sbip_t04.cc,0.12794595,0.12794595,0%
1609,mcf,BRRIP-SHiP Streaming Bypass with BIP Leader Sets (BRRIP-SHiP-SBIP),"This policy combines BRRIP (Bimodal RRIP) as the default insertion depth controller with SHiP-lite's PC-based reuse prediction to bias insertion for hot blocks, and introduces a streaming detector that can bypass cache insertion entirely for strongly monotonic sets. Instead of the previous dead-block counter, we use BIP-style leader sets to guide global insertion depth selection, improving adaptivity for workloads with mixed spatial/temporal locality. BRRIP's rare MRU insertion reduces cache pollution from streaming (lbm, milc), while SHiP's hot signatures allow frequent reuse for pointer-chasing (mcf, omnetpp). The streaming detector uses a compact per-set stride counter to trigger bypass for sets with high monotonicity, further reducing pollution. Metadata is kept under 64 KiB by using 2-bit RRPV, 5-bit SHiP signatures, 2-bit outcome counters, and 2 bits per-set for streaming detection. This materially changes the insertion depth control and streaming/bypass logic, improving performance diversity across all workloads.",,ChampSim_CRC2/new_policies/022_01_brrip_ship_streaming_bypass_with_bip_leader_sets__brrip_ship_sbip_t04.cc,0.473018791,0.473018791,0%
1610,milc,BRRIP-SHiP Streaming Bypass with BIP Leader Sets (BRRIP-SHiP-SBIP),"This policy combines BRRIP (Bimodal RRIP) as the default insertion depth controller with SHiP-lite's PC-based reuse prediction to bias insertion for hot blocks, and introduces a streaming detector that can bypass cache insertion entirely for strongly monotonic sets. Instead of the previous dead-block counter, we use BIP-style leader sets to guide global insertion depth selection, improving adaptivity for workloads with mixed spatial/temporal locality. BRRIP's rare MRU insertion reduces cache pollution from streaming (lbm, milc), while SHiP's hot signatures allow frequent reuse for pointer-chasing (mcf, omnetpp). The streaming detector uses a compact per-set stride counter to trigger bypass for sets with high monotonicity, further reducing pollution. Metadata is kept under 64 KiB by using 2-bit RRPV, 5-bit SHiP signatures, 2-bit outcome counters, and 2 bits per-set for streaming detection. This materially changes the insertion depth control and streaming/bypass logic, improving performance diversity across all workloads.",,ChampSim_CRC2/new_policies/022_01_brrip_ship_streaming_bypass_with_bip_leader_sets__brrip_ship_sbip_t04.cc,0.023034534,0.023034534,0%
1611,omnetpp,BRRIP-SHiP Streaming Bypass with BIP Leader Sets (BRRIP-SHiP-SBIP),"This policy combines BRRIP (Bimodal RRIP) as the default insertion depth controller with SHiP-lite's PC-based reuse prediction to bias insertion for hot blocks, and introduces a streaming detector that can bypass cache insertion entirely for strongly monotonic sets. Instead of the previous dead-block counter, we use BIP-style leader sets to guide global insertion depth selection, improving adaptivity for workloads with mixed spatial/temporal locality. BRRIP's rare MRU insertion reduces cache pollution from streaming (lbm, milc), while SHiP's hot signatures allow frequent reuse for pointer-chasing (mcf, omnetpp). The streaming detector uses a compact per-set stride counter to trigger bypass for sets with high monotonicity, further reducing pollution. Metadata is kept under 64 KiB by using 2-bit RRPV, 5-bit SHiP signatures, 2-bit outcome counters, and 2 bits per-set for streaming detection. This materially changes the insertion depth control and streaming/bypass logic, improving performance diversity across all workloads.",,ChampSim_CRC2/new_policies/022_01_brrip_ship_streaming_bypass_with_bip_leader_sets__brrip_ship_sbip_t04.cc,0.09855114,0.09855114,0%
1612,astar,BRRIP-DIP Hybrid with Streaming Set Bypass (BRRIP-DIP-SB),"This policy combines DRRIP's dynamic insertion depth control (BRRIP vs SRRIP, selected via set-dueling and a global PSEL) with DIP-style leader sets for LIP/BIP insertion, but adds a streaming set detector that triggers full bypass (blocks not inserted at all) for sets showing monotonic access strides. Prediction source is diversified: insertion depth is chosen by DRRIP (BRRIP/SRRIP) except for streaming sets, which bypass the cache entirely. By using per-set stride monitors and leveraging DIP-style leader sets for additional insertion diversity, the policy adapts to phases (milc, omnetpp), resists streaming pollution (lbm), and maintains adaptive dead-block eviction (mcf, astar) without needing per-block counters or PC signatures—reducing metadata overhead. This materially changes both the insertion logic and streaming/bypass mechanism from the previous policy, leading to improved hit rates for workloads with high spatial locality and better resilience to streaming-induced pollution. Total metadata remains well under 64 KiB by relying on 2-bit RRPV, a 10-bit PSEL, 64 leader sets, and 2-bit per-set stride monotonicity counters.",,ChampSim_CRC2/new_policies/022_02_brrip_dip_hybrid_with_streaming_set_bypass__brrip_dip_sb_t07.cc,0.308006669,0.308006669,0%
1613,lbm,BRRIP-DIP Hybrid with Streaming Set Bypass (BRRIP-DIP-SB),"This policy combines DRRIP's dynamic insertion depth control (BRRIP vs SRRIP, selected via set-dueling and a global PSEL) with DIP-style leader sets for LIP/BIP insertion, but adds a streaming set detector that triggers full bypass (blocks not inserted at all) for sets showing monotonic access strides. Prediction source is diversified: insertion depth is chosen by DRRIP (BRRIP/SRRIP) except for streaming sets, which bypass the cache entirely. By using per-set stride monitors and leveraging DIP-style leader sets for additional insertion diversity, the policy adapts to phases (milc, omnetpp), resists streaming pollution (lbm), and maintains adaptive dead-block eviction (mcf, astar) without needing per-block counters or PC signatures—reducing metadata overhead. This materially changes both the insertion logic and streaming/bypass mechanism from the previous policy, leading to improved hit rates for workloads with high spatial locality and better resilience to streaming-induced pollution. Total metadata remains well under 64 KiB by relying on 2-bit RRPV, a 10-bit PSEL, 64 leader sets, and 2-bit per-set stride monotonicity counters.",,ChampSim_CRC2/new_policies/022_02_brrip_dip_hybrid_with_streaming_set_bypass__brrip_dip_sb_t07.cc,0.1858871,0.1858871,0%
1614,mcf,BRRIP-DIP Hybrid with Streaming Set Bypass (BRRIP-DIP-SB),"This policy combines DRRIP's dynamic insertion depth control (BRRIP vs SRRIP, selected via set-dueling and a global PSEL) with DIP-style leader sets for LIP/BIP insertion, but adds a streaming set detector that triggers full bypass (blocks not inserted at all) for sets showing monotonic access strides. Prediction source is diversified: insertion depth is chosen by DRRIP (BRRIP/SRRIP) except for streaming sets, which bypass the cache entirely. By using per-set stride monitors and leveraging DIP-style leader sets for additional insertion diversity, the policy adapts to phases (milc, omnetpp), resists streaming pollution (lbm), and maintains adaptive dead-block eviction (mcf, astar) without needing per-block counters or PC signatures—reducing metadata overhead. This materially changes both the insertion logic and streaming/bypass mechanism from the previous policy, leading to improved hit rates for workloads with high spatial locality and better resilience to streaming-induced pollution. Total metadata remains well under 64 KiB by relying on 2-bit RRPV, a 10-bit PSEL, 64 leader sets, and 2-bit per-set stride monotonicity counters.",,ChampSim_CRC2/new_policies/022_02_brrip_dip_hybrid_with_streaming_set_bypass__brrip_dip_sb_t07.cc,0.446388704,0.446388704,0%
1615,milc,BRRIP-DIP Hybrid with Streaming Set Bypass (BRRIP-DIP-SB),"This policy combines DRRIP's dynamic insertion depth control (BRRIP vs SRRIP, selected via set-dueling and a global PSEL) with DIP-style leader sets for LIP/BIP insertion, but adds a streaming set detector that triggers full bypass (blocks not inserted at all) for sets showing monotonic access strides. Prediction source is diversified: insertion depth is chosen by DRRIP (BRRIP/SRRIP) except for streaming sets, which bypass the cache entirely. By using per-set stride monitors and leveraging DIP-style leader sets for additional insertion diversity, the policy adapts to phases (milc, omnetpp), resists streaming pollution (lbm), and maintains adaptive dead-block eviction (mcf, astar) without needing per-block counters or PC signatures—reducing metadata overhead. This materially changes both the insertion logic and streaming/bypass mechanism from the previous policy, leading to improved hit rates for workloads with high spatial locality and better resilience to streaming-induced pollution. Total metadata remains well under 64 KiB by relying on 2-bit RRPV, a 10-bit PSEL, 64 leader sets, and 2-bit per-set stride monotonicity counters.",,ChampSim_CRC2/new_policies/022_02_brrip_dip_hybrid_with_streaming_set_bypass__brrip_dip_sb_t07.cc,0.246153066,0.246153066,0%
1616,omnetpp,BRRIP-DIP Hybrid with Streaming Set Bypass (BRRIP-DIP-SB),"This policy combines DRRIP's dynamic insertion depth control (BRRIP vs SRRIP, selected via set-dueling and a global PSEL) with DIP-style leader sets for LIP/BIP insertion, but adds a streaming set detector that triggers full bypass (blocks not inserted at all) for sets showing monotonic access strides. Prediction source is diversified: insertion depth is chosen by DRRIP (BRRIP/SRRIP) except for streaming sets, which bypass the cache entirely. By using per-set stride monitors and leveraging DIP-style leader sets for additional insertion diversity, the policy adapts to phases (milc, omnetpp), resists streaming pollution (lbm), and maintains adaptive dead-block eviction (mcf, astar) without needing per-block counters or PC signatures—reducing metadata overhead. This materially changes both the insertion logic and streaming/bypass mechanism from the previous policy, leading to improved hit rates for workloads with high spatial locality and better resilience to streaming-induced pollution. Total metadata remains well under 64 KiB by relying on 2-bit RRPV, a 10-bit PSEL, 64 leader sets, and 2-bit per-set stride monotonicity counters.",,ChampSim_CRC2/new_policies/022_02_brrip_dip_hybrid_with_streaming_set_bypass__brrip_dip_sb_t07.cc,0.544995258,0.544995258,0%
1617,all,DRRIP-BIP with Streaming Bypass and Signature-Guided Insertion (DRRIP-BIP-SB-SIG),"This policy combines DRRIP (Dynamic RRIP) with BIP (Bimodal Insertion Policy) set-dueling, a lightweight streaming detector for monotonic access patterns, and a compact PC signature table to bias insertion depth. DRRIP adaptively chooses between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets, while BIP occasionally inserts at MRU to retain blocks with potential reuse. Streaming sets are detected via stride monotonicity and bypassed (not inserted) to avoid pollution from workloads like lbm. For non-streaming sets, insertion depth is further biased by a 2-bit outcome counter indexed by a 5-bit PC signature: hot signatures get MRU, others get distant RRPV. This hybrid approach improves adaptivity to phase changes (milc, omnetpp), reduces pollution from streaming (lbm), and leverages signature-guided insertion for control-dominated workloads (astar, mcf). All metadata fits within 64 KiB by using 2-bit RRPV, 2-bit outcome counters, and compact streaming/leader set bits.",,ChampSim_CRC2/new_policies/022_00_drrip_bip_with_streaming_bypass_and_signature_guided_insertion__drrip_bip_sb_sig_t02.cc,0.454029985,0.454029985,45%
1618,astar,DRRIP-SHiP-DBP: Dynamic RRIP with SHiP-Lite and Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) set-dueling with SHiP-lite signature-based insertion and a lightweight dead-block predictor (DBP) using per-line reuse counters. DRRIP adaptively selects between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth toward MRU for hot signatures. The dead-block predictor maintains a 2-bit reuse counter per cache line, incremented on hits and periodically decayed; lines predicted dead (counter=0) are inserted at LRU and prioritized for eviction. This hybrid approach improves adaptivity to control-dominated and phase-changing workloads (astar, milc, omnetpp), leverages signature-guided insertion for irregular access (mcf), and actively reduces cache pollution from lines with no reuse (lbm, streaming phases) without explicit streaming detection. All metadata fits within 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/023_00_drrip_ship_dbp__dynamic_rrip_with_ship_lite_and_dead_block_prediction_t02.cc,0.318062623,0.318062623,0%
1619,lbm,DRRIP-SHiP-DBP: Dynamic RRIP with SHiP-Lite and Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) set-dueling with SHiP-lite signature-based insertion and a lightweight dead-block predictor (DBP) using per-line reuse counters. DRRIP adaptively selects between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth toward MRU for hot signatures. The dead-block predictor maintains a 2-bit reuse counter per cache line, incremented on hits and periodically decayed; lines predicted dead (counter=0) are inserted at LRU and prioritized for eviction. This hybrid approach improves adaptivity to control-dominated and phase-changing workloads (astar, milc, omnetpp), leverages signature-guided insertion for irregular access (mcf), and actively reduces cache pollution from lines with no reuse (lbm, streaming phases) without explicit streaming detection. All metadata fits within 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/023_00_drrip_ship_dbp__dynamic_rrip_with_ship_lite_and_dead_block_prediction_t02.cc,0.245259273,0.245259273,0%
1620,mcf,DRRIP-SHiP-DBP: Dynamic RRIP with SHiP-Lite and Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) set-dueling with SHiP-lite signature-based insertion and a lightweight dead-block predictor (DBP) using per-line reuse counters. DRRIP adaptively selects between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth toward MRU for hot signatures. The dead-block predictor maintains a 2-bit reuse counter per cache line, incremented on hits and periodically decayed; lines predicted dead (counter=0) are inserted at LRU and prioritized for eviction. This hybrid approach improves adaptivity to control-dominated and phase-changing workloads (astar, milc, omnetpp), leverages signature-guided insertion for irregular access (mcf), and actively reduces cache pollution from lines with no reuse (lbm, streaming phases) without explicit streaming detection. All metadata fits within 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/023_00_drrip_ship_dbp__dynamic_rrip_with_ship_lite_and_dead_block_prediction_t02.cc,0.481312294,0.481312294,0%
1621,milc,DRRIP-SHiP-DBP: Dynamic RRIP with SHiP-Lite and Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) set-dueling with SHiP-lite signature-based insertion and a lightweight dead-block predictor (DBP) using per-line reuse counters. DRRIP adaptively selects between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth toward MRU for hot signatures. The dead-block predictor maintains a 2-bit reuse counter per cache line, incremented on hits and periodically decayed; lines predicted dead (counter=0) are inserted at LRU and prioritized for eviction. This hybrid approach improves adaptivity to control-dominated and phase-changing workloads (astar, milc, omnetpp), leverages signature-guided insertion for irregular access (mcf), and actively reduces cache pollution from lines with no reuse (lbm, streaming phases) without explicit streaming detection. All metadata fits within 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/023_00_drrip_ship_dbp__dynamic_rrip_with_ship_lite_and_dead_block_prediction_t02.cc,0.229930773,0.229930773,0%
1622,omnetpp,DRRIP-SHiP-DBP: Dynamic RRIP with SHiP-Lite and Dead-Block Prediction,"This policy combines DRRIP (Dynamic RRIP) set-dueling with SHiP-lite signature-based insertion and a lightweight dead-block predictor (DBP) using per-line reuse counters. DRRIP adaptively selects between SRRIP and BRRIP using a 10-bit PSEL and 64 leader sets. SHiP-lite uses 5-bit PC signatures and 2-bit outcome counters to bias insertion depth toward MRU for hot signatures. The dead-block predictor maintains a 2-bit reuse counter per cache line, incremented on hits and periodically decayed; lines predicted dead (counter=0) are inserted at LRU and prioritized for eviction. This hybrid approach improves adaptivity to control-dominated and phase-changing workloads (astar, milc, omnetpp), leverages signature-guided insertion for irregular access (mcf), and actively reduces cache pollution from lines with no reuse (lbm, streaming phases) without explicit streaming detection. All metadata fits within 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/023_00_drrip_ship_dbp__dynamic_rrip_with_ship_lite_and_dead_block_prediction_t02.cc,0.387857965,0.387857965,0%
1623,astar,SRRIP-DBP-SB (Static RRIP with Dead Block Prediction and Streaming Bypass),"This policy combines Static RRIP (SRRIP) with per-block dead block prediction and a refined streaming bypass detector. Each cache block maintains a tiny 2-bit dead counter that is incremented on miss and reset on hit, approximating block reuse likelihood. Blocks predicted dead are inserted at the most distant RRPV (max eviction priority), while blocks predicted live are inserted at MRU. A lightweight streaming detector (per-set stride monotonicity) triggers bypass for detected streaming sets, avoiding cache pollution from workloads like lbm. This approach improves over prior designs by using direct dead-block prediction (not PC signatures) to guide insertion depth, and by making streaming bypass more aggressive. The policy remains simple and compact, with all metadata fitting well within 64 KiB. By targeting dead blocks for quick eviction and leveraging streaming bypass, it adapts effectively to both memory-bound (mcf, lbm) and phase-changing (milc, omnetpp) workloads.",,ChampSim_CRC2/new_policies/023_01_srrip_dbp_sb__static_rrip_with_dead_block_prediction_and_streaming_bypass_t04.cc,0.447886398,0.447886398,0%
1624,lbm,SRRIP-DBP-SB (Static RRIP with Dead Block Prediction and Streaming Bypass),"This policy combines Static RRIP (SRRIP) with per-block dead block prediction and a refined streaming bypass detector. Each cache block maintains a tiny 2-bit dead counter that is incremented on miss and reset on hit, approximating block reuse likelihood. Blocks predicted dead are inserted at the most distant RRPV (max eviction priority), while blocks predicted live are inserted at MRU. A lightweight streaming detector (per-set stride monotonicity) triggers bypass for detected streaming sets, avoiding cache pollution from workloads like lbm. This approach improves over prior designs by using direct dead-block prediction (not PC signatures) to guide insertion depth, and by making streaming bypass more aggressive. The policy remains simple and compact, with all metadata fitting well within 64 KiB. By targeting dead blocks for quick eviction and leveraging streaming bypass, it adapts effectively to both memory-bound (mcf, lbm) and phase-changing (milc, omnetpp) workloads.",,ChampSim_CRC2/new_policies/023_01_srrip_dbp_sb__static_rrip_with_dead_block_prediction_and_streaming_bypass_t04.cc,0.430471785,0.430471785,0%
1625,mcf,SRRIP-DBP-SB (Static RRIP with Dead Block Prediction and Streaming Bypass),"This policy combines Static RRIP (SRRIP) with per-block dead block prediction and a refined streaming bypass detector. Each cache block maintains a tiny 2-bit dead counter that is incremented on miss and reset on hit, approximating block reuse likelihood. Blocks predicted dead are inserted at the most distant RRPV (max eviction priority), while blocks predicted live are inserted at MRU. A lightweight streaming detector (per-set stride monotonicity) triggers bypass for detected streaming sets, avoiding cache pollution from workloads like lbm. This approach improves over prior designs by using direct dead-block prediction (not PC signatures) to guide insertion depth, and by making streaming bypass more aggressive. The policy remains simple and compact, with all metadata fitting well within 64 KiB. By targeting dead blocks for quick eviction and leveraging streaming bypass, it adapts effectively to both memory-bound (mcf, lbm) and phase-changing (milc, omnetpp) workloads.",,ChampSim_CRC2/new_policies/023_01_srrip_dbp_sb__static_rrip_with_dead_block_prediction_and_streaming_bypass_t04.cc,0.44408142,0.44408142,0%
1626,milc,SRRIP-DBP-SB (Static RRIP with Dead Block Prediction and Streaming Bypass),"This policy combines Static RRIP (SRRIP) with per-block dead block prediction and a refined streaming bypass detector. Each cache block maintains a tiny 2-bit dead counter that is incremented on miss and reset on hit, approximating block reuse likelihood. Blocks predicted dead are inserted at the most distant RRPV (max eviction priority), while blocks predicted live are inserted at MRU. A lightweight streaming detector (per-set stride monotonicity) triggers bypass for detected streaming sets, avoiding cache pollution from workloads like lbm. This approach improves over prior designs by using direct dead-block prediction (not PC signatures) to guide insertion depth, and by making streaming bypass more aggressive. The policy remains simple and compact, with all metadata fitting well within 64 KiB. By targeting dead blocks for quick eviction and leveraging streaming bypass, it adapts effectively to both memory-bound (mcf, lbm) and phase-changing (milc, omnetpp) workloads.",,ChampSim_CRC2/new_policies/023_01_srrip_dbp_sb__static_rrip_with_dead_block_prediction_and_streaming_bypass_t04.cc,0.310779742,0.310779742,0%
1627,omnetpp,SRRIP-DBP-SB (Static RRIP with Dead Block Prediction and Streaming Bypass),"This policy combines Static RRIP (SRRIP) with per-block dead block prediction and a refined streaming bypass detector. Each cache block maintains a tiny 2-bit dead counter that is incremented on miss and reset on hit, approximating block reuse likelihood. Blocks predicted dead are inserted at the most distant RRPV (max eviction priority), while blocks predicted live are inserted at MRU. A lightweight streaming detector (per-set stride monotonicity) triggers bypass for detected streaming sets, avoiding cache pollution from workloads like lbm. This approach improves over prior designs by using direct dead-block prediction (not PC signatures) to guide insertion depth, and by making streaming bypass more aggressive. The policy remains simple and compact, with all metadata fitting well within 64 KiB. By targeting dead blocks for quick eviction and leveraging streaming bypass, it adapts effectively to both memory-bound (mcf, lbm) and phase-changing (milc, omnetpp) workloads.",,ChampSim_CRC2/new_policies/023_01_srrip_dbp_sb__static_rrip_with_dead_block_prediction_and_streaming_bypass_t04.cc,0.461351259,0.461351259,0%
1628,astar,SRRIP-GDBP: Signature-based RRIP with Global Dead-Block Prediction,"SRRIP-GDBP combines SRRIP (Static Re-reference Interval Prediction) with a global dead-block prediction table indexed by compact PC signatures, replacing streaming bypass with lightweight per-line deadness detection. Each cache line is tagged with a 5-bit PC signature, and a small global table (32 entries, 2-bit counters) tracks how often blocks accessed by each signature are reused before eviction. On insertion, lines with cold signatures (low reuse history) are inserted at distant RRPV (likely dead), while hot signatures get MRU. Additionally, every cache line has a 1-bit deadness flag: if a block was not reused before eviction, its signature counter is decayed (dead-block feedback). Unlike streaming detectors, this mechanism adapts to both streaming and irregular workloads, suppressing pollution from dead blocks in lbm/mcf and improving insertion for control-dominated code in astar/milc/omnetpp. The policy uses only SRRIP (no set-dueling or probabilistic insertion), simplifies metadata, and fits well within 64 KiB.",,ChampSim_CRC2/new_policies/023_02_srrip_gdbp__signature_based_rrip_with_global_dead_block_prediction_t07.cc,0.451434464,0.451434464,0%
1629,lbm,SRRIP-GDBP: Signature-based RRIP with Global Dead-Block Prediction,"SRRIP-GDBP combines SRRIP (Static Re-reference Interval Prediction) with a global dead-block prediction table indexed by compact PC signatures, replacing streaming bypass with lightweight per-line deadness detection. Each cache line is tagged with a 5-bit PC signature, and a small global table (32 entries, 2-bit counters) tracks how often blocks accessed by each signature are reused before eviction. On insertion, lines with cold signatures (low reuse history) are inserted at distant RRPV (likely dead), while hot signatures get MRU. Additionally, every cache line has a 1-bit deadness flag: if a block was not reused before eviction, its signature counter is decayed (dead-block feedback). Unlike streaming detectors, this mechanism adapts to both streaming and irregular workloads, suppressing pollution from dead blocks in lbm/mcf and improving insertion for control-dominated code in astar/milc/omnetpp. The policy uses only SRRIP (no set-dueling or probabilistic insertion), simplifies metadata, and fits well within 64 KiB.",,ChampSim_CRC2/new_policies/023_02_srrip_gdbp__signature_based_rrip_with_global_dead_block_prediction_t07.cc,0.431985238,0.431985238,0%
1630,mcf,SRRIP-GDBP: Signature-based RRIP with Global Dead-Block Prediction,"SRRIP-GDBP combines SRRIP (Static Re-reference Interval Prediction) with a global dead-block prediction table indexed by compact PC signatures, replacing streaming bypass with lightweight per-line deadness detection. Each cache line is tagged with a 5-bit PC signature, and a small global table (32 entries, 2-bit counters) tracks how often blocks accessed by each signature are reused before eviction. On insertion, lines with cold signatures (low reuse history) are inserted at distant RRPV (likely dead), while hot signatures get MRU. Additionally, every cache line has a 1-bit deadness flag: if a block was not reused before eviction, its signature counter is decayed (dead-block feedback). Unlike streaming detectors, this mechanism adapts to both streaming and irregular workloads, suppressing pollution from dead blocks in lbm/mcf and improving insertion for control-dominated code in astar/milc/omnetpp. The policy uses only SRRIP (no set-dueling or probabilistic insertion), simplifies metadata, and fits well within 64 KiB.",,ChampSim_CRC2/new_policies/023_02_srrip_gdbp__signature_based_rrip_with_global_dead_block_prediction_t07.cc,0.468420713,0.468420713,0%
1631,milc,SRRIP-GDBP: Signature-based RRIP with Global Dead-Block Prediction,"SRRIP-GDBP combines SRRIP (Static Re-reference Interval Prediction) with a global dead-block prediction table indexed by compact PC signatures, replacing streaming bypass with lightweight per-line deadness detection. Each cache line is tagged with a 5-bit PC signature, and a small global table (32 entries, 2-bit counters) tracks how often blocks accessed by each signature are reused before eviction. On insertion, lines with cold signatures (low reuse history) are inserted at distant RRPV (likely dead), while hot signatures get MRU. Additionally, every cache line has a 1-bit deadness flag: if a block was not reused before eviction, its signature counter is decayed (dead-block feedback). Unlike streaming detectors, this mechanism adapts to both streaming and irregular workloads, suppressing pollution from dead blocks in lbm/mcf and improving insertion for control-dominated code in astar/milc/omnetpp. The policy uses only SRRIP (no set-dueling or probabilistic insertion), simplifies metadata, and fits well within 64 KiB.",,ChampSim_CRC2/new_policies/023_02_srrip_gdbp__signature_based_rrip_with_global_dead_block_prediction_t07.cc,0.316295792,0.316295792,0%
1632,omnetpp,SRRIP-GDBP: Signature-based RRIP with Global Dead-Block Prediction,"SRRIP-GDBP combines SRRIP (Static Re-reference Interval Prediction) with a global dead-block prediction table indexed by compact PC signatures, replacing streaming bypass with lightweight per-line deadness detection. Each cache line is tagged with a 5-bit PC signature, and a small global table (32 entries, 2-bit counters) tracks how often blocks accessed by each signature are reused before eviction. On insertion, lines with cold signatures (low reuse history) are inserted at distant RRPV (likely dead), while hot signatures get MRU. Additionally, every cache line has a 1-bit deadness flag: if a block was not reused before eviction, its signature counter is decayed (dead-block feedback). Unlike streaming detectors, this mechanism adapts to both streaming and irregular workloads, suppressing pollution from dead blocks in lbm/mcf and improving insertion for control-dominated code in astar/milc/omnetpp. The policy uses only SRRIP (no set-dueling or probabilistic insertion), simplifies metadata, and fits well within 64 KiB.",,ChampSim_CRC2/new_policies/023_02_srrip_gdbp__signature_based_rrip_with_global_dead_block_prediction_t07.cc,0.662220923,0.662220923,0%
1633,all,SRRIP-GDBP: Signature-based RRIP with Global Dead-Block Prediction,"SRRIP-GDBP combines SRRIP (Static Re-reference Interval Prediction) with a global dead-block prediction table indexed by compact PC signatures, replacing streaming bypass with lightweight per-line deadness detection. Each cache line is tagged with a 5-bit PC signature, and a small global table (32 entries, 2-bit counters) tracks how often blocks accessed by each signature are reused before eviction. On insertion, lines with cold signatures (low reuse history) are inserted at distant RRPV (likely dead), while hot signatures get MRU. Additionally, every cache line has a 1-bit deadness flag: if a block was not reused before eviction, its signature counter is decayed (dead-block feedback). Unlike streaming detectors, this mechanism adapts to both streaming and irregular workloads, suppressing pollution from dead blocks in lbm/mcf and improving insertion for control-dominated code in astar/milc/omnetpp. The policy uses only SRRIP (no set-dueling or probabilistic insertion), simplifies metadata, and fits well within 64 KiB.",,ChampSim_CRC2/new_policies/023_02_srrip_gdbp__signature_based_rrip_with_global_dead_block_prediction_t07.cc,0.466071426,0.466071426,47%
1634,astar,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) set-dueling and a lightweight streaming detector for address monotonicity. Each cache line is tagged with a 6-bit PC signature, and a global table of 64 entries (2-bit counters) tracks signature reuse. DRRIP set-dueling (using 32 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths. On insertion, SHiP biases insertion depth: hot signatures (counter ≥2) get MRU, cold get distant. Additionally, a streaming detector tracks recent address deltas per set; if a block is part of a detected streaming pattern, it is inserted at distant RRPV or bypassed if the set is highly streaming. This hybrid approach improves performance by adapting insertion depth to both code phase (via SHiP) and access pattern (via streaming detection), reducing pollution in streaming workloads (lbm, mcf) and boosting reuse in control-dominated workloads (astar, milc, omnetpp). Metadata fits well within 64 KiB.",,ChampSim_CRC2/new_policies/042_00_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t02.cc,0.429776645,0.429776645,0%
1635,lbm,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) set-dueling and a lightweight streaming detector for address monotonicity. Each cache line is tagged with a 6-bit PC signature, and a global table of 64 entries (2-bit counters) tracks signature reuse. DRRIP set-dueling (using 32 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths. On insertion, SHiP biases insertion depth: hot signatures (counter ≥2) get MRU, cold get distant. Additionally, a streaming detector tracks recent address deltas per set; if a block is part of a detected streaming pattern, it is inserted at distant RRPV or bypassed if the set is highly streaming. This hybrid approach improves performance by adapting insertion depth to both code phase (via SHiP) and access pattern (via streaming detection), reducing pollution in streaming workloads (lbm, mcf) and boosting reuse in control-dominated workloads (astar, milc, omnetpp). Metadata fits well within 64 KiB.",,ChampSim_CRC2/new_policies/042_00_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t02.cc,0.413302422,0.413302422,0%
1636,mcf,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) set-dueling and a lightweight streaming detector for address monotonicity. Each cache line is tagged with a 6-bit PC signature, and a global table of 64 entries (2-bit counters) tracks signature reuse. DRRIP set-dueling (using 32 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths. On insertion, SHiP biases insertion depth: hot signatures (counter ≥2) get MRU, cold get distant. Additionally, a streaming detector tracks recent address deltas per set; if a block is part of a detected streaming pattern, it is inserted at distant RRPV or bypassed if the set is highly streaming. This hybrid approach improves performance by adapting insertion depth to both code phase (via SHiP) and access pattern (via streaming detection), reducing pollution in streaming workloads (lbm, mcf) and boosting reuse in control-dominated workloads (astar, milc, omnetpp). Metadata fits well within 64 KiB.",,ChampSim_CRC2/new_policies/042_00_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t02.cc,0.465341471,0.465341471,0%
1637,milc,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) set-dueling and a lightweight streaming detector for address monotonicity. Each cache line is tagged with a 6-bit PC signature, and a global table of 64 entries (2-bit counters) tracks signature reuse. DRRIP set-dueling (using 32 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths. On insertion, SHiP biases insertion depth: hot signatures (counter ≥2) get MRU, cold get distant. Additionally, a streaming detector tracks recent address deltas per set; if a block is part of a detected streaming pattern, it is inserted at distant RRPV or bypassed if the set is highly streaming. This hybrid approach improves performance by adapting insertion depth to both code phase (via SHiP) and access pattern (via streaming detection), reducing pollution in streaming workloads (lbm, mcf) and boosting reuse in control-dominated workloads (astar, milc, omnetpp). Metadata fits well within 64 KiB.",,ChampSim_CRC2/new_policies/042_00_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t02.cc,0.309063557,0.309063557,0%
1638,omnetpp,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite (Signature-based Hit Predictor) with DRRIP (Dynamic RRIP) set-dueling and a lightweight streaming detector for address monotonicity. Each cache line is tagged with a 6-bit PC signature, and a global table of 64 entries (2-bit counters) tracks signature reuse. DRRIP set-dueling (using 32 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths. On insertion, SHiP biases insertion depth: hot signatures (counter ≥2) get MRU, cold get distant. Additionally, a streaming detector tracks recent address deltas per set; if a block is part of a detected streaming pattern, it is inserted at distant RRPV or bypassed if the set is highly streaming. This hybrid approach improves performance by adapting insertion depth to both code phase (via SHiP) and access pattern (via streaming detection), reducing pollution in streaming workloads (lbm, mcf) and boosting reuse in control-dominated workloads (astar, milc, omnetpp). Metadata fits well within 64 KiB.",,ChampSim_CRC2/new_policies/042_00_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t02.cc,0.649146143,0.649146143,0%
1639,astar,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite signature-based insertion depth control with DRRIP set-dueling and a compact streaming detector for address-delta-based bypass. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depth (MRU for hot signatures, distant for cold), adapting to control-flow and pointer-heavy workloads (astar, milc, omnetpp, mcf). DRRIP set-dueling (10-bit PSEL, 32 leader sets) dynamically chooses between SRRIP and BRRIP for baseline insertion, improving robustness across phase changes. A lightweight streaming detector (per-set, 8 bits) identifies monotonic address deltas and bypasses insertion for detected streaming patterns, reducing pollution in workloads like lbm and mcf. Metadata is compact (≈32 KiB for SHiP table, <1 KiB for streaming, <1 KiB for PSEL), and the policy is highly adaptive, outperforming static or single-source predictors across all workload types.",,ChampSim_CRC2/new_policies/042_01_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t04.cc,0.452830657,0.452830657,0%
1640,lbm,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite signature-based insertion depth control with DRRIP set-dueling and a compact streaming detector for address-delta-based bypass. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depth (MRU for hot signatures, distant for cold), adapting to control-flow and pointer-heavy workloads (astar, milc, omnetpp, mcf). DRRIP set-dueling (10-bit PSEL, 32 leader sets) dynamically chooses between SRRIP and BRRIP for baseline insertion, improving robustness across phase changes. A lightweight streaming detector (per-set, 8 bits) identifies monotonic address deltas and bypasses insertion for detected streaming patterns, reducing pollution in workloads like lbm and mcf. Metadata is compact (≈32 KiB for SHiP table, <1 KiB for streaming, <1 KiB for PSEL), and the policy is highly adaptive, outperforming static or single-source predictors across all workload types.",,ChampSim_CRC2/new_policies/042_01_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t04.cc,0.435335553,0.435335553,0%
1641,mcf,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite signature-based insertion depth control with DRRIP set-dueling and a compact streaming detector for address-delta-based bypass. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depth (MRU for hot signatures, distant for cold), adapting to control-flow and pointer-heavy workloads (astar, milc, omnetpp, mcf). DRRIP set-dueling (10-bit PSEL, 32 leader sets) dynamically chooses between SRRIP and BRRIP for baseline insertion, improving robustness across phase changes. A lightweight streaming detector (per-set, 8 bits) identifies monotonic address deltas and bypasses insertion for detected streaming patterns, reducing pollution in workloads like lbm and mcf. Metadata is compact (≈32 KiB for SHiP table, <1 KiB for streaming, <1 KiB for PSEL), and the policy is highly adaptive, outperforming static or single-source predictors across all workload types.",,ChampSim_CRC2/new_policies/042_01_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t04.cc,0.431210977,0.431210977,0%
1642,milc,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite signature-based insertion depth control with DRRIP set-dueling and a compact streaming detector for address-delta-based bypass. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depth (MRU for hot signatures, distant for cold), adapting to control-flow and pointer-heavy workloads (astar, milc, omnetpp, mcf). DRRIP set-dueling (10-bit PSEL, 32 leader sets) dynamically chooses between SRRIP and BRRIP for baseline insertion, improving robustness across phase changes. A lightweight streaming detector (per-set, 8 bits) identifies monotonic address deltas and bypasses insertion for detected streaming patterns, reducing pollution in workloads like lbm and mcf. Metadata is compact (≈32 KiB for SHiP table, <1 KiB for streaming, <1 KiB for PSEL), and the policy is highly adaptive, outperforming static or single-source predictors across all workload types.",,ChampSim_CRC2/new_policies/042_01_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t04.cc,0.320636944,0.320636944,0%
1643,omnetpp,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"This policy combines SHiP-lite signature-based insertion depth control with DRRIP set-dueling and a compact streaming detector for address-delta-based bypass. SHiP-lite uses 6-bit PC signatures and 2-bit outcome counters to bias block insertion depth (MRU for hot signatures, distant for cold), adapting to control-flow and pointer-heavy workloads (astar, milc, omnetpp, mcf). DRRIP set-dueling (10-bit PSEL, 32 leader sets) dynamically chooses between SRRIP and BRRIP for baseline insertion, improving robustness across phase changes. A lightweight streaming detector (per-set, 8 bits) identifies monotonic address deltas and bypasses insertion for detected streaming patterns, reducing pollution in workloads like lbm and mcf. Metadata is compact (≈32 KiB for SHiP table, <1 KiB for streaming, <1 KiB for PSEL), and the policy is highly adaptive, outperforming static or single-source predictors across all workload types.",,ChampSim_CRC2/new_policies/042_01_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t04.cc,0.565269518,0.565269518,0%
1644,astar,SHiP-lite + Streaming Bypass (SHiP-SDB),"SHiP-SDB merges a compact SHiP-lite predictor with a fast streaming detector to adapt insertion policy per access source and memory pattern. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit outcome counter (per signature, 64 entries). On block insertion, the policy checks both the SHiP prediction (based on signature reuse history) and a streaming detector that flags near-monotonic physical address deltas within sets. If the streaming detector reports a streaming access (e.g., LBM, MCF phases), new blocks are inserted at distant RRPV or bypassed if the SHiP counter is cold; this reduces pollution from one-shot blocks. For control-dominated or irregular workloads (ASTAR, OMNETPP, MILC), the SHiP counter enables deeper insertion for hot code paths, improving hit rate. Set-dueling (32 leader sets) dynamically selects between SRRIP and streaming bypass for optimal balance, using an 10-bit PSEL selector. The metadata (6-bit signatures, 2-bit counters, streaming flags) fits comfortably within 64 KiB. This hybrid approach improves performance by tuning insertion depth and bypass on both access context (PC) and memory pattern, exploiting spatial locality and suppressing dead blocks.",,ChampSim_CRC2/new_policies/042_02_ship_lite___streaming_bypass__ship_sdb_t07.cc,0.429812967,0.429812967,0%
1645,lbm,SHiP-lite + Streaming Bypass (SHiP-SDB),"SHiP-SDB merges a compact SHiP-lite predictor with a fast streaming detector to adapt insertion policy per access source and memory pattern. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit outcome counter (per signature, 64 entries). On block insertion, the policy checks both the SHiP prediction (based on signature reuse history) and a streaming detector that flags near-monotonic physical address deltas within sets. If the streaming detector reports a streaming access (e.g., LBM, MCF phases), new blocks are inserted at distant RRPV or bypassed if the SHiP counter is cold; this reduces pollution from one-shot blocks. For control-dominated or irregular workloads (ASTAR, OMNETPP, MILC), the SHiP counter enables deeper insertion for hot code paths, improving hit rate. Set-dueling (32 leader sets) dynamically selects between SRRIP and streaming bypass for optimal balance, using an 10-bit PSEL selector. The metadata (6-bit signatures, 2-bit counters, streaming flags) fits comfortably within 64 KiB. This hybrid approach improves performance by tuning insertion depth and bypass on both access context (PC) and memory pattern, exploiting spatial locality and suppressing dead blocks.",,ChampSim_CRC2/new_policies/042_02_ship_lite___streaming_bypass__ship_sdb_t07.cc,0.413437245,0.413437245,0%
1646,mcf,SHiP-lite + Streaming Bypass (SHiP-SDB),"SHiP-SDB merges a compact SHiP-lite predictor with a fast streaming detector to adapt insertion policy per access source and memory pattern. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit outcome counter (per signature, 64 entries). On block insertion, the policy checks both the SHiP prediction (based on signature reuse history) and a streaming detector that flags near-monotonic physical address deltas within sets. If the streaming detector reports a streaming access (e.g., LBM, MCF phases), new blocks are inserted at distant RRPV or bypassed if the SHiP counter is cold; this reduces pollution from one-shot blocks. For control-dominated or irregular workloads (ASTAR, OMNETPP, MILC), the SHiP counter enables deeper insertion for hot code paths, improving hit rate. Set-dueling (32 leader sets) dynamically selects between SRRIP and streaming bypass for optimal balance, using an 10-bit PSEL selector. The metadata (6-bit signatures, 2-bit counters, streaming flags) fits comfortably within 64 KiB. This hybrid approach improves performance by tuning insertion depth and bypass on both access context (PC) and memory pattern, exploiting spatial locality and suppressing dead blocks.",,ChampSim_CRC2/new_policies/042_02_ship_lite___streaming_bypass__ship_sdb_t07.cc,0.46560483,0.46560483,0%
1647,milc,SHiP-lite + Streaming Bypass (SHiP-SDB),"SHiP-SDB merges a compact SHiP-lite predictor with a fast streaming detector to adapt insertion policy per access source and memory pattern. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit outcome counter (per signature, 64 entries). On block insertion, the policy checks both the SHiP prediction (based on signature reuse history) and a streaming detector that flags near-monotonic physical address deltas within sets. If the streaming detector reports a streaming access (e.g., LBM, MCF phases), new blocks are inserted at distant RRPV or bypassed if the SHiP counter is cold; this reduces pollution from one-shot blocks. For control-dominated or irregular workloads (ASTAR, OMNETPP, MILC), the SHiP counter enables deeper insertion for hot code paths, improving hit rate. Set-dueling (32 leader sets) dynamically selects between SRRIP and streaming bypass for optimal balance, using an 10-bit PSEL selector. The metadata (6-bit signatures, 2-bit counters, streaming flags) fits comfortably within 64 KiB. This hybrid approach improves performance by tuning insertion depth and bypass on both access context (PC) and memory pattern, exploiting spatial locality and suppressing dead blocks.",,ChampSim_CRC2/new_policies/042_02_ship_lite___streaming_bypass__ship_sdb_t07.cc,0.308942265,0.308942265,0%
1648,omnetpp,SHiP-lite + Streaming Bypass (SHiP-SDB),"SHiP-SDB merges a compact SHiP-lite predictor with a fast streaming detector to adapt insertion policy per access source and memory pattern. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit outcome counter (per signature, 64 entries). On block insertion, the policy checks both the SHiP prediction (based on signature reuse history) and a streaming detector that flags near-monotonic physical address deltas within sets. If the streaming detector reports a streaming access (e.g., LBM, MCF phases), new blocks are inserted at distant RRPV or bypassed if the SHiP counter is cold; this reduces pollution from one-shot blocks. For control-dominated or irregular workloads (ASTAR, OMNETPP, MILC), the SHiP counter enables deeper insertion for hot code paths, improving hit rate. Set-dueling (32 leader sets) dynamically selects between SRRIP and streaming bypass for optimal balance, using an 10-bit PSEL selector. The metadata (6-bit signatures, 2-bit counters, streaming flags) fits comfortably within 64 KiB. This hybrid approach improves performance by tuning insertion depth and bypass on both access context (PC) and memory pattern, exploiting spatial locality and suppressing dead blocks.",,ChampSim_CRC2/new_policies/042_02_ship_lite___streaming_bypass__ship_sdb_t07.cc,0.649504029,0.649504029,0%
1649,all,SHiP-lite + Streaming Bypass (SHiP-SDB),"SHiP-SDB merges a compact SHiP-lite predictor with a fast streaming detector to adapt insertion policy per access source and memory pattern. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit outcome counter (per signature, 64 entries). On block insertion, the policy checks both the SHiP prediction (based on signature reuse history) and a streaming detector that flags near-monotonic physical address deltas within sets. If the streaming detector reports a streaming access (e.g., LBM, MCF phases), new blocks are inserted at distant RRPV or bypassed if the SHiP counter is cold; this reduces pollution from one-shot blocks. For control-dominated or irregular workloads (ASTAR, OMNETPP, MILC), the SHiP counter enables deeper insertion for hot code paths, improving hit rate. Set-dueling (32 leader sets) dynamically selects between SRRIP and streaming bypass for optimal balance, using an 10-bit PSEL selector. The metadata (6-bit signatures, 2-bit counters, streaming flags) fits comfortably within 64 KiB. This hybrid approach improves performance by tuning insertion depth and bypass on both access context (PC) and memory pattern, exploiting spatial locality and suppressing dead blocks.",,ChampSim_CRC2/new_policies/042_02_ship_lite___streaming_bypass__ship_sdb_t07.cc,0.453460267,0.453460267,45%
1650,astar,SHiP-DBR: SHiP-lite + Dead-Block Reuse (with Adaptive Insertion Depth),"SHiP-DBR combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block approximation to more accurately identify blocks likely to be reused, while adaptively controlling insertion depth using set-dueling between SRRIP and BRRIP. Each cache line tracks a 2-bit dead-block counter (decayed periodically) and a 6-bit PC signature. The global SHiP-lite table (64 entries, 2 bits each) biases insertion depth for blocks with hot signatures. On insertion, the policy consults both the SHiP counter and the dead-block counter: blocks predicted dead (counter=0) and cold (SHiP counter≤1) are inserted at distant RRPV or bypassed (BRRIP), while hot/reused blocks are inserted at MRU (SRRIP). Set-dueling (32 leader sets per policy, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-leader sets. This hybrid approach improves hit rate by suppressing dead blocks and retaining hot/reused blocks, adapting quickly to phase changes and irregular access patterns (e.g., MCF, MILC, OMNETPP), while handling streaming and spatial locality (LBM) via BRRIP. Metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/043_00_ship_dbr__ship_lite___dead_block_reuse__with_adaptive_insertion_depth_t02.cc,0.454947094,0.454947094,0%
1651,lbm,SHiP-DBR: SHiP-lite + Dead-Block Reuse (with Adaptive Insertion Depth),"SHiP-DBR combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block approximation to more accurately identify blocks likely to be reused, while adaptively controlling insertion depth using set-dueling between SRRIP and BRRIP. Each cache line tracks a 2-bit dead-block counter (decayed periodically) and a 6-bit PC signature. The global SHiP-lite table (64 entries, 2 bits each) biases insertion depth for blocks with hot signatures. On insertion, the policy consults both the SHiP counter and the dead-block counter: blocks predicted dead (counter=0) and cold (SHiP counter≤1) are inserted at distant RRPV or bypassed (BRRIP), while hot/reused blocks are inserted at MRU (SRRIP). Set-dueling (32 leader sets per policy, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-leader sets. This hybrid approach improves hit rate by suppressing dead blocks and retaining hot/reused blocks, adapting quickly to phase changes and irregular access patterns (e.g., MCF, MILC, OMNETPP), while handling streaming and spatial locality (LBM) via BRRIP. Metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/043_00_ship_dbr__ship_lite___dead_block_reuse__with_adaptive_insertion_depth_t02.cc,0.43992869,0.43992869,0%
1652,mcf,SHiP-DBR: SHiP-lite + Dead-Block Reuse (with Adaptive Insertion Depth),"SHiP-DBR combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block approximation to more accurately identify blocks likely to be reused, while adaptively controlling insertion depth using set-dueling between SRRIP and BRRIP. Each cache line tracks a 2-bit dead-block counter (decayed periodically) and a 6-bit PC signature. The global SHiP-lite table (64 entries, 2 bits each) biases insertion depth for blocks with hot signatures. On insertion, the policy consults both the SHiP counter and the dead-block counter: blocks predicted dead (counter=0) and cold (SHiP counter≤1) are inserted at distant RRPV or bypassed (BRRIP), while hot/reused blocks are inserted at MRU (SRRIP). Set-dueling (32 leader sets per policy, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-leader sets. This hybrid approach improves hit rate by suppressing dead blocks and retaining hot/reused blocks, adapting quickly to phase changes and irregular access patterns (e.g., MCF, MILC, OMNETPP), while handling streaming and spatial locality (LBM) via BRRIP. Metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/043_00_ship_dbr__ship_lite___dead_block_reuse__with_adaptive_insertion_depth_t02.cc,0.402761442,0.402761442,0%
1653,milc,SHiP-DBR: SHiP-lite + Dead-Block Reuse (with Adaptive Insertion Depth),"SHiP-DBR combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block approximation to more accurately identify blocks likely to be reused, while adaptively controlling insertion depth using set-dueling between SRRIP and BRRIP. Each cache line tracks a 2-bit dead-block counter (decayed periodically) and a 6-bit PC signature. The global SHiP-lite table (64 entries, 2 bits each) biases insertion depth for blocks with hot signatures. On insertion, the policy consults both the SHiP counter and the dead-block counter: blocks predicted dead (counter=0) and cold (SHiP counter≤1) are inserted at distant RRPV or bypassed (BRRIP), while hot/reused blocks are inserted at MRU (SRRIP). Set-dueling (32 leader sets per policy, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-leader sets. This hybrid approach improves hit rate by suppressing dead blocks and retaining hot/reused blocks, adapting quickly to phase changes and irregular access patterns (e.g., MCF, MILC, OMNETPP), while handling streaming and spatial locality (LBM) via BRRIP. Metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/043_00_ship_dbr__ship_lite___dead_block_reuse__with_adaptive_insertion_depth_t02.cc,0.321811842,0.321811842,0%
1654,omnetpp,SHiP-DBR: SHiP-lite + Dead-Block Reuse (with Adaptive Insertion Depth),"SHiP-DBR combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block approximation to more accurately identify blocks likely to be reused, while adaptively controlling insertion depth using set-dueling between SRRIP and BRRIP. Each cache line tracks a 2-bit dead-block counter (decayed periodically) and a 6-bit PC signature. The global SHiP-lite table (64 entries, 2 bits each) biases insertion depth for blocks with hot signatures. On insertion, the policy consults both the SHiP counter and the dead-block counter: blocks predicted dead (counter=0) and cold (SHiP counter≤1) are inserted at distant RRPV or bypassed (BRRIP), while hot/reused blocks are inserted at MRU (SRRIP). Set-dueling (32 leader sets per policy, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-leader sets. This hybrid approach improves hit rate by suppressing dead blocks and retaining hot/reused blocks, adapting quickly to phase changes and irregular access patterns (e.g., MCF, MILC, OMNETPP), while handling streaming and spatial locality (LBM) via BRRIP. Metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/043_00_ship_dbr__ship_lite___dead_block_reuse__with_adaptive_insertion_depth_t02.cc,0.460104622,0.460104622,0%
1655,astar,SHiP-DBR: SHiP-lite + Dead-Block Reuse (DBR) Hybrid,"SHiP-DBR combines SHiP-lite PC-based reuse prediction with a per-block dead-block approximation to refine insertion and retention decisions. Each cache line tracks a compact 2-bit dead-block counter, incremented on non-reuse and decayed periodically, providing a direct signal for blocks that are likely dead regardless of PC history. SHiP-lite maintains 6-bit PC signatures and 2-bit outcome counters for insertion bias. On insertion, both the SHiP prediction and the dead-block counter are consulted: blocks with cold PC signatures or high dead-block counts are inserted at distant RRPV or bypassed, while hot signatures and low dead-block counts are inserted MRU. Set-dueling (32 leader sets for SHiP vs DBR) dynamically tunes the policy mix via a 10-bit PSEL. This hybrid approach improves performance by suppressing dead blocks from streaming/pointer-chasing phases (LBM, MCF) and retaining useful blocks in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP), leveraging both access context and direct reuse observation. Total metadata fits in <64 KiB.",,ChampSim_CRC2/new_policies/043_01_ship_dbr__ship_lite___dead_block_reuse__dbr__hybrid_t04.cc,0.429813853,0.429813853,0%
1656,lbm,SHiP-DBR: SHiP-lite + Dead-Block Reuse (DBR) Hybrid,"SHiP-DBR combines SHiP-lite PC-based reuse prediction with a per-block dead-block approximation to refine insertion and retention decisions. Each cache line tracks a compact 2-bit dead-block counter, incremented on non-reuse and decayed periodically, providing a direct signal for blocks that are likely dead regardless of PC history. SHiP-lite maintains 6-bit PC signatures and 2-bit outcome counters for insertion bias. On insertion, both the SHiP prediction and the dead-block counter are consulted: blocks with cold PC signatures or high dead-block counts are inserted at distant RRPV or bypassed, while hot signatures and low dead-block counts are inserted MRU. Set-dueling (32 leader sets for SHiP vs DBR) dynamically tunes the policy mix via a 10-bit PSEL. This hybrid approach improves performance by suppressing dead blocks from streaming/pointer-chasing phases (LBM, MCF) and retaining useful blocks in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP), leveraging both access context and direct reuse observation. Total metadata fits in <64 KiB.",,ChampSim_CRC2/new_policies/043_01_ship_dbr__ship_lite___dead_block_reuse__dbr__hybrid_t04.cc,0.41347888,0.41347888,0%
1657,mcf,SHiP-DBR: SHiP-lite + Dead-Block Reuse (DBR) Hybrid,"SHiP-DBR combines SHiP-lite PC-based reuse prediction with a per-block dead-block approximation to refine insertion and retention decisions. Each cache line tracks a compact 2-bit dead-block counter, incremented on non-reuse and decayed periodically, providing a direct signal for blocks that are likely dead regardless of PC history. SHiP-lite maintains 6-bit PC signatures and 2-bit outcome counters for insertion bias. On insertion, both the SHiP prediction and the dead-block counter are consulted: blocks with cold PC signatures or high dead-block counts are inserted at distant RRPV or bypassed, while hot signatures and low dead-block counts are inserted MRU. Set-dueling (32 leader sets for SHiP vs DBR) dynamically tunes the policy mix via a 10-bit PSEL. This hybrid approach improves performance by suppressing dead blocks from streaming/pointer-chasing phases (LBM, MCF) and retaining useful blocks in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP), leveraging both access context and direct reuse observation. Total metadata fits in <64 KiB.",,ChampSim_CRC2/new_policies/043_01_ship_dbr__ship_lite___dead_block_reuse__dbr__hybrid_t04.cc,0.465751563,0.465751563,0%
1658,milc,SHiP-DBR: SHiP-lite + Dead-Block Reuse (DBR) Hybrid,"SHiP-DBR combines SHiP-lite PC-based reuse prediction with a per-block dead-block approximation to refine insertion and retention decisions. Each cache line tracks a compact 2-bit dead-block counter, incremented on non-reuse and decayed periodically, providing a direct signal for blocks that are likely dead regardless of PC history. SHiP-lite maintains 6-bit PC signatures and 2-bit outcome counters for insertion bias. On insertion, both the SHiP prediction and the dead-block counter are consulted: blocks with cold PC signatures or high dead-block counts are inserted at distant RRPV or bypassed, while hot signatures and low dead-block counts are inserted MRU. Set-dueling (32 leader sets for SHiP vs DBR) dynamically tunes the policy mix via a 10-bit PSEL. This hybrid approach improves performance by suppressing dead blocks from streaming/pointer-chasing phases (LBM, MCF) and retaining useful blocks in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP), leveraging both access context and direct reuse observation. Total metadata fits in <64 KiB.",,ChampSim_CRC2/new_policies/043_01_ship_dbr__ship_lite___dead_block_reuse__dbr__hybrid_t04.cc,0.309289847,0.309289847,0%
1659,omnetpp,SHiP-DBR: SHiP-lite + Dead-Block Reuse (DBR) Hybrid,"SHiP-DBR combines SHiP-lite PC-based reuse prediction with a per-block dead-block approximation to refine insertion and retention decisions. Each cache line tracks a compact 2-bit dead-block counter, incremented on non-reuse and decayed periodically, providing a direct signal for blocks that are likely dead regardless of PC history. SHiP-lite maintains 6-bit PC signatures and 2-bit outcome counters for insertion bias. On insertion, both the SHiP prediction and the dead-block counter are consulted: blocks with cold PC signatures or high dead-block counts are inserted at distant RRPV or bypassed, while hot signatures and low dead-block counts are inserted MRU. Set-dueling (32 leader sets for SHiP vs DBR) dynamically tunes the policy mix via a 10-bit PSEL. This hybrid approach improves performance by suppressing dead blocks from streaming/pointer-chasing phases (LBM, MCF) and retaining useful blocks in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP), leveraging both access context and direct reuse observation. Total metadata fits in <64 KiB.",,ChampSim_CRC2/new_policies/043_01_ship_dbr__ship_lite___dead_block_reuse__dbr__hybrid_t04.cc,0.646414277,0.646414277,0%
1660,astar,SHiP-DeadBlock Dynamic Insertion (SHiP-DBDI),"SHiP-DBDI combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to more accurately identify and suppress cache pollution from one-shot and streaming accesses. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit SHiP outcome counter (64 entries). Additionally, every block tracks a 2-bit dead-block counter that is incremented on misses and decayed periodically, indicating probable dead-on-arrival status. On insertion, the policy dynamically selects between MRU (rrpv=0), mid (rrpv=2), or LRU/bypass (rrpv=3) based on both signature hotness and dead-block evidence. Set-dueling between SRRIP and SHiP-DBDI controls overall insertion aggressiveness using a 10-bit PSEL. This approach improves performance by tightly targeting blocks that are unlikely to be reused (as indicated by both signature and dead-block status), minimizing pollution from streaming and pointer-chasing accesses (e.g., LBM, MCF, OMNETPP) while favoring hot code paths for irregular/control workloads (ASTAR, MILC). The metadata fits within 64 KiB, and periodic decay prevents stale dead-block predictions.",,ChampSim_CRC2/new_policies/043_02_ship_deadblock_dynamic_insertion__ship_dbdi_t07.cc,0.428458412,0.428458412,0%
1661,lbm,SHiP-DeadBlock Dynamic Insertion (SHiP-DBDI),"SHiP-DBDI combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to more accurately identify and suppress cache pollution from one-shot and streaming accesses. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit SHiP outcome counter (64 entries). Additionally, every block tracks a 2-bit dead-block counter that is incremented on misses and decayed periodically, indicating probable dead-on-arrival status. On insertion, the policy dynamically selects between MRU (rrpv=0), mid (rrpv=2), or LRU/bypass (rrpv=3) based on both signature hotness and dead-block evidence. Set-dueling between SRRIP and SHiP-DBDI controls overall insertion aggressiveness using a 10-bit PSEL. This approach improves performance by tightly targeting blocks that are unlikely to be reused (as indicated by both signature and dead-block status), minimizing pollution from streaming and pointer-chasing accesses (e.g., LBM, MCF, OMNETPP) while favoring hot code paths for irregular/control workloads (ASTAR, MILC). The metadata fits within 64 KiB, and periodic decay prevents stale dead-block predictions.",,ChampSim_CRC2/new_policies/043_02_ship_deadblock_dynamic_insertion__ship_dbdi_t07.cc,0.412556444,0.412556444,0%
1662,mcf,SHiP-DeadBlock Dynamic Insertion (SHiP-DBDI),"SHiP-DBDI combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to more accurately identify and suppress cache pollution from one-shot and streaming accesses. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit SHiP outcome counter (64 entries). Additionally, every block tracks a 2-bit dead-block counter that is incremented on misses and decayed periodically, indicating probable dead-on-arrival status. On insertion, the policy dynamically selects between MRU (rrpv=0), mid (rrpv=2), or LRU/bypass (rrpv=3) based on both signature hotness and dead-block evidence. Set-dueling between SRRIP and SHiP-DBDI controls overall insertion aggressiveness using a 10-bit PSEL. This approach improves performance by tightly targeting blocks that are unlikely to be reused (as indicated by both signature and dead-block status), minimizing pollution from streaming and pointer-chasing accesses (e.g., LBM, MCF, OMNETPP) while favoring hot code paths for irregular/control workloads (ASTAR, MILC). The metadata fits within 64 KiB, and periodic decay prevents stale dead-block predictions.",,ChampSim_CRC2/new_policies/043_02_ship_deadblock_dynamic_insertion__ship_dbdi_t07.cc,0.465639288,0.465639288,0%
1663,milc,SHiP-DeadBlock Dynamic Insertion (SHiP-DBDI),"SHiP-DBDI combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to more accurately identify and suppress cache pollution from one-shot and streaming accesses. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit SHiP outcome counter (64 entries). Additionally, every block tracks a 2-bit dead-block counter that is incremented on misses and decayed periodically, indicating probable dead-on-arrival status. On insertion, the policy dynamically selects between MRU (rrpv=0), mid (rrpv=2), or LRU/bypass (rrpv=3) based on both signature hotness and dead-block evidence. Set-dueling between SRRIP and SHiP-DBDI controls overall insertion aggressiveness using a 10-bit PSEL. This approach improves performance by tightly targeting blocks that are unlikely to be reused (as indicated by both signature and dead-block status), minimizing pollution from streaming and pointer-chasing accesses (e.g., LBM, MCF, OMNETPP) while favoring hot code paths for irregular/control workloads (ASTAR, MILC). The metadata fits within 64 KiB, and periodic decay prevents stale dead-block predictions.",,ChampSim_CRC2/new_policies/043_02_ship_deadblock_dynamic_insertion__ship_dbdi_t07.cc,0.274118916,0.274118916,0%
1664,omnetpp,SHiP-DeadBlock Dynamic Insertion (SHiP-DBDI),"SHiP-DBDI combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter to more accurately identify and suppress cache pollution from one-shot and streaming accesses. Each cache line is tagged with a 6-bit PC signature and a tiny 2-bit SHiP outcome counter (64 entries). Additionally, every block tracks a 2-bit dead-block counter that is incremented on misses and decayed periodically, indicating probable dead-on-arrival status. On insertion, the policy dynamically selects between MRU (rrpv=0), mid (rrpv=2), or LRU/bypass (rrpv=3) based on both signature hotness and dead-block evidence. Set-dueling between SRRIP and SHiP-DBDI controls overall insertion aggressiveness using a 10-bit PSEL. This approach improves performance by tightly targeting blocks that are unlikely to be reused (as indicated by both signature and dead-block status), minimizing pollution from streaming and pointer-chasing accesses (e.g., LBM, MCF, OMNETPP) while favoring hot code paths for irregular/control workloads (ASTAR, MILC). The metadata fits within 64 KiB, and periodic decay prevents stale dead-block predictions.",,ChampSim_CRC2/new_policies/043_02_ship_deadblock_dynamic_insertion__ship_dbdi_t07.cc,0.651496263,0.651496263,0%
1665,all,SHiP-DBR: SHiP-lite + Dead-Block Reuse (DBR) Hybrid,"SHiP-DBR combines SHiP-lite PC-based reuse prediction with a per-block dead-block approximation to refine insertion and retention decisions. Each cache line tracks a compact 2-bit dead-block counter, incremented on non-reuse and decayed periodically, providing a direct signal for blocks that are likely dead regardless of PC history. SHiP-lite maintains 6-bit PC signatures and 2-bit outcome counters for insertion bias. On insertion, both the SHiP prediction and the dead-block counter are consulted: blocks with cold PC signatures or high dead-block counts are inserted at distant RRPV or bypassed, while hot signatures and low dead-block counts are inserted MRU. Set-dueling (32 leader sets for SHiP vs DBR) dynamically tunes the policy mix via a 10-bit PSEL. This hybrid approach improves performance by suppressing dead blocks from streaming/pointer-chasing phases (LBM, MCF) and retaining useful blocks in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP), leveraging both access context and direct reuse observation. Total metadata fits in <64 KiB.",,ChampSim_CRC2/new_policies/043_01_ship_dbr__ship_lite___dead_block_reuse__dbr__hybrid_t04.cc,0.452949684,0.452949684,45%
1666,astar,SRRIP-BIP + Streaming Detector Hybrid,"This policy combines SRRIP (Static RRIP) and BIP (Bimodal Insertion Policy) with a lightweight streaming detector to adapt insertion depth and bypass logic based on observed memory access patterns. SRRIP favors retaining blocks with potential reuse, while BIP occasionally inserts at MRU to capture bursts of locality. A compact streaming detector tracks recent address deltas per set to identify streaming phases (near-monotonic accesses), triggering distant RRPV insertion or bypass for detected streams. Set-dueling with 32 leader sets and a 10-bit PSEL dynamically selects between SRRIP and BIP for non-streaming accesses. This hybrid approach improves performance by aggressively filtering streaming/pointer-chasing blocks (LBM, MCF), while retaining locality in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP). All metadata fits within 64 KiB, using only small counters and per-set streaming state.",,ChampSim_CRC2/new_policies/044_00_srrip_bip___streaming_detector_hybrid_t02.cc,0.433770323,0.433770323,0%
1667,lbm,SRRIP-BIP + Streaming Detector Hybrid,"This policy combines SRRIP (Static RRIP) and BIP (Bimodal Insertion Policy) with a lightweight streaming detector to adapt insertion depth and bypass logic based on observed memory access patterns. SRRIP favors retaining blocks with potential reuse, while BIP occasionally inserts at MRU to capture bursts of locality. A compact streaming detector tracks recent address deltas per set to identify streaming phases (near-monotonic accesses), triggering distant RRPV insertion or bypass for detected streams. Set-dueling with 32 leader sets and a 10-bit PSEL dynamically selects between SRRIP and BIP for non-streaming accesses. This hybrid approach improves performance by aggressively filtering streaming/pointer-chasing blocks (LBM, MCF), while retaining locality in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP). All metadata fits within 64 KiB, using only small counters and per-set streaming state.",,ChampSim_CRC2/new_policies/044_00_srrip_bip___streaming_detector_hybrid_t02.cc,0.413342291,0.413342291,0%
1668,mcf,SRRIP-BIP + Streaming Detector Hybrid,"This policy combines SRRIP (Static RRIP) and BIP (Bimodal Insertion Policy) with a lightweight streaming detector to adapt insertion depth and bypass logic based on observed memory access patterns. SRRIP favors retaining blocks with potential reuse, while BIP occasionally inserts at MRU to capture bursts of locality. A compact streaming detector tracks recent address deltas per set to identify streaming phases (near-monotonic accesses), triggering distant RRPV insertion or bypass for detected streams. Set-dueling with 32 leader sets and a 10-bit PSEL dynamically selects between SRRIP and BIP for non-streaming accesses. This hybrid approach improves performance by aggressively filtering streaming/pointer-chasing blocks (LBM, MCF), while retaining locality in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP). All metadata fits within 64 KiB, using only small counters and per-set streaming state.",,ChampSim_CRC2/new_policies/044_00_srrip_bip___streaming_detector_hybrid_t02.cc,0.460011558,0.460011558,0%
1669,milc,SRRIP-BIP + Streaming Detector Hybrid,"This policy combines SRRIP (Static RRIP) and BIP (Bimodal Insertion Policy) with a lightweight streaming detector to adapt insertion depth and bypass logic based on observed memory access patterns. SRRIP favors retaining blocks with potential reuse, while BIP occasionally inserts at MRU to capture bursts of locality. A compact streaming detector tracks recent address deltas per set to identify streaming phases (near-monotonic accesses), triggering distant RRPV insertion or bypass for detected streams. Set-dueling with 32 leader sets and a 10-bit PSEL dynamically selects between SRRIP and BIP for non-streaming accesses. This hybrid approach improves performance by aggressively filtering streaming/pointer-chasing blocks (LBM, MCF), while retaining locality in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP). All metadata fits within 64 KiB, using only small counters and per-set streaming state.",,ChampSim_CRC2/new_policies/044_00_srrip_bip___streaming_detector_hybrid_t02.cc,0.310868448,0.310868448,0%
1670,omnetpp,SRRIP-BIP + Streaming Detector Hybrid,"This policy combines SRRIP (Static RRIP) and BIP (Bimodal Insertion Policy) with a lightweight streaming detector to adapt insertion depth and bypass logic based on observed memory access patterns. SRRIP favors retaining blocks with potential reuse, while BIP occasionally inserts at MRU to capture bursts of locality. A compact streaming detector tracks recent address deltas per set to identify streaming phases (near-monotonic accesses), triggering distant RRPV insertion or bypass for detected streams. Set-dueling with 32 leader sets and a 10-bit PSEL dynamically selects between SRRIP and BIP for non-streaming accesses. This hybrid approach improves performance by aggressively filtering streaming/pointer-chasing blocks (LBM, MCF), while retaining locality in control-dominated and phase-changing workloads (ASTAR, MILC, OMNETPP). All metadata fits within 64 KiB, using only small counters and per-set streaming state.",,ChampSim_CRC2/new_policies/044_00_srrip_bip___streaming_detector_hybrid_t02.cc,0.476668794,0.476668794,0%
1671,astar,SRRIP-Streaming Hybrid (SRRIP-SD),"SRRIP-Streaming Hybrid combines classic SRRIP (Static RRIP) insertion depth control with a lightweight streaming detector based on address deltas, dynamically bypassing or deprioritizing blocks in streaming phases. This approach improves performance by retaining blocks with spatial/temporal reuse (LBM, MILC, ASTAR) while suppressing cache pollution from streaming or pointer-chasing phases (MCF, OMNETPP). The streaming detector uses a compact 2-bit per-set saturating counter to identify near-monotonic access patterns; when streaming is detected, new blocks are inserted at distant RRPV or bypassed. Otherwise, SRRIP MRU insertion is used. Set-dueling (32 leader sets for SRRIP vs Streaming) and a 10-bit PSEL selector dynamically tune the policy mix. Metadata fits under 64 KiB, and the mechanism is materially different from SHiP-DBR by changing both the prediction source and insertion/bypass logic.",,ChampSim_CRC2/new_policies/044_01_srrip_streaming_hybrid__srrip_sd_t04.cc,0.454947094,0.454947094,0%
1672,lbm,SRRIP-Streaming Hybrid (SRRIP-SD),"SRRIP-Streaming Hybrid combines classic SRRIP (Static RRIP) insertion depth control with a lightweight streaming detector based on address deltas, dynamically bypassing or deprioritizing blocks in streaming phases. This approach improves performance by retaining blocks with spatial/temporal reuse (LBM, MILC, ASTAR) while suppressing cache pollution from streaming or pointer-chasing phases (MCF, OMNETPP). The streaming detector uses a compact 2-bit per-set saturating counter to identify near-monotonic access patterns; when streaming is detected, new blocks are inserted at distant RRPV or bypassed. Otherwise, SRRIP MRU insertion is used. Set-dueling (32 leader sets for SRRIP vs Streaming) and a 10-bit PSEL selector dynamically tune the policy mix. Metadata fits under 64 KiB, and the mechanism is materially different from SHiP-DBR by changing both the prediction source and insertion/bypass logic.",,ChampSim_CRC2/new_policies/044_01_srrip_streaming_hybrid__srrip_sd_t04.cc,0.43992869,0.43992869,0%
1673,mcf,SRRIP-Streaming Hybrid (SRRIP-SD),"SRRIP-Streaming Hybrid combines classic SRRIP (Static RRIP) insertion depth control with a lightweight streaming detector based on address deltas, dynamically bypassing or deprioritizing blocks in streaming phases. This approach improves performance by retaining blocks with spatial/temporal reuse (LBM, MILC, ASTAR) while suppressing cache pollution from streaming or pointer-chasing phases (MCF, OMNETPP). The streaming detector uses a compact 2-bit per-set saturating counter to identify near-monotonic access patterns; when streaming is detected, new blocks are inserted at distant RRPV or bypassed. Otherwise, SRRIP MRU insertion is used. Set-dueling (32 leader sets for SRRIP vs Streaming) and a 10-bit PSEL selector dynamically tune the policy mix. Metadata fits under 64 KiB, and the mechanism is materially different from SHiP-DBR by changing both the prediction source and insertion/bypass logic.",,ChampSim_CRC2/new_policies/044_01_srrip_streaming_hybrid__srrip_sd_t04.cc,0.402761442,0.402761442,0%
1674,milc,SRRIP-Streaming Hybrid (SRRIP-SD),"SRRIP-Streaming Hybrid combines classic SRRIP (Static RRIP) insertion depth control with a lightweight streaming detector based on address deltas, dynamically bypassing or deprioritizing blocks in streaming phases. This approach improves performance by retaining blocks with spatial/temporal reuse (LBM, MILC, ASTAR) while suppressing cache pollution from streaming or pointer-chasing phases (MCF, OMNETPP). The streaming detector uses a compact 2-bit per-set saturating counter to identify near-monotonic access patterns; when streaming is detected, new blocks are inserted at distant RRPV or bypassed. Otherwise, SRRIP MRU insertion is used. Set-dueling (32 leader sets for SRRIP vs Streaming) and a 10-bit PSEL selector dynamically tune the policy mix. Metadata fits under 64 KiB, and the mechanism is materially different from SHiP-DBR by changing both the prediction source and insertion/bypass logic.",,ChampSim_CRC2/new_policies/044_01_srrip_streaming_hybrid__srrip_sd_t04.cc,0.321811842,0.321811842,0%
1675,omnetpp,SRRIP-Streaming Hybrid (SRRIP-SD),"SRRIP-Streaming Hybrid combines classic SRRIP (Static RRIP) insertion depth control with a lightweight streaming detector based on address deltas, dynamically bypassing or deprioritizing blocks in streaming phases. This approach improves performance by retaining blocks with spatial/temporal reuse (LBM, MILC, ASTAR) while suppressing cache pollution from streaming or pointer-chasing phases (MCF, OMNETPP). The streaming detector uses a compact 2-bit per-set saturating counter to identify near-monotonic access patterns; when streaming is detected, new blocks are inserted at distant RRPV or bypassed. Otherwise, SRRIP MRU insertion is used. Set-dueling (32 leader sets for SRRIP vs Streaming) and a 10-bit PSEL selector dynamically tune the policy mix. Metadata fits under 64 KiB, and the mechanism is materially different from SHiP-DBR by changing both the prediction source and insertion/bypass logic.",,ChampSim_CRC2/new_policies/044_01_srrip_streaming_hybrid__srrip_sd_t04.cc,0.460104622,0.460104622,0%
1676,astar,Stream-SHiP Adaptive Hybrid (SSAH),"SSAH combines SHiP-lite PC-based reuse prediction with an online streaming detector and adaptive insertion depth, set-dueling between SHiP and a streaming-aware bypass/BRRIP branch. Instead of a dead-block counter, SSAH detects streaming or pointer-chasing phases by monitoring address deltas per set and inserts at distant RRPV or bypasses when monotonic access is observed. SHiP-lite continues to bias insertion depth based on hot/cold PC signatures. DIP-style set-dueling (32 leader sets each) and a 10-bit PSEL selector tune the mix. This approach improves performance by quickly suppressing cache pollution from streaming and pointer-heavy phases (LBM, MCF, OMNETPP), while retaining blocks with high reuse potential in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB and leverages compact saturating counters and small per-set streaming detectors for low overhead.",,ChampSim_CRC2/new_policies/044_02_stream_ship_adaptive_hybrid__ssah_t07.cc,0.429813853,0.429813853,0%
1677,lbm,Stream-SHiP Adaptive Hybrid (SSAH),"SSAH combines SHiP-lite PC-based reuse prediction with an online streaming detector and adaptive insertion depth, set-dueling between SHiP and a streaming-aware bypass/BRRIP branch. Instead of a dead-block counter, SSAH detects streaming or pointer-chasing phases by monitoring address deltas per set and inserts at distant RRPV or bypasses when monotonic access is observed. SHiP-lite continues to bias insertion depth based on hot/cold PC signatures. DIP-style set-dueling (32 leader sets each) and a 10-bit PSEL selector tune the mix. This approach improves performance by quickly suppressing cache pollution from streaming and pointer-heavy phases (LBM, MCF, OMNETPP), while retaining blocks with high reuse potential in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB and leverages compact saturating counters and small per-set streaming detectors for low overhead.",,ChampSim_CRC2/new_policies/044_02_stream_ship_adaptive_hybrid__ssah_t07.cc,0.41347888,0.41347888,0%
1678,mcf,Stream-SHiP Adaptive Hybrid (SSAH),"SSAH combines SHiP-lite PC-based reuse prediction with an online streaming detector and adaptive insertion depth, set-dueling between SHiP and a streaming-aware bypass/BRRIP branch. Instead of a dead-block counter, SSAH detects streaming or pointer-chasing phases by monitoring address deltas per set and inserts at distant RRPV or bypasses when monotonic access is observed. SHiP-lite continues to bias insertion depth based on hot/cold PC signatures. DIP-style set-dueling (32 leader sets each) and a 10-bit PSEL selector tune the mix. This approach improves performance by quickly suppressing cache pollution from streaming and pointer-heavy phases (LBM, MCF, OMNETPP), while retaining blocks with high reuse potential in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB and leverages compact saturating counters and small per-set streaming detectors for low overhead.",,ChampSim_CRC2/new_policies/044_02_stream_ship_adaptive_hybrid__ssah_t07.cc,0.465751563,0.465751563,0%
1679,milc,Stream-SHiP Adaptive Hybrid (SSAH),"SSAH combines SHiP-lite PC-based reuse prediction with an online streaming detector and adaptive insertion depth, set-dueling between SHiP and a streaming-aware bypass/BRRIP branch. Instead of a dead-block counter, SSAH detects streaming or pointer-chasing phases by monitoring address deltas per set and inserts at distant RRPV or bypasses when monotonic access is observed. SHiP-lite continues to bias insertion depth based on hot/cold PC signatures. DIP-style set-dueling (32 leader sets each) and a 10-bit PSEL selector tune the mix. This approach improves performance by quickly suppressing cache pollution from streaming and pointer-heavy phases (LBM, MCF, OMNETPP), while retaining blocks with high reuse potential in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB and leverages compact saturating counters and small per-set streaming detectors for low overhead.",,ChampSim_CRC2/new_policies/044_02_stream_ship_adaptive_hybrid__ssah_t07.cc,0.309289847,0.309289847,0%
1680,omnetpp,Stream-SHiP Adaptive Hybrid (SSAH),"SSAH combines SHiP-lite PC-based reuse prediction with an online streaming detector and adaptive insertion depth, set-dueling between SHiP and a streaming-aware bypass/BRRIP branch. Instead of a dead-block counter, SSAH detects streaming or pointer-chasing phases by monitoring address deltas per set and inserts at distant RRPV or bypasses when monotonic access is observed. SHiP-lite continues to bias insertion depth based on hot/cold PC signatures. DIP-style set-dueling (32 leader sets each) and a 10-bit PSEL selector tune the mix. This approach improves performance by quickly suppressing cache pollution from streaming and pointer-heavy phases (LBM, MCF, OMNETPP), while retaining blocks with high reuse potential in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB and leverages compact saturating counters and small per-set streaming detectors for low overhead.",,ChampSim_CRC2/new_policies/044_02_stream_ship_adaptive_hybrid__ssah_t07.cc,0.646414277,0.646414277,0%
1681,all,Stream-SHiP Adaptive Hybrid (SSAH),"SSAH combines SHiP-lite PC-based reuse prediction with an online streaming detector and adaptive insertion depth, set-dueling between SHiP and a streaming-aware bypass/BRRIP branch. Instead of a dead-block counter, SSAH detects streaming or pointer-chasing phases by monitoring address deltas per set and inserts at distant RRPV or bypasses when monotonic access is observed. SHiP-lite continues to bias insertion depth based on hot/cold PC signatures. DIP-style set-dueling (32 leader sets each) and a 10-bit PSEL selector tune the mix. This approach improves performance by quickly suppressing cache pollution from streaming and pointer-heavy phases (LBM, MCF, OMNETPP), while retaining blocks with high reuse potential in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB and leverages compact saturating counters and small per-set streaming detectors for low overhead.",,ChampSim_CRC2/new_policies/044_02_stream_ship_adaptive_hybrid__ssah_t07.cc,0.452949684,0.452949684,45%
1682,astar,DIP-DeadBlock Streaming Hybrid (DDSH),"DDSH combines DIP-style insertion depth control (LIP vs BIP) with a compact per-line dead-block counter and a per-set streaming detector. Leader sets (32 each) track LIP and BIP effectiveness using a 10-bit PSEL selector. Each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate block reusability. The streaming detector monitors address deltas per set and triggers bypass or distant insertion when monotonic access is detected. On insertion, DDSH chooses between LIP/BIP based on PSEL, but overrides with bypass/distant insertion for streaming sets and with MRU insertion for blocks with low dead-block counts. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining reusable blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB: 2 bits per block for dead-block, 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/045_00_dip_deadblock_streaming_hybrid__ddsh_t02.cc,0.45332145,0.45332145,0%
1683,lbm,DIP-DeadBlock Streaming Hybrid (DDSH),"DDSH combines DIP-style insertion depth control (LIP vs BIP) with a compact per-line dead-block counter and a per-set streaming detector. Leader sets (32 each) track LIP and BIP effectiveness using a 10-bit PSEL selector. Each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate block reusability. The streaming detector monitors address deltas per set and triggers bypass or distant insertion when monotonic access is detected. On insertion, DDSH chooses between LIP/BIP based on PSEL, but overrides with bypass/distant insertion for streaming sets and with MRU insertion for blocks with low dead-block counts. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining reusable blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB: 2 bits per block for dead-block, 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/045_00_dip_deadblock_streaming_hybrid__ddsh_t02.cc,0.433401149,0.433401149,0%
1684,mcf,DIP-DeadBlock Streaming Hybrid (DDSH),"DDSH combines DIP-style insertion depth control (LIP vs BIP) with a compact per-line dead-block counter and a per-set streaming detector. Leader sets (32 each) track LIP and BIP effectiveness using a 10-bit PSEL selector. Each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate block reusability. The streaming detector monitors address deltas per set and triggers bypass or distant insertion when monotonic access is detected. On insertion, DDSH chooses between LIP/BIP based on PSEL, but overrides with bypass/distant insertion for streaming sets and with MRU insertion for blocks with low dead-block counts. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining reusable blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB: 2 bits per block for dead-block, 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/045_00_dip_deadblock_streaming_hybrid__ddsh_t02.cc,0.444234681,0.444234681,0%
1685,milc,DIP-DeadBlock Streaming Hybrid (DDSH),"DDSH combines DIP-style insertion depth control (LIP vs BIP) with a compact per-line dead-block counter and a per-set streaming detector. Leader sets (32 each) track LIP and BIP effectiveness using a 10-bit PSEL selector. Each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate block reusability. The streaming detector monitors address deltas per set and triggers bypass or distant insertion when monotonic access is detected. On insertion, DDSH chooses between LIP/BIP based on PSEL, but overrides with bypass/distant insertion for streaming sets and with MRU insertion for blocks with low dead-block counts. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining reusable blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB: 2 bits per block for dead-block, 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/045_00_dip_deadblock_streaming_hybrid__ddsh_t02.cc,0.321768395,0.321768395,0%
1686,omnetpp,DIP-DeadBlock Streaming Hybrid (DDSH),"DDSH combines DIP-style insertion depth control (LIP vs BIP) with a compact per-line dead-block counter and a per-set streaming detector. Leader sets (32 each) track LIP and BIP effectiveness using a 10-bit PSEL selector. Each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate block reusability. The streaming detector monitors address deltas per set and triggers bypass or distant insertion when monotonic access is detected. On insertion, DDSH chooses between LIP/BIP based on PSEL, but overrides with bypass/distant insertion for streaming sets and with MRU insertion for blocks with low dead-block counts. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining reusable blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB: 2 bits per block for dead-block, 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/045_00_dip_deadblock_streaming_hybrid__ddsh_t02.cc,0.448014029,0.448014029,0%
1687,astar,SHiP-Dead Adaptive Streaming (SDAS),"SDAS fuses SHiP-lite PC-based reuse prediction with a compact dead-block counter and an improved streaming detector, switching insertion depth and bypass logic adaptively. Each cache block tracks a 2-bit dead-block counter that decays periodically, allowing rapid identification and bypassing of blocks with no reuse. The streaming detector uses a 3-bit per-set stride score for monotonic access detection. Set-dueling (DIP-style) chooses between SHiP-guided insertion and a dead-block/streaming-aware branch, tuned by a 10-bit PSEL. On streaming or dead-block detection, blocks are inserted at distant RRPV or bypassed; hot signatures and reused blocks get MRU. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining high-reuse blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata remains compact (<64 KiB) via small saturating counters and per-block dead-block bits.",,ChampSim_CRC2/new_policies/045_01_ship_dead_adaptive_streaming__sdas_t04.cc,0.107221576,0.107221576,0%
1688,lbm,SHiP-Dead Adaptive Streaming (SDAS),"SDAS fuses SHiP-lite PC-based reuse prediction with a compact dead-block counter and an improved streaming detector, switching insertion depth and bypass logic adaptively. Each cache block tracks a 2-bit dead-block counter that decays periodically, allowing rapid identification and bypassing of blocks with no reuse. The streaming detector uses a 3-bit per-set stride score for monotonic access detection. Set-dueling (DIP-style) chooses between SHiP-guided insertion and a dead-block/streaming-aware branch, tuned by a 10-bit PSEL. On streaming or dead-block detection, blocks are inserted at distant RRPV or bypassed; hot signatures and reused blocks get MRU. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining high-reuse blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata remains compact (<64 KiB) via small saturating counters and per-block dead-block bits.",,ChampSim_CRC2/new_policies/045_01_ship_dead_adaptive_streaming__sdas_t04.cc,0.090689044,0.090689044,0%
1689,mcf,SHiP-Dead Adaptive Streaming (SDAS),"SDAS fuses SHiP-lite PC-based reuse prediction with a compact dead-block counter and an improved streaming detector, switching insertion depth and bypass logic adaptively. Each cache block tracks a 2-bit dead-block counter that decays periodically, allowing rapid identification and bypassing of blocks with no reuse. The streaming detector uses a 3-bit per-set stride score for monotonic access detection. Set-dueling (DIP-style) chooses between SHiP-guided insertion and a dead-block/streaming-aware branch, tuned by a 10-bit PSEL. On streaming or dead-block detection, blocks are inserted at distant RRPV or bypassed; hot signatures and reused blocks get MRU. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining high-reuse blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata remains compact (<64 KiB) via small saturating counters and per-block dead-block bits.",,ChampSim_CRC2/new_policies/045_01_ship_dead_adaptive_streaming__sdas_t04.cc,0.4166216,0.4166216,0%
1690,milc,SHiP-Dead Adaptive Streaming (SDAS),"SDAS fuses SHiP-lite PC-based reuse prediction with a compact dead-block counter and an improved streaming detector, switching insertion depth and bypass logic adaptively. Each cache block tracks a 2-bit dead-block counter that decays periodically, allowing rapid identification and bypassing of blocks with no reuse. The streaming detector uses a 3-bit per-set stride score for monotonic access detection. Set-dueling (DIP-style) chooses between SHiP-guided insertion and a dead-block/streaming-aware branch, tuned by a 10-bit PSEL. On streaming or dead-block detection, blocks are inserted at distant RRPV or bypassed; hot signatures and reused blocks get MRU. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining high-reuse blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata remains compact (<64 KiB) via small saturating counters and per-block dead-block bits.",,ChampSim_CRC2/new_policies/045_01_ship_dead_adaptive_streaming__sdas_t04.cc,0.084561938,0.084561938,0%
1691,omnetpp,SHiP-Dead Adaptive Streaming (SDAS),"SDAS fuses SHiP-lite PC-based reuse prediction with a compact dead-block counter and an improved streaming detector, switching insertion depth and bypass logic adaptively. Each cache block tracks a 2-bit dead-block counter that decays periodically, allowing rapid identification and bypassing of blocks with no reuse. The streaming detector uses a 3-bit per-set stride score for monotonic access detection. Set-dueling (DIP-style) chooses between SHiP-guided insertion and a dead-block/streaming-aware branch, tuned by a 10-bit PSEL. On streaming or dead-block detection, blocks are inserted at distant RRPV or bypassed; hot signatures and reused blocks get MRU. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining high-reuse blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata remains compact (<64 KiB) via small saturating counters and per-block dead-block bits.",,ChampSim_CRC2/new_policies/045_01_ship_dead_adaptive_streaming__sdas_t04.cc,0.142074906,0.142074906,0%
1692,astar,Dead-Stream SRRIP Hybrid (DSSH),"DSSH integrates compact per-block dead-block prediction with set-dueling SRRIP/BRRIP and a streaming detector to adaptively manage cache insertion depth and bypass logic. Each cache block tracks a tiny reuse counter (dead-block score) that decays on replacement and increments on hit, improving prediction of blocks likely to be dead (no future reuse). Sets are classified as leader for SRRIP or BRRIP, tuning insertion aggressiveness via the 10-bit PSEL. The streaming detector uses per-set address deltas to identify monotonic accesses (indicative of streaming or pointer-chasing), triggering bypass or distant insertions when detected. By combining dead-block detection (to aggressively evict non-reused blocks), streaming awareness (to avoid pollution from predictable stride accesses), and adaptive insertion policies (via SRRIP/BRRIP set-dueling), DSSH achieves better hit rates across diverse workloads—retaining useful blocks in irregular/control-dominated phases while suppressing pollution from streaming and pointer-heavy code. All metadata fits comfortably within 64 KiB, leveraging small saturating counters and per-line reuse bits.",,ChampSim_CRC2/new_policies/045_02_dead_stream_srrip_hybrid__dssh_t07.cc,0.346372734,0.346372734,0%
1693,lbm,Dead-Stream SRRIP Hybrid (DSSH),"DSSH integrates compact per-block dead-block prediction with set-dueling SRRIP/BRRIP and a streaming detector to adaptively manage cache insertion depth and bypass logic. Each cache block tracks a tiny reuse counter (dead-block score) that decays on replacement and increments on hit, improving prediction of blocks likely to be dead (no future reuse). Sets are classified as leader for SRRIP or BRRIP, tuning insertion aggressiveness via the 10-bit PSEL. The streaming detector uses per-set address deltas to identify monotonic accesses (indicative of streaming or pointer-chasing), triggering bypass or distant insertions when detected. By combining dead-block detection (to aggressively evict non-reused blocks), streaming awareness (to avoid pollution from predictable stride accesses), and adaptive insertion policies (via SRRIP/BRRIP set-dueling), DSSH achieves better hit rates across diverse workloads—retaining useful blocks in irregular/control-dominated phases while suppressing pollution from streaming and pointer-heavy code. All metadata fits comfortably within 64 KiB, leveraging small saturating counters and per-line reuse bits.",,ChampSim_CRC2/new_policies/045_02_dead_stream_srrip_hybrid__dssh_t07.cc,0.350109861,0.350109861,0%
1694,mcf,Dead-Stream SRRIP Hybrid (DSSH),"DSSH integrates compact per-block dead-block prediction with set-dueling SRRIP/BRRIP and a streaming detector to adaptively manage cache insertion depth and bypass logic. Each cache block tracks a tiny reuse counter (dead-block score) that decays on replacement and increments on hit, improving prediction of blocks likely to be dead (no future reuse). Sets are classified as leader for SRRIP or BRRIP, tuning insertion aggressiveness via the 10-bit PSEL. The streaming detector uses per-set address deltas to identify monotonic accesses (indicative of streaming or pointer-chasing), triggering bypass or distant insertions when detected. By combining dead-block detection (to aggressively evict non-reused blocks), streaming awareness (to avoid pollution from predictable stride accesses), and adaptive insertion policies (via SRRIP/BRRIP set-dueling), DSSH achieves better hit rates across diverse workloads—retaining useful blocks in irregular/control-dominated phases while suppressing pollution from streaming and pointer-heavy code. All metadata fits comfortably within 64 KiB, leveraging small saturating counters and per-line reuse bits.",,ChampSim_CRC2/new_policies/045_02_dead_stream_srrip_hybrid__dssh_t07.cc,0.192403235,0.192403235,0%
1695,milc,Dead-Stream SRRIP Hybrid (DSSH),"DSSH integrates compact per-block dead-block prediction with set-dueling SRRIP/BRRIP and a streaming detector to adaptively manage cache insertion depth and bypass logic. Each cache block tracks a tiny reuse counter (dead-block score) that decays on replacement and increments on hit, improving prediction of blocks likely to be dead (no future reuse). Sets are classified as leader for SRRIP or BRRIP, tuning insertion aggressiveness via the 10-bit PSEL. The streaming detector uses per-set address deltas to identify monotonic accesses (indicative of streaming or pointer-chasing), triggering bypass or distant insertions when detected. By combining dead-block detection (to aggressively evict non-reused blocks), streaming awareness (to avoid pollution from predictable stride accesses), and adaptive insertion policies (via SRRIP/BRRIP set-dueling), DSSH achieves better hit rates across diverse workloads—retaining useful blocks in irregular/control-dominated phases while suppressing pollution from streaming and pointer-heavy code. All metadata fits comfortably within 64 KiB, leveraging small saturating counters and per-line reuse bits.",,ChampSim_CRC2/new_policies/045_02_dead_stream_srrip_hybrid__dssh_t07.cc,0.26547101,0.26547101,0%
1696,omnetpp,Dead-Stream SRRIP Hybrid (DSSH),"DSSH integrates compact per-block dead-block prediction with set-dueling SRRIP/BRRIP and a streaming detector to adaptively manage cache insertion depth and bypass logic. Each cache block tracks a tiny reuse counter (dead-block score) that decays on replacement and increments on hit, improving prediction of blocks likely to be dead (no future reuse). Sets are classified as leader for SRRIP or BRRIP, tuning insertion aggressiveness via the 10-bit PSEL. The streaming detector uses per-set address deltas to identify monotonic accesses (indicative of streaming or pointer-chasing), triggering bypass or distant insertions when detected. By combining dead-block detection (to aggressively evict non-reused blocks), streaming awareness (to avoid pollution from predictable stride accesses), and adaptive insertion policies (via SRRIP/BRRIP set-dueling), DSSH achieves better hit rates across diverse workloads—retaining useful blocks in irregular/control-dominated phases while suppressing pollution from streaming and pointer-heavy code. All metadata fits comfortably within 64 KiB, leveraging small saturating counters and per-line reuse bits.",,ChampSim_CRC2/new_policies/045_02_dead_stream_srrip_hybrid__dssh_t07.cc,0.018538733,0.018538733,0%
1697,all,DIP-DeadBlock Streaming Hybrid (DDSH),"DDSH combines DIP-style insertion depth control (LIP vs BIP) with a compact per-line dead-block counter and a per-set streaming detector. Leader sets (32 each) track LIP and BIP effectiveness using a 10-bit PSEL selector. Each cache line maintains a 2-bit dead-block counter, incremented on eviction and decayed periodically, to approximate block reusability. The streaming detector monitors address deltas per set and triggers bypass or distant insertion when monotonic access is detected. On insertion, DDSH chooses between LIP/BIP based on PSEL, but overrides with bypass/distant insertion for streaming sets and with MRU insertion for blocks with low dead-block counts. This hybrid approach improves performance by suppressing pollution from streaming and dead blocks (LBM, MCF, OMNETPP), while retaining reusable blocks in control-dominated or phase-changing workloads (ASTAR, MILC). Metadata fits in <64 KiB: 2 bits per block for dead-block, 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/045_00_dip_deadblock_streaming_hybrid__ddsh_t02.cc,0.420147941,0.420147941,42%
1698,astar,SHiP-Lite Streaming Adaptive Replacement (SLSAR),"SLSAR combines SHiP-lite signature-based insertion depth prediction with a lightweight streaming detector to adaptively manage cache blocks. Each cache line is tagged with a compact 5-bit PC signature and a 2-bit outcome counter, enabling the policy to learn which PCs produce reusable blocks and bias insertion depth accordingly (MRU for ""good"" PCs, LRU for ""bad"" PCs). A per-set streaming detector monitors address deltas to identify streaming access patterns and triggers bypass or distant insertion for streaming sets, reducing pollution from workloads like LBM and MCF. This hybrid approach improves performance by retaining blocks from high-reuse PCs (benefiting ASTAR, MILC, OMNETPP) while suppressing streaming and dead blocks. Metadata fits within 64 KiB: 5 bits per block for signature, 2 bits per block for outcome, 3 bits per set for streaming, and minimal counters for statistics.",,ChampSim_CRC2/new_policies/046_00_ship_lite_streaming_adaptive_replacement__slsar_t02.cc,0.470398234,0.470398234,0%
1699,lbm,SHiP-Lite Streaming Adaptive Replacement (SLSAR),"SLSAR combines SHiP-lite signature-based insertion depth prediction with a lightweight streaming detector to adaptively manage cache blocks. Each cache line is tagged with a compact 5-bit PC signature and a 2-bit outcome counter, enabling the policy to learn which PCs produce reusable blocks and bias insertion depth accordingly (MRU for ""good"" PCs, LRU for ""bad"" PCs). A per-set streaming detector monitors address deltas to identify streaming access patterns and triggers bypass or distant insertion for streaming sets, reducing pollution from workloads like LBM and MCF. This hybrid approach improves performance by retaining blocks from high-reuse PCs (benefiting ASTAR, MILC, OMNETPP) while suppressing streaming and dead blocks. Metadata fits within 64 KiB: 5 bits per block for signature, 2 bits per block for outcome, 3 bits per set for streaming, and minimal counters for statistics.",,ChampSim_CRC2/new_policies/046_00_ship_lite_streaming_adaptive_replacement__slsar_t02.cc,0.441279947,0.441279947,0%
1700,mcf,SHiP-Lite Streaming Adaptive Replacement (SLSAR),"SLSAR combines SHiP-lite signature-based insertion depth prediction with a lightweight streaming detector to adaptively manage cache blocks. Each cache line is tagged with a compact 5-bit PC signature and a 2-bit outcome counter, enabling the policy to learn which PCs produce reusable blocks and bias insertion depth accordingly (MRU for ""good"" PCs, LRU for ""bad"" PCs). A per-set streaming detector monitors address deltas to identify streaming access patterns and triggers bypass or distant insertion for streaming sets, reducing pollution from workloads like LBM and MCF. This hybrid approach improves performance by retaining blocks from high-reuse PCs (benefiting ASTAR, MILC, OMNETPP) while suppressing streaming and dead blocks. Metadata fits within 64 KiB: 5 bits per block for signature, 2 bits per block for outcome, 3 bits per set for streaming, and minimal counters for statistics.",,ChampSim_CRC2/new_policies/046_00_ship_lite_streaming_adaptive_replacement__slsar_t02.cc,0.448646191,0.448646191,0%
1701,milc,SHiP-Lite Streaming Adaptive Replacement (SLSAR),"SLSAR combines SHiP-lite signature-based insertion depth prediction with a lightweight streaming detector to adaptively manage cache blocks. Each cache line is tagged with a compact 5-bit PC signature and a 2-bit outcome counter, enabling the policy to learn which PCs produce reusable blocks and bias insertion depth accordingly (MRU for ""good"" PCs, LRU for ""bad"" PCs). A per-set streaming detector monitors address deltas to identify streaming access patterns and triggers bypass or distant insertion for streaming sets, reducing pollution from workloads like LBM and MCF. This hybrid approach improves performance by retaining blocks from high-reuse PCs (benefiting ASTAR, MILC, OMNETPP) while suppressing streaming and dead blocks. Metadata fits within 64 KiB: 5 bits per block for signature, 2 bits per block for outcome, 3 bits per set for streaming, and minimal counters for statistics.",,ChampSim_CRC2/new_policies/046_00_ship_lite_streaming_adaptive_replacement__slsar_t02.cc,0.321706844,0.321706844,0%
1702,omnetpp,SHiP-Lite Streaming Adaptive Replacement (SLSAR),"SLSAR combines SHiP-lite signature-based insertion depth prediction with a lightweight streaming detector to adaptively manage cache blocks. Each cache line is tagged with a compact 5-bit PC signature and a 2-bit outcome counter, enabling the policy to learn which PCs produce reusable blocks and bias insertion depth accordingly (MRU for ""good"" PCs, LRU for ""bad"" PCs). A per-set streaming detector monitors address deltas to identify streaming access patterns and triggers bypass or distant insertion for streaming sets, reducing pollution from workloads like LBM and MCF. This hybrid approach improves performance by retaining blocks from high-reuse PCs (benefiting ASTAR, MILC, OMNETPP) while suppressing streaming and dead blocks. Metadata fits within 64 KiB: 5 bits per block for signature, 2 bits per block for outcome, 3 bits per set for streaming, and minimal counters for statistics.",,ChampSim_CRC2/new_policies/046_00_ship_lite_streaming_adaptive_replacement__slsar_t02.cc,0.46107688,0.46107688,0%
1703,astar,SHiP-Lite Streaming Adaptive (SLSA),"SLSA fuses a lightweight SHiP-style PC-based signature predictor with a per-set streaming detector and DRRIP-style insertion depth control. Each cache line is tagged with a 6-bit PC signature, and a global table of 2048 2-bit saturating counters tracks reuse outcomes per signature. On insertion, SLSA biases the RRPV: blocks with strong reuse signatures are inserted at MRU, while weak or unseen signatures are inserted at distant RRPV. For sets with monotonic address deltas (streaming detected), SLSA bypasses insertion with probability 1/8 or inserts at LRU to suppress pollution. DRRIP set-dueling (SRRIP vs BRRIP, 32 leader sets, 10-bit PSEL) is used as a fallback for ambiguous cases. This hybrid approach improves performance by accurately retaining reusable blocks (ASTAR, MILC, OMNETPP), suppressing streaming pollution (LBM, MCF), and adapting to phase changes with compact metadata (<64 KiB): 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for DRRIP.",,ChampSim_CRC2/new_policies/046_01_ship_lite_streaming_adaptive__slsa_t04.cc,0.450977335,0.450977335,0%
1704,lbm,SHiP-Lite Streaming Adaptive (SLSA),"SLSA fuses a lightweight SHiP-style PC-based signature predictor with a per-set streaming detector and DRRIP-style insertion depth control. Each cache line is tagged with a 6-bit PC signature, and a global table of 2048 2-bit saturating counters tracks reuse outcomes per signature. On insertion, SLSA biases the RRPV: blocks with strong reuse signatures are inserted at MRU, while weak or unseen signatures are inserted at distant RRPV. For sets with monotonic address deltas (streaming detected), SLSA bypasses insertion with probability 1/8 or inserts at LRU to suppress pollution. DRRIP set-dueling (SRRIP vs BRRIP, 32 leader sets, 10-bit PSEL) is used as a fallback for ambiguous cases. This hybrid approach improves performance by accurately retaining reusable blocks (ASTAR, MILC, OMNETPP), suppressing streaming pollution (LBM, MCF), and adapting to phase changes with compact metadata (<64 KiB): 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for DRRIP.",,ChampSim_CRC2/new_policies/046_01_ship_lite_streaming_adaptive__slsa_t04.cc,0.435903308,0.435903308,0%
1705,mcf,SHiP-Lite Streaming Adaptive (SLSA),"SLSA fuses a lightweight SHiP-style PC-based signature predictor with a per-set streaming detector and DRRIP-style insertion depth control. Each cache line is tagged with a 6-bit PC signature, and a global table of 2048 2-bit saturating counters tracks reuse outcomes per signature. On insertion, SLSA biases the RRPV: blocks with strong reuse signatures are inserted at MRU, while weak or unseen signatures are inserted at distant RRPV. For sets with monotonic address deltas (streaming detected), SLSA bypasses insertion with probability 1/8 or inserts at LRU to suppress pollution. DRRIP set-dueling (SRRIP vs BRRIP, 32 leader sets, 10-bit PSEL) is used as a fallback for ambiguous cases. This hybrid approach improves performance by accurately retaining reusable blocks (ASTAR, MILC, OMNETPP), suppressing streaming pollution (LBM, MCF), and adapting to phase changes with compact metadata (<64 KiB): 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for DRRIP.",,ChampSim_CRC2/new_policies/046_01_ship_lite_streaming_adaptive__slsa_t04.cc,0.453138069,0.453138069,0%
1706,milc,SHiP-Lite Streaming Adaptive (SLSA),"SLSA fuses a lightweight SHiP-style PC-based signature predictor with a per-set streaming detector and DRRIP-style insertion depth control. Each cache line is tagged with a 6-bit PC signature, and a global table of 2048 2-bit saturating counters tracks reuse outcomes per signature. On insertion, SLSA biases the RRPV: blocks with strong reuse signatures are inserted at MRU, while weak or unseen signatures are inserted at distant RRPV. For sets with monotonic address deltas (streaming detected), SLSA bypasses insertion with probability 1/8 or inserts at LRU to suppress pollution. DRRIP set-dueling (SRRIP vs BRRIP, 32 leader sets, 10-bit PSEL) is used as a fallback for ambiguous cases. This hybrid approach improves performance by accurately retaining reusable blocks (ASTAR, MILC, OMNETPP), suppressing streaming pollution (LBM, MCF), and adapting to phase changes with compact metadata (<64 KiB): 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for DRRIP.",,ChampSim_CRC2/new_policies/046_01_ship_lite_streaming_adaptive__slsa_t04.cc,0.320202466,0.320202466,0%
1707,omnetpp,SHiP-Lite Streaming Adaptive (SLSA),"SLSA fuses a lightweight SHiP-style PC-based signature predictor with a per-set streaming detector and DRRIP-style insertion depth control. Each cache line is tagged with a 6-bit PC signature, and a global table of 2048 2-bit saturating counters tracks reuse outcomes per signature. On insertion, SLSA biases the RRPV: blocks with strong reuse signatures are inserted at MRU, while weak or unseen signatures are inserted at distant RRPV. For sets with monotonic address deltas (streaming detected), SLSA bypasses insertion with probability 1/8 or inserts at LRU to suppress pollution. DRRIP set-dueling (SRRIP vs BRRIP, 32 leader sets, 10-bit PSEL) is used as a fallback for ambiguous cases. This hybrid approach improves performance by accurately retaining reusable blocks (ASTAR, MILC, OMNETPP), suppressing streaming pollution (LBM, MCF), and adapting to phase changes with compact metadata (<64 KiB): 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for DRRIP.",,ChampSim_CRC2/new_policies/046_01_ship_lite_streaming_adaptive__slsa_t04.cc,0.659190819,0.659190819,0%
1708,astar,SHiP-Lite Streaming Hybrid (SLSH),"SLSH fuses a compact SHiP-lite signature predictor with a streaming detector, enabling fine-grained insertion depth control based on PC reuse history and dynamic access patterns. Each cache block tracks a 5-bit truncated PC signature; a global 2-bit outcome counter per signature biases insertion depth between MRU (for predicted reusable PCs) and LRU (for dead PCs). A small per-set streaming score detects monotonic address strides, triggering bypass or distant insertion for detected streaming sets. Set-dueling (32+32 leader sets) selects between SRRIP and BRRIP for blocks with unknown PC history or ambiguous streaming behavior. This hybrid approach improves hit rates on control- and phase-dominated workloads (ASTAR, MILC) by learning PC reuse, while suppressing pollution from streaming or dead blocks (LBM, MCF, OMNETPP). Metadata fits in <64 KiB: 5 bits per block for signature, 2 bits per (32-entry) outcome table, 3 bits per set for streaming, and DIP PSEL logic.",,ChampSim_CRC2/new_policies/046_02_ship_lite_streaming_hybrid__slsh_t07.cc,0.45823293,0.45823293,0%
1709,lbm,SHiP-Lite Streaming Hybrid (SLSH),"SLSH fuses a compact SHiP-lite signature predictor with a streaming detector, enabling fine-grained insertion depth control based on PC reuse history and dynamic access patterns. Each cache block tracks a 5-bit truncated PC signature; a global 2-bit outcome counter per signature biases insertion depth between MRU (for predicted reusable PCs) and LRU (for dead PCs). A small per-set streaming score detects monotonic address strides, triggering bypass or distant insertion for detected streaming sets. Set-dueling (32+32 leader sets) selects between SRRIP and BRRIP for blocks with unknown PC history or ambiguous streaming behavior. This hybrid approach improves hit rates on control- and phase-dominated workloads (ASTAR, MILC) by learning PC reuse, while suppressing pollution from streaming or dead blocks (LBM, MCF, OMNETPP). Metadata fits in <64 KiB: 5 bits per block for signature, 2 bits per (32-entry) outcome table, 3 bits per set for streaming, and DIP PSEL logic.",,ChampSim_CRC2/new_policies/046_02_ship_lite_streaming_hybrid__slsh_t07.cc,0.434904059,0.434904059,0%
1710,mcf,SHiP-Lite Streaming Hybrid (SLSH),"SLSH fuses a compact SHiP-lite signature predictor with a streaming detector, enabling fine-grained insertion depth control based on PC reuse history and dynamic access patterns. Each cache block tracks a 5-bit truncated PC signature; a global 2-bit outcome counter per signature biases insertion depth between MRU (for predicted reusable PCs) and LRU (for dead PCs). A small per-set streaming score detects monotonic address strides, triggering bypass or distant insertion for detected streaming sets. Set-dueling (32+32 leader sets) selects between SRRIP and BRRIP for blocks with unknown PC history or ambiguous streaming behavior. This hybrid approach improves hit rates on control- and phase-dominated workloads (ASTAR, MILC) by learning PC reuse, while suppressing pollution from streaming or dead blocks (LBM, MCF, OMNETPP). Metadata fits in <64 KiB: 5 bits per block for signature, 2 bits per (32-entry) outcome table, 3 bits per set for streaming, and DIP PSEL logic.",,ChampSim_CRC2/new_policies/046_02_ship_lite_streaming_hybrid__slsh_t07.cc,0.476391958,0.476391958,0%
1711,milc,SHiP-Lite Streaming Hybrid (SLSH),"SLSH fuses a compact SHiP-lite signature predictor with a streaming detector, enabling fine-grained insertion depth control based on PC reuse history and dynamic access patterns. Each cache block tracks a 5-bit truncated PC signature; a global 2-bit outcome counter per signature biases insertion depth between MRU (for predicted reusable PCs) and LRU (for dead PCs). A small per-set streaming score detects monotonic address strides, triggering bypass or distant insertion for detected streaming sets. Set-dueling (32+32 leader sets) selects between SRRIP and BRRIP for blocks with unknown PC history or ambiguous streaming behavior. This hybrid approach improves hit rates on control- and phase-dominated workloads (ASTAR, MILC) by learning PC reuse, while suppressing pollution from streaming or dead blocks (LBM, MCF, OMNETPP). Metadata fits in <64 KiB: 5 bits per block for signature, 2 bits per (32-entry) outcome table, 3 bits per set for streaming, and DIP PSEL logic.",,ChampSim_CRC2/new_policies/046_02_ship_lite_streaming_hybrid__slsh_t07.cc,0.316246913,0.316246913,0%
1712,omnetpp,SHiP-Lite Streaming Hybrid (SLSH),"SLSH fuses a compact SHiP-lite signature predictor with a streaming detector, enabling fine-grained insertion depth control based on PC reuse history and dynamic access patterns. Each cache block tracks a 5-bit truncated PC signature; a global 2-bit outcome counter per signature biases insertion depth between MRU (for predicted reusable PCs) and LRU (for dead PCs). A small per-set streaming score detects monotonic address strides, triggering bypass or distant insertion for detected streaming sets. Set-dueling (32+32 leader sets) selects between SRRIP and BRRIP for blocks with unknown PC history or ambiguous streaming behavior. This hybrid approach improves hit rates on control- and phase-dominated workloads (ASTAR, MILC) by learning PC reuse, while suppressing pollution from streaming or dead blocks (LBM, MCF, OMNETPP). Metadata fits in <64 KiB: 5 bits per block for signature, 2 bits per (32-entry) outcome table, 3 bits per set for streaming, and DIP PSEL logic.",,ChampSim_CRC2/new_policies/046_02_ship_lite_streaming_hybrid__slsh_t07.cc,0.601237094,0.601237094,0%
1713,all,SHiP-Lite Streaming Adaptive (SLSA),"SLSA fuses a lightweight SHiP-style PC-based signature predictor with a per-set streaming detector and DRRIP-style insertion depth control. Each cache line is tagged with a 6-bit PC signature, and a global table of 2048 2-bit saturating counters tracks reuse outcomes per signature. On insertion, SLSA biases the RRPV: blocks with strong reuse signatures are inserted at MRU, while weak or unseen signatures are inserted at distant RRPV. For sets with monotonic address deltas (streaming detected), SLSA bypasses insertion with probability 1/8 or inserts at LRU to suppress pollution. DRRIP set-dueling (SRRIP vs BRRIP, 32 leader sets, 10-bit PSEL) is used as a fallback for ambiguous cases. This hybrid approach improves performance by accurately retaining reusable blocks (ASTAR, MILC, OMNETPP), suppressing streaming pollution (LBM, MCF), and adapting to phase changes with compact metadata (<64 KiB): 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for DRRIP.",,ChampSim_CRC2/new_policies/046_01_ship_lite_streaming_adaptive__slsa_t04.cc,0.463882399,0.463882399,46%
1714,astar,Signature-Deadblock Hybrid Adaptive (SDHA),"SDHA combines lightweight PC-based signature prediction (SHiP-lite) with per-block dead-block approximation and a streaming-aware bypass mechanism. Each cache line tracks a 6-bit PC signature and a 2-bit dead-block counter, while a global table of 2048 2-bit signature outcome counters guides insertion depth. On insertion, blocks with strong signatures and low dead-block counters are inserted at MRU; blocks with weak signatures or high dead-block counters are inserted at distant RRPV. A per-set streaming detector monitors monotonic address deltas and triggers probabilistic bypass (1/4) or LRU insertion for streaming sets. Periodic decay of dead-block counters and signature outcomes adapts to phase changes. This hybrid approach improves retention of reusable blocks (ASTAR, MILC, OMNETPP), suppresses pollution from streaming and dead blocks (LBM, MCF), and adapts quickly to workload shifts, all within a compact metadata budget (<64 KiB): 6 bits per block for signature, 2 bits per block for dead-block counter, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for decay.",,ChampSim_CRC2/new_policies/047_00_signature_deadblock_hybrid_adaptive__sdha_t02.cc,0.451022516,0.451022516,0%
1715,lbm,Signature-Deadblock Hybrid Adaptive (SDHA),"SDHA combines lightweight PC-based signature prediction (SHiP-lite) with per-block dead-block approximation and a streaming-aware bypass mechanism. Each cache line tracks a 6-bit PC signature and a 2-bit dead-block counter, while a global table of 2048 2-bit signature outcome counters guides insertion depth. On insertion, blocks with strong signatures and low dead-block counters are inserted at MRU; blocks with weak signatures or high dead-block counters are inserted at distant RRPV. A per-set streaming detector monitors monotonic address deltas and triggers probabilistic bypass (1/4) or LRU insertion for streaming sets. Periodic decay of dead-block counters and signature outcomes adapts to phase changes. This hybrid approach improves retention of reusable blocks (ASTAR, MILC, OMNETPP), suppresses pollution from streaming and dead blocks (LBM, MCF), and adapts quickly to workload shifts, all within a compact metadata budget (<64 KiB): 6 bits per block for signature, 2 bits per block for dead-block counter, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for decay.",,ChampSim_CRC2/new_policies/047_00_signature_deadblock_hybrid_adaptive__sdha_t02.cc,0.435715124,0.435715124,0%
1716,mcf,Signature-Deadblock Hybrid Adaptive (SDHA),"SDHA combines lightweight PC-based signature prediction (SHiP-lite) with per-block dead-block approximation and a streaming-aware bypass mechanism. Each cache line tracks a 6-bit PC signature and a 2-bit dead-block counter, while a global table of 2048 2-bit signature outcome counters guides insertion depth. On insertion, blocks with strong signatures and low dead-block counters are inserted at MRU; blocks with weak signatures or high dead-block counters are inserted at distant RRPV. A per-set streaming detector monitors monotonic address deltas and triggers probabilistic bypass (1/4) or LRU insertion for streaming sets. Periodic decay of dead-block counters and signature outcomes adapts to phase changes. This hybrid approach improves retention of reusable blocks (ASTAR, MILC, OMNETPP), suppresses pollution from streaming and dead blocks (LBM, MCF), and adapts quickly to workload shifts, all within a compact metadata budget (<64 KiB): 6 bits per block for signature, 2 bits per block for dead-block counter, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for decay.",,ChampSim_CRC2/new_policies/047_00_signature_deadblock_hybrid_adaptive__sdha_t02.cc,0.452961924,0.452961924,0%
1717,milc,Signature-Deadblock Hybrid Adaptive (SDHA),"SDHA combines lightweight PC-based signature prediction (SHiP-lite) with per-block dead-block approximation and a streaming-aware bypass mechanism. Each cache line tracks a 6-bit PC signature and a 2-bit dead-block counter, while a global table of 2048 2-bit signature outcome counters guides insertion depth. On insertion, blocks with strong signatures and low dead-block counters are inserted at MRU; blocks with weak signatures or high dead-block counters are inserted at distant RRPV. A per-set streaming detector monitors monotonic address deltas and triggers probabilistic bypass (1/4) or LRU insertion for streaming sets. Periodic decay of dead-block counters and signature outcomes adapts to phase changes. This hybrid approach improves retention of reusable blocks (ASTAR, MILC, OMNETPP), suppresses pollution from streaming and dead blocks (LBM, MCF), and adapts quickly to workload shifts, all within a compact metadata budget (<64 KiB): 6 bits per block for signature, 2 bits per block for dead-block counter, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for decay.",,ChampSim_CRC2/new_policies/047_00_signature_deadblock_hybrid_adaptive__sdha_t02.cc,0.319900143,0.319900143,0%
1718,omnetpp,Signature-Deadblock Hybrid Adaptive (SDHA),"SDHA combines lightweight PC-based signature prediction (SHiP-lite) with per-block dead-block approximation and a streaming-aware bypass mechanism. Each cache line tracks a 6-bit PC signature and a 2-bit dead-block counter, while a global table of 2048 2-bit signature outcome counters guides insertion depth. On insertion, blocks with strong signatures and low dead-block counters are inserted at MRU; blocks with weak signatures or high dead-block counters are inserted at distant RRPV. A per-set streaming detector monitors monotonic address deltas and triggers probabilistic bypass (1/4) or LRU insertion for streaming sets. Periodic decay of dead-block counters and signature outcomes adapts to phase changes. This hybrid approach improves retention of reusable blocks (ASTAR, MILC, OMNETPP), suppresses pollution from streaming and dead blocks (LBM, MCF), and adapts quickly to workload shifts, all within a compact metadata budget (<64 KiB): 6 bits per block for signature, 2 bits per block for dead-block counter, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for decay.",,ChampSim_CRC2/new_policies/047_00_signature_deadblock_hybrid_adaptive__sdha_t02.cc,0.685137577,0.685137577,0%
1719,astar,Signature-Deadblock Streaming Hybrid (SDSH),"SDSH combines SHiP-lite signature prediction with per-block dead-block counters and a streaming detector to create a highly adaptive, phase-aware LLC replacement policy. Each cache line is tagged with a 5-bit PC signature and a 2-bit deadblock counter, while a small global table of 1024 2-bit signature outcome counters tracks reuse. On insertion, blocks with strong signatures and low deadblock are inserted at MRU; weak signatures or high deadblock lines are inserted at distant RRPV. A streaming detector per set (3-bit score) triggers aggressive bypass (probability 1/4) or LRU insertion for detected streaming phases. DIP-style set-dueling (LIP vs BIP, 32 leader sets, 10-bit PSEL) is used for ambiguous cases. This design improves performance by combining fine-grained dead-block prediction (good for MCF, OMNETPP), signature-based reuse (ASTAR, MILC), and robust streaming suppression (LBM), while maintaining compact metadata: 5 bits per block for signature, 2 bits per block for deadblock, 2 bits per signature (1024 entries), 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/047_01_signature_deadblock_streaming_hybrid__sdsh_t04.cc,0.450953415,0.450953415,0%
1720,lbm,Signature-Deadblock Streaming Hybrid (SDSH),"SDSH combines SHiP-lite signature prediction with per-block dead-block counters and a streaming detector to create a highly adaptive, phase-aware LLC replacement policy. Each cache line is tagged with a 5-bit PC signature and a 2-bit deadblock counter, while a small global table of 1024 2-bit signature outcome counters tracks reuse. On insertion, blocks with strong signatures and low deadblock are inserted at MRU; weak signatures or high deadblock lines are inserted at distant RRPV. A streaming detector per set (3-bit score) triggers aggressive bypass (probability 1/4) or LRU insertion for detected streaming phases. DIP-style set-dueling (LIP vs BIP, 32 leader sets, 10-bit PSEL) is used for ambiguous cases. This design improves performance by combining fine-grained dead-block prediction (good for MCF, OMNETPP), signature-based reuse (ASTAR, MILC), and robust streaming suppression (LBM), while maintaining compact metadata: 5 bits per block for signature, 2 bits per block for deadblock, 2 bits per signature (1024 entries), 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/047_01_signature_deadblock_streaming_hybrid__sdsh_t04.cc,0.435677855,0.435677855,0%
1721,mcf,Signature-Deadblock Streaming Hybrid (SDSH),"SDSH combines SHiP-lite signature prediction with per-block dead-block counters and a streaming detector to create a highly adaptive, phase-aware LLC replacement policy. Each cache line is tagged with a 5-bit PC signature and a 2-bit deadblock counter, while a small global table of 1024 2-bit signature outcome counters tracks reuse. On insertion, blocks with strong signatures and low deadblock are inserted at MRU; weak signatures or high deadblock lines are inserted at distant RRPV. A streaming detector per set (3-bit score) triggers aggressive bypass (probability 1/4) or LRU insertion for detected streaming phases. DIP-style set-dueling (LIP vs BIP, 32 leader sets, 10-bit PSEL) is used for ambiguous cases. This design improves performance by combining fine-grained dead-block prediction (good for MCF, OMNETPP), signature-based reuse (ASTAR, MILC), and robust streaming suppression (LBM), while maintaining compact metadata: 5 bits per block for signature, 2 bits per block for deadblock, 2 bits per signature (1024 entries), 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/047_01_signature_deadblock_streaming_hybrid__sdsh_t04.cc,0.456139503,0.456139503,0%
1722,milc,Signature-Deadblock Streaming Hybrid (SDSH),"SDSH combines SHiP-lite signature prediction with per-block dead-block counters and a streaming detector to create a highly adaptive, phase-aware LLC replacement policy. Each cache line is tagged with a 5-bit PC signature and a 2-bit deadblock counter, while a small global table of 1024 2-bit signature outcome counters tracks reuse. On insertion, blocks with strong signatures and low deadblock are inserted at MRU; weak signatures or high deadblock lines are inserted at distant RRPV. A streaming detector per set (3-bit score) triggers aggressive bypass (probability 1/4) or LRU insertion for detected streaming phases. DIP-style set-dueling (LIP vs BIP, 32 leader sets, 10-bit PSEL) is used for ambiguous cases. This design improves performance by combining fine-grained dead-block prediction (good for MCF, OMNETPP), signature-based reuse (ASTAR, MILC), and robust streaming suppression (LBM), while maintaining compact metadata: 5 bits per block for signature, 2 bits per block for deadblock, 2 bits per signature (1024 entries), 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/047_01_signature_deadblock_streaming_hybrid__sdsh_t04.cc,0.320019624,0.320019624,0%
1723,omnetpp,Signature-Deadblock Streaming Hybrid (SDSH),"SDSH combines SHiP-lite signature prediction with per-block dead-block counters and a streaming detector to create a highly adaptive, phase-aware LLC replacement policy. Each cache line is tagged with a 5-bit PC signature and a 2-bit deadblock counter, while a small global table of 1024 2-bit signature outcome counters tracks reuse. On insertion, blocks with strong signatures and low deadblock are inserted at MRU; weak signatures or high deadblock lines are inserted at distant RRPV. A streaming detector per set (3-bit score) triggers aggressive bypass (probability 1/4) or LRU insertion for detected streaming phases. DIP-style set-dueling (LIP vs BIP, 32 leader sets, 10-bit PSEL) is used for ambiguous cases. This design improves performance by combining fine-grained dead-block prediction (good for MCF, OMNETPP), signature-based reuse (ASTAR, MILC), and robust streaming suppression (LBM), while maintaining compact metadata: 5 bits per block for signature, 2 bits per block for deadblock, 2 bits per signature (1024 entries), 3 bits per set for streaming, and small counters for DIP.",,ChampSim_CRC2/new_policies/047_01_signature_deadblock_streaming_hybrid__sdsh_t04.cc,0.65930415,0.65930415,0%
1724,astar,Adaptive Dead-Streaming SHiP (ADS-SHiP),"ADS-SHiP fuses three compact mechanisms for robust cache replacement: (1) per-block dead-block prediction via a 2-bit saturating reuse counter (not PC-indexed), (2) phase-aware streaming detection using per-set monotonic address deltas, and (3) SHiP-lite PC signature prediction for selective MRU insertion. On insertion, blocks predicted dead (reuse ctr=0) or in streaming sets are bypassed with high probability, while reusable blocks are inserted at MRU if their PC signature is strong (SHiP counter≥2). Regular blocks fall back to DIP-style insertion depth (LIP/BIP), selected via 32 leader sets and an 8-bit PSEL. This hybrid improves hit rates by suppressing pollution from streaming and dead blocks (LBM, MCF), retaining reusable blocks (ASTAR, MILC, OMNETPP), and adapting to phase changes with minimal metadata: 2 bits per block for dead counter, 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and DIP bits/counters, all fitting well under 64 KiB.",,ChampSim_CRC2/new_policies/047_02_adaptive_dead_streaming_ship__ads_ship_t07.cc,0.385921487,0.385921487,0%
1725,lbm,Adaptive Dead-Streaming SHiP (ADS-SHiP),"ADS-SHiP fuses three compact mechanisms for robust cache replacement: (1) per-block dead-block prediction via a 2-bit saturating reuse counter (not PC-indexed), (2) phase-aware streaming detection using per-set monotonic address deltas, and (3) SHiP-lite PC signature prediction for selective MRU insertion. On insertion, blocks predicted dead (reuse ctr=0) or in streaming sets are bypassed with high probability, while reusable blocks are inserted at MRU if their PC signature is strong (SHiP counter≥2). Regular blocks fall back to DIP-style insertion depth (LIP/BIP), selected via 32 leader sets and an 8-bit PSEL. This hybrid improves hit rates by suppressing pollution from streaming and dead blocks (LBM, MCF), retaining reusable blocks (ASTAR, MILC, OMNETPP), and adapting to phase changes with minimal metadata: 2 bits per block for dead counter, 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and DIP bits/counters, all fitting well under 64 KiB.",,ChampSim_CRC2/new_policies/047_02_adaptive_dead_streaming_ship__ads_ship_t07.cc,0.107650119,0.107650119,0%
1726,mcf,Adaptive Dead-Streaming SHiP (ADS-SHiP),"ADS-SHiP fuses three compact mechanisms for robust cache replacement: (1) per-block dead-block prediction via a 2-bit saturating reuse counter (not PC-indexed), (2) phase-aware streaming detection using per-set monotonic address deltas, and (3) SHiP-lite PC signature prediction for selective MRU insertion. On insertion, blocks predicted dead (reuse ctr=0) or in streaming sets are bypassed with high probability, while reusable blocks are inserted at MRU if their PC signature is strong (SHiP counter≥2). Regular blocks fall back to DIP-style insertion depth (LIP/BIP), selected via 32 leader sets and an 8-bit PSEL. This hybrid improves hit rates by suppressing pollution from streaming and dead blocks (LBM, MCF), retaining reusable blocks (ASTAR, MILC, OMNETPP), and adapting to phase changes with minimal metadata: 2 bits per block for dead counter, 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and DIP bits/counters, all fitting well under 64 KiB.",,ChampSim_CRC2/new_policies/047_02_adaptive_dead_streaming_ship__ads_ship_t07.cc,0.411056104,0.411056104,0%
1727,milc,Adaptive Dead-Streaming SHiP (ADS-SHiP),"ADS-SHiP fuses three compact mechanisms for robust cache replacement: (1) per-block dead-block prediction via a 2-bit saturating reuse counter (not PC-indexed), (2) phase-aware streaming detection using per-set monotonic address deltas, and (3) SHiP-lite PC signature prediction for selective MRU insertion. On insertion, blocks predicted dead (reuse ctr=0) or in streaming sets are bypassed with high probability, while reusable blocks are inserted at MRU if their PC signature is strong (SHiP counter≥2). Regular blocks fall back to DIP-style insertion depth (LIP/BIP), selected via 32 leader sets and an 8-bit PSEL. This hybrid improves hit rates by suppressing pollution from streaming and dead blocks (LBM, MCF), retaining reusable blocks (ASTAR, MILC, OMNETPP), and adapting to phase changes with minimal metadata: 2 bits per block for dead counter, 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and DIP bits/counters, all fitting well under 64 KiB.",,ChampSim_CRC2/new_policies/047_02_adaptive_dead_streaming_ship__ads_ship_t07.cc,0.117290745,0.117290745,0%
1728,omnetpp,Adaptive Dead-Streaming SHiP (ADS-SHiP),"ADS-SHiP fuses three compact mechanisms for robust cache replacement: (1) per-block dead-block prediction via a 2-bit saturating reuse counter (not PC-indexed), (2) phase-aware streaming detection using per-set monotonic address deltas, and (3) SHiP-lite PC signature prediction for selective MRU insertion. On insertion, blocks predicted dead (reuse ctr=0) or in streaming sets are bypassed with high probability, while reusable blocks are inserted at MRU if their PC signature is strong (SHiP counter≥2). Regular blocks fall back to DIP-style insertion depth (LIP/BIP), selected via 32 leader sets and an 8-bit PSEL. This hybrid improves hit rates by suppressing pollution from streaming and dead blocks (LBM, MCF), retaining reusable blocks (ASTAR, MILC, OMNETPP), and adapting to phase changes with minimal metadata: 2 bits per block for dead counter, 6 bits per block for signature, 2 bits per signature (2048 entries), 3 bits per set for streaming, and DIP bits/counters, all fitting well under 64 KiB.",,ChampSim_CRC2/new_policies/047_02_adaptive_dead_streaming_ship__ads_ship_t07.cc,0.843687183,0.843687183,0%
1729,all,Signature-Deadblock Hybrid Adaptive (SDHA),"SDHA combines lightweight PC-based signature prediction (SHiP-lite) with per-block dead-block approximation and a streaming-aware bypass mechanism. Each cache line tracks a 6-bit PC signature and a 2-bit dead-block counter, while a global table of 2048 2-bit signature outcome counters guides insertion depth. On insertion, blocks with strong signatures and low dead-block counters are inserted at MRU; blocks with weak signatures or high dead-block counters are inserted at distant RRPV. A per-set streaming detector monitors monotonic address deltas and triggers probabilistic bypass (1/4) or LRU insertion for streaming sets. Periodic decay of dead-block counters and signature outcomes adapts to phase changes. This hybrid approach improves retention of reusable blocks (ASTAR, MILC, OMNETPP), suppresses pollution from streaming and dead blocks (LBM, MCF), and adapts quickly to workload shifts, all within a compact metadata budget (<64 KiB): 6 bits per block for signature, 2 bits per block for dead-block counter, 2 bits per signature (2048 entries), 3 bits per set for streaming, and small counters for decay.",,ChampSim_CRC2/new_policies/047_00_signature_deadblock_hybrid_adaptive__sdha_t02.cc,0.468947457,0.468947457,47%
1730,astar,SHiP-DRRIP Streaming-Bypass (SDSB),"SDSB integrates SHiP-lite signature prediction with DRRIP set-dueling and a streaming-aware bypass mechanism for robust, adaptive cache replacement. Each block tracks a 6-bit PC signature; a global table of 2048 2-bit outcome counters biases insertion depth toward MRU for reusable blocks. DRRIP set-dueling (using a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for most sets, improving adaptability to phase changes (MILC, OMNETPP). A per-set streaming detector monitors monotonic address deltas and triggers aggressive bypass for streaming sets (LBM, MCF), minimizing pollution. This design changes the insertion depth policy (DRRIP set-dueling) and streaming/bypass logic, while keeping metadata compact: 6 bits per block for signature, 2 bits per signature (2048 entries), 2 bits per block for RRPV, 10 bits for PSEL, 32 leader sets, and 3 bits per set for streaming detection. SDSB improves retention of reusable blocks, suppresses streaming pollution, and adapts quickly to workload shifts, targeting higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/048_00_ship_drrip_streaming_bypass__sdsb_t02.cc,0.302315589,0.302315589,0%
1731,lbm,SHiP-DRRIP Streaming-Bypass (SDSB),"SDSB integrates SHiP-lite signature prediction with DRRIP set-dueling and a streaming-aware bypass mechanism for robust, adaptive cache replacement. Each block tracks a 6-bit PC signature; a global table of 2048 2-bit outcome counters biases insertion depth toward MRU for reusable blocks. DRRIP set-dueling (using a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for most sets, improving adaptability to phase changes (MILC, OMNETPP). A per-set streaming detector monitors monotonic address deltas and triggers aggressive bypass for streaming sets (LBM, MCF), minimizing pollution. This design changes the insertion depth policy (DRRIP set-dueling) and streaming/bypass logic, while keeping metadata compact: 6 bits per block for signature, 2 bits per signature (2048 entries), 2 bits per block for RRPV, 10 bits for PSEL, 32 leader sets, and 3 bits per set for streaming detection. SDSB improves retention of reusable blocks, suppresses streaming pollution, and adapts quickly to workload shifts, targeting higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/048_00_ship_drrip_streaming_bypass__sdsb_t02.cc,0.158598254,0.158598254,0%
1732,mcf,SHiP-DRRIP Streaming-Bypass (SDSB),"SDSB integrates SHiP-lite signature prediction with DRRIP set-dueling and a streaming-aware bypass mechanism for robust, adaptive cache replacement. Each block tracks a 6-bit PC signature; a global table of 2048 2-bit outcome counters biases insertion depth toward MRU for reusable blocks. DRRIP set-dueling (using a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for most sets, improving adaptability to phase changes (MILC, OMNETPP). A per-set streaming detector monitors monotonic address deltas and triggers aggressive bypass for streaming sets (LBM, MCF), minimizing pollution. This design changes the insertion depth policy (DRRIP set-dueling) and streaming/bypass logic, while keeping metadata compact: 6 bits per block for signature, 2 bits per signature (2048 entries), 2 bits per block for RRPV, 10 bits for PSEL, 32 leader sets, and 3 bits per set for streaming detection. SDSB improves retention of reusable blocks, suppresses streaming pollution, and adapts quickly to workload shifts, targeting higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/048_00_ship_drrip_streaming_bypass__sdsb_t02.cc,0.43053778,0.43053778,0%
1733,milc,SHiP-DRRIP Streaming-Bypass (SDSB),"SDSB integrates SHiP-lite signature prediction with DRRIP set-dueling and a streaming-aware bypass mechanism for robust, adaptive cache replacement. Each block tracks a 6-bit PC signature; a global table of 2048 2-bit outcome counters biases insertion depth toward MRU for reusable blocks. DRRIP set-dueling (using a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for most sets, improving adaptability to phase changes (MILC, OMNETPP). A per-set streaming detector monitors monotonic address deltas and triggers aggressive bypass for streaming sets (LBM, MCF), minimizing pollution. This design changes the insertion depth policy (DRRIP set-dueling) and streaming/bypass logic, while keeping metadata compact: 6 bits per block for signature, 2 bits per signature (2048 entries), 2 bits per block for RRPV, 10 bits for PSEL, 32 leader sets, and 3 bits per set for streaming detection. SDSB improves retention of reusable blocks, suppresses streaming pollution, and adapts quickly to workload shifts, targeting higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/048_00_ship_drrip_streaming_bypass__sdsb_t02.cc,0.074561721,0.074561721,0%
1734,omnetpp,SHiP-DRRIP Streaming-Bypass (SDSB),"SDSB integrates SHiP-lite signature prediction with DRRIP set-dueling and a streaming-aware bypass mechanism for robust, adaptive cache replacement. Each block tracks a 6-bit PC signature; a global table of 2048 2-bit outcome counters biases insertion depth toward MRU for reusable blocks. DRRIP set-dueling (using a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for most sets, improving adaptability to phase changes (MILC, OMNETPP). A per-set streaming detector monitors monotonic address deltas and triggers aggressive bypass for streaming sets (LBM, MCF), minimizing pollution. This design changes the insertion depth policy (DRRIP set-dueling) and streaming/bypass logic, while keeping metadata compact: 6 bits per block for signature, 2 bits per signature (2048 entries), 2 bits per block for RRPV, 10 bits for PSEL, 32 leader sets, and 3 bits per set for streaming detection. SDSB improves retention of reusable blocks, suppresses streaming pollution, and adapts quickly to workload shifts, targeting higher hit rates across all workloads.",,ChampSim_CRC2/new_policies/048_00_ship_drrip_streaming_bypass__sdsb_t02.cc,0.725196987,0.725196987,0%
1735,astar,DRRIP-SHiP Streaming Hybrid (DSSH),"DSSH combines dynamic RRIP (DRRIP) with SHiP-lite signature prediction and a lightweight streaming detector, using set-dueling to adapt insertion depth between SRRIP and BRRIP. Leader sets (64) track policy performance via a 10-bit PSEL counter, guiding insertion depth globally. SHiP-lite tags each block with a 6-bit PC signature and maintains per-signature 2-bit outcome counters to bias insertion depth toward MRU for reusable blocks. A per-set streaming detector identifies monotonic address deltas and triggers bypass (1/4 probability) for streaming sets, reducing pollution from LBM/MCF. Dead-block approximation is omitted for simplicity and metadata savings. This approach improves performance by dynamically adapting to workload phase changes (MILC, OMNETPP), retaining reusable blocks (ASTAR), and suppressing streaming pollution, all within a compact metadata budget (<64 KiB): 2 bits per block for RRPV, 6 bits per block for signature, 2 bits per signature (2048 entries), 10 bits for PSEL, 64 bits for leader set mask, and 3 bits per set for streaming detection.",,ChampSim_CRC2/new_policies/048_01_drrip_ship_streaming_hybrid__dssh_t04.cc,0.449165651,0.449165651,0%
1736,lbm,DRRIP-SHiP Streaming Hybrid (DSSH),"DSSH combines dynamic RRIP (DRRIP) with SHiP-lite signature prediction and a lightweight streaming detector, using set-dueling to adapt insertion depth between SRRIP and BRRIP. Leader sets (64) track policy performance via a 10-bit PSEL counter, guiding insertion depth globally. SHiP-lite tags each block with a 6-bit PC signature and maintains per-signature 2-bit outcome counters to bias insertion depth toward MRU for reusable blocks. A per-set streaming detector identifies monotonic address deltas and triggers bypass (1/4 probability) for streaming sets, reducing pollution from LBM/MCF. Dead-block approximation is omitted for simplicity and metadata savings. This approach improves performance by dynamically adapting to workload phase changes (MILC, OMNETPP), retaining reusable blocks (ASTAR), and suppressing streaming pollution, all within a compact metadata budget (<64 KiB): 2 bits per block for RRPV, 6 bits per block for signature, 2 bits per signature (2048 entries), 10 bits for PSEL, 64 bits for leader set mask, and 3 bits per set for streaming detection.",,ChampSim_CRC2/new_policies/048_01_drrip_ship_streaming_hybrid__dssh_t04.cc,0.414697661,0.414697661,0%
1737,mcf,DRRIP-SHiP Streaming Hybrid (DSSH),"DSSH combines dynamic RRIP (DRRIP) with SHiP-lite signature prediction and a lightweight streaming detector, using set-dueling to adapt insertion depth between SRRIP and BRRIP. Leader sets (64) track policy performance via a 10-bit PSEL counter, guiding insertion depth globally. SHiP-lite tags each block with a 6-bit PC signature and maintains per-signature 2-bit outcome counters to bias insertion depth toward MRU for reusable blocks. A per-set streaming detector identifies monotonic address deltas and triggers bypass (1/4 probability) for streaming sets, reducing pollution from LBM/MCF. Dead-block approximation is omitted for simplicity and metadata savings. This approach improves performance by dynamically adapting to workload phase changes (MILC, OMNETPP), retaining reusable blocks (ASTAR), and suppressing streaming pollution, all within a compact metadata budget (<64 KiB): 2 bits per block for RRPV, 6 bits per block for signature, 2 bits per signature (2048 entries), 10 bits for PSEL, 64 bits for leader set mask, and 3 bits per set for streaming detection.",,ChampSim_CRC2/new_policies/048_01_drrip_ship_streaming_hybrid__dssh_t04.cc,0.453290135,0.453290135,0%
1738,milc,DRRIP-SHiP Streaming Hybrid (DSSH),"DSSH combines dynamic RRIP (DRRIP) with SHiP-lite signature prediction and a lightweight streaming detector, using set-dueling to adapt insertion depth between SRRIP and BRRIP. Leader sets (64) track policy performance via a 10-bit PSEL counter, guiding insertion depth globally. SHiP-lite tags each block with a 6-bit PC signature and maintains per-signature 2-bit outcome counters to bias insertion depth toward MRU for reusable blocks. A per-set streaming detector identifies monotonic address deltas and triggers bypass (1/4 probability) for streaming sets, reducing pollution from LBM/MCF. Dead-block approximation is omitted for simplicity and metadata savings. This approach improves performance by dynamically adapting to workload phase changes (MILC, OMNETPP), retaining reusable blocks (ASTAR), and suppressing streaming pollution, all within a compact metadata budget (<64 KiB): 2 bits per block for RRPV, 6 bits per block for signature, 2 bits per signature (2048 entries), 10 bits for PSEL, 64 bits for leader set mask, and 3 bits per set for streaming detection.",,ChampSim_CRC2/new_policies/048_01_drrip_ship_streaming_hybrid__dssh_t04.cc,0.317543104,0.317543104,0%
1739,omnetpp,DRRIP-SHiP Streaming Hybrid (DSSH),"DSSH combines dynamic RRIP (DRRIP) with SHiP-lite signature prediction and a lightweight streaming detector, using set-dueling to adapt insertion depth between SRRIP and BRRIP. Leader sets (64) track policy performance via a 10-bit PSEL counter, guiding insertion depth globally. SHiP-lite tags each block with a 6-bit PC signature and maintains per-signature 2-bit outcome counters to bias insertion depth toward MRU for reusable blocks. A per-set streaming detector identifies monotonic address deltas and triggers bypass (1/4 probability) for streaming sets, reducing pollution from LBM/MCF. Dead-block approximation is omitted for simplicity and metadata savings. This approach improves performance by dynamically adapting to workload phase changes (MILC, OMNETPP), retaining reusable blocks (ASTAR), and suppressing streaming pollution, all within a compact metadata budget (<64 KiB): 2 bits per block for RRPV, 6 bits per block for signature, 2 bits per signature (2048 entries), 10 bits for PSEL, 64 bits for leader set mask, and 3 bits per set for streaming detection.",,ChampSim_CRC2/new_policies/048_01_drrip_ship_streaming_hybrid__dssh_t04.cc,0.641057912,0.641057912,0%
1740,astar,DRRIP-SHiP Streaming-Bypass (DSSB),"DSSB fuses DRRIP (Dynamic RRIP) with SHiP-lite signature prediction and a set-level streaming-bypass detector to address diverse workload behaviors. DRRIP adaptively chooses between SRRIP (insertions at distant RRPV) and BRRIP (mostly distant, occasional MRU) via 10-bit PSEL and 64 leader sets, responding to recency/frequency patterns. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion: blocks with strong reuse signatures are inserted at MRU regardless of DRRIP mode. Streaming sets are detected by tracking monotonic address deltas; sets with consistent streaming are bypassed (blocks not inserted) with probability 1/2, reducing pollution for workloads like LBM/MCF. This design diversifies prediction sources (combining DRRIP’s recency heuristics and SHiP’s PC-based reuse), insertion depth (MRU for reusable, distant for others), and streaming/bypass logic (set-level detection + probabilistic bypass), all within a compact metadata envelope (~46 KiB). DSSB adapts quickly to phase changes, retaining reusable blocks for control-heavy or phase-changing workloads (ASTAR, MILC, OMNETPP), while suppressing cache pollution from streaming or irregular access patterns.",,ChampSim_CRC2/new_policies/048_02_drrip_ship_streaming_bypass__dssb_t07.cc,0.449903613,0.449903613,0%
1741,lbm,DRRIP-SHiP Streaming-Bypass (DSSB),"DSSB fuses DRRIP (Dynamic RRIP) with SHiP-lite signature prediction and a set-level streaming-bypass detector to address diverse workload behaviors. DRRIP adaptively chooses between SRRIP (insertions at distant RRPV) and BRRIP (mostly distant, occasional MRU) via 10-bit PSEL and 64 leader sets, responding to recency/frequency patterns. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion: blocks with strong reuse signatures are inserted at MRU regardless of DRRIP mode. Streaming sets are detected by tracking monotonic address deltas; sets with consistent streaming are bypassed (blocks not inserted) with probability 1/2, reducing pollution for workloads like LBM/MCF. This design diversifies prediction sources (combining DRRIP’s recency heuristics and SHiP’s PC-based reuse), insertion depth (MRU for reusable, distant for others), and streaming/bypass logic (set-level detection + probabilistic bypass), all within a compact metadata envelope (~46 KiB). DSSB adapts quickly to phase changes, retaining reusable blocks for control-heavy or phase-changing workloads (ASTAR, MILC, OMNETPP), while suppressing cache pollution from streaming or irregular access patterns.",,ChampSim_CRC2/new_policies/048_02_drrip_ship_streaming_bypass__dssb_t07.cc,0.435028965,0.435028965,0%
1742,mcf,DRRIP-SHiP Streaming-Bypass (DSSB),"DSSB fuses DRRIP (Dynamic RRIP) with SHiP-lite signature prediction and a set-level streaming-bypass detector to address diverse workload behaviors. DRRIP adaptively chooses between SRRIP (insertions at distant RRPV) and BRRIP (mostly distant, occasional MRU) via 10-bit PSEL and 64 leader sets, responding to recency/frequency patterns. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion: blocks with strong reuse signatures are inserted at MRU regardless of DRRIP mode. Streaming sets are detected by tracking monotonic address deltas; sets with consistent streaming are bypassed (blocks not inserted) with probability 1/2, reducing pollution for workloads like LBM/MCF. This design diversifies prediction sources (combining DRRIP’s recency heuristics and SHiP’s PC-based reuse), insertion depth (MRU for reusable, distant for others), and streaming/bypass logic (set-level detection + probabilistic bypass), all within a compact metadata envelope (~46 KiB). DSSB adapts quickly to phase changes, retaining reusable blocks for control-heavy or phase-changing workloads (ASTAR, MILC, OMNETPP), while suppressing cache pollution from streaming or irregular access patterns.",,ChampSim_CRC2/new_policies/048_02_drrip_ship_streaming_bypass__dssb_t07.cc,0.45317443,0.45317443,0%
1743,milc,DRRIP-SHiP Streaming-Bypass (DSSB),"DSSB fuses DRRIP (Dynamic RRIP) with SHiP-lite signature prediction and a set-level streaming-bypass detector to address diverse workload behaviors. DRRIP adaptively chooses between SRRIP (insertions at distant RRPV) and BRRIP (mostly distant, occasional MRU) via 10-bit PSEL and 64 leader sets, responding to recency/frequency patterns. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion: blocks with strong reuse signatures are inserted at MRU regardless of DRRIP mode. Streaming sets are detected by tracking monotonic address deltas; sets with consistent streaming are bypassed (blocks not inserted) with probability 1/2, reducing pollution for workloads like LBM/MCF. This design diversifies prediction sources (combining DRRIP’s recency heuristics and SHiP’s PC-based reuse), insertion depth (MRU for reusable, distant for others), and streaming/bypass logic (set-level detection + probabilistic bypass), all within a compact metadata envelope (~46 KiB). DSSB adapts quickly to phase changes, retaining reusable blocks for control-heavy or phase-changing workloads (ASTAR, MILC, OMNETPP), while suppressing cache pollution from streaming or irregular access patterns.",,ChampSim_CRC2/new_policies/048_02_drrip_ship_streaming_bypass__dssb_t07.cc,0.320209708,0.320209708,0%
1744,omnetpp,DRRIP-SHiP Streaming-Bypass (DSSB),"DSSB fuses DRRIP (Dynamic RRIP) with SHiP-lite signature prediction and a set-level streaming-bypass detector to address diverse workload behaviors. DRRIP adaptively chooses between SRRIP (insertions at distant RRPV) and BRRIP (mostly distant, occasional MRU) via 10-bit PSEL and 64 leader sets, responding to recency/frequency patterns. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion: blocks with strong reuse signatures are inserted at MRU regardless of DRRIP mode. Streaming sets are detected by tracking monotonic address deltas; sets with consistent streaming are bypassed (blocks not inserted) with probability 1/2, reducing pollution for workloads like LBM/MCF. This design diversifies prediction sources (combining DRRIP’s recency heuristics and SHiP’s PC-based reuse), insertion depth (MRU for reusable, distant for others), and streaming/bypass logic (set-level detection + probabilistic bypass), all within a compact metadata envelope (~46 KiB). DSSB adapts quickly to phase changes, retaining reusable blocks for control-heavy or phase-changing workloads (ASTAR, MILC, OMNETPP), while suppressing cache pollution from streaming or irregular access patterns.",,ChampSim_CRC2/new_policies/048_02_drrip_ship_streaming_bypass__dssb_t07.cc,0.662698105,0.662698105,0%
1745,all,DRRIP-SHiP Streaming-Bypass (DSSB),"DSSB fuses DRRIP (Dynamic RRIP) with SHiP-lite signature prediction and a set-level streaming-bypass detector to address diverse workload behaviors. DRRIP adaptively chooses between SRRIP (insertions at distant RRPV) and BRRIP (mostly distant, occasional MRU) via 10-bit PSEL and 64 leader sets, responding to recency/frequency patterns. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion: blocks with strong reuse signatures are inserted at MRU regardless of DRRIP mode. Streaming sets are detected by tracking monotonic address deltas; sets with consistent streaming are bypassed (blocks not inserted) with probability 1/2, reducing pollution for workloads like LBM/MCF. This design diversifies prediction sources (combining DRRIP’s recency heuristics and SHiP’s PC-based reuse), insertion depth (MRU for reusable, distant for others), and streaming/bypass logic (set-level detection + probabilistic bypass), all within a compact metadata envelope (~46 KiB). DSSB adapts quickly to phase changes, retaining reusable blocks for control-heavy or phase-changing workloads (ASTAR, MILC, OMNETPP), while suppressing cache pollution from streaming or irregular access patterns.",,ChampSim_CRC2/new_policies/048_02_drrip_ship_streaming_bypass__dssb_t07.cc,0.464202964,0.464202964,46%
1746,astar,SHiP-DBP Adaptive Streaming (SDA-Stream),"SDA-Stream fuses SHiP-lite signature-based prediction with per-block dead-block approximation and a lightweight adaptive streaming bypass. Instead of set-level streaming detection, each block tracks a 2-bit dead-block counter, incremented on misses and decayed periodically, enabling fine-grained identification of cache lines unlikely to be reused. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth: blocks with strong signatures are inserted at MRU, while dead blocks are inserted at distant RRPV or bypassed. Streaming detection is simplified: if a set sees three consecutive monotonic address strides, all new blocks in that set are bypassed for a short window. This hybrid approach improves performance by combining PC-based reuse prediction, per-block dead-block filtering, and adaptive streaming suppression, reducing pollution from LBM/MCF while retaining reusable lines for control-heavy or phase-changing workloads. Metadata remains compact (~48 KiB), and the policy adapts quickly to phase changes and irregular access patterns.",,ChampSim_CRC2/new_policies/049_00_ship_dbp_adaptive_streaming__sda_stream_t02.cc,0.445785022,0.445785022,0%
1747,lbm,SHiP-DBP Adaptive Streaming (SDA-Stream),"SDA-Stream fuses SHiP-lite signature-based prediction with per-block dead-block approximation and a lightweight adaptive streaming bypass. Instead of set-level streaming detection, each block tracks a 2-bit dead-block counter, incremented on misses and decayed periodically, enabling fine-grained identification of cache lines unlikely to be reused. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth: blocks with strong signatures are inserted at MRU, while dead blocks are inserted at distant RRPV or bypassed. Streaming detection is simplified: if a set sees three consecutive monotonic address strides, all new blocks in that set are bypassed for a short window. This hybrid approach improves performance by combining PC-based reuse prediction, per-block dead-block filtering, and adaptive streaming suppression, reducing pollution from LBM/MCF while retaining reusable lines for control-heavy or phase-changing workloads. Metadata remains compact (~48 KiB), and the policy adapts quickly to phase changes and irregular access patterns.",,ChampSim_CRC2/new_policies/049_00_ship_dbp_adaptive_streaming__sda_stream_t02.cc,0.432975077,0.432975077,0%
1748,mcf,SHiP-DBP Adaptive Streaming (SDA-Stream),"SDA-Stream fuses SHiP-lite signature-based prediction with per-block dead-block approximation and a lightweight adaptive streaming bypass. Instead of set-level streaming detection, each block tracks a 2-bit dead-block counter, incremented on misses and decayed periodically, enabling fine-grained identification of cache lines unlikely to be reused. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth: blocks with strong signatures are inserted at MRU, while dead blocks are inserted at distant RRPV or bypassed. Streaming detection is simplified: if a set sees three consecutive monotonic address strides, all new blocks in that set are bypassed for a short window. This hybrid approach improves performance by combining PC-based reuse prediction, per-block dead-block filtering, and adaptive streaming suppression, reducing pollution from LBM/MCF while retaining reusable lines for control-heavy or phase-changing workloads. Metadata remains compact (~48 KiB), and the policy adapts quickly to phase changes and irregular access patterns.",,ChampSim_CRC2/new_policies/049_00_ship_dbp_adaptive_streaming__sda_stream_t02.cc,0.452635472,0.452635472,0%
1749,milc,SHiP-DBP Adaptive Streaming (SDA-Stream),"SDA-Stream fuses SHiP-lite signature-based prediction with per-block dead-block approximation and a lightweight adaptive streaming bypass. Instead of set-level streaming detection, each block tracks a 2-bit dead-block counter, incremented on misses and decayed periodically, enabling fine-grained identification of cache lines unlikely to be reused. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth: blocks with strong signatures are inserted at MRU, while dead blocks are inserted at distant RRPV or bypassed. Streaming detection is simplified: if a set sees three consecutive monotonic address strides, all new blocks in that set are bypassed for a short window. This hybrid approach improves performance by combining PC-based reuse prediction, per-block dead-block filtering, and adaptive streaming suppression, reducing pollution from LBM/MCF while retaining reusable lines for control-heavy or phase-changing workloads. Metadata remains compact (~48 KiB), and the policy adapts quickly to phase changes and irregular access patterns.",,ChampSim_CRC2/new_policies/049_00_ship_dbp_adaptive_streaming__sda_stream_t02.cc,0.30210649,0.30210649,0%
1750,omnetpp,SHiP-DBP Adaptive Streaming (SDA-Stream),"SDA-Stream fuses SHiP-lite signature-based prediction with per-block dead-block approximation and a lightweight adaptive streaming bypass. Instead of set-level streaming detection, each block tracks a 2-bit dead-block counter, incremented on misses and decayed periodically, enabling fine-grained identification of cache lines unlikely to be reused. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth: blocks with strong signatures are inserted at MRU, while dead blocks are inserted at distant RRPV or bypassed. Streaming detection is simplified: if a set sees three consecutive monotonic address strides, all new blocks in that set are bypassed for a short window. This hybrid approach improves performance by combining PC-based reuse prediction, per-block dead-block filtering, and adaptive streaming suppression, reducing pollution from LBM/MCF while retaining reusable lines for control-heavy or phase-changing workloads. Metadata remains compact (~48 KiB), and the policy adapts quickly to phase changes and irregular access patterns.",,ChampSim_CRC2/new_policies/049_00_ship_dbp_adaptive_streaming__sda_stream_t02.cc,0.701695785,0.701695785,0%
1751,astar,SHiP-DIP Streaming Dead-Block (SDSD),"SDSD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion depth control and a lightweight dead-block approximation, while simplifying streaming detection to reduce metadata and improve adaptability. DIP set-dueling dynamically selects between LIP (always insert at LRU) and BIP (insert at MRU with low probability), targeting workloads with bursty or streaming accesses (LBM, MCF). SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth for blocks with strong reuse, overriding DIP when reuse is predicted. A per-block 1-bit dead-block flag is set on eviction and cleared on hit, giving a fast, phase-responsive approximation of block liveness. Streaming sets are detected using a single-bit monotonic delta tracker, and blocks in streaming sets are bypassed with probability 3/4. This design changes both the insertion depth policy (DIP replaces DRRIP) and the streaming/bypass logic, while introducing dead-block approximation for fine-grained control. The result is a compact (<48 KiB) policy that adapts quickly to phase changes, suppresses pollution from streaming/irregular workloads, and retains reusable blocks for control-heavy or phase-changing workloads.",,ChampSim_CRC2/new_policies/049_01_ship_dip_streaming_dead_block__sdsd_t04.cc,0.01198192,0.01198192,0%
1752,lbm,SHiP-DIP Streaming Dead-Block (SDSD),"SDSD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion depth control and a lightweight dead-block approximation, while simplifying streaming detection to reduce metadata and improve adaptability. DIP set-dueling dynamically selects between LIP (always insert at LRU) and BIP (insert at MRU with low probability), targeting workloads with bursty or streaming accesses (LBM, MCF). SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth for blocks with strong reuse, overriding DIP when reuse is predicted. A per-block 1-bit dead-block flag is set on eviction and cleared on hit, giving a fast, phase-responsive approximation of block liveness. Streaming sets are detected using a single-bit monotonic delta tracker, and blocks in streaming sets are bypassed with probability 3/4. This design changes both the insertion depth policy (DIP replaces DRRIP) and the streaming/bypass logic, while introducing dead-block approximation for fine-grained control. The result is a compact (<48 KiB) policy that adapts quickly to phase changes, suppresses pollution from streaming/irregular workloads, and retains reusable blocks for control-heavy or phase-changing workloads.",,ChampSim_CRC2/new_policies/049_01_ship_dip_streaming_dead_block__sdsd_t04.cc,0.020853717,0.020853717,0%
1753,mcf,SHiP-DIP Streaming Dead-Block (SDSD),"SDSD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion depth control and a lightweight dead-block approximation, while simplifying streaming detection to reduce metadata and improve adaptability. DIP set-dueling dynamically selects between LIP (always insert at LRU) and BIP (insert at MRU with low probability), targeting workloads with bursty or streaming accesses (LBM, MCF). SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth for blocks with strong reuse, overriding DIP when reuse is predicted. A per-block 1-bit dead-block flag is set on eviction and cleared on hit, giving a fast, phase-responsive approximation of block liveness. Streaming sets are detected using a single-bit monotonic delta tracker, and blocks in streaming sets are bypassed with probability 3/4. This design changes both the insertion depth policy (DIP replaces DRRIP) and the streaming/bypass logic, while introducing dead-block approximation for fine-grained control. The result is a compact (<48 KiB) policy that adapts quickly to phase changes, suppresses pollution from streaming/irregular workloads, and retains reusable blocks for control-heavy or phase-changing workloads.",,ChampSim_CRC2/new_policies/049_01_ship_dip_streaming_dead_block__sdsd_t04.cc,0.025861876,0.025861876,0%
1754,milc,SHiP-DIP Streaming Dead-Block (SDSD),"SDSD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion depth control and a lightweight dead-block approximation, while simplifying streaming detection to reduce metadata and improve adaptability. DIP set-dueling dynamically selects between LIP (always insert at LRU) and BIP (insert at MRU with low probability), targeting workloads with bursty or streaming accesses (LBM, MCF). SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth for blocks with strong reuse, overriding DIP when reuse is predicted. A per-block 1-bit dead-block flag is set on eviction and cleared on hit, giving a fast, phase-responsive approximation of block liveness. Streaming sets are detected using a single-bit monotonic delta tracker, and blocks in streaming sets are bypassed with probability 3/4. This design changes both the insertion depth policy (DIP replaces DRRIP) and the streaming/bypass logic, while introducing dead-block approximation for fine-grained control. The result is a compact (<48 KiB) policy that adapts quickly to phase changes, suppresses pollution from streaming/irregular workloads, and retains reusable blocks for control-heavy or phase-changing workloads.",,ChampSim_CRC2/new_policies/049_01_ship_dip_streaming_dead_block__sdsd_t04.cc,0.009372036,0.009372036,0%
1755,omnetpp,SHiP-DIP Streaming Dead-Block (SDSD),"SDSD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion depth control and a lightweight dead-block approximation, while simplifying streaming detection to reduce metadata and improve adaptability. DIP set-dueling dynamically selects between LIP (always insert at LRU) and BIP (insert at MRU with low probability), targeting workloads with bursty or streaming accesses (LBM, MCF). SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth for blocks with strong reuse, overriding DIP when reuse is predicted. A per-block 1-bit dead-block flag is set on eviction and cleared on hit, giving a fast, phase-responsive approximation of block liveness. Streaming sets are detected using a single-bit monotonic delta tracker, and blocks in streaming sets are bypassed with probability 3/4. This design changes both the insertion depth policy (DIP replaces DRRIP) and the streaming/bypass logic, while introducing dead-block approximation for fine-grained control. The result is a compact (<48 KiB) policy that adapts quickly to phase changes, suppresses pollution from streaming/irregular workloads, and retains reusable blocks for control-heavy or phase-changing workloads.",,ChampSim_CRC2/new_policies/049_01_ship_dip_streaming_dead_block__sdsd_t04.cc,0.000721746,0.000721746,0%
1756,astar,DB-SHiP Adaptive Streaming (DBSAS),"DBSAS combines per-block dead-block prediction (DBP), SHiP-lite signature-based reuse prediction, and a streamlined set-level streaming detector for robust adaptation across diverse workloads. Each cache block tracks a tiny 2-bit reuse counter, incremented on hits and periodically decayed, providing direct dead-block approximation. SHiP-lite, with 6-bit PC signatures and 2-bit outcome counters, biases insertion depth for blocks with strong reuse history. For sets exhibiting streaming (monotonic address deltas), the policy inserts all blocks at long re-reference distance and probabilistically bypasses insertion to suppress pollution. Insertion depth control fuses DBP and SHiP: blocks predicted dead or in streaming sets are inserted at distant RRPV (or bypassed), while blocks with strong reuse signature or recent hits are inserted at MRU. This hybrid approach leverages direct reuse/deadness signals and signature-based learning, dynamically adapting to phase changes, irregular access, and streaming patterns. Metadata is compact: per-block 2 bits for DBP, per-block 6 bits for SHiP-lite signature, plus small set-level streaming state. This design materially changes prediction source (adds DBP), insertion depth policy (combines DBP + SHiP), and streaming logic for improved overall cache hit rate.",,ChampSim_CRC2/new_policies/049_02_db_ship_adaptive_streaming__dbsas_t07.cc,0.025284731,0.025284731,0%
1757,lbm,DB-SHiP Adaptive Streaming (DBSAS),"DBSAS combines per-block dead-block prediction (DBP), SHiP-lite signature-based reuse prediction, and a streamlined set-level streaming detector for robust adaptation across diverse workloads. Each cache block tracks a tiny 2-bit reuse counter, incremented on hits and periodically decayed, providing direct dead-block approximation. SHiP-lite, with 6-bit PC signatures and 2-bit outcome counters, biases insertion depth for blocks with strong reuse history. For sets exhibiting streaming (monotonic address deltas), the policy inserts all blocks at long re-reference distance and probabilistically bypasses insertion to suppress pollution. Insertion depth control fuses DBP and SHiP: blocks predicted dead or in streaming sets are inserted at distant RRPV (or bypassed), while blocks with strong reuse signature or recent hits are inserted at MRU. This hybrid approach leverages direct reuse/deadness signals and signature-based learning, dynamically adapting to phase changes, irregular access, and streaming patterns. Metadata is compact: per-block 2 bits for DBP, per-block 6 bits for SHiP-lite signature, plus small set-level streaming state. This design materially changes prediction source (adds DBP), insertion depth policy (combines DBP + SHiP), and streaming logic for improved overall cache hit rate.",,ChampSim_CRC2/new_policies/049_02_db_ship_adaptive_streaming__dbsas_t07.cc,0.037307317,0.037307317,0%
1758,mcf,DB-SHiP Adaptive Streaming (DBSAS),"DBSAS combines per-block dead-block prediction (DBP), SHiP-lite signature-based reuse prediction, and a streamlined set-level streaming detector for robust adaptation across diverse workloads. Each cache block tracks a tiny 2-bit reuse counter, incremented on hits and periodically decayed, providing direct dead-block approximation. SHiP-lite, with 6-bit PC signatures and 2-bit outcome counters, biases insertion depth for blocks with strong reuse history. For sets exhibiting streaming (monotonic address deltas), the policy inserts all blocks at long re-reference distance and probabilistically bypasses insertion to suppress pollution. Insertion depth control fuses DBP and SHiP: blocks predicted dead or in streaming sets are inserted at distant RRPV (or bypassed), while blocks with strong reuse signature or recent hits are inserted at MRU. This hybrid approach leverages direct reuse/deadness signals and signature-based learning, dynamically adapting to phase changes, irregular access, and streaming patterns. Metadata is compact: per-block 2 bits for DBP, per-block 6 bits for SHiP-lite signature, plus small set-level streaming state. This design materially changes prediction source (adds DBP), insertion depth policy (combines DBP + SHiP), and streaming logic for improved overall cache hit rate.",,ChampSim_CRC2/new_policies/049_02_db_ship_adaptive_streaming__dbsas_t07.cc,0.098986457,0.098986457,0%
1759,milc,DB-SHiP Adaptive Streaming (DBSAS),"DBSAS combines per-block dead-block prediction (DBP), SHiP-lite signature-based reuse prediction, and a streamlined set-level streaming detector for robust adaptation across diverse workloads. Each cache block tracks a tiny 2-bit reuse counter, incremented on hits and periodically decayed, providing direct dead-block approximation. SHiP-lite, with 6-bit PC signatures and 2-bit outcome counters, biases insertion depth for blocks with strong reuse history. For sets exhibiting streaming (monotonic address deltas), the policy inserts all blocks at long re-reference distance and probabilistically bypasses insertion to suppress pollution. Insertion depth control fuses DBP and SHiP: blocks predicted dead or in streaming sets are inserted at distant RRPV (or bypassed), while blocks with strong reuse signature or recent hits are inserted at MRU. This hybrid approach leverages direct reuse/deadness signals and signature-based learning, dynamically adapting to phase changes, irregular access, and streaming patterns. Metadata is compact: per-block 2 bits for DBP, per-block 6 bits for SHiP-lite signature, plus small set-level streaming state. This design materially changes prediction source (adds DBP), insertion depth policy (combines DBP + SHiP), and streaming logic for improved overall cache hit rate.",,ChampSim_CRC2/new_policies/049_02_db_ship_adaptive_streaming__dbsas_t07.cc,0.011528129,0.011528129,0%
1760,omnetpp,DB-SHiP Adaptive Streaming (DBSAS),"DBSAS combines per-block dead-block prediction (DBP), SHiP-lite signature-based reuse prediction, and a streamlined set-level streaming detector for robust adaptation across diverse workloads. Each cache block tracks a tiny 2-bit reuse counter, incremented on hits and periodically decayed, providing direct dead-block approximation. SHiP-lite, with 6-bit PC signatures and 2-bit outcome counters, biases insertion depth for blocks with strong reuse history. For sets exhibiting streaming (monotonic address deltas), the policy inserts all blocks at long re-reference distance and probabilistically bypasses insertion to suppress pollution. Insertion depth control fuses DBP and SHiP: blocks predicted dead or in streaming sets are inserted at distant RRPV (or bypassed), while blocks with strong reuse signature or recent hits are inserted at MRU. This hybrid approach leverages direct reuse/deadness signals and signature-based learning, dynamically adapting to phase changes, irregular access, and streaming patterns. Metadata is compact: per-block 2 bits for DBP, per-block 6 bits for SHiP-lite signature, plus small set-level streaming state. This design materially changes prediction source (adds DBP), insertion depth policy (combines DBP + SHiP), and streaming logic for improved overall cache hit rate.",,ChampSim_CRC2/new_policies/049_02_db_ship_adaptive_streaming__dbsas_t07.cc,0.001813312,0.001813312,0%
1761,all,SHiP-DBP Adaptive Streaming (SDA-Stream),"SDA-Stream fuses SHiP-lite signature-based prediction with per-block dead-block approximation and a lightweight adaptive streaming bypass. Instead of set-level streaming detection, each block tracks a 2-bit dead-block counter, incremented on misses and decayed periodically, enabling fine-grained identification of cache lines unlikely to be reused. SHiP-lite (6-bit PC signature, 2-bit outcome counters) biases insertion depth: blocks with strong signatures are inserted at MRU, while dead blocks are inserted at distant RRPV or bypassed. Streaming detection is simplified: if a set sees three consecutive monotonic address strides, all new blocks in that set are bypassed for a short window. This hybrid approach improves performance by combining PC-based reuse prediction, per-block dead-block filtering, and adaptive streaming suppression, reducing pollution from LBM/MCF while retaining reusable lines for control-heavy or phase-changing workloads. Metadata remains compact (~48 KiB), and the policy adapts quickly to phase changes and irregular access patterns.",,ChampSim_CRC2/new_policies/049_00_ship_dbp_adaptive_streaming__sda_stream_t02.cc,0.467039569,0.467039569,47%
1762,astar,Hybrid Address-Signature Streaming Deadblock (HASD),"HASD combines three compact mechanisms for robust cache replacement: (1) Address-based reuse prediction using a 6-bit partial address signature per block, (2) per-block dead-block counters for fine-grained deadness detection, and (3) a lightweight per-set streaming detector that tracks monotonic address strides. On insertion, blocks with hot address signatures and low dead-block counters are inserted at MRU (RRPV=0), while cold signatures or high dead-block counters are inserted at distant RRPV (RRPV=2/3). If a set is detected as streaming (three consecutive monotonic strides), all new blocks in that set are bypassed for a short window. This hybrid approach adapts quickly to phase changes (MILC, OMNETPP), suppresses pollution from streaming scans (LBM, MCF), and retains reusable lines for control-heavy workloads (ASTAR). Metadata is compact: 6 bits/block for address signature, 2 bits/block for dead-block counter, 2 bits/signature (2048-entry table), 3 bits/set for streaming detection, and 2 bits/block for RRPV, totaling <64 KiB. By leveraging address-based prediction (diverse from PC-based), fine-grained dead-block filtering, and adaptive streaming suppression, HASD outperforms prior policies across all workloads.",,ChampSim_CRC2/new_policies/000_00_hybrid_address_signature_streaming_deadblock__hasd_t02.cc,0.437415839,0.437415839,0%
1763,lbm,Hybrid Address-Signature Streaming Deadblock (HASD),"HASD combines three compact mechanisms for robust cache replacement: (1) Address-based reuse prediction using a 6-bit partial address signature per block, (2) per-block dead-block counters for fine-grained deadness detection, and (3) a lightweight per-set streaming detector that tracks monotonic address strides. On insertion, blocks with hot address signatures and low dead-block counters are inserted at MRU (RRPV=0), while cold signatures or high dead-block counters are inserted at distant RRPV (RRPV=2/3). If a set is detected as streaming (three consecutive monotonic strides), all new blocks in that set are bypassed for a short window. This hybrid approach adapts quickly to phase changes (MILC, OMNETPP), suppresses pollution from streaming scans (LBM, MCF), and retains reusable lines for control-heavy workloads (ASTAR). Metadata is compact: 6 bits/block for address signature, 2 bits/block for dead-block counter, 2 bits/signature (2048-entry table), 3 bits/set for streaming detection, and 2 bits/block for RRPV, totaling <64 KiB. By leveraging address-based prediction (diverse from PC-based), fine-grained dead-block filtering, and adaptive streaming suppression, HASD outperforms prior policies across all workloads.",,ChampSim_CRC2/new_policies/000_00_hybrid_address_signature_streaming_deadblock__hasd_t02.cc,0.413981964,0.413981964,0%
1764,mcf,Hybrid Address-Signature Streaming Deadblock (HASD),"HASD combines three compact mechanisms for robust cache replacement: (1) Address-based reuse prediction using a 6-bit partial address signature per block, (2) per-block dead-block counters for fine-grained deadness detection, and (3) a lightweight per-set streaming detector that tracks monotonic address strides. On insertion, blocks with hot address signatures and low dead-block counters are inserted at MRU (RRPV=0), while cold signatures or high dead-block counters are inserted at distant RRPV (RRPV=2/3). If a set is detected as streaming (three consecutive monotonic strides), all new blocks in that set are bypassed for a short window. This hybrid approach adapts quickly to phase changes (MILC, OMNETPP), suppresses pollution from streaming scans (LBM, MCF), and retains reusable lines for control-heavy workloads (ASTAR). Metadata is compact: 6 bits/block for address signature, 2 bits/block for dead-block counter, 2 bits/signature (2048-entry table), 3 bits/set for streaming detection, and 2 bits/block for RRPV, totaling <64 KiB. By leveraging address-based prediction (diverse from PC-based), fine-grained dead-block filtering, and adaptive streaming suppression, HASD outperforms prior policies across all workloads.",,ChampSim_CRC2/new_policies/000_00_hybrid_address_signature_streaming_deadblock__hasd_t02.cc,0.447593396,0.447593396,0%
1765,milc,Hybrid Address-Signature Streaming Deadblock (HASD),"HASD combines three compact mechanisms for robust cache replacement: (1) Address-based reuse prediction using a 6-bit partial address signature per block, (2) per-block dead-block counters for fine-grained deadness detection, and (3) a lightweight per-set streaming detector that tracks monotonic address strides. On insertion, blocks with hot address signatures and low dead-block counters are inserted at MRU (RRPV=0), while cold signatures or high dead-block counters are inserted at distant RRPV (RRPV=2/3). If a set is detected as streaming (three consecutive monotonic strides), all new blocks in that set are bypassed for a short window. This hybrid approach adapts quickly to phase changes (MILC, OMNETPP), suppresses pollution from streaming scans (LBM, MCF), and retains reusable lines for control-heavy workloads (ASTAR). Metadata is compact: 6 bits/block for address signature, 2 bits/block for dead-block counter, 2 bits/signature (2048-entry table), 3 bits/set for streaming detection, and 2 bits/block for RRPV, totaling <64 KiB. By leveraging address-based prediction (diverse from PC-based), fine-grained dead-block filtering, and adaptive streaming suppression, HASD outperforms prior policies across all workloads.",,ChampSim_CRC2/new_policies/000_00_hybrid_address_signature_streaming_deadblock__hasd_t02.cc,0.310989739,0.310989739,0%
1766,omnetpp,Hybrid Address-Signature Streaming Deadblock (HASD),"HASD combines three compact mechanisms for robust cache replacement: (1) Address-based reuse prediction using a 6-bit partial address signature per block, (2) per-block dead-block counters for fine-grained deadness detection, and (3) a lightweight per-set streaming detector that tracks monotonic address strides. On insertion, blocks with hot address signatures and low dead-block counters are inserted at MRU (RRPV=0), while cold signatures or high dead-block counters are inserted at distant RRPV (RRPV=2/3). If a set is detected as streaming (three consecutive monotonic strides), all new blocks in that set are bypassed for a short window. This hybrid approach adapts quickly to phase changes (MILC, OMNETPP), suppresses pollution from streaming scans (LBM, MCF), and retains reusable lines for control-heavy workloads (ASTAR). Metadata is compact: 6 bits/block for address signature, 2 bits/block for dead-block counter, 2 bits/signature (2048-entry table), 3 bits/set for streaming detection, and 2 bits/block for RRPV, totaling <64 KiB. By leveraging address-based prediction (diverse from PC-based), fine-grained dead-block filtering, and adaptive streaming suppression, HASD outperforms prior policies across all workloads.",,ChampSim_CRC2/new_policies/000_00_hybrid_address_signature_streaming_deadblock__hasd_t02.cc,0.544106507,0.544106507,0%
1767,astar,Hybrid Address-Signature Streaming Adaptive (HAS-SA),"HAS-SA combines address-based reuse prediction (via compact address hashing), lightweight PC signature tracking, and per-set streaming detection to adapt insertion and bypass strategies for diverse workloads. For control-heavy and phase-shifting workloads (astar, milc, omnetpp), PC signatures bias insertion depth: hot signatures insert at MRU, cold at distant RRPV. For memory-bound and streaming workloads (lbm, mcf), address-based reuse counters (using 8-bit address hashes) identify blocks with low reuse, which are inserted at distant RRPV or bypassed. A per-set streaming detector tracks monotonic address strides; if detected, all new blocks with cold address hashes or PC signatures are bypassed for that set. Set-dueling across 32 leader sets selects between SRRIP and BRRIP globally. This hybrid approach leverages both address and PC-based reuse signals, adapts to streaming scans, and suppresses pollution from dead blocks, outperforming prior policies across all workloads. Metadata is kept under 64 KiB: 6 bits/block for PC signature, 8 bits/block for address hash, 2 bits/block for RRPV, 2 bits/counter for 2K PC signatures, 2 bits/counter for 1K address hashes, 3 bits/set for streaming, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/000_01_hybrid_address_signature_streaming_adaptive__has_sa_t04.cc,0.008052028,0.008052028,0%
1768,lbm,Hybrid Address-Signature Streaming Adaptive (HAS-SA),"HAS-SA combines address-based reuse prediction (via compact address hashing), lightweight PC signature tracking, and per-set streaming detection to adapt insertion and bypass strategies for diverse workloads. For control-heavy and phase-shifting workloads (astar, milc, omnetpp), PC signatures bias insertion depth: hot signatures insert at MRU, cold at distant RRPV. For memory-bound and streaming workloads (lbm, mcf), address-based reuse counters (using 8-bit address hashes) identify blocks with low reuse, which are inserted at distant RRPV or bypassed. A per-set streaming detector tracks monotonic address strides; if detected, all new blocks with cold address hashes or PC signatures are bypassed for that set. Set-dueling across 32 leader sets selects between SRRIP and BRRIP globally. This hybrid approach leverages both address and PC-based reuse signals, adapts to streaming scans, and suppresses pollution from dead blocks, outperforming prior policies across all workloads. Metadata is kept under 64 KiB: 6 bits/block for PC signature, 8 bits/block for address hash, 2 bits/block for RRPV, 2 bits/counter for 2K PC signatures, 2 bits/counter for 1K address hashes, 3 bits/set for streaming, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/000_01_hybrid_address_signature_streaming_adaptive__has_sa_t04.cc,0.018892991,0.018892991,0%
1769,mcf,Hybrid Address-Signature Streaming Adaptive (HAS-SA),"HAS-SA combines address-based reuse prediction (via compact address hashing), lightweight PC signature tracking, and per-set streaming detection to adapt insertion and bypass strategies for diverse workloads. For control-heavy and phase-shifting workloads (astar, milc, omnetpp), PC signatures bias insertion depth: hot signatures insert at MRU, cold at distant RRPV. For memory-bound and streaming workloads (lbm, mcf), address-based reuse counters (using 8-bit address hashes) identify blocks with low reuse, which are inserted at distant RRPV or bypassed. A per-set streaming detector tracks monotonic address strides; if detected, all new blocks with cold address hashes or PC signatures are bypassed for that set. Set-dueling across 32 leader sets selects between SRRIP and BRRIP globally. This hybrid approach leverages both address and PC-based reuse signals, adapts to streaming scans, and suppresses pollution from dead blocks, outperforming prior policies across all workloads. Metadata is kept under 64 KiB: 6 bits/block for PC signature, 8 bits/block for address hash, 2 bits/block for RRPV, 2 bits/counter for 2K PC signatures, 2 bits/counter for 1K address hashes, 3 bits/set for streaming, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/000_01_hybrid_address_signature_streaming_adaptive__has_sa_t04.cc,0.010292393,0.010292393,0%
1770,milc,Hybrid Address-Signature Streaming Adaptive (HAS-SA),"HAS-SA combines address-based reuse prediction (via compact address hashing), lightweight PC signature tracking, and per-set streaming detection to adapt insertion and bypass strategies for diverse workloads. For control-heavy and phase-shifting workloads (astar, milc, omnetpp), PC signatures bias insertion depth: hot signatures insert at MRU, cold at distant RRPV. For memory-bound and streaming workloads (lbm, mcf), address-based reuse counters (using 8-bit address hashes) identify blocks with low reuse, which are inserted at distant RRPV or bypassed. A per-set streaming detector tracks monotonic address strides; if detected, all new blocks with cold address hashes or PC signatures are bypassed for that set. Set-dueling across 32 leader sets selects between SRRIP and BRRIP globally. This hybrid approach leverages both address and PC-based reuse signals, adapts to streaming scans, and suppresses pollution from dead blocks, outperforming prior policies across all workloads. Metadata is kept under 64 KiB: 6 bits/block for PC signature, 8 bits/block for address hash, 2 bits/block for RRPV, 2 bits/counter for 2K PC signatures, 2 bits/counter for 1K address hashes, 3 bits/set for streaming, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/000_01_hybrid_address_signature_streaming_adaptive__has_sa_t04.cc,0.008928507,0.008928507,0%
1771,omnetpp,Hybrid Address-Signature Streaming Adaptive (HAS-SA),"HAS-SA combines address-based reuse prediction (via compact address hashing), lightweight PC signature tracking, and per-set streaming detection to adapt insertion and bypass strategies for diverse workloads. For control-heavy and phase-shifting workloads (astar, milc, omnetpp), PC signatures bias insertion depth: hot signatures insert at MRU, cold at distant RRPV. For memory-bound and streaming workloads (lbm, mcf), address-based reuse counters (using 8-bit address hashes) identify blocks with low reuse, which are inserted at distant RRPV or bypassed. A per-set streaming detector tracks monotonic address strides; if detected, all new blocks with cold address hashes or PC signatures are bypassed for that set. Set-dueling across 32 leader sets selects between SRRIP and BRRIP globally. This hybrid approach leverages both address and PC-based reuse signals, adapts to streaming scans, and suppresses pollution from dead blocks, outperforming prior policies across all workloads. Metadata is kept under 64 KiB: 6 bits/block for PC signature, 8 bits/block for address hash, 2 bits/block for RRPV, 2 bits/counter for 2K PC signatures, 2 bits/counter for 1K address hashes, 3 bits/set for streaming, and 10 bits for PSEL.",,ChampSim_CRC2/new_policies/000_01_hybrid_address_signature_streaming_adaptive__has_sa_t04.cc,0.000721746,0.000721746,0%
1772,all,Hybrid Address-Signature Streaming Deadblock (HASD),"HASD combines three compact mechanisms for robust cache replacement: (1) Address-based reuse prediction using a 6-bit partial address signature per block, (2) per-block dead-block counters for fine-grained deadness detection, and (3) a lightweight per-set streaming detector that tracks monotonic address strides. On insertion, blocks with hot address signatures and low dead-block counters are inserted at MRU (RRPV=0), while cold signatures or high dead-block counters are inserted at distant RRPV (RRPV=2/3). If a set is detected as streaming (three consecutive monotonic strides), all new blocks in that set are bypassed for a short window. This hybrid approach adapts quickly to phase changes (MILC, OMNETPP), suppresses pollution from streaming scans (LBM, MCF), and retains reusable lines for control-heavy workloads (ASTAR). Metadata is compact: 6 bits/block for address signature, 2 bits/block for dead-block counter, 2 bits/signature (2048-entry table), 3 bits/set for streaming detection, and 2 bits/block for RRPV, totaling <64 KiB. By leveraging address-based prediction (diverse from PC-based), fine-grained dead-block filtering, and adaptive streaming suppression, HASD outperforms prior policies across all workloads.",,ChampSim_CRC2/new_policies/000_00_hybrid_address_signature_streaming_deadblock__hasd_t02.cc,0.430817489,0.430817489,43%
1773,astar,SHiP-Lite + Streaming-Aware DRRIP (SADRRIP),"SADRRIP combines SHiP-lite (Signature-based Hit Predictor) using 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, with DRRIP (Dynamic RRIP) set-dueling for global adaptation, and a lightweight per-set streaming detector for scan/bypass. On insertion, blocks are placed at MRU (RRPV=0) if their PC signature is ""hot"" (outcome counter ≥2), or at distant RRPV (RRPV=2/3) otherwise. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-streaming sets. If a set is detected as streaming (three consecutive monotonic address strides), all new blocks in that set are inserted at LRU (RRPV=3) for a short window, suppressing scan pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 10 bits for PSEL, 1 bit/set for leader, 3 bits/set for streaming detection, and 2 bits/block for outcome counter, totaling <64 KiB. This design leverages PC-based reuse prediction (diverse from address-based), global adaptation to workload phase changes, and streaming suppression, improving hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_00_ship_lite___streaming_aware_drrip__sadrrip_t02.cc,0.441975613,0.441975613,0%
1774,lbm,SHiP-Lite + Streaming-Aware DRRIP (SADRRIP),"SADRRIP combines SHiP-lite (Signature-based Hit Predictor) using 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, with DRRIP (Dynamic RRIP) set-dueling for global adaptation, and a lightweight per-set streaming detector for scan/bypass. On insertion, blocks are placed at MRU (RRPV=0) if their PC signature is ""hot"" (outcome counter ≥2), or at distant RRPV (RRPV=2/3) otherwise. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-streaming sets. If a set is detected as streaming (three consecutive monotonic address strides), all new blocks in that set are inserted at LRU (RRPV=3) for a short window, suppressing scan pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 10 bits for PSEL, 1 bit/set for leader, 3 bits/set for streaming detection, and 2 bits/block for outcome counter, totaling <64 KiB. This design leverages PC-based reuse prediction (diverse from address-based), global adaptation to workload phase changes, and streaming suppression, improving hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_00_ship_lite___streaming_aware_drrip__sadrrip_t02.cc,0.30274132,0.30274132,0%
1775,mcf,SHiP-Lite + Streaming-Aware DRRIP (SADRRIP),"SADRRIP combines SHiP-lite (Signature-based Hit Predictor) using 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, with DRRIP (Dynamic RRIP) set-dueling for global adaptation, and a lightweight per-set streaming detector for scan/bypass. On insertion, blocks are placed at MRU (RRPV=0) if their PC signature is ""hot"" (outcome counter ≥2), or at distant RRPV (RRPV=2/3) otherwise. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-streaming sets. If a set is detected as streaming (three consecutive monotonic address strides), all new blocks in that set are inserted at LRU (RRPV=3) for a short window, suppressing scan pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 10 bits for PSEL, 1 bit/set for leader, 3 bits/set for streaming detection, and 2 bits/block for outcome counter, totaling <64 KiB. This design leverages PC-based reuse prediction (diverse from address-based), global adaptation to workload phase changes, and streaming suppression, improving hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_00_ship_lite___streaming_aware_drrip__sadrrip_t02.cc,0.480079691,0.480079691,0%
1776,milc,SHiP-Lite + Streaming-Aware DRRIP (SADRRIP),"SADRRIP combines SHiP-lite (Signature-based Hit Predictor) using 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, with DRRIP (Dynamic RRIP) set-dueling for global adaptation, and a lightweight per-set streaming detector for scan/bypass. On insertion, blocks are placed at MRU (RRPV=0) if their PC signature is ""hot"" (outcome counter ≥2), or at distant RRPV (RRPV=2/3) otherwise. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-streaming sets. If a set is detected as streaming (three consecutive monotonic address strides), all new blocks in that set are inserted at LRU (RRPV=3) for a short window, suppressing scan pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 10 bits for PSEL, 1 bit/set for leader, 3 bits/set for streaming detection, and 2 bits/block for outcome counter, totaling <64 KiB. This design leverages PC-based reuse prediction (diverse from address-based), global adaptation to workload phase changes, and streaming suppression, improving hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_00_ship_lite___streaming_aware_drrip__sadrrip_t02.cc,0.18208578,0.18208578,0%
1777,omnetpp,SHiP-Lite + Streaming-Aware DRRIP (SADRRIP),"SADRRIP combines SHiP-lite (Signature-based Hit Predictor) using 6-bit PC signatures and 2-bit outcome counters to bias insertion depth, with DRRIP (Dynamic RRIP) set-dueling for global adaptation, and a lightweight per-set streaming detector for scan/bypass. On insertion, blocks are placed at MRU (RRPV=0) if their PC signature is ""hot"" (outcome counter ≥2), or at distant RRPV (RRPV=2/3) otherwise. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for non-streaming sets. If a set is detected as streaming (three consecutive monotonic address strides), all new blocks in that set are inserted at LRU (RRPV=3) for a short window, suppressing scan pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 10 bits for PSEL, 1 bit/set for leader, 3 bits/set for streaming detection, and 2 bits/block for outcome counter, totaling <64 KiB. This design leverages PC-based reuse prediction (diverse from address-based), global adaptation to workload phase changes, and streaming suppression, improving hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_00_ship_lite___streaming_aware_drrip__sadrrip_t02.cc,0.684547065,0.684547065,0%
1778,astar,SHiP-Lite Streaming DRRIP (SLSD),"SLSD combines PC-based signature prediction (SHiP-Lite) with Dynamic RRIP (DRRIP) set-dueling and a lightweight streaming detector to adaptively control insertion depth and bypass logic. Each cache block tracks a 6-bit PC signature and a 2-bit outcome counter (global table, 2048 entries), biasing insertion toward MRU if the signature is ""hot"" (high reuse) and toward distant RRPV if ""cold."" DRRIP set-dueling (with a 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for most sets, improving adaptation to phase changes (MILC, OMNETPP). A per-set streaming detector (3 bits/set) identifies monotonic address strides and triggers short-term bypassing for streaming sets (LBM, MCF), reducing pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (2048-entry table), 10 bits for PSEL, 3 bits/set for streaming detection, totaling <64 KiB. By diversifying prediction source (PC signature), leveraging DRRIP adaptation, and streaming-aware bypass, SLSD robustly improves hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_01_ship_lite_streaming_drrip__slsd_t04.cc,0.187423812,0.187423812,0%
1779,lbm,SHiP-Lite Streaming DRRIP (SLSD),"SLSD combines PC-based signature prediction (SHiP-Lite) with Dynamic RRIP (DRRIP) set-dueling and a lightweight streaming detector to adaptively control insertion depth and bypass logic. Each cache block tracks a 6-bit PC signature and a 2-bit outcome counter (global table, 2048 entries), biasing insertion toward MRU if the signature is ""hot"" (high reuse) and toward distant RRPV if ""cold."" DRRIP set-dueling (with a 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for most sets, improving adaptation to phase changes (MILC, OMNETPP). A per-set streaming detector (3 bits/set) identifies monotonic address strides and triggers short-term bypassing for streaming sets (LBM, MCF), reducing pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (2048-entry table), 10 bits for PSEL, 3 bits/set for streaming detection, totaling <64 KiB. By diversifying prediction source (PC signature), leveraging DRRIP adaptation, and streaming-aware bypass, SLSD robustly improves hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_01_ship_lite_streaming_drrip__slsd_t04.cc,0.137697602,0.137697602,0%
1780,mcf,SHiP-Lite Streaming DRRIP (SLSD),"SLSD combines PC-based signature prediction (SHiP-Lite) with Dynamic RRIP (DRRIP) set-dueling and a lightweight streaming detector to adaptively control insertion depth and bypass logic. Each cache block tracks a 6-bit PC signature and a 2-bit outcome counter (global table, 2048 entries), biasing insertion toward MRU if the signature is ""hot"" (high reuse) and toward distant RRPV if ""cold."" DRRIP set-dueling (with a 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for most sets, improving adaptation to phase changes (MILC, OMNETPP). A per-set streaming detector (3 bits/set) identifies monotonic address strides and triggers short-term bypassing for streaming sets (LBM, MCF), reducing pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (2048-entry table), 10 bits for PSEL, 3 bits/set for streaming detection, totaling <64 KiB. By diversifying prediction source (PC signature), leveraging DRRIP adaptation, and streaming-aware bypass, SLSD robustly improves hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_01_ship_lite_streaming_drrip__slsd_t04.cc,0.360174823,0.360174823,0%
1781,milc,SHiP-Lite Streaming DRRIP (SLSD),"SLSD combines PC-based signature prediction (SHiP-Lite) with Dynamic RRIP (DRRIP) set-dueling and a lightweight streaming detector to adaptively control insertion depth and bypass logic. Each cache block tracks a 6-bit PC signature and a 2-bit outcome counter (global table, 2048 entries), biasing insertion toward MRU if the signature is ""hot"" (high reuse) and toward distant RRPV if ""cold."" DRRIP set-dueling (with a 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for most sets, improving adaptation to phase changes (MILC, OMNETPP). A per-set streaming detector (3 bits/set) identifies monotonic address strides and triggers short-term bypassing for streaming sets (LBM, MCF), reducing pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (2048-entry table), 10 bits for PSEL, 3 bits/set for streaming detection, totaling <64 KiB. By diversifying prediction source (PC signature), leveraging DRRIP adaptation, and streaming-aware bypass, SLSD robustly improves hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_01_ship_lite_streaming_drrip__slsd_t04.cc,0.017044179,0.017044179,0%
1782,omnetpp,SHiP-Lite Streaming DRRIP (SLSD),"SLSD combines PC-based signature prediction (SHiP-Lite) with Dynamic RRIP (DRRIP) set-dueling and a lightweight streaming detector to adaptively control insertion depth and bypass logic. Each cache block tracks a 6-bit PC signature and a 2-bit outcome counter (global table, 2048 entries), biasing insertion toward MRU if the signature is ""hot"" (high reuse) and toward distant RRPV if ""cold."" DRRIP set-dueling (with a 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for most sets, improving adaptation to phase changes (MILC, OMNETPP). A per-set streaming detector (3 bits/set) identifies monotonic address strides and triggers short-term bypassing for streaming sets (LBM, MCF), reducing pollution. Metadata is compact: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (2048-entry table), 10 bits for PSEL, 3 bits/set for streaming detection, totaling <64 KiB. By diversifying prediction source (PC signature), leveraging DRRIP adaptation, and streaming-aware bypass, SLSD robustly improves hit rate across all workloads.",,ChampSim_CRC2/new_policies/001_01_ship_lite_streaming_drrip__slsd_t04.cc,0.335409099,0.335409099,0%
1783,astar,SHiP-Lite with DRRIP Bypassing (SLDB),"SLDB combines PC-based SHiP-lite signatures (6-bit per-block, 2-bit outcome table) with DRRIP (Dynamic RRIP) insertion depth control and a streaming detector for adaptive bypassing. SHiP-lite uses the PC of the memory instruction to guide insertion: blocks with hot signatures (high reuse) are inserted at MRU, while cold ones are inserted at distant RRPV. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for non-leader sets, improving adaptation to workload phase changes (MILC, OMNETPP). A compact streaming detector (3 bits/set) identifies monotonic address strides (LBM, MCF) and triggers short-lived bypassing, preventing cache pollution from streaming accesses. Metadata includes: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL, for a total under 64 KiB. By switching prediction source to PC-based signatures, leveraging DRRIP's adaptive depth control, and integrating streaming bypass, SLDB robustly improves performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_02_ship_lite_with_drrip_bypassing__sldb_t07.cc,0.43296326,0.43296326,0%
1784,lbm,SHiP-Lite with DRRIP Bypassing (SLDB),"SLDB combines PC-based SHiP-lite signatures (6-bit per-block, 2-bit outcome table) with DRRIP (Dynamic RRIP) insertion depth control and a streaming detector for adaptive bypassing. SHiP-lite uses the PC of the memory instruction to guide insertion: blocks with hot signatures (high reuse) are inserted at MRU, while cold ones are inserted at distant RRPV. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for non-leader sets, improving adaptation to workload phase changes (MILC, OMNETPP). A compact streaming detector (3 bits/set) identifies monotonic address strides (LBM, MCF) and triggers short-lived bypassing, preventing cache pollution from streaming accesses. Metadata includes: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL, for a total under 64 KiB. By switching prediction source to PC-based signatures, leveraging DRRIP's adaptive depth control, and integrating streaming bypass, SLDB robustly improves performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_02_ship_lite_with_drrip_bypassing__sldb_t07.cc,0.411871355,0.411871355,0%
1785,mcf,SHiP-Lite with DRRIP Bypassing (SLDB),"SLDB combines PC-based SHiP-lite signatures (6-bit per-block, 2-bit outcome table) with DRRIP (Dynamic RRIP) insertion depth control and a streaming detector for adaptive bypassing. SHiP-lite uses the PC of the memory instruction to guide insertion: blocks with hot signatures (high reuse) are inserted at MRU, while cold ones are inserted at distant RRPV. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for non-leader sets, improving adaptation to workload phase changes (MILC, OMNETPP). A compact streaming detector (3 bits/set) identifies monotonic address strides (LBM, MCF) and triggers short-lived bypassing, preventing cache pollution from streaming accesses. Metadata includes: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL, for a total under 64 KiB. By switching prediction source to PC-based signatures, leveraging DRRIP's adaptive depth control, and integrating streaming bypass, SLDB robustly improves performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_02_ship_lite_with_drrip_bypassing__sldb_t07.cc,0.472916373,0.472916373,0%
1786,milc,SHiP-Lite with DRRIP Bypassing (SLDB),"SLDB combines PC-based SHiP-lite signatures (6-bit per-block, 2-bit outcome table) with DRRIP (Dynamic RRIP) insertion depth control and a streaming detector for adaptive bypassing. SHiP-lite uses the PC of the memory instruction to guide insertion: blocks with hot signatures (high reuse) are inserted at MRU, while cold ones are inserted at distant RRPV. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for non-leader sets, improving adaptation to workload phase changes (MILC, OMNETPP). A compact streaming detector (3 bits/set) identifies monotonic address strides (LBM, MCF) and triggers short-lived bypassing, preventing cache pollution from streaming accesses. Metadata includes: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL, for a total under 64 KiB. By switching prediction source to PC-based signatures, leveraging DRRIP's adaptive depth control, and integrating streaming bypass, SLDB robustly improves performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_02_ship_lite_with_drrip_bypassing__sldb_t07.cc,0.314114354,0.314114354,0%
1787,omnetpp,SHiP-Lite with DRRIP Bypassing (SLDB),"SLDB combines PC-based SHiP-lite signatures (6-bit per-block, 2-bit outcome table) with DRRIP (Dynamic RRIP) insertion depth control and a streaming detector for adaptive bypassing. SHiP-lite uses the PC of the memory instruction to guide insertion: blocks with hot signatures (high reuse) are inserted at MRU, while cold ones are inserted at distant RRPV. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for non-leader sets, improving adaptation to workload phase changes (MILC, OMNETPP). A compact streaming detector (3 bits/set) identifies monotonic address strides (LBM, MCF) and triggers short-lived bypassing, preventing cache pollution from streaming accesses. Metadata includes: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL, for a total under 64 KiB. By switching prediction source to PC-based signatures, leveraging DRRIP's adaptive depth control, and integrating streaming bypass, SLDB robustly improves performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_02_ship_lite_with_drrip_bypassing__sldb_t07.cc,0.583617157,0.583617157,0%
1788,all,SHiP-Lite with DRRIP Bypassing (SLDB),"SLDB combines PC-based SHiP-lite signatures (6-bit per-block, 2-bit outcome table) with DRRIP (Dynamic RRIP) insertion depth control and a streaming detector for adaptive bypassing. SHiP-lite uses the PC of the memory instruction to guide insertion: blocks with hot signatures (high reuse) are inserted at MRU, while cold ones are inserted at distant RRPV. DRRIP set-dueling (using 64 leader sets and a 10-bit PSEL) dynamically chooses between SRRIP and BRRIP insertion depths for non-leader sets, improving adaptation to workload phase changes (MILC, OMNETPP). A compact streaming detector (3 bits/set) identifies monotonic address strides (LBM, MCF) and triggers short-lived bypassing, preventing cache pollution from streaming accesses. Metadata includes: 6 bits/block for PC signature, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL, for a total under 64 KiB. By switching prediction source to PC-based signatures, leveraging DRRIP's adaptive depth control, and integrating streaming bypass, SLDB robustly improves performance across diverse workloads.",,ChampSim_CRC2/new_policies/001_02_ship_lite_with_drrip_bypassing__sldb_t07.cc,0.4430965,0.4430965,44%
1789,astar,SHiP-Lite + Dead-Block Counter with DIP Streaming Bypass (SLDC-DIP),"SLDC-DIP combines SHiP-lite PC-based signatures (6 bits/block, 2-bit outcome table) with a compact per-block dead-block counter (2 bits/block) to approximate block reusability, and uses DIP-style insertion depth control (LIP/BIP with 32 leader sets and 10-bit PSEL) for phase adaptation. Streaming detection is performed per-set (3 bits/set) and triggers DIP-based bypassing: streaming sets use LIP (insert at LRU) to minimize pollution, while others use BIP (insert at MRU with low probability) for better retention of reusable blocks. On insertion, both the SHiP outcome and dead-block counter bias the insertion depth: blocks with hot signatures and high reuse counters are inserted at MRU, while cold or dead blocks are inserted at LRU. This hybrid approach improves performance by combining instruction-context prediction (SHiP-lite), direct block reuse tracking (dead-block counter), and adaptive insertion depth (DIP), while streaming bypass prevents pollution from monotonic accesses (LBM, MCF). Metadata fits under 64 KiB: 6 bits/block for PC signature, 2 bits/block for dead-block counter, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL. This design is materially different from SLDB by adding dead-block counters and DIP insertion control, improving adaptability and filtering for all workloads.",,ChampSim_CRC2/new_policies/002_00_ship_lite___dead_block_counter_with_dip_streaming_bypass__sldc_dip_t02.cc,0.214348361,0.214348361,0%
1790,lbm,SHiP-Lite + Dead-Block Counter with DIP Streaming Bypass (SLDC-DIP),"SLDC-DIP combines SHiP-lite PC-based signatures (6 bits/block, 2-bit outcome table) with a compact per-block dead-block counter (2 bits/block) to approximate block reusability, and uses DIP-style insertion depth control (LIP/BIP with 32 leader sets and 10-bit PSEL) for phase adaptation. Streaming detection is performed per-set (3 bits/set) and triggers DIP-based bypassing: streaming sets use LIP (insert at LRU) to minimize pollution, while others use BIP (insert at MRU with low probability) for better retention of reusable blocks. On insertion, both the SHiP outcome and dead-block counter bias the insertion depth: blocks with hot signatures and high reuse counters are inserted at MRU, while cold or dead blocks are inserted at LRU. This hybrid approach improves performance by combining instruction-context prediction (SHiP-lite), direct block reuse tracking (dead-block counter), and adaptive insertion depth (DIP), while streaming bypass prevents pollution from monotonic accesses (LBM, MCF). Metadata fits under 64 KiB: 6 bits/block for PC signature, 2 bits/block for dead-block counter, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL. This design is materially different from SLDB by adding dead-block counters and DIP insertion control, improving adaptability and filtering for all workloads.",,ChampSim_CRC2/new_policies/002_00_ship_lite___dead_block_counter_with_dip_streaming_bypass__sldc_dip_t02.cc,0.104673983,0.104673983,0%
1791,mcf,SHiP-Lite + Dead-Block Counter with DIP Streaming Bypass (SLDC-DIP),"SLDC-DIP combines SHiP-lite PC-based signatures (6 bits/block, 2-bit outcome table) with a compact per-block dead-block counter (2 bits/block) to approximate block reusability, and uses DIP-style insertion depth control (LIP/BIP with 32 leader sets and 10-bit PSEL) for phase adaptation. Streaming detection is performed per-set (3 bits/set) and triggers DIP-based bypassing: streaming sets use LIP (insert at LRU) to minimize pollution, while others use BIP (insert at MRU with low probability) for better retention of reusable blocks. On insertion, both the SHiP outcome and dead-block counter bias the insertion depth: blocks with hot signatures and high reuse counters are inserted at MRU, while cold or dead blocks are inserted at LRU. This hybrid approach improves performance by combining instruction-context prediction (SHiP-lite), direct block reuse tracking (dead-block counter), and adaptive insertion depth (DIP), while streaming bypass prevents pollution from monotonic accesses (LBM, MCF). Metadata fits under 64 KiB: 6 bits/block for PC signature, 2 bits/block for dead-block counter, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL. This design is materially different from SLDB by adding dead-block counters and DIP insertion control, improving adaptability and filtering for all workloads.",,ChampSim_CRC2/new_policies/002_00_ship_lite___dead_block_counter_with_dip_streaming_bypass__sldc_dip_t02.cc,0.346449147,0.346449147,0%
1792,milc,SHiP-Lite + Dead-Block Counter with DIP Streaming Bypass (SLDC-DIP),"SLDC-DIP combines SHiP-lite PC-based signatures (6 bits/block, 2-bit outcome table) with a compact per-block dead-block counter (2 bits/block) to approximate block reusability, and uses DIP-style insertion depth control (LIP/BIP with 32 leader sets and 10-bit PSEL) for phase adaptation. Streaming detection is performed per-set (3 bits/set) and triggers DIP-based bypassing: streaming sets use LIP (insert at LRU) to minimize pollution, while others use BIP (insert at MRU with low probability) for better retention of reusable blocks. On insertion, both the SHiP outcome and dead-block counter bias the insertion depth: blocks with hot signatures and high reuse counters are inserted at MRU, while cold or dead blocks are inserted at LRU. This hybrid approach improves performance by combining instruction-context prediction (SHiP-lite), direct block reuse tracking (dead-block counter), and adaptive insertion depth (DIP), while streaming bypass prevents pollution from monotonic accesses (LBM, MCF). Metadata fits under 64 KiB: 6 bits/block for PC signature, 2 bits/block for dead-block counter, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL. This design is materially different from SLDB by adding dead-block counters and DIP insertion control, improving adaptability and filtering for all workloads.",,ChampSim_CRC2/new_policies/002_00_ship_lite___dead_block_counter_with_dip_streaming_bypass__sldc_dip_t02.cc,0.022149286,0.022149286,0%
1793,omnetpp,SHiP-Lite + Dead-Block Counter with DIP Streaming Bypass (SLDC-DIP),"SLDC-DIP combines SHiP-lite PC-based signatures (6 bits/block, 2-bit outcome table) with a compact per-block dead-block counter (2 bits/block) to approximate block reusability, and uses DIP-style insertion depth control (LIP/BIP with 32 leader sets and 10-bit PSEL) for phase adaptation. Streaming detection is performed per-set (3 bits/set) and triggers DIP-based bypassing: streaming sets use LIP (insert at LRU) to minimize pollution, while others use BIP (insert at MRU with low probability) for better retention of reusable blocks. On insertion, both the SHiP outcome and dead-block counter bias the insertion depth: blocks with hot signatures and high reuse counters are inserted at MRU, while cold or dead blocks are inserted at LRU. This hybrid approach improves performance by combining instruction-context prediction (SHiP-lite), direct block reuse tracking (dead-block counter), and adaptive insertion depth (DIP), while streaming bypass prevents pollution from monotonic accesses (LBM, MCF). Metadata fits under 64 KiB: 6 bits/block for PC signature, 2 bits/block for dead-block counter, 2 bits/block for RRPV, 2 bits/signature (4096-entry table), 3 bits/set for streaming, and 10 bits for PSEL. This design is materially different from SLDB by adding dead-block counters and DIP insertion control, improving adaptability and filtering for all workloads.",,ChampSim_CRC2/new_policies/002_00_ship_lite___dead_block_counter_with_dip_streaming_bypass__sldc_dip_t02.cc,0.090063168,0.090063168,0%
1794,astar,Hybrid SHiP-Lite + Dead-Block Predictor with DIP Bypassing (SLDP),"SLDP combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter and DIP-style (LIP/BIP) insertion control, plus a lightweight streaming detector for adaptive bypassing. Each block tracks a 2-bit dead-block counter, incremented on eviction and decayed periodically, approximating block “deadness” to bias victim selection toward blocks with low reuse. SHiP-lite (6-bit PC signature, 2-bit outcome table) guides insertion depth: hot signatures insert at MRU, cold at distant. DIP set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) adapts insertion depth globally. The streaming detector (3 bits/set) triggers bypassing for monotonic strides, inserting blocks at LRU to avoid pollution. By blending PC-based reuse, dead-block approximation, and phase-adaptive insertion, SLDP better handles irregular (mcf, omnetpp), streaming (lbm), and phase-changing (milc) workloads, improving hit rate and robustness. Metadata: 2 bits/block dead-counter, 6 bits/block PC sig, 2 bits/block RRPV, 2 bits/signature (4096-entry table), 3 bits/set streaming, 10 bits PSEL, fitting under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_hybrid_ship_lite___dead_block_predictor_with_dip_bypassing__sldp_t04.cc,0.066063126,0.066063126,0%
1795,lbm,Hybrid SHiP-Lite + Dead-Block Predictor with DIP Bypassing (SLDP),"SLDP combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter and DIP-style (LIP/BIP) insertion control, plus a lightweight streaming detector for adaptive bypassing. Each block tracks a 2-bit dead-block counter, incremented on eviction and decayed periodically, approximating block “deadness” to bias victim selection toward blocks with low reuse. SHiP-lite (6-bit PC signature, 2-bit outcome table) guides insertion depth: hot signatures insert at MRU, cold at distant. DIP set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) adapts insertion depth globally. The streaming detector (3 bits/set) triggers bypassing for monotonic strides, inserting blocks at LRU to avoid pollution. By blending PC-based reuse, dead-block approximation, and phase-adaptive insertion, SLDP better handles irregular (mcf, omnetpp), streaming (lbm), and phase-changing (milc) workloads, improving hit rate and robustness. Metadata: 2 bits/block dead-counter, 6 bits/block PC sig, 2 bits/block RRPV, 2 bits/signature (4096-entry table), 3 bits/set streaming, 10 bits PSEL, fitting under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_hybrid_ship_lite___dead_block_predictor_with_dip_bypassing__sldp_t04.cc,0.07543599,0.07543599,0%
1796,mcf,Hybrid SHiP-Lite + Dead-Block Predictor with DIP Bypassing (SLDP),"SLDP combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter and DIP-style (LIP/BIP) insertion control, plus a lightweight streaming detector for adaptive bypassing. Each block tracks a 2-bit dead-block counter, incremented on eviction and decayed periodically, approximating block “deadness” to bias victim selection toward blocks with low reuse. SHiP-lite (6-bit PC signature, 2-bit outcome table) guides insertion depth: hot signatures insert at MRU, cold at distant. DIP set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) adapts insertion depth globally. The streaming detector (3 bits/set) triggers bypassing for monotonic strides, inserting blocks at LRU to avoid pollution. By blending PC-based reuse, dead-block approximation, and phase-adaptive insertion, SLDP better handles irregular (mcf, omnetpp), streaming (lbm), and phase-changing (milc) workloads, improving hit rate and robustness. Metadata: 2 bits/block dead-counter, 6 bits/block PC sig, 2 bits/block RRPV, 2 bits/signature (4096-entry table), 3 bits/set streaming, 10 bits PSEL, fitting under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_hybrid_ship_lite___dead_block_predictor_with_dip_bypassing__sldp_t04.cc,0.289470716,0.289470716,0%
1797,milc,Hybrid SHiP-Lite + Dead-Block Predictor with DIP Bypassing (SLDP),"SLDP combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter and DIP-style (LIP/BIP) insertion control, plus a lightweight streaming detector for adaptive bypassing. Each block tracks a 2-bit dead-block counter, incremented on eviction and decayed periodically, approximating block “deadness” to bias victim selection toward blocks with low reuse. SHiP-lite (6-bit PC signature, 2-bit outcome table) guides insertion depth: hot signatures insert at MRU, cold at distant. DIP set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) adapts insertion depth globally. The streaming detector (3 bits/set) triggers bypassing for monotonic strides, inserting blocks at LRU to avoid pollution. By blending PC-based reuse, dead-block approximation, and phase-adaptive insertion, SLDP better handles irregular (mcf, omnetpp), streaming (lbm), and phase-changing (milc) workloads, improving hit rate and robustness. Metadata: 2 bits/block dead-counter, 6 bits/block PC sig, 2 bits/block RRPV, 2 bits/signature (4096-entry table), 3 bits/set streaming, 10 bits PSEL, fitting under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_hybrid_ship_lite___dead_block_predictor_with_dip_bypassing__sldp_t04.cc,0.014216457,0.014216457,0%
1798,omnetpp,Hybrid SHiP-Lite + Dead-Block Predictor with DIP Bypassing (SLDP),"SLDP combines SHiP-lite’s PC-based reuse prediction with a per-block dead-block counter and DIP-style (LIP/BIP) insertion control, plus a lightweight streaming detector for adaptive bypassing. Each block tracks a 2-bit dead-block counter, incremented on eviction and decayed periodically, approximating block “deadness” to bias victim selection toward blocks with low reuse. SHiP-lite (6-bit PC signature, 2-bit outcome table) guides insertion depth: hot signatures insert at MRU, cold at distant. DIP set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) adapts insertion depth globally. The streaming detector (3 bits/set) triggers bypassing for monotonic strides, inserting blocks at LRU to avoid pollution. By blending PC-based reuse, dead-block approximation, and phase-adaptive insertion, SLDP better handles irregular (mcf, omnetpp), streaming (lbm), and phase-changing (milc) workloads, improving hit rate and robustness. Metadata: 2 bits/block dead-counter, 6 bits/block PC sig, 2 bits/block RRPV, 2 bits/signature (4096-entry table), 3 bits/set streaming, 10 bits PSEL, fitting under 64 KiB.",,ChampSim_CRC2/new_policies/002_01_hybrid_ship_lite___dead_block_predictor_with_dip_bypassing__sldp_t04.cc,0.03252629,0.03252629,0%
1799,astar,SHiP-Lite with Dead Block Prediction and Adaptive Streaming (SLDAS),"SLDAS combines SHiP-lite (PC-based signatures) with per-block dead block prediction, replacing RRIP's recency-only approach with a simple reuse counter to anticipate when lines are unlikely to be reused. On insertion, SHiP-lite guides insertion depth (MRU or distant) according to recent signature reuse. Each line tracks a 2-bit reuse counter, incremented on hits and periodically decayed to capture dead blocks. Lines with zero reuse counter are prioritized for eviction. Additionally, a lightweight streaming detector (3 bits/set) identifies monotonic address patterns; when active, blocks are inserted at LRU and considered dead, effectively bypassing pollution from streaming accesses (LBM, MCF). This hybrid approach improves prediction for irregular workloads (astar, mcf, omnetpp) and adapts to phase changes (milc) while maintaining low metadata (6 bits/block for PC signature, 2 bits/block for reuse counter, 2 bits/block for RRPV, 2 bits/signature in a 4096-entry table, and 3 bits/set for streaming). By shifting eviction preference to dead blocks and adding adaptive streaming bypass, SLDAS delivers improved hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/002_02_ship_lite_with_dead_block_prediction_and_adaptive_streaming__sldas_t07.cc,0.431155119,0.431155119,0%
1800,lbm,SHiP-Lite with Dead Block Prediction and Adaptive Streaming (SLDAS),"SLDAS combines SHiP-lite (PC-based signatures) with per-block dead block prediction, replacing RRIP's recency-only approach with a simple reuse counter to anticipate when lines are unlikely to be reused. On insertion, SHiP-lite guides insertion depth (MRU or distant) according to recent signature reuse. Each line tracks a 2-bit reuse counter, incremented on hits and periodically decayed to capture dead blocks. Lines with zero reuse counter are prioritized for eviction. Additionally, a lightweight streaming detector (3 bits/set) identifies monotonic address patterns; when active, blocks are inserted at LRU and considered dead, effectively bypassing pollution from streaming accesses (LBM, MCF). This hybrid approach improves prediction for irregular workloads (astar, mcf, omnetpp) and adapts to phase changes (milc) while maintaining low metadata (6 bits/block for PC signature, 2 bits/block for reuse counter, 2 bits/block for RRPV, 2 bits/signature in a 4096-entry table, and 3 bits/set for streaming). By shifting eviction preference to dead blocks and adding adaptive streaming bypass, SLDAS delivers improved hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/002_02_ship_lite_with_dead_block_prediction_and_adaptive_streaming__sldas_t07.cc,0.410663931,0.410663931,0%
1801,mcf,SHiP-Lite with Dead Block Prediction and Adaptive Streaming (SLDAS),"SLDAS combines SHiP-lite (PC-based signatures) with per-block dead block prediction, replacing RRIP's recency-only approach with a simple reuse counter to anticipate when lines are unlikely to be reused. On insertion, SHiP-lite guides insertion depth (MRU or distant) according to recent signature reuse. Each line tracks a 2-bit reuse counter, incremented on hits and periodically decayed to capture dead blocks. Lines with zero reuse counter are prioritized for eviction. Additionally, a lightweight streaming detector (3 bits/set) identifies monotonic address patterns; when active, blocks are inserted at LRU and considered dead, effectively bypassing pollution from streaming accesses (LBM, MCF). This hybrid approach improves prediction for irregular workloads (astar, mcf, omnetpp) and adapts to phase changes (milc) while maintaining low metadata (6 bits/block for PC signature, 2 bits/block for reuse counter, 2 bits/block for RRPV, 2 bits/signature in a 4096-entry table, and 3 bits/set for streaming). By shifting eviction preference to dead blocks and adding adaptive streaming bypass, SLDAS delivers improved hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/002_02_ship_lite_with_dead_block_prediction_and_adaptive_streaming__sldas_t07.cc,0.473319613,0.473319613,0%
1802,milc,SHiP-Lite with Dead Block Prediction and Adaptive Streaming (SLDAS),"SLDAS combines SHiP-lite (PC-based signatures) with per-block dead block prediction, replacing RRIP's recency-only approach with a simple reuse counter to anticipate when lines are unlikely to be reused. On insertion, SHiP-lite guides insertion depth (MRU or distant) according to recent signature reuse. Each line tracks a 2-bit reuse counter, incremented on hits and periodically decayed to capture dead blocks. Lines with zero reuse counter are prioritized for eviction. Additionally, a lightweight streaming detector (3 bits/set) identifies monotonic address patterns; when active, blocks are inserted at LRU and considered dead, effectively bypassing pollution from streaming accesses (LBM, MCF). This hybrid approach improves prediction for irregular workloads (astar, mcf, omnetpp) and adapts to phase changes (milc) while maintaining low metadata (6 bits/block for PC signature, 2 bits/block for reuse counter, 2 bits/block for RRPV, 2 bits/signature in a 4096-entry table, and 3 bits/set for streaming). By shifting eviction preference to dead blocks and adding adaptive streaming bypass, SLDAS delivers improved hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/002_02_ship_lite_with_dead_block_prediction_and_adaptive_streaming__sldas_t07.cc,0.312827216,0.312827216,0%
1803,omnetpp,SHiP-Lite with Dead Block Prediction and Adaptive Streaming (SLDAS),"SLDAS combines SHiP-lite (PC-based signatures) with per-block dead block prediction, replacing RRIP's recency-only approach with a simple reuse counter to anticipate when lines are unlikely to be reused. On insertion, SHiP-lite guides insertion depth (MRU or distant) according to recent signature reuse. Each line tracks a 2-bit reuse counter, incremented on hits and periodically decayed to capture dead blocks. Lines with zero reuse counter are prioritized for eviction. Additionally, a lightweight streaming detector (3 bits/set) identifies monotonic address patterns; when active, blocks are inserted at LRU and considered dead, effectively bypassing pollution from streaming accesses (LBM, MCF). This hybrid approach improves prediction for irregular workloads (astar, mcf, omnetpp) and adapts to phase changes (milc) while maintaining low metadata (6 bits/block for PC signature, 2 bits/block for reuse counter, 2 bits/block for RRPV, 2 bits/signature in a 4096-entry table, and 3 bits/set for streaming). By shifting eviction preference to dead blocks and adding adaptive streaming bypass, SLDAS delivers improved hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/002_02_ship_lite_with_dead_block_prediction_and_adaptive_streaming__sldas_t07.cc,0.637932371,0.637932371,0%
1804,all,SHiP-Lite with Dead Block Prediction and Adaptive Streaming (SLDAS),"SLDAS combines SHiP-lite (PC-based signatures) with per-block dead block prediction, replacing RRIP's recency-only approach with a simple reuse counter to anticipate when lines are unlikely to be reused. On insertion, SHiP-lite guides insertion depth (MRU or distant) according to recent signature reuse. Each line tracks a 2-bit reuse counter, incremented on hits and periodically decayed to capture dead blocks. Lines with zero reuse counter are prioritized for eviction. Additionally, a lightweight streaming detector (3 bits/set) identifies monotonic address patterns; when active, blocks are inserted at LRU and considered dead, effectively bypassing pollution from streaming accesses (LBM, MCF). This hybrid approach improves prediction for irregular workloads (astar, mcf, omnetpp) and adapts to phase changes (milc) while maintaining low metadata (6 bits/block for PC signature, 2 bits/block for reuse counter, 2 bits/block for RRPV, 2 bits/signature in a 4096-entry table, and 3 bits/set for streaming). By shifting eviction preference to dead blocks and adding adaptive streaming bypass, SLDAS delivers improved hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/002_02_ship_lite_with_dead_block_prediction_and_adaptive_streaming__sldas_t07.cc,0.45317965,0.45317965,45%
1805,astar,DRRIP-SD with Streaming Bypass and Phase-Adaptive Insertion (DSSPA),"DSSPA combines Dynamic RRIP (DRRIP) with set-dueling (SRRIP vs BRRIP) and a lightweight streaming detector, while introducing phase-adaptive insertion depth using a small per-set reuse counter. DRRIP's set-dueling and 10-bit PSEL selector adapt insertion depth globally, while the streaming detector identifies monotonic address patterns and triggers bypass (immediate LRU insertion) for streaming sets (LBM, MCF). Additionally, each set tracks a 2-bit reuse counter that is incremented on hits and decayed periodically; sets with low reuse bias toward distant insertions, helping to avoid pollution during irregular or phase-changing workloads (astar, milc, omnetpp). This hybrid approach leverages global and local adaptation: DRRIP handles workload diversity, streaming bypass reduces pollution, and per-set phase tracking improves responsiveness to locality changes. Metadata is compact: 2 bits/block for RRPV, 2 bits/set for reuse counter, 3 bits/set for streaming detection, 10 bits for PSEL, and 64 leader sets (SRRIP/BRRIP). This design delivers improved hit rates by dynamically tuning insertion and eviction policies to both global and local workload behaviors.",,ChampSim_CRC2/new_policies/003_00_drrip_sd_with_streaming_bypass_and_phase_adaptive_insertion__dsspa_t02.cc,0.426464231,0.426464231,0%
1806,lbm,DRRIP-SD with Streaming Bypass and Phase-Adaptive Insertion (DSSPA),"DSSPA combines Dynamic RRIP (DRRIP) with set-dueling (SRRIP vs BRRIP) and a lightweight streaming detector, while introducing phase-adaptive insertion depth using a small per-set reuse counter. DRRIP's set-dueling and 10-bit PSEL selector adapt insertion depth globally, while the streaming detector identifies monotonic address patterns and triggers bypass (immediate LRU insertion) for streaming sets (LBM, MCF). Additionally, each set tracks a 2-bit reuse counter that is incremented on hits and decayed periodically; sets with low reuse bias toward distant insertions, helping to avoid pollution during irregular or phase-changing workloads (astar, milc, omnetpp). This hybrid approach leverages global and local adaptation: DRRIP handles workload diversity, streaming bypass reduces pollution, and per-set phase tracking improves responsiveness to locality changes. Metadata is compact: 2 bits/block for RRPV, 2 bits/set for reuse counter, 3 bits/set for streaming detection, 10 bits for PSEL, and 64 leader sets (SRRIP/BRRIP). This design delivers improved hit rates by dynamically tuning insertion and eviction policies to both global and local workload behaviors.",,ChampSim_CRC2/new_policies/003_00_drrip_sd_with_streaming_bypass_and_phase_adaptive_insertion__dsspa_t02.cc,0.403951589,0.403951589,0%
1807,mcf,DRRIP-SD with Streaming Bypass and Phase-Adaptive Insertion (DSSPA),"DSSPA combines Dynamic RRIP (DRRIP) with set-dueling (SRRIP vs BRRIP) and a lightweight streaming detector, while introducing phase-adaptive insertion depth using a small per-set reuse counter. DRRIP's set-dueling and 10-bit PSEL selector adapt insertion depth globally, while the streaming detector identifies monotonic address patterns and triggers bypass (immediate LRU insertion) for streaming sets (LBM, MCF). Additionally, each set tracks a 2-bit reuse counter that is incremented on hits and decayed periodically; sets with low reuse bias toward distant insertions, helping to avoid pollution during irregular or phase-changing workloads (astar, milc, omnetpp). This hybrid approach leverages global and local adaptation: DRRIP handles workload diversity, streaming bypass reduces pollution, and per-set phase tracking improves responsiveness to locality changes. Metadata is compact: 2 bits/block for RRPV, 2 bits/set for reuse counter, 3 bits/set for streaming detection, 10 bits for PSEL, and 64 leader sets (SRRIP/BRRIP). This design delivers improved hit rates by dynamically tuning insertion and eviction policies to both global and local workload behaviors.",,ChampSim_CRC2/new_policies/003_00_drrip_sd_with_streaming_bypass_and_phase_adaptive_insertion__dsspa_t02.cc,0.457819653,0.457819653,0%
1808,milc,DRRIP-SD with Streaming Bypass and Phase-Adaptive Insertion (DSSPA),"DSSPA combines Dynamic RRIP (DRRIP) with set-dueling (SRRIP vs BRRIP) and a lightweight streaming detector, while introducing phase-adaptive insertion depth using a small per-set reuse counter. DRRIP's set-dueling and 10-bit PSEL selector adapt insertion depth globally, while the streaming detector identifies monotonic address patterns and triggers bypass (immediate LRU insertion) for streaming sets (LBM, MCF). Additionally, each set tracks a 2-bit reuse counter that is incremented on hits and decayed periodically; sets with low reuse bias toward distant insertions, helping to avoid pollution during irregular or phase-changing workloads (astar, milc, omnetpp). This hybrid approach leverages global and local adaptation: DRRIP handles workload diversity, streaming bypass reduces pollution, and per-set phase tracking improves responsiveness to locality changes. Metadata is compact: 2 bits/block for RRPV, 2 bits/set for reuse counter, 3 bits/set for streaming detection, 10 bits for PSEL, and 64 leader sets (SRRIP/BRRIP). This design delivers improved hit rates by dynamically tuning insertion and eviction policies to both global and local workload behaviors.",,ChampSim_CRC2/new_policies/003_00_drrip_sd_with_streaming_bypass_and_phase_adaptive_insertion__dsspa_t02.cc,0.304258963,0.304258963,0%
1809,omnetpp,DRRIP-SD with Streaming Bypass and Phase-Adaptive Insertion (DSSPA),"DSSPA combines Dynamic RRIP (DRRIP) with set-dueling (SRRIP vs BRRIP) and a lightweight streaming detector, while introducing phase-adaptive insertion depth using a small per-set reuse counter. DRRIP's set-dueling and 10-bit PSEL selector adapt insertion depth globally, while the streaming detector identifies monotonic address patterns and triggers bypass (immediate LRU insertion) for streaming sets (LBM, MCF). Additionally, each set tracks a 2-bit reuse counter that is incremented on hits and decayed periodically; sets with low reuse bias toward distant insertions, helping to avoid pollution during irregular or phase-changing workloads (astar, milc, omnetpp). This hybrid approach leverages global and local adaptation: DRRIP handles workload diversity, streaming bypass reduces pollution, and per-set phase tracking improves responsiveness to locality changes. Metadata is compact: 2 bits/block for RRPV, 2 bits/set for reuse counter, 3 bits/set for streaming detection, 10 bits for PSEL, and 64 leader sets (SRRIP/BRRIP). This design delivers improved hit rates by dynamically tuning insertion and eviction policies to both global and local workload behaviors.",,ChampSim_CRC2/new_policies/003_00_drrip_sd_with_streaming_bypass_and_phase_adaptive_insertion__dsspa_t02.cc,0.441995574,0.441995574,0%
1810,astar,DRRIP + Streaming Bypass (DRRIP-SB),"DRRIP-SB combines Dynamic RRIP (DRRIP) set-dueling with an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using a small set of leader sets and a 10-bit PSEL counter, adapting insertion depth to workload locality. To further reduce cache pollution from streaming and pointer-chasing workloads (LBM, MCF, omnetpp), DRRIP-SB integrates a lightweight per-set streaming detector (3 bits/set) that monitors monotonic address strides. When streaming is detected, new lines are inserted at distant RRPV (max), making them likely victims and minimizing pollution. This design changes both the prediction source (set-dueling, not PC) and insertion depth logic, while keeping metadata compact: 2 bits/block for RRPV, 3 bits/set for streaming, 10 bits for PSEL, and 64 leader sets. DRRIP-SB adapts to irregular and phase-changing workloads (milc, astar) while efficiently bypassing streaming accesses, delivering improved hit rates across all patterns.",,ChampSim_CRC2/new_policies/003_01_drrip___streaming_bypass__drrip_sb_t04.cc,0.429641986,0.429641986,0%
1811,lbm,DRRIP + Streaming Bypass (DRRIP-SB),"DRRIP-SB combines Dynamic RRIP (DRRIP) set-dueling with an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using a small set of leader sets and a 10-bit PSEL counter, adapting insertion depth to workload locality. To further reduce cache pollution from streaming and pointer-chasing workloads (LBM, MCF, omnetpp), DRRIP-SB integrates a lightweight per-set streaming detector (3 bits/set) that monitors monotonic address strides. When streaming is detected, new lines are inserted at distant RRPV (max), making them likely victims and minimizing pollution. This design changes both the prediction source (set-dueling, not PC) and insertion depth logic, while keeping metadata compact: 2 bits/block for RRPV, 3 bits/set for streaming, 10 bits for PSEL, and 64 leader sets. DRRIP-SB adapts to irregular and phase-changing workloads (milc, astar) while efficiently bypassing streaming accesses, delivering improved hit rates across all patterns.",,ChampSim_CRC2/new_policies/003_01_drrip___streaming_bypass__drrip_sb_t04.cc,0.408561777,0.408561777,0%
1812,mcf,DRRIP + Streaming Bypass (DRRIP-SB),"DRRIP-SB combines Dynamic RRIP (DRRIP) set-dueling with an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using a small set of leader sets and a 10-bit PSEL counter, adapting insertion depth to workload locality. To further reduce cache pollution from streaming and pointer-chasing workloads (LBM, MCF, omnetpp), DRRIP-SB integrates a lightweight per-set streaming detector (3 bits/set) that monitors monotonic address strides. When streaming is detected, new lines are inserted at distant RRPV (max), making them likely victims and minimizing pollution. This design changes both the prediction source (set-dueling, not PC) and insertion depth logic, while keeping metadata compact: 2 bits/block for RRPV, 3 bits/set for streaming, 10 bits for PSEL, and 64 leader sets. DRRIP-SB adapts to irregular and phase-changing workloads (milc, astar) while efficiently bypassing streaming accesses, delivering improved hit rates across all patterns.",,ChampSim_CRC2/new_policies/003_01_drrip___streaming_bypass__drrip_sb_t04.cc,0.459726562,0.459726562,0%
1813,milc,DRRIP + Streaming Bypass (DRRIP-SB),"DRRIP-SB combines Dynamic RRIP (DRRIP) set-dueling with an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using a small set of leader sets and a 10-bit PSEL counter, adapting insertion depth to workload locality. To further reduce cache pollution from streaming and pointer-chasing workloads (LBM, MCF, omnetpp), DRRIP-SB integrates a lightweight per-set streaming detector (3 bits/set) that monitors monotonic address strides. When streaming is detected, new lines are inserted at distant RRPV (max), making them likely victims and minimizing pollution. This design changes both the prediction source (set-dueling, not PC) and insertion depth logic, while keeping metadata compact: 2 bits/block for RRPV, 3 bits/set for streaming, 10 bits for PSEL, and 64 leader sets. DRRIP-SB adapts to irregular and phase-changing workloads (milc, astar) while efficiently bypassing streaming accesses, delivering improved hit rates across all patterns.",,ChampSim_CRC2/new_policies/003_01_drrip___streaming_bypass__drrip_sb_t04.cc,0.307640644,0.307640644,0%
1814,omnetpp,DRRIP + Streaming Bypass (DRRIP-SB),"DRRIP-SB combines Dynamic RRIP (DRRIP) set-dueling with an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using a small set of leader sets and a 10-bit PSEL counter, adapting insertion depth to workload locality. To further reduce cache pollution from streaming and pointer-chasing workloads (LBM, MCF, omnetpp), DRRIP-SB integrates a lightweight per-set streaming detector (3 bits/set) that monitors monotonic address strides. When streaming is detected, new lines are inserted at distant RRPV (max), making them likely victims and minimizing pollution. This design changes both the prediction source (set-dueling, not PC) and insertion depth logic, while keeping metadata compact: 2 bits/block for RRPV, 3 bits/set for streaming, 10 bits for PSEL, and 64 leader sets. DRRIP-SB adapts to irregular and phase-changing workloads (milc, astar) while efficiently bypassing streaming accesses, delivering improved hit rates across all patterns.",,ChampSim_CRC2/new_policies/003_01_drrip___streaming_bypass__drrip_sb_t04.cc,0.454271075,0.454271075,0%
1815,astar,DIP-LIP-BIP Hybrid with Adaptive Streaming Bypass (DLASB),"DLASB fuses DIP-style insertion depth control (using leader sets to choose between LIP and BIP) with adaptive streaming detection and targeted bypass. Leader sets (1/32 of total) track hit rates for LIP (always insert at LRU) and BIP (insert at MRU 1/32 of the time, else LRU), using a global 10-bit PSEL counter to select the dominant policy per set. This mechanism excels at phase adaptation (MILC, OMNETPP) and regular reuse (LBM). Separately, a lightweight streaming detector (3 bits/set) identifies monotonic address strides; during streaming phases, blocks are forcibly inserted at LRU and marked as ""dead"" (evictable immediately), reducing pollution for LBM and MCF. Metadata is compact: 2 bits/block for RRPV, 1 bit/block for dead-block flag, 3 bits/set for streaming detection, and basic DIP bookkeeping. By decoupling insertion depth control (phase-adaptive) from streaming bypass (access-pattern-adaptive), DLASB delivers higher hit rates on irregular (ASTAR, MCF, OMNETPP) and regular (LBM, MILC) workloads, outperforming simple SHiP or dead-block-only designs while fitting easily within 64 KiB.",,ChampSim_CRC2/new_policies/003_02_dip_lip_bip_hybrid_with_adaptive_streaming_bypass__dlasb_t07.cc,0.193157415,0.193157415,0%
1816,lbm,DIP-LIP-BIP Hybrid with Adaptive Streaming Bypass (DLASB),"DLASB fuses DIP-style insertion depth control (using leader sets to choose between LIP and BIP) with adaptive streaming detection and targeted bypass. Leader sets (1/32 of total) track hit rates for LIP (always insert at LRU) and BIP (insert at MRU 1/32 of the time, else LRU), using a global 10-bit PSEL counter to select the dominant policy per set. This mechanism excels at phase adaptation (MILC, OMNETPP) and regular reuse (LBM). Separately, a lightweight streaming detector (3 bits/set) identifies monotonic address strides; during streaming phases, blocks are forcibly inserted at LRU and marked as ""dead"" (evictable immediately), reducing pollution for LBM and MCF. Metadata is compact: 2 bits/block for RRPV, 1 bit/block for dead-block flag, 3 bits/set for streaming detection, and basic DIP bookkeeping. By decoupling insertion depth control (phase-adaptive) from streaming bypass (access-pattern-adaptive), DLASB delivers higher hit rates on irregular (ASTAR, MCF, OMNETPP) and regular (LBM, MILC) workloads, outperforming simple SHiP or dead-block-only designs while fitting easily within 64 KiB.",,ChampSim_CRC2/new_policies/003_02_dip_lip_bip_hybrid_with_adaptive_streaming_bypass__dlasb_t07.cc,0.093577367,0.093577367,0%
1817,mcf,DIP-LIP-BIP Hybrid with Adaptive Streaming Bypass (DLASB),"DLASB fuses DIP-style insertion depth control (using leader sets to choose between LIP and BIP) with adaptive streaming detection and targeted bypass. Leader sets (1/32 of total) track hit rates for LIP (always insert at LRU) and BIP (insert at MRU 1/32 of the time, else LRU), using a global 10-bit PSEL counter to select the dominant policy per set. This mechanism excels at phase adaptation (MILC, OMNETPP) and regular reuse (LBM). Separately, a lightweight streaming detector (3 bits/set) identifies monotonic address strides; during streaming phases, blocks are forcibly inserted at LRU and marked as ""dead"" (evictable immediately), reducing pollution for LBM and MCF. Metadata is compact: 2 bits/block for RRPV, 1 bit/block for dead-block flag, 3 bits/set for streaming detection, and basic DIP bookkeeping. By decoupling insertion depth control (phase-adaptive) from streaming bypass (access-pattern-adaptive), DLASB delivers higher hit rates on irregular (ASTAR, MCF, OMNETPP) and regular (LBM, MILC) workloads, outperforming simple SHiP or dead-block-only designs while fitting easily within 64 KiB.",,ChampSim_CRC2/new_policies/003_02_dip_lip_bip_hybrid_with_adaptive_streaming_bypass__dlasb_t07.cc,0.333669122,0.333669122,0%
1818,milc,DIP-LIP-BIP Hybrid with Adaptive Streaming Bypass (DLASB),"DLASB fuses DIP-style insertion depth control (using leader sets to choose between LIP and BIP) with adaptive streaming detection and targeted bypass. Leader sets (1/32 of total) track hit rates for LIP (always insert at LRU) and BIP (insert at MRU 1/32 of the time, else LRU), using a global 10-bit PSEL counter to select the dominant policy per set. This mechanism excels at phase adaptation (MILC, OMNETPP) and regular reuse (LBM). Separately, a lightweight streaming detector (3 bits/set) identifies monotonic address strides; during streaming phases, blocks are forcibly inserted at LRU and marked as ""dead"" (evictable immediately), reducing pollution for LBM and MCF. Metadata is compact: 2 bits/block for RRPV, 1 bit/block for dead-block flag, 3 bits/set for streaming detection, and basic DIP bookkeeping. By decoupling insertion depth control (phase-adaptive) from streaming bypass (access-pattern-adaptive), DLASB delivers higher hit rates on irregular (ASTAR, MCF, OMNETPP) and regular (LBM, MILC) workloads, outperforming simple SHiP or dead-block-only designs while fitting easily within 64 KiB.",,ChampSim_CRC2/new_policies/003_02_dip_lip_bip_hybrid_with_adaptive_streaming_bypass__dlasb_t07.cc,0.017750205,0.017750205,0%
1819,omnetpp,DIP-LIP-BIP Hybrid with Adaptive Streaming Bypass (DLASB),"DLASB fuses DIP-style insertion depth control (using leader sets to choose between LIP and BIP) with adaptive streaming detection and targeted bypass. Leader sets (1/32 of total) track hit rates for LIP (always insert at LRU) and BIP (insert at MRU 1/32 of the time, else LRU), using a global 10-bit PSEL counter to select the dominant policy per set. This mechanism excels at phase adaptation (MILC, OMNETPP) and regular reuse (LBM). Separately, a lightweight streaming detector (3 bits/set) identifies monotonic address strides; during streaming phases, blocks are forcibly inserted at LRU and marked as ""dead"" (evictable immediately), reducing pollution for LBM and MCF. Metadata is compact: 2 bits/block for RRPV, 1 bit/block for dead-block flag, 3 bits/set for streaming detection, and basic DIP bookkeeping. By decoupling insertion depth control (phase-adaptive) from streaming bypass (access-pattern-adaptive), DLASB delivers higher hit rates on irregular (ASTAR, MCF, OMNETPP) and regular (LBM, MILC) workloads, outperforming simple SHiP or dead-block-only designs while fitting easily within 64 KiB.",,ChampSim_CRC2/new_policies/003_02_dip_lip_bip_hybrid_with_adaptive_streaming_bypass__dlasb_t07.cc,0.017298045,0.017298045,0%
1820,all,DRRIP + Streaming Bypass (DRRIP-SB),"DRRIP-SB combines Dynamic RRIP (DRRIP) set-dueling with an adaptive streaming bypass mechanism. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using a small set of leader sets and a 10-bit PSEL counter, adapting insertion depth to workload locality. To further reduce cache pollution from streaming and pointer-chasing workloads (LBM, MCF, omnetpp), DRRIP-SB integrates a lightweight per-set streaming detector (3 bits/set) that monitors monotonic address strides. When streaming is detected, new lines are inserted at distant RRPV (max), making them likely victims and minimizing pollution. This design changes both the prediction source (set-dueling, not PC) and insertion depth logic, while keeping metadata compact: 2 bits/block for RRPV, 3 bits/set for streaming, 10 bits for PSEL, and 64 leader sets. DRRIP-SB adapts to irregular and phase-changing workloads (milc, astar) while efficiently bypassing streaming accesses, delivering improved hit rates across all patterns.",,ChampSim_CRC2/new_policies/003_01_drrip___streaming_bypass__drrip_sb_t04.cc,0.411968409,0.411968409,41%
1821,astar,SHiP-Lite + Streaming Dead-Block Bypass (SHiP-SDB),"SHiP-SDB combines a lightweight SHiP-style PC signature predictor with a streaming-aware dead-block bypass for robust cache management across diverse workloads. Each cache line tracks a 6-bit PC signature and a 2-bit reuse counter, enabling the policy to learn whether lines loaded by specific PCs are likely to be reused. On insertion, lines with low predicted reuse are placed at distant RRPV, while high-reuse PCs get near-MRU insertion. In parallel, a compact per-set streaming detector (3 bits/set) identifies monotonic address strides (for LBM, mcf, omnetpp) and triggers bypass: new lines in streaming sets are inserted at RRIP_MAX and their reuse counters are periodically decayed, hastening eviction of dead blocks. This dual mechanism allows the policy to adapt to both control-dominated (astar, milc) and streaming workloads, reducing pollution and improving hit rates. Metadata is compact (2 bits/block RRPV, 6 bits/block signature, 2 bits/block reuse, 3 bits/set streaming), fitting comfortably within the 64 KiB budget.",,ChampSim_CRC2/new_policies/005_01_ship_lite___streaming_dead_block_bypass__ship_sdb_t04.cc,0.454210903,0.454210903,0%
1822,lbm,SHiP-Lite + Streaming Dead-Block Bypass (SHiP-SDB),"SHiP-SDB combines a lightweight SHiP-style PC signature predictor with a streaming-aware dead-block bypass for robust cache management across diverse workloads. Each cache line tracks a 6-bit PC signature and a 2-bit reuse counter, enabling the policy to learn whether lines loaded by specific PCs are likely to be reused. On insertion, lines with low predicted reuse are placed at distant RRPV, while high-reuse PCs get near-MRU insertion. In parallel, a compact per-set streaming detector (3 bits/set) identifies monotonic address strides (for LBM, mcf, omnetpp) and triggers bypass: new lines in streaming sets are inserted at RRIP_MAX and their reuse counters are periodically decayed, hastening eviction of dead blocks. This dual mechanism allows the policy to adapt to both control-dominated (astar, milc) and streaming workloads, reducing pollution and improving hit rates. Metadata is compact (2 bits/block RRPV, 6 bits/block signature, 2 bits/block reuse, 3 bits/set streaming), fitting comfortably within the 64 KiB budget.",,ChampSim_CRC2/new_policies/005_01_ship_lite___streaming_dead_block_bypass__ship_sdb_t04.cc,0.434492313,0.434492313,0%
1823,mcf,SHiP-Lite + Streaming Dead-Block Bypass (SHiP-SDB),"SHiP-SDB combines a lightweight SHiP-style PC signature predictor with a streaming-aware dead-block bypass for robust cache management across diverse workloads. Each cache line tracks a 6-bit PC signature and a 2-bit reuse counter, enabling the policy to learn whether lines loaded by specific PCs are likely to be reused. On insertion, lines with low predicted reuse are placed at distant RRPV, while high-reuse PCs get near-MRU insertion. In parallel, a compact per-set streaming detector (3 bits/set) identifies monotonic address strides (for LBM, mcf, omnetpp) and triggers bypass: new lines in streaming sets are inserted at RRIP_MAX and their reuse counters are periodically decayed, hastening eviction of dead blocks. This dual mechanism allows the policy to adapt to both control-dominated (astar, milc) and streaming workloads, reducing pollution and improving hit rates. Metadata is compact (2 bits/block RRPV, 6 bits/block signature, 2 bits/block reuse, 3 bits/set streaming), fitting comfortably within the 64 KiB budget.",,ChampSim_CRC2/new_policies/005_01_ship_lite___streaming_dead_block_bypass__ship_sdb_t04.cc,0.412843587,0.412843587,0%
1824,milc,SHiP-Lite + Streaming Dead-Block Bypass (SHiP-SDB),"SHiP-SDB combines a lightweight SHiP-style PC signature predictor with a streaming-aware dead-block bypass for robust cache management across diverse workloads. Each cache line tracks a 6-bit PC signature and a 2-bit reuse counter, enabling the policy to learn whether lines loaded by specific PCs are likely to be reused. On insertion, lines with low predicted reuse are placed at distant RRPV, while high-reuse PCs get near-MRU insertion. In parallel, a compact per-set streaming detector (3 bits/set) identifies monotonic address strides (for LBM, mcf, omnetpp) and triggers bypass: new lines in streaming sets are inserted at RRIP_MAX and their reuse counters are periodically decayed, hastening eviction of dead blocks. This dual mechanism allows the policy to adapt to both control-dominated (astar, milc) and streaming workloads, reducing pollution and improving hit rates. Metadata is compact (2 bits/block RRPV, 6 bits/block signature, 2 bits/block reuse, 3 bits/set streaming), fitting comfortably within the 64 KiB budget.",,ChampSim_CRC2/new_policies/005_01_ship_lite___streaming_dead_block_bypass__ship_sdb_t04.cc,0.324176123,0.324176123,0%
1825,omnetpp,SHiP-Lite + Streaming Dead-Block Bypass (SHiP-SDB),"SHiP-SDB combines a lightweight SHiP-style PC signature predictor with a streaming-aware dead-block bypass for robust cache management across diverse workloads. Each cache line tracks a 6-bit PC signature and a 2-bit reuse counter, enabling the policy to learn whether lines loaded by specific PCs are likely to be reused. On insertion, lines with low predicted reuse are placed at distant RRPV, while high-reuse PCs get near-MRU insertion. In parallel, a compact per-set streaming detector (3 bits/set) identifies monotonic address strides (for LBM, mcf, omnetpp) and triggers bypass: new lines in streaming sets are inserted at RRIP_MAX and their reuse counters are periodically decayed, hastening eviction of dead blocks. This dual mechanism allows the policy to adapt to both control-dominated (astar, milc) and streaming workloads, reducing pollution and improving hit rates. Metadata is compact (2 bits/block RRPV, 6 bits/block signature, 2 bits/block reuse, 3 bits/set streaming), fitting comfortably within the 64 KiB budget.",,ChampSim_CRC2/new_policies/005_01_ship_lite___streaming_dead_block_bypass__ship_sdb_t04.cc,0.518851662,0.518851662,0%
1826,astar,SHiP-Lite + Streaming Bypass (SHiP-SB),"SHiP-SB merges PC-based insertion biasing (SHiP-lite) with a lightweight streaming bypass detector to handle both irregular and streaming access patterns. Each cache line is tagged with a compact 4-bit PC signature and a 2-bit outcome counter, recording reuse history and guiding insertion depth: blocks with positive reuse are inserted closer to MRU, while blocks with little or no reuse are inserted at distant RRPV to minimize pollution. In parallel, a per-set 3-bit streaming detector identifies monotonic address strides, triggering aggressive distant insertion (RRIP_MAX) for streaming phases (LBM, MCF, omnetpp) and further reducing pollution. This dual mechanism allows the policy to adapt to both control-flow-dominated (astar, milc) and streaming workloads, leveraging PC-locality when present and bypassing when not, all with metadata well under 64 KiB. Compared to prior DRRIP-SB, this policy changes both the prediction source (PC signature/outcome rather than set-dueling) and insertion logic, improving hit rates for mixed, phase-changing, and streaming patterns.",,ChampSim_CRC2/new_policies/005_02_ship_lite___streaming_bypass__ship_sb_t07.cc,0.424707473,0.424707473,0%
1827,lbm,SHiP-Lite + Streaming Bypass (SHiP-SB),"SHiP-SB merges PC-based insertion biasing (SHiP-lite) with a lightweight streaming bypass detector to handle both irregular and streaming access patterns. Each cache line is tagged with a compact 4-bit PC signature and a 2-bit outcome counter, recording reuse history and guiding insertion depth: blocks with positive reuse are inserted closer to MRU, while blocks with little or no reuse are inserted at distant RRPV to minimize pollution. In parallel, a per-set 3-bit streaming detector identifies monotonic address strides, triggering aggressive distant insertion (RRIP_MAX) for streaming phases (LBM, MCF, omnetpp) and further reducing pollution. This dual mechanism allows the policy to adapt to both control-flow-dominated (astar, milc) and streaming workloads, leveraging PC-locality when present and bypassing when not, all with metadata well under 64 KiB. Compared to prior DRRIP-SB, this policy changes both the prediction source (PC signature/outcome rather than set-dueling) and insertion logic, improving hit rates for mixed, phase-changing, and streaming patterns.",,ChampSim_CRC2/new_policies/005_02_ship_lite___streaming_bypass__ship_sb_t07.cc,0.269391633,0.269391633,0%
1828,mcf,SHiP-Lite + Streaming Bypass (SHiP-SB),"SHiP-SB merges PC-based insertion biasing (SHiP-lite) with a lightweight streaming bypass detector to handle both irregular and streaming access patterns. Each cache line is tagged with a compact 4-bit PC signature and a 2-bit outcome counter, recording reuse history and guiding insertion depth: blocks with positive reuse are inserted closer to MRU, while blocks with little or no reuse are inserted at distant RRPV to minimize pollution. In parallel, a per-set 3-bit streaming detector identifies monotonic address strides, triggering aggressive distant insertion (RRIP_MAX) for streaming phases (LBM, MCF, omnetpp) and further reducing pollution. This dual mechanism allows the policy to adapt to both control-flow-dominated (astar, milc) and streaming workloads, leveraging PC-locality when present and bypassing when not, all with metadata well under 64 KiB. Compared to prior DRRIP-SB, this policy changes both the prediction source (PC signature/outcome rather than set-dueling) and insertion logic, improving hit rates for mixed, phase-changing, and streaming patterns.",,ChampSim_CRC2/new_policies/005_02_ship_lite___streaming_bypass__ship_sb_t07.cc,0.460866452,0.460866452,0%
1829,milc,SHiP-Lite + Streaming Bypass (SHiP-SB),"SHiP-SB merges PC-based insertion biasing (SHiP-lite) with a lightweight streaming bypass detector to handle both irregular and streaming access patterns. Each cache line is tagged with a compact 4-bit PC signature and a 2-bit outcome counter, recording reuse history and guiding insertion depth: blocks with positive reuse are inserted closer to MRU, while blocks with little or no reuse are inserted at distant RRPV to minimize pollution. In parallel, a per-set 3-bit streaming detector identifies monotonic address strides, triggering aggressive distant insertion (RRIP_MAX) for streaming phases (LBM, MCF, omnetpp) and further reducing pollution. This dual mechanism allows the policy to adapt to both control-flow-dominated (astar, milc) and streaming workloads, leveraging PC-locality when present and bypassing when not, all with metadata well under 64 KiB. Compared to prior DRRIP-SB, this policy changes both the prediction source (PC signature/outcome rather than set-dueling) and insertion logic, improving hit rates for mixed, phase-changing, and streaming patterns.",,ChampSim_CRC2/new_policies/005_02_ship_lite___streaming_bypass__ship_sb_t07.cc,0.045587522,0.045587522,0%
1830,omnetpp,SHiP-Lite + Streaming Bypass (SHiP-SB),"SHiP-SB merges PC-based insertion biasing (SHiP-lite) with a lightweight streaming bypass detector to handle both irregular and streaming access patterns. Each cache line is tagged with a compact 4-bit PC signature and a 2-bit outcome counter, recording reuse history and guiding insertion depth: blocks with positive reuse are inserted closer to MRU, while blocks with little or no reuse are inserted at distant RRPV to minimize pollution. In parallel, a per-set 3-bit streaming detector identifies monotonic address strides, triggering aggressive distant insertion (RRIP_MAX) for streaming phases (LBM, MCF, omnetpp) and further reducing pollution. This dual mechanism allows the policy to adapt to both control-flow-dominated (astar, milc) and streaming workloads, leveraging PC-locality when present and bypassing when not, all with metadata well under 64 KiB. Compared to prior DRRIP-SB, this policy changes both the prediction source (PC signature/outcome rather than set-dueling) and insertion logic, improving hit rates for mixed, phase-changing, and streaming patterns.",,ChampSim_CRC2/new_policies/005_02_ship_lite___streaming_bypass__ship_sb_t07.cc,0.222232164,0.222232164,0%
1831,all,SHiP-Lite + Streaming Dead-Block Bypass (SHiP-SDB),"SHiP-SDB combines a lightweight SHiP-style PC signature predictor with a streaming-aware dead-block bypass for robust cache management across diverse workloads. Each cache line tracks a 6-bit PC signature and a 2-bit reuse counter, enabling the policy to learn whether lines loaded by specific PCs are likely to be reused. On insertion, lines with low predicted reuse are placed at distant RRPV, while high-reuse PCs get near-MRU insertion. In parallel, a compact per-set streaming detector (3 bits/set) identifies monotonic address strides (for LBM, mcf, omnetpp) and triggers bypass: new lines in streaming sets are inserted at RRIP_MAX and their reuse counters are periodically decayed, hastening eviction of dead blocks. This dual mechanism allows the policy to adapt to both control-dominated (astar, milc) and streaming workloads, reducing pollution and improving hit rates. Metadata is compact (2 bits/block RRPV, 6 bits/block signature, 2 bits/block reuse, 3 bits/set streaming), fitting comfortably within the 64 KiB budget.",,ChampSim_CRC2/new_policies/005_01_ship_lite___streaming_dead_block_bypass__ship_sdb_t04.cc,0.428914917,0.428914917,43%
1832,astar,DRRIP-Ship Hybrid with Adaptive Streaming Bypass (DS-ASB),"DS-ASB combines Dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming detector that triggers direct bypass for detected monotonic access patterns. DRRIP uses a compact 10-bit PSEL selector to dynamically switch between SRRIP and BRRIP insertion depths, optimizing for workloads with varying reuse. SHiP-lite overlays a 4-bit PC signature and 2-bit outcome table to further bias insertion depth toward MRU for PCs with strong reuse history. The streaming detector monitors address strides per set (3 bits/set), and when streaming is detected, newly inserted lines are bypassed (not cached) to prevent pollution. This hybrid approach leverages DRRIP’s adaptability, SHiP’s fine-grained reuse prediction, and aggressive dead-block avoidance for streaming workloads, yielding improved hit rates across diverse patterns while keeping metadata well under 64 KiB.",,ChampSim_CRC2/new_policies/006_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__ds_asb_t04.cc,0.452326574,0.452326574,0%
1833,lbm,DRRIP-Ship Hybrid with Adaptive Streaming Bypass (DS-ASB),"DS-ASB combines Dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming detector that triggers direct bypass for detected monotonic access patterns. DRRIP uses a compact 10-bit PSEL selector to dynamically switch between SRRIP and BRRIP insertion depths, optimizing for workloads with varying reuse. SHiP-lite overlays a 4-bit PC signature and 2-bit outcome table to further bias insertion depth toward MRU for PCs with strong reuse history. The streaming detector monitors address strides per set (3 bits/set), and when streaming is detected, newly inserted lines are bypassed (not cached) to prevent pollution. This hybrid approach leverages DRRIP’s adaptability, SHiP’s fine-grained reuse prediction, and aggressive dead-block avoidance for streaming workloads, yielding improved hit rates across diverse patterns while keeping metadata well under 64 KiB.",,ChampSim_CRC2/new_policies/006_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__ds_asb_t04.cc,0.438157295,0.438157295,0%
1834,mcf,DRRIP-Ship Hybrid with Adaptive Streaming Bypass (DS-ASB),"DS-ASB combines Dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming detector that triggers direct bypass for detected monotonic access patterns. DRRIP uses a compact 10-bit PSEL selector to dynamically switch between SRRIP and BRRIP insertion depths, optimizing for workloads with varying reuse. SHiP-lite overlays a 4-bit PC signature and 2-bit outcome table to further bias insertion depth toward MRU for PCs with strong reuse history. The streaming detector monitors address strides per set (3 bits/set), and when streaming is detected, newly inserted lines are bypassed (not cached) to prevent pollution. This hybrid approach leverages DRRIP’s adaptability, SHiP’s fine-grained reuse prediction, and aggressive dead-block avoidance for streaming workloads, yielding improved hit rates across diverse patterns while keeping metadata well under 64 KiB.",,ChampSim_CRC2/new_policies/006_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__ds_asb_t04.cc,0.402951973,0.402951973,0%
1835,milc,DRRIP-Ship Hybrid with Adaptive Streaming Bypass (DS-ASB),"DS-ASB combines Dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming detector that triggers direct bypass for detected monotonic access patterns. DRRIP uses a compact 10-bit PSEL selector to dynamically switch between SRRIP and BRRIP insertion depths, optimizing for workloads with varying reuse. SHiP-lite overlays a 4-bit PC signature and 2-bit outcome table to further bias insertion depth toward MRU for PCs with strong reuse history. The streaming detector monitors address strides per set (3 bits/set), and when streaming is detected, newly inserted lines are bypassed (not cached) to prevent pollution. This hybrid approach leverages DRRIP’s adaptability, SHiP’s fine-grained reuse prediction, and aggressive dead-block avoidance for streaming workloads, yielding improved hit rates across diverse patterns while keeping metadata well under 64 KiB.",,ChampSim_CRC2/new_policies/006_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__ds_asb_t04.cc,0.324469395,0.324469395,0%
1836,omnetpp,DRRIP-Ship Hybrid with Adaptive Streaming Bypass (DS-ASB),"DS-ASB combines Dynamic RRIP (DRRIP) set-dueling with SHiP-lite PC-based reuse prediction and an adaptive streaming detector that triggers direct bypass for detected monotonic access patterns. DRRIP uses a compact 10-bit PSEL selector to dynamically switch between SRRIP and BRRIP insertion depths, optimizing for workloads with varying reuse. SHiP-lite overlays a 4-bit PC signature and 2-bit outcome table to further bias insertion depth toward MRU for PCs with strong reuse history. The streaming detector monitors address strides per set (3 bits/set), and when streaming is detected, newly inserted lines are bypassed (not cached) to prevent pollution. This hybrid approach leverages DRRIP’s adaptability, SHiP’s fine-grained reuse prediction, and aggressive dead-block avoidance for streaming workloads, yielding improved hit rates across diverse patterns while keeping metadata well under 64 KiB.",,ChampSim_CRC2/new_policies/006_01_drrip_ship_hybrid_with_adaptive_streaming_bypass__ds_asb_t04.cc,0.508818915,0.508818915,0%
1837,astar,DRRIP + SHiP-Lite + Streaming Set Bypass (DSSB),"This policy combines DRRIP (Dynamic RRIP) set-dueling for global insertion depth control, SHiP-lite PC signature prediction for fine-grained reuse awareness, and streaming set detection with full line bypass for monotonic access patterns. DRRIP adaptively chooses between SRRIP (insert at distant) and BRRIP (rarely insert at MRU) using a 10-bit PSEL counter and 64 leader sets, robustly handling phase changes in workloads like milc and omnetpp. SHiP-lite augments insertion on regular sets: 6-bit PC signatures per block track reuse, with a 2-bit global outcome table biasing insertion depth for control- and pointer-heavy workloads (astar, mcf). For sets exhibiting streaming (detected via 3 consecutive monotonic strides in a small 3-bit per-set detector), new lines are fully bypassed (not inserted), preventing pollution in workloads like lbm and mcf. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming), fitting well under 64 KiB. This material redesign changes the insertion depth control (DRRIP set-dueling replaces static SHiP-based insertion) and streaming logic (full bypass), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/006_02_drrip___ship_lite___streaming_set_bypass__dssb_t07.cc,0.446478689,0.446478689,0%
1838,lbm,DRRIP + SHiP-Lite + Streaming Set Bypass (DSSB),"This policy combines DRRIP (Dynamic RRIP) set-dueling for global insertion depth control, SHiP-lite PC signature prediction for fine-grained reuse awareness, and streaming set detection with full line bypass for monotonic access patterns. DRRIP adaptively chooses between SRRIP (insert at distant) and BRRIP (rarely insert at MRU) using a 10-bit PSEL counter and 64 leader sets, robustly handling phase changes in workloads like milc and omnetpp. SHiP-lite augments insertion on regular sets: 6-bit PC signatures per block track reuse, with a 2-bit global outcome table biasing insertion depth for control- and pointer-heavy workloads (astar, mcf). For sets exhibiting streaming (detected via 3 consecutive monotonic strides in a small 3-bit per-set detector), new lines are fully bypassed (not inserted), preventing pollution in workloads like lbm and mcf. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming), fitting well under 64 KiB. This material redesign changes the insertion depth control (DRRIP set-dueling replaces static SHiP-based insertion) and streaming logic (full bypass), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/006_02_drrip___ship_lite___streaming_set_bypass__dssb_t07.cc,0.425312786,0.425312786,0%
1839,mcf,DRRIP + SHiP-Lite + Streaming Set Bypass (DSSB),"This policy combines DRRIP (Dynamic RRIP) set-dueling for global insertion depth control, SHiP-lite PC signature prediction for fine-grained reuse awareness, and streaming set detection with full line bypass for monotonic access patterns. DRRIP adaptively chooses between SRRIP (insert at distant) and BRRIP (rarely insert at MRU) using a 10-bit PSEL counter and 64 leader sets, robustly handling phase changes in workloads like milc and omnetpp. SHiP-lite augments insertion on regular sets: 6-bit PC signatures per block track reuse, with a 2-bit global outcome table biasing insertion depth for control- and pointer-heavy workloads (astar, mcf). For sets exhibiting streaming (detected via 3 consecutive monotonic strides in a small 3-bit per-set detector), new lines are fully bypassed (not inserted), preventing pollution in workloads like lbm and mcf. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming), fitting well under 64 KiB. This material redesign changes the insertion depth control (DRRIP set-dueling replaces static SHiP-based insertion) and streaming logic (full bypass), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/006_02_drrip___ship_lite___streaming_set_bypass__dssb_t07.cc,0.474454667,0.474454667,0%
1840,milc,DRRIP + SHiP-Lite + Streaming Set Bypass (DSSB),"This policy combines DRRIP (Dynamic RRIP) set-dueling for global insertion depth control, SHiP-lite PC signature prediction for fine-grained reuse awareness, and streaming set detection with full line bypass for monotonic access patterns. DRRIP adaptively chooses between SRRIP (insert at distant) and BRRIP (rarely insert at MRU) using a 10-bit PSEL counter and 64 leader sets, robustly handling phase changes in workloads like milc and omnetpp. SHiP-lite augments insertion on regular sets: 6-bit PC signatures per block track reuse, with a 2-bit global outcome table biasing insertion depth for control- and pointer-heavy workloads (astar, mcf). For sets exhibiting streaming (detected via 3 consecutive monotonic strides in a small 3-bit per-set detector), new lines are fully bypassed (not inserted), preventing pollution in workloads like lbm and mcf. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming), fitting well under 64 KiB. This material redesign changes the insertion depth control (DRRIP set-dueling replaces static SHiP-based insertion) and streaming logic (full bypass), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/006_02_drrip___ship_lite___streaming_set_bypass__dssb_t07.cc,0.315082877,0.315082877,0%
1841,omnetpp,DRRIP + SHiP-Lite + Streaming Set Bypass (DSSB),"This policy combines DRRIP (Dynamic RRIP) set-dueling for global insertion depth control, SHiP-lite PC signature prediction for fine-grained reuse awareness, and streaming set detection with full line bypass for monotonic access patterns. DRRIP adaptively chooses between SRRIP (insert at distant) and BRRIP (rarely insert at MRU) using a 10-bit PSEL counter and 64 leader sets, robustly handling phase changes in workloads like milc and omnetpp. SHiP-lite augments insertion on regular sets: 6-bit PC signatures per block track reuse, with a 2-bit global outcome table biasing insertion depth for control- and pointer-heavy workloads (astar, mcf). For sets exhibiting streaming (detected via 3 consecutive monotonic strides in a small 3-bit per-set detector), new lines are fully bypassed (not inserted), preventing pollution in workloads like lbm and mcf. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming), fitting well under 64 KiB. This material redesign changes the insertion depth control (DRRIP set-dueling replaces static SHiP-based insertion) and streaming logic (full bypass), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/006_02_drrip___ship_lite___streaming_set_bypass__dssb_t07.cc,0.612146662,0.612146662,0%
1842,all,DRRIP + SHiP-Lite + Streaming Set Bypass (DSSB),"This policy combines DRRIP (Dynamic RRIP) set-dueling for global insertion depth control, SHiP-lite PC signature prediction for fine-grained reuse awareness, and streaming set detection with full line bypass for monotonic access patterns. DRRIP adaptively chooses between SRRIP (insert at distant) and BRRIP (rarely insert at MRU) using a 10-bit PSEL counter and 64 leader sets, robustly handling phase changes in workloads like milc and omnetpp. SHiP-lite augments insertion on regular sets: 6-bit PC signatures per block track reuse, with a 2-bit global outcome table biasing insertion depth for control- and pointer-heavy workloads (astar, mcf). For sets exhibiting streaming (detected via 3 consecutive monotonic strides in a small 3-bit per-set detector), new lines are fully bypassed (not inserted), preventing pollution in workloads like lbm and mcf. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming), fitting well under 64 KiB. This material redesign changes the insertion depth control (DRRIP set-dueling replaces static SHiP-based insertion) and streaming logic (full bypass), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/006_02_drrip___ship_lite___streaming_set_bypass__dssb_t07.cc,0.454695136,0.454695136,45%
1843,astar,DIP-SHiP Hybrid with Streaming-Aware Distant Insertion (DIP-SHiP-SD),"This policy combines DIP (Dynamic Insertion Policy) set-dueling for global insertion depth control (choosing between LIP and BIP), SHiP-lite per-block PC signature prediction for fine-grained reuse awareness, and a streaming detector that inserts new lines at distant RRPV (rather than bypassing) when monotonic access is detected. DIP uses 32 leader sets (16 LIP, 16 BIP) and a 10-bit PSEL to adapt insertion depth globally, improving phase response for workloads like milc and omnetpp. SHiP-lite (6-bit PC signature per block, 2-bit outcome table) biases insertion depth for pointer-heavy and control-dominated workloads (astar, mcf). The streaming detector (3 bits/set) triggers distant insertion for detected streaming sets, reducing pollution in lbm and mcf without fully bypassing useful lines. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 32 leader sets, 3b/set streaming), fitting well under 64 KiB. This design changes the global insertion control (DIP replaces DRRIP), streaming logic (distant insertion replaces bypass), and metadata layout (fewer leader sets), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/007_00_dip_ship_hybrid_with_streaming_aware_distant_insertion__dip_ship_sd_t02.cc,0.408505967,0.408505967,0%
1844,lbm,DIP-SHiP Hybrid with Streaming-Aware Distant Insertion (DIP-SHiP-SD),"This policy combines DIP (Dynamic Insertion Policy) set-dueling for global insertion depth control (choosing between LIP and BIP), SHiP-lite per-block PC signature prediction for fine-grained reuse awareness, and a streaming detector that inserts new lines at distant RRPV (rather than bypassing) when monotonic access is detected. DIP uses 32 leader sets (16 LIP, 16 BIP) and a 10-bit PSEL to adapt insertion depth globally, improving phase response for workloads like milc and omnetpp. SHiP-lite (6-bit PC signature per block, 2-bit outcome table) biases insertion depth for pointer-heavy and control-dominated workloads (astar, mcf). The streaming detector (3 bits/set) triggers distant insertion for detected streaming sets, reducing pollution in lbm and mcf without fully bypassing useful lines. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 32 leader sets, 3b/set streaming), fitting well under 64 KiB. This design changes the global insertion control (DIP replaces DRRIP), streaming logic (distant insertion replaces bypass), and metadata layout (fewer leader sets), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/007_00_dip_ship_hybrid_with_streaming_aware_distant_insertion__dip_ship_sd_t02.cc,0.420179486,0.420179486,0%
1845,mcf,DIP-SHiP Hybrid with Streaming-Aware Distant Insertion (DIP-SHiP-SD),"This policy combines DIP (Dynamic Insertion Policy) set-dueling for global insertion depth control (choosing between LIP and BIP), SHiP-lite per-block PC signature prediction for fine-grained reuse awareness, and a streaming detector that inserts new lines at distant RRPV (rather than bypassing) when monotonic access is detected. DIP uses 32 leader sets (16 LIP, 16 BIP) and a 10-bit PSEL to adapt insertion depth globally, improving phase response for workloads like milc and omnetpp. SHiP-lite (6-bit PC signature per block, 2-bit outcome table) biases insertion depth for pointer-heavy and control-dominated workloads (astar, mcf). The streaming detector (3 bits/set) triggers distant insertion for detected streaming sets, reducing pollution in lbm and mcf without fully bypassing useful lines. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 32 leader sets, 3b/set streaming), fitting well under 64 KiB. This design changes the global insertion control (DIP replaces DRRIP), streaming logic (distant insertion replaces bypass), and metadata layout (fewer leader sets), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/007_00_dip_ship_hybrid_with_streaming_aware_distant_insertion__dip_ship_sd_t02.cc,0.471598746,0.471598746,0%
1846,milc,DIP-SHiP Hybrid with Streaming-Aware Distant Insertion (DIP-SHiP-SD),"This policy combines DIP (Dynamic Insertion Policy) set-dueling for global insertion depth control (choosing between LIP and BIP), SHiP-lite per-block PC signature prediction for fine-grained reuse awareness, and a streaming detector that inserts new lines at distant RRPV (rather than bypassing) when monotonic access is detected. DIP uses 32 leader sets (16 LIP, 16 BIP) and a 10-bit PSEL to adapt insertion depth globally, improving phase response for workloads like milc and omnetpp. SHiP-lite (6-bit PC signature per block, 2-bit outcome table) biases insertion depth for pointer-heavy and control-dominated workloads (astar, mcf). The streaming detector (3 bits/set) triggers distant insertion for detected streaming sets, reducing pollution in lbm and mcf without fully bypassing useful lines. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 32 leader sets, 3b/set streaming), fitting well under 64 KiB. This design changes the global insertion control (DIP replaces DRRIP), streaming logic (distant insertion replaces bypass), and metadata layout (fewer leader sets), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/007_00_dip_ship_hybrid_with_streaming_aware_distant_insertion__dip_ship_sd_t02.cc,0.310473797,0.310473797,0%
1847,omnetpp,DIP-SHiP Hybrid with Streaming-Aware Distant Insertion (DIP-SHiP-SD),"This policy combines DIP (Dynamic Insertion Policy) set-dueling for global insertion depth control (choosing between LIP and BIP), SHiP-lite per-block PC signature prediction for fine-grained reuse awareness, and a streaming detector that inserts new lines at distant RRPV (rather than bypassing) when monotonic access is detected. DIP uses 32 leader sets (16 LIP, 16 BIP) and a 10-bit PSEL to adapt insertion depth globally, improving phase response for workloads like milc and omnetpp. SHiP-lite (6-bit PC signature per block, 2-bit outcome table) biases insertion depth for pointer-heavy and control-dominated workloads (astar, mcf). The streaming detector (3 bits/set) triggers distant insertion for detected streaming sets, reducing pollution in lbm and mcf without fully bypassing useful lines. Metadata remains compact (2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 32 leader sets, 3b/set streaming), fitting well under 64 KiB. This design changes the global insertion control (DIP replaces DRRIP), streaming logic (distant insertion replaces bypass), and metadata layout (fewer leader sets), improving adaptability and hit rate across all workloads.",,ChampSim_CRC2/new_policies/007_00_dip_ship_hybrid_with_streaming_aware_distant_insertion__dip_ship_sd_t02.cc,0.473856248,0.473856248,0%
1848,astar,SHiP-Lite + Streaming-Aware LIP/BIP (SSLB),"SSLB combines SHiP-lite PC signature prediction for fine-grained reuse detection with DIP-style set-dueling between LIP (always insert at LRU) and BIP (insert at LRU only 1/32 times, otherwise at MRU), controlled by a 10-bit PSEL and 64 leader sets. To address streaming and monotonic access patterns (e.g., in lbm and mcf), a lightweight per-set streaming detector tags sets with 3 consecutive monotonic strides, causing new lines to be inserted at LRU (maximally distant) for the streaming window. This limits pollution from non-reusing blocks without fully bypassing the cache, retaining hits for short reuse intervals. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control- and pointer-heavy workloads (astar, mcf, omnetpp). Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming detector. This design improves adaptability to phase changes and streaming bursts while maintaining hit rates for workloads with irregular and regular reuse.",,ChampSim_CRC2/new_policies/007_01_ship_lite___streaming_aware_lip_bip__sslb_t04.cc,0.448732441,0.448732441,0%
1849,lbm,SHiP-Lite + Streaming-Aware LIP/BIP (SSLB),"SSLB combines SHiP-lite PC signature prediction for fine-grained reuse detection with DIP-style set-dueling between LIP (always insert at LRU) and BIP (insert at LRU only 1/32 times, otherwise at MRU), controlled by a 10-bit PSEL and 64 leader sets. To address streaming and monotonic access patterns (e.g., in lbm and mcf), a lightweight per-set streaming detector tags sets with 3 consecutive monotonic strides, causing new lines to be inserted at LRU (maximally distant) for the streaming window. This limits pollution from non-reusing blocks without fully bypassing the cache, retaining hits for short reuse intervals. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control- and pointer-heavy workloads (astar, mcf, omnetpp). Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming detector. This design improves adaptability to phase changes and streaming bursts while maintaining hit rates for workloads with irregular and regular reuse.",,ChampSim_CRC2/new_policies/007_01_ship_lite___streaming_aware_lip_bip__sslb_t04.cc,0.431260149,0.431260149,0%
1850,mcf,SHiP-Lite + Streaming-Aware LIP/BIP (SSLB),"SSLB combines SHiP-lite PC signature prediction for fine-grained reuse detection with DIP-style set-dueling between LIP (always insert at LRU) and BIP (insert at LRU only 1/32 times, otherwise at MRU), controlled by a 10-bit PSEL and 64 leader sets. To address streaming and monotonic access patterns (e.g., in lbm and mcf), a lightweight per-set streaming detector tags sets with 3 consecutive monotonic strides, causing new lines to be inserted at LRU (maximally distant) for the streaming window. This limits pollution from non-reusing blocks without fully bypassing the cache, retaining hits for short reuse intervals. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control- and pointer-heavy workloads (astar, mcf, omnetpp). Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming detector. This design improves adaptability to phase changes and streaming bursts while maintaining hit rates for workloads with irregular and regular reuse.",,ChampSim_CRC2/new_policies/007_01_ship_lite___streaming_aware_lip_bip__sslb_t04.cc,0.498759389,0.498759389,0%
1851,milc,SHiP-Lite + Streaming-Aware LIP/BIP (SSLB),"SSLB combines SHiP-lite PC signature prediction for fine-grained reuse detection with DIP-style set-dueling between LIP (always insert at LRU) and BIP (insert at LRU only 1/32 times, otherwise at MRU), controlled by a 10-bit PSEL and 64 leader sets. To address streaming and monotonic access patterns (e.g., in lbm and mcf), a lightweight per-set streaming detector tags sets with 3 consecutive monotonic strides, causing new lines to be inserted at LRU (maximally distant) for the streaming window. This limits pollution from non-reusing blocks without fully bypassing the cache, retaining hits for short reuse intervals. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control- and pointer-heavy workloads (astar, mcf, omnetpp). Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming detector. This design improves adaptability to phase changes and streaming bursts while maintaining hit rates for workloads with irregular and regular reuse.",,ChampSim_CRC2/new_policies/007_01_ship_lite___streaming_aware_lip_bip__sslb_t04.cc,0.316181742,0.316181742,0%
1852,omnetpp,SHiP-Lite + Streaming-Aware LIP/BIP (SSLB),"SSLB combines SHiP-lite PC signature prediction for fine-grained reuse detection with DIP-style set-dueling between LIP (always insert at LRU) and BIP (insert at LRU only 1/32 times, otherwise at MRU), controlled by a 10-bit PSEL and 64 leader sets. To address streaming and monotonic access patterns (e.g., in lbm and mcf), a lightweight per-set streaming detector tags sets with 3 consecutive monotonic strides, causing new lines to be inserted at LRU (maximally distant) for the streaming window. This limits pollution from non-reusing blocks without fully bypassing the cache, retaining hits for short reuse intervals. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control- and pointer-heavy workloads (astar, mcf, omnetpp). Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming detector. This design improves adaptability to phase changes and streaming bursts while maintaining hit rates for workloads with irregular and regular reuse.",,ChampSim_CRC2/new_policies/007_01_ship_lite___streaming_aware_lip_bip__sslb_t04.cc,0.441321555,0.441321555,0%
1853,astar,Adaptive SHiP-Lite with Streaming-aware LIP (ASLIP),"ASLIP combines SHiP-lite’s PC-based reuse prediction for fine-grained insertion control with streaming-aware LIP (“Low Insertion Position”) to minimize cache pollution from streaming or monotonic access patterns. On regular sets, blocks are inserted at MRU or LRU depth based on SHiP outcome counters (4-bit PC signatures, 2-bit counters). When a set’s streaming detector (3 bits per set) identifies a monotonic stride, insertion switches to LIP (always at LRU position), preventing pollution from one-shot accesses typical in lbm and mcf. Unlike DRRIP, this design uses DIP-style set-dueling (32 leader sets each for SHiP-based and pure LIP insertion), with an 8-bit PSEL controlling which insertion policy dominates non-leader sets. Metadata: 2b RRPV/block, 4b signature/block, 2b outcome/entry, 8b PSEL, 64 leader sets, 3b/set streaming—well under 64 KiB. This approach improves hit rates by more aggressively filtering streaming accesses and adapting insertion depth to workload phase, especially benefiting workloads with phase changes (milc, omnetpp) and streaming bursts (lbm).",,ChampSim_CRC2/new_policies/007_02_adaptive_ship_lite_with_streaming_aware_lip__aslip_t07.cc,0.06345944,0.06345944,0%
1854,lbm,Adaptive SHiP-Lite with Streaming-aware LIP (ASLIP),"ASLIP combines SHiP-lite’s PC-based reuse prediction for fine-grained insertion control with streaming-aware LIP (“Low Insertion Position”) to minimize cache pollution from streaming or monotonic access patterns. On regular sets, blocks are inserted at MRU or LRU depth based on SHiP outcome counters (4-bit PC signatures, 2-bit counters). When a set’s streaming detector (3 bits per set) identifies a monotonic stride, insertion switches to LIP (always at LRU position), preventing pollution from one-shot accesses typical in lbm and mcf. Unlike DRRIP, this design uses DIP-style set-dueling (32 leader sets each for SHiP-based and pure LIP insertion), with an 8-bit PSEL controlling which insertion policy dominates non-leader sets. Metadata: 2b RRPV/block, 4b signature/block, 2b outcome/entry, 8b PSEL, 64 leader sets, 3b/set streaming—well under 64 KiB. This approach improves hit rates by more aggressively filtering streaming accesses and adapting insertion depth to workload phase, especially benefiting workloads with phase changes (milc, omnetpp) and streaming bursts (lbm).",,ChampSim_CRC2/new_policies/007_02_adaptive_ship_lite_with_streaming_aware_lip__aslip_t07.cc,0.095642102,0.095642102,0%
1855,mcf,Adaptive SHiP-Lite with Streaming-aware LIP (ASLIP),"ASLIP combines SHiP-lite’s PC-based reuse prediction for fine-grained insertion control with streaming-aware LIP (“Low Insertion Position”) to minimize cache pollution from streaming or monotonic access patterns. On regular sets, blocks are inserted at MRU or LRU depth based on SHiP outcome counters (4-bit PC signatures, 2-bit counters). When a set’s streaming detector (3 bits per set) identifies a monotonic stride, insertion switches to LIP (always at LRU position), preventing pollution from one-shot accesses typical in lbm and mcf. Unlike DRRIP, this design uses DIP-style set-dueling (32 leader sets each for SHiP-based and pure LIP insertion), with an 8-bit PSEL controlling which insertion policy dominates non-leader sets. Metadata: 2b RRPV/block, 4b signature/block, 2b outcome/entry, 8b PSEL, 64 leader sets, 3b/set streaming—well under 64 KiB. This approach improves hit rates by more aggressively filtering streaming accesses and adapting insertion depth to workload phase, especially benefiting workloads with phase changes (milc, omnetpp) and streaming bursts (lbm).",,ChampSim_CRC2/new_policies/007_02_adaptive_ship_lite_with_streaming_aware_lip__aslip_t07.cc,0.452556999,0.452556999,0%
1856,milc,Adaptive SHiP-Lite with Streaming-aware LIP (ASLIP),"ASLIP combines SHiP-lite’s PC-based reuse prediction for fine-grained insertion control with streaming-aware LIP (“Low Insertion Position”) to minimize cache pollution from streaming or monotonic access patterns. On regular sets, blocks are inserted at MRU or LRU depth based on SHiP outcome counters (4-bit PC signatures, 2-bit counters). When a set’s streaming detector (3 bits per set) identifies a monotonic stride, insertion switches to LIP (always at LRU position), preventing pollution from one-shot accesses typical in lbm and mcf. Unlike DRRIP, this design uses DIP-style set-dueling (32 leader sets each for SHiP-based and pure LIP insertion), with an 8-bit PSEL controlling which insertion policy dominates non-leader sets. Metadata: 2b RRPV/block, 4b signature/block, 2b outcome/entry, 8b PSEL, 64 leader sets, 3b/set streaming—well under 64 KiB. This approach improves hit rates by more aggressively filtering streaming accesses and adapting insertion depth to workload phase, especially benefiting workloads with phase changes (milc, omnetpp) and streaming bursts (lbm).",,ChampSim_CRC2/new_policies/007_02_adaptive_ship_lite_with_streaming_aware_lip__aslip_t07.cc,0.013170091,0.013170091,0%
1857,omnetpp,Adaptive SHiP-Lite with Streaming-aware LIP (ASLIP),"ASLIP combines SHiP-lite’s PC-based reuse prediction for fine-grained insertion control with streaming-aware LIP (“Low Insertion Position”) to minimize cache pollution from streaming or monotonic access patterns. On regular sets, blocks are inserted at MRU or LRU depth based on SHiP outcome counters (4-bit PC signatures, 2-bit counters). When a set’s streaming detector (3 bits per set) identifies a monotonic stride, insertion switches to LIP (always at LRU position), preventing pollution from one-shot accesses typical in lbm and mcf. Unlike DRRIP, this design uses DIP-style set-dueling (32 leader sets each for SHiP-based and pure LIP insertion), with an 8-bit PSEL controlling which insertion policy dominates non-leader sets. Metadata: 2b RRPV/block, 4b signature/block, 2b outcome/entry, 8b PSEL, 64 leader sets, 3b/set streaming—well under 64 KiB. This approach improves hit rates by more aggressively filtering streaming accesses and adapting insertion depth to workload phase, especially benefiting workloads with phase changes (milc, omnetpp) and streaming bursts (lbm).",,ChampSim_CRC2/new_policies/007_02_adaptive_ship_lite_with_streaming_aware_lip__aslip_t07.cc,0.001437527,0.001437527,0%
1858,all,SHiP-Lite + Streaming-Aware LIP/BIP (SSLB),"SSLB combines SHiP-lite PC signature prediction for fine-grained reuse detection with DIP-style set-dueling between LIP (always insert at LRU) and BIP (insert at LRU only 1/32 times, otherwise at MRU), controlled by a 10-bit PSEL and 64 leader sets. To address streaming and monotonic access patterns (e.g., in lbm and mcf), a lightweight per-set streaming detector tags sets with 3 consecutive monotonic strides, causing new lines to be inserted at LRU (maximally distant) for the streaming window. This limits pollution from non-reusing blocks without fully bypassing the cache, retaining hits for short reuse intervals. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control- and pointer-heavy workloads (astar, mcf, omnetpp). Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, 3b/set streaming detector. This design improves adaptability to phase changes and streaming bursts while maintaining hit rates for workloads with irregular and regular reuse.",,ChampSim_CRC2/new_policies/007_01_ship_lite___streaming_aware_lip_bip__sslb_t04.cc,0.427251055,0.427251055,43%
1859,astar,Adaptive Dead-Block + Streaming Bypass (ADSB),"ADSB combines per-block dead-block prediction with a streaming-aware bypass mechanism to improve cache hit rates across diverse workloads. Each cache block maintains a compact 2-bit reuse counter, incremented on hits and periodically decayed, allowing the policy to approximate dead-block status and bias insertion depth: blocks predicted dead are inserted at distant RRPV, while likely-reused blocks are inserted at MRU. A lightweight per-set streaming detector monitors monotonic address strides; when streaming is detected, new lines are bypassed (not cached) for the streaming window, minimizing pollution from non-reusing blocks (e.g., in lbm and mcf). This approach adapts to both irregular pointer-heavy workloads (astar, mcf, omnetpp) and regular streaming phases (lbm, milc), improving cache utilization and reducing pollution. Metadata remains compact: 2b RRPV/block, 2b reuse counter/block, 3b/set streaming detector, totaling under 64 KiB. This materially differs from SSLB by changing the prediction source (per-block reuse counters) and streaming logic (full bypass).",,ChampSim_CRC2/new_policies/008_00_adaptive_dead_block___streaming_bypass__adsb_t02.cc,0.282451736,0.282451736,0%
1860,lbm,Adaptive Dead-Block + Streaming Bypass (ADSB),"ADSB combines per-block dead-block prediction with a streaming-aware bypass mechanism to improve cache hit rates across diverse workloads. Each cache block maintains a compact 2-bit reuse counter, incremented on hits and periodically decayed, allowing the policy to approximate dead-block status and bias insertion depth: blocks predicted dead are inserted at distant RRPV, while likely-reused blocks are inserted at MRU. A lightweight per-set streaming detector monitors monotonic address strides; when streaming is detected, new lines are bypassed (not cached) for the streaming window, minimizing pollution from non-reusing blocks (e.g., in lbm and mcf). This approach adapts to both irregular pointer-heavy workloads (astar, mcf, omnetpp) and regular streaming phases (lbm, milc), improving cache utilization and reducing pollution. Metadata remains compact: 2b RRPV/block, 2b reuse counter/block, 3b/set streaming detector, totaling under 64 KiB. This materially differs from SSLB by changing the prediction source (per-block reuse counters) and streaming logic (full bypass).",,ChampSim_CRC2/new_policies/008_00_adaptive_dead_block___streaming_bypass__adsb_t02.cc,0.196098024,0.196098024,0%
1861,mcf,Adaptive Dead-Block + Streaming Bypass (ADSB),"ADSB combines per-block dead-block prediction with a streaming-aware bypass mechanism to improve cache hit rates across diverse workloads. Each cache block maintains a compact 2-bit reuse counter, incremented on hits and periodically decayed, allowing the policy to approximate dead-block status and bias insertion depth: blocks predicted dead are inserted at distant RRPV, while likely-reused blocks are inserted at MRU. A lightweight per-set streaming detector monitors monotonic address strides; when streaming is detected, new lines are bypassed (not cached) for the streaming window, minimizing pollution from non-reusing blocks (e.g., in lbm and mcf). This approach adapts to both irregular pointer-heavy workloads (astar, mcf, omnetpp) and regular streaming phases (lbm, milc), improving cache utilization and reducing pollution. Metadata remains compact: 2b RRPV/block, 2b reuse counter/block, 3b/set streaming detector, totaling under 64 KiB. This materially differs from SSLB by changing the prediction source (per-block reuse counters) and streaming logic (full bypass).",,ChampSim_CRC2/new_policies/008_00_adaptive_dead_block___streaming_bypass__adsb_t02.cc,0.466380759,0.466380759,0%
1862,milc,Adaptive Dead-Block + Streaming Bypass (ADSB),"ADSB combines per-block dead-block prediction with a streaming-aware bypass mechanism to improve cache hit rates across diverse workloads. Each cache block maintains a compact 2-bit reuse counter, incremented on hits and periodically decayed, allowing the policy to approximate dead-block status and bias insertion depth: blocks predicted dead are inserted at distant RRPV, while likely-reused blocks are inserted at MRU. A lightweight per-set streaming detector monitors monotonic address strides; when streaming is detected, new lines are bypassed (not cached) for the streaming window, minimizing pollution from non-reusing blocks (e.g., in lbm and mcf). This approach adapts to both irregular pointer-heavy workloads (astar, mcf, omnetpp) and regular streaming phases (lbm, milc), improving cache utilization and reducing pollution. Metadata remains compact: 2b RRPV/block, 2b reuse counter/block, 3b/set streaming detector, totaling under 64 KiB. This materially differs from SSLB by changing the prediction source (per-block reuse counters) and streaming logic (full bypass).",,ChampSim_CRC2/new_policies/008_00_adaptive_dead_block___streaming_bypass__adsb_t02.cc,0.141802501,0.141802501,0%
1863,omnetpp,Adaptive Dead-Block + Streaming Bypass (ADSB),"ADSB combines per-block dead-block prediction with a streaming-aware bypass mechanism to improve cache hit rates across diverse workloads. Each cache block maintains a compact 2-bit reuse counter, incremented on hits and periodically decayed, allowing the policy to approximate dead-block status and bias insertion depth: blocks predicted dead are inserted at distant RRPV, while likely-reused blocks are inserted at MRU. A lightweight per-set streaming detector monitors monotonic address strides; when streaming is detected, new lines are bypassed (not cached) for the streaming window, minimizing pollution from non-reusing blocks (e.g., in lbm and mcf). This approach adapts to both irregular pointer-heavy workloads (astar, mcf, omnetpp) and regular streaming phases (lbm, milc), improving cache utilization and reducing pollution. Metadata remains compact: 2b RRPV/block, 2b reuse counter/block, 3b/set streaming detector, totaling under 64 KiB. This materially differs from SSLB by changing the prediction source (per-block reuse counters) and streaming logic (full bypass).",,ChampSim_CRC2/new_policies/008_00_adaptive_dead_block___streaming_bypass__adsb_t02.cc,0.57515911,0.57515911,0%
1864,astar,Hybrid SHiP-Lite + Dead-Block Counter Bypass (HSDB),"HSDB combines SHiP-lite PC signature-based reuse prediction with a per-block dead-block counter (DBC) to approximate non-reuse and trigger selective bypassing. Each cache block maintains a tiny saturating counter (2 bits) that is incremented on misses and decayed periodically. When a block is evicted with a high DBC (indicating repeated misses and little reuse), future insertions for that PC signature are biased toward bypassing the cache entirely for a short window. SHiP-lite provides fine-grained insertion depth control, while DBC enables dynamic, workload-adaptive bypassing for streaming and pointer-chasing patterns (e.g., lbm, mcf, omnetpp) without relying on set-level streaming detection. This hybrid approach improves performance by reducing cache pollution from dead blocks, retaining hits for short reuse intervals, and responding quickly to phase changes. Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b SHiP table/entry, 2b DBC/block, and a small bypass window table per signature.",,ChampSim_CRC2/new_policies/008_01_hybrid_ship_lite___dead_block_counter_bypass__hsdb_t04.cc,0.128319501,0.128319501,0%
1865,lbm,Hybrid SHiP-Lite + Dead-Block Counter Bypass (HSDB),"HSDB combines SHiP-lite PC signature-based reuse prediction with a per-block dead-block counter (DBC) to approximate non-reuse and trigger selective bypassing. Each cache block maintains a tiny saturating counter (2 bits) that is incremented on misses and decayed periodically. When a block is evicted with a high DBC (indicating repeated misses and little reuse), future insertions for that PC signature are biased toward bypassing the cache entirely for a short window. SHiP-lite provides fine-grained insertion depth control, while DBC enables dynamic, workload-adaptive bypassing for streaming and pointer-chasing patterns (e.g., lbm, mcf, omnetpp) without relying on set-level streaming detection. This hybrid approach improves performance by reducing cache pollution from dead blocks, retaining hits for short reuse intervals, and responding quickly to phase changes. Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b SHiP table/entry, 2b DBC/block, and a small bypass window table per signature.",,ChampSim_CRC2/new_policies/008_01_hybrid_ship_lite___dead_block_counter_bypass__hsdb_t04.cc,0.223997396,0.223997396,0%
1866,mcf,Hybrid SHiP-Lite + Dead-Block Counter Bypass (HSDB),"HSDB combines SHiP-lite PC signature-based reuse prediction with a per-block dead-block counter (DBC) to approximate non-reuse and trigger selective bypassing. Each cache block maintains a tiny saturating counter (2 bits) that is incremented on misses and decayed periodically. When a block is evicted with a high DBC (indicating repeated misses and little reuse), future insertions for that PC signature are biased toward bypassing the cache entirely for a short window. SHiP-lite provides fine-grained insertion depth control, while DBC enables dynamic, workload-adaptive bypassing for streaming and pointer-chasing patterns (e.g., lbm, mcf, omnetpp) without relying on set-level streaming detection. This hybrid approach improves performance by reducing cache pollution from dead blocks, retaining hits for short reuse intervals, and responding quickly to phase changes. Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b SHiP table/entry, 2b DBC/block, and a small bypass window table per signature.",,ChampSim_CRC2/new_policies/008_01_hybrid_ship_lite___dead_block_counter_bypass__hsdb_t04.cc,0.486965415,0.486965415,0%
1867,milc,Hybrid SHiP-Lite + Dead-Block Counter Bypass (HSDB),"HSDB combines SHiP-lite PC signature-based reuse prediction with a per-block dead-block counter (DBC) to approximate non-reuse and trigger selective bypassing. Each cache block maintains a tiny saturating counter (2 bits) that is incremented on misses and decayed periodically. When a block is evicted with a high DBC (indicating repeated misses and little reuse), future insertions for that PC signature are biased toward bypassing the cache entirely for a short window. SHiP-lite provides fine-grained insertion depth control, while DBC enables dynamic, workload-adaptive bypassing for streaming and pointer-chasing patterns (e.g., lbm, mcf, omnetpp) without relying on set-level streaming detection. This hybrid approach improves performance by reducing cache pollution from dead blocks, retaining hits for short reuse intervals, and responding quickly to phase changes. Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b SHiP table/entry, 2b DBC/block, and a small bypass window table per signature.",,ChampSim_CRC2/new_policies/008_01_hybrid_ship_lite___dead_block_counter_bypass__hsdb_t04.cc,0.025760878,0.025760878,0%
1868,omnetpp,Hybrid SHiP-Lite + Dead-Block Counter Bypass (HSDB),"HSDB combines SHiP-lite PC signature-based reuse prediction with a per-block dead-block counter (DBC) to approximate non-reuse and trigger selective bypassing. Each cache block maintains a tiny saturating counter (2 bits) that is incremented on misses and decayed periodically. When a block is evicted with a high DBC (indicating repeated misses and little reuse), future insertions for that PC signature are biased toward bypassing the cache entirely for a short window. SHiP-lite provides fine-grained insertion depth control, while DBC enables dynamic, workload-adaptive bypassing for streaming and pointer-chasing patterns (e.g., lbm, mcf, omnetpp) without relying on set-level streaming detection. This hybrid approach improves performance by reducing cache pollution from dead blocks, retaining hits for short reuse intervals, and responding quickly to phase changes. Metadata remains compact: 2b RRPV/block, 6b signature/block, 2b SHiP table/entry, 2b DBC/block, and a small bypass window table per signature.",,ChampSim_CRC2/new_policies/008_01_hybrid_ship_lite___dead_block_counter_bypass__hsdb_t04.cc,0.004527316,0.004527316,0%
1869,astar,SHiP-DRRIP with Streaming Bypass (SDSB),"SDSB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth selection, and introduces a streaming-aware per-set bypass mechanism. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control-heavy or pointer-chasing workloads. DRRIP set-dueling (64 leader sets, 10-bit PSEL) dynamically chooses between SRRIP (inserts at distant RRPV) and BRRIP (inserts at distant RRPV rarely, else near-MRU) to adapt to phase changes. A compact streaming detector tags sets with monotonic strides, and if a set is streaming for a sustained window, incoming lines are bypassed at insertion (not allocated in cache) unless SHiP predicts high reuse. This avoids pollution from streaming bursts (e.g., lbm, mcf) while retaining adaptive insertion for irregular workloads (astar, milc, omnetpp). The policy uses only 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, and 3b/set streaming detector, keeping metadata compact (<64KiB). By combining prediction source (PC signature), dynamic insertion depth, and selective bypass, SDSB aims to boost hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/008_02_ship_drrip_with_streaming_bypass__sdsb_t07.cc,0.443062623,0.443062623,0%
1870,lbm,SHiP-DRRIP with Streaming Bypass (SDSB),"SDSB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth selection, and introduces a streaming-aware per-set bypass mechanism. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control-heavy or pointer-chasing workloads. DRRIP set-dueling (64 leader sets, 10-bit PSEL) dynamically chooses between SRRIP (inserts at distant RRPV) and BRRIP (inserts at distant RRPV rarely, else near-MRU) to adapt to phase changes. A compact streaming detector tags sets with monotonic strides, and if a set is streaming for a sustained window, incoming lines are bypassed at insertion (not allocated in cache) unless SHiP predicts high reuse. This avoids pollution from streaming bursts (e.g., lbm, mcf) while retaining adaptive insertion for irregular workloads (astar, milc, omnetpp). The policy uses only 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, and 3b/set streaming detector, keeping metadata compact (<64KiB). By combining prediction source (PC signature), dynamic insertion depth, and selective bypass, SDSB aims to boost hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/008_02_ship_drrip_with_streaming_bypass__sdsb_t07.cc,0.395704366,0.395704366,0%
1871,mcf,SHiP-DRRIP with Streaming Bypass (SDSB),"SDSB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth selection, and introduces a streaming-aware per-set bypass mechanism. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control-heavy or pointer-chasing workloads. DRRIP set-dueling (64 leader sets, 10-bit PSEL) dynamically chooses between SRRIP (inserts at distant RRPV) and BRRIP (inserts at distant RRPV rarely, else near-MRU) to adapt to phase changes. A compact streaming detector tags sets with monotonic strides, and if a set is streaming for a sustained window, incoming lines are bypassed at insertion (not allocated in cache) unless SHiP predicts high reuse. This avoids pollution from streaming bursts (e.g., lbm, mcf) while retaining adaptive insertion for irregular workloads (astar, milc, omnetpp). The policy uses only 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, and 3b/set streaming detector, keeping metadata compact (<64KiB). By combining prediction source (PC signature), dynamic insertion depth, and selective bypass, SDSB aims to boost hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/008_02_ship_drrip_with_streaming_bypass__sdsb_t07.cc,0.517734426,0.517734426,0%
1872,milc,SHiP-DRRIP with Streaming Bypass (SDSB),"SDSB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth selection, and introduces a streaming-aware per-set bypass mechanism. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control-heavy or pointer-chasing workloads. DRRIP set-dueling (64 leader sets, 10-bit PSEL) dynamically chooses between SRRIP (inserts at distant RRPV) and BRRIP (inserts at distant RRPV rarely, else near-MRU) to adapt to phase changes. A compact streaming detector tags sets with monotonic strides, and if a set is streaming for a sustained window, incoming lines are bypassed at insertion (not allocated in cache) unless SHiP predicts high reuse. This avoids pollution from streaming bursts (e.g., lbm, mcf) while retaining adaptive insertion for irregular workloads (astar, milc, omnetpp). The policy uses only 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, and 3b/set streaming detector, keeping metadata compact (<64KiB). By combining prediction source (PC signature), dynamic insertion depth, and selective bypass, SDSB aims to boost hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/008_02_ship_drrip_with_streaming_bypass__sdsb_t07.cc,0.243964387,0.243964387,0%
1873,omnetpp,SHiP-DRRIP with Streaming Bypass (SDSB),"SDSB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth selection, and introduces a streaming-aware per-set bypass mechanism. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control-heavy or pointer-chasing workloads. DRRIP set-dueling (64 leader sets, 10-bit PSEL) dynamically chooses between SRRIP (inserts at distant RRPV) and BRRIP (inserts at distant RRPV rarely, else near-MRU) to adapt to phase changes. A compact streaming detector tags sets with monotonic strides, and if a set is streaming for a sustained window, incoming lines are bypassed at insertion (not allocated in cache) unless SHiP predicts high reuse. This avoids pollution from streaming bursts (e.g., lbm, mcf) while retaining adaptive insertion for irregular workloads (astar, milc, omnetpp). The policy uses only 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, and 3b/set streaming detector, keeping metadata compact (<64KiB). By combining prediction source (PC signature), dynamic insertion depth, and selective bypass, SDSB aims to boost hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/008_02_ship_drrip_with_streaming_bypass__sdsb_t07.cc,0.607810273,0.607810273,0%
1874,all,SHiP-DRRIP with Streaming Bypass (SDSB),"SDSB combines SHiP-lite’s PC-based reuse prediction with DRRIP’s dynamic insertion depth selection, and introduces a streaming-aware per-set bypass mechanism. SHiP-lite uses 6-bit PC signatures and a 2-bit outcome table to bias insertion depth for control-heavy or pointer-chasing workloads. DRRIP set-dueling (64 leader sets, 10-bit PSEL) dynamically chooses between SRRIP (inserts at distant RRPV) and BRRIP (inserts at distant RRPV rarely, else near-MRU) to adapt to phase changes. A compact streaming detector tags sets with monotonic strides, and if a set is streaming for a sustained window, incoming lines are bypassed at insertion (not allocated in cache) unless SHiP predicts high reuse. This avoids pollution from streaming bursts (e.g., lbm, mcf) while retaining adaptive insertion for irregular workloads (astar, milc, omnetpp). The policy uses only 2b RRPV/block, 6b signature/block, 2b outcome table/entry, 10b PSEL, 64 leader sets, and 3b/set streaming detector, keeping metadata compact (<64KiB). By combining prediction source (PC signature), dynamic insertion depth, and selective bypass, SDSB aims to boost hit rates across diverse access patterns.",,ChampSim_CRC2/new_policies/008_02_ship_drrip_with_streaming_bypass__sdsb_t07.cc,0.441655215,0.441655215,44%
1875,astar,SHiP-LIP with Lightweight Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion control (LIP/BIP) and augments it with a compact per-block dead-block counter that decays periodically. SHiP-lite (6-bit PC signatures, 2-bit outcome table) biases insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at MRU only 1/32 fills) to adapt to phase changes. Each cache block has a 2-bit dead-block counter incremented on eviction and decayed every N fills, approximating recency/frequency without tracking full reuse history. This mechanism helps identify blocks that are repeatedly evicted without reuse, allowing the policy to deprioritize them for insertion. By combining PC-based prediction, adaptive insertion depth, and dead-block approximation, SLD improves hit rates for both streaming and irregular workloads, while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_00_ship_lip_with_lightweight_dead_block_decay__sld_t02.cc,0.43900073,0.43900073,0%
1876,lbm,SHiP-LIP with Lightweight Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion control (LIP/BIP) and augments it with a compact per-block dead-block counter that decays periodically. SHiP-lite (6-bit PC signatures, 2-bit outcome table) biases insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at MRU only 1/32 fills) to adapt to phase changes. Each cache block has a 2-bit dead-block counter incremented on eviction and decayed every N fills, approximating recency/frequency without tracking full reuse history. This mechanism helps identify blocks that are repeatedly evicted without reuse, allowing the policy to deprioritize them for insertion. By combining PC-based prediction, adaptive insertion depth, and dead-block approximation, SLD improves hit rates for both streaming and irregular workloads, while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_00_ship_lip_with_lightweight_dead_block_decay__sld_t02.cc,0.235259719,0.235259719,0%
1877,mcf,SHiP-LIP with Lightweight Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion control (LIP/BIP) and augments it with a compact per-block dead-block counter that decays periodically. SHiP-lite (6-bit PC signatures, 2-bit outcome table) biases insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at MRU only 1/32 fills) to adapt to phase changes. Each cache block has a 2-bit dead-block counter incremented on eviction and decayed every N fills, approximating recency/frequency without tracking full reuse history. This mechanism helps identify blocks that are repeatedly evicted without reuse, allowing the policy to deprioritize them for insertion. By combining PC-based prediction, adaptive insertion depth, and dead-block approximation, SLD improves hit rates for both streaming and irregular workloads, while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_00_ship_lip_with_lightweight_dead_block_decay__sld_t02.cc,0.439999804,0.439999804,0%
1878,milc,SHiP-LIP with Lightweight Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion control (LIP/BIP) and augments it with a compact per-block dead-block counter that decays periodically. SHiP-lite (6-bit PC signatures, 2-bit outcome table) biases insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at MRU only 1/32 fills) to adapt to phase changes. Each cache block has a 2-bit dead-block counter incremented on eviction and decayed every N fills, approximating recency/frequency without tracking full reuse history. This mechanism helps identify blocks that are repeatedly evicted without reuse, allowing the policy to deprioritize them for insertion. By combining PC-based prediction, adaptive insertion depth, and dead-block approximation, SLD improves hit rates for both streaming and irregular workloads, while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_00_ship_lip_with_lightweight_dead_block_decay__sld_t02.cc,0.158444789,0.158444789,0%
1879,omnetpp,SHiP-LIP with Lightweight Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with DIP-style insertion control (LIP/BIP) and augments it with a compact per-block dead-block counter that decays periodically. SHiP-lite (6-bit PC signatures, 2-bit outcome table) biases insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at MRU only 1/32 fills) to adapt to phase changes. Each cache block has a 2-bit dead-block counter incremented on eviction and decayed every N fills, approximating recency/frequency without tracking full reuse history. This mechanism helps identify blocks that are repeatedly evicted without reuse, allowing the policy to deprioritize them for insertion. By combining PC-based prediction, adaptive insertion depth, and dead-block approximation, SLD improves hit rates for both streaming and irregular workloads, while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_00_ship_lip_with_lightweight_dead_block_decay__sld_t02.cc,0.388010737,0.388010737,0%
1880,astar,SHiP-LIP with Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy (LIP vs. BIP) and augments per-block dead-block approximation via tiny reuse counters that periodically decay. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at LRU rarely, else near-MRU) to adapt to streaming and irregular phases. Each cache block has a 2-bit reuse counter, incremented on hits and decayed every N fills, approximating dead blocks and boosting eviction accuracy for workloads with weak locality (e.g., mcf, omnetpp). By integrating PC-based prediction, dynamic insertion, and dead-block tracking, SLD improves hit rates across diverse patterns while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_01_ship_lip_with_dead_block_decay__sld_t04.cc,0.457971587,0.457971587,0%
1881,lbm,SHiP-LIP with Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy (LIP vs. BIP) and augments per-block dead-block approximation via tiny reuse counters that periodically decay. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at LRU rarely, else near-MRU) to adapt to streaming and irregular phases. Each cache block has a 2-bit reuse counter, incremented on hits and decayed every N fills, approximating dead blocks and boosting eviction accuracy for workloads with weak locality (e.g., mcf, omnetpp). By integrating PC-based prediction, dynamic insertion, and dead-block tracking, SLD improves hit rates across diverse patterns while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_01_ship_lip_with_dead_block_decay__sld_t04.cc,0.437591196,0.437591196,0%
1882,mcf,SHiP-LIP with Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy (LIP vs. BIP) and augments per-block dead-block approximation via tiny reuse counters that periodically decay. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at LRU rarely, else near-MRU) to adapt to streaming and irregular phases. Each cache block has a 2-bit reuse counter, incremented on hits and decayed every N fills, approximating dead blocks and boosting eviction accuracy for workloads with weak locality (e.g., mcf, omnetpp). By integrating PC-based prediction, dynamic insertion, and dead-block tracking, SLD improves hit rates across diverse patterns while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_01_ship_lip_with_dead_block_decay__sld_t04.cc,0.512980822,0.512980822,0%
1883,milc,SHiP-LIP with Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy (LIP vs. BIP) and augments per-block dead-block approximation via tiny reuse counters that periodically decay. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at LRU rarely, else near-MRU) to adapt to streaming and irregular phases. Each cache block has a 2-bit reuse counter, incremented on hits and decayed every N fills, approximating dead blocks and boosting eviction accuracy for workloads with weak locality (e.g., mcf, omnetpp). By integrating PC-based prediction, dynamic insertion, and dead-block tracking, SLD improves hit rates across diverse patterns while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_01_ship_lip_with_dead_block_decay__sld_t04.cc,0.321500467,0.321500467,0%
1884,omnetpp,SHiP-LIP with Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy (LIP vs. BIP) and augments per-block dead-block approximation via tiny reuse counters that periodically decay. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at LRU rarely, else near-MRU) to adapt to streaming and irregular phases. Each cache block has a 2-bit reuse counter, incremented on hits and decayed every N fills, approximating dead blocks and boosting eviction accuracy for workloads with weak locality (e.g., mcf, omnetpp). By integrating PC-based prediction, dynamic insertion, and dead-block tracking, SLD improves hit rates across diverse patterns while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_01_ship_lip_with_dead_block_decay__sld_t04.cc,0.570780968,0.570780968,0%
1885,astar,**SHiP-PC + DIP-LIP Hybrid with Lightweight Dead-Block Tracking (SPLD)**,"SPLD combines SHiP-lite’s PC-based reuse prediction with DIP set-dueling between LIP (always insert at LRU/distant) and BIP (insert at MRU only 1/32 fills, else LRU/distant), and introduces a compact per-block dead-block counter to further bias insertion for blocks with recent reuse history. SHiP-lite uses 6-bit PC signatures with 2-bit outcome counters to favor MRU insertion for PCs with proven reuse. DIP leader sets (32 LIP, 32 BIP, 10-bit PSEL) adapt to phase changes, selecting the best global insertion depth policy. A 2-bit dead-block counter per line (decayed periodically) tracks true reuse, allowing MRU bias for blocks with recent hits even if SHiP is uncertain. Streaming detection is omitted, relying on the DIP’s LIP/BIP logic and dead-block tracking to avoid pollution from streaming bursts and pointer-chasing. Metadata remains compact: 2b RRPV, 2b dead-block counter/line, 6b PC signature/line, 2b SHiP table/entry, 10b PSEL, 64 leader sets. By combining PC-based reuse, global insertion depth tuning, and per-line dead-block signals, SPLD improves hit rates across both regular/streaming and irregular workloads.",,ChampSim_CRC2/new_policies/009_02_ship_pc___dip_lip_hybrid_with_lightweight_dead_block_tracking__spld_t07.cc,0.363674538,0.363674538,0%
1886,lbm,**SHiP-PC + DIP-LIP Hybrid with Lightweight Dead-Block Tracking (SPLD)**,"SPLD combines SHiP-lite’s PC-based reuse prediction with DIP set-dueling between LIP (always insert at LRU/distant) and BIP (insert at MRU only 1/32 fills, else LRU/distant), and introduces a compact per-block dead-block counter to further bias insertion for blocks with recent reuse history. SHiP-lite uses 6-bit PC signatures with 2-bit outcome counters to favor MRU insertion for PCs with proven reuse. DIP leader sets (32 LIP, 32 BIP, 10-bit PSEL) adapt to phase changes, selecting the best global insertion depth policy. A 2-bit dead-block counter per line (decayed periodically) tracks true reuse, allowing MRU bias for blocks with recent hits even if SHiP is uncertain. Streaming detection is omitted, relying on the DIP’s LIP/BIP logic and dead-block tracking to avoid pollution from streaming bursts and pointer-chasing. Metadata remains compact: 2b RRPV, 2b dead-block counter/line, 6b PC signature/line, 2b SHiP table/entry, 10b PSEL, 64 leader sets. By combining PC-based reuse, global insertion depth tuning, and per-line dead-block signals, SPLD improves hit rates across both regular/streaming and irregular workloads.",,ChampSim_CRC2/new_policies/009_02_ship_pc___dip_lip_hybrid_with_lightweight_dead_block_tracking__spld_t07.cc,0.26832301,0.26832301,0%
1887,mcf,**SHiP-PC + DIP-LIP Hybrid with Lightweight Dead-Block Tracking (SPLD)**,"SPLD combines SHiP-lite’s PC-based reuse prediction with DIP set-dueling between LIP (always insert at LRU/distant) and BIP (insert at MRU only 1/32 fills, else LRU/distant), and introduces a compact per-block dead-block counter to further bias insertion for blocks with recent reuse history. SHiP-lite uses 6-bit PC signatures with 2-bit outcome counters to favor MRU insertion for PCs with proven reuse. DIP leader sets (32 LIP, 32 BIP, 10-bit PSEL) adapt to phase changes, selecting the best global insertion depth policy. A 2-bit dead-block counter per line (decayed periodically) tracks true reuse, allowing MRU bias for blocks with recent hits even if SHiP is uncertain. Streaming detection is omitted, relying on the DIP’s LIP/BIP logic and dead-block tracking to avoid pollution from streaming bursts and pointer-chasing. Metadata remains compact: 2b RRPV, 2b dead-block counter/line, 6b PC signature/line, 2b SHiP table/entry, 10b PSEL, 64 leader sets. By combining PC-based reuse, global insertion depth tuning, and per-line dead-block signals, SPLD improves hit rates across both regular/streaming and irregular workloads.",,ChampSim_CRC2/new_policies/009_02_ship_pc___dip_lip_hybrid_with_lightweight_dead_block_tracking__spld_t07.cc,0.433203086,0.433203086,0%
1888,milc,**SHiP-PC + DIP-LIP Hybrid with Lightweight Dead-Block Tracking (SPLD)**,"SPLD combines SHiP-lite’s PC-based reuse prediction with DIP set-dueling between LIP (always insert at LRU/distant) and BIP (insert at MRU only 1/32 fills, else LRU/distant), and introduces a compact per-block dead-block counter to further bias insertion for blocks with recent reuse history. SHiP-lite uses 6-bit PC signatures with 2-bit outcome counters to favor MRU insertion for PCs with proven reuse. DIP leader sets (32 LIP, 32 BIP, 10-bit PSEL) adapt to phase changes, selecting the best global insertion depth policy. A 2-bit dead-block counter per line (decayed periodically) tracks true reuse, allowing MRU bias for blocks with recent hits even if SHiP is uncertain. Streaming detection is omitted, relying on the DIP’s LIP/BIP logic and dead-block tracking to avoid pollution from streaming bursts and pointer-chasing. Metadata remains compact: 2b RRPV, 2b dead-block counter/line, 6b PC signature/line, 2b SHiP table/entry, 10b PSEL, 64 leader sets. By combining PC-based reuse, global insertion depth tuning, and per-line dead-block signals, SPLD improves hit rates across both regular/streaming and irregular workloads.",,ChampSim_CRC2/new_policies/009_02_ship_pc___dip_lip_hybrid_with_lightweight_dead_block_tracking__spld_t07.cc,0.172244871,0.172244871,0%
1889,omnetpp,**SHiP-PC + DIP-LIP Hybrid with Lightweight Dead-Block Tracking (SPLD)**,"SPLD combines SHiP-lite’s PC-based reuse prediction with DIP set-dueling between LIP (always insert at LRU/distant) and BIP (insert at MRU only 1/32 fills, else LRU/distant), and introduces a compact per-block dead-block counter to further bias insertion for blocks with recent reuse history. SHiP-lite uses 6-bit PC signatures with 2-bit outcome counters to favor MRU insertion for PCs with proven reuse. DIP leader sets (32 LIP, 32 BIP, 10-bit PSEL) adapt to phase changes, selecting the best global insertion depth policy. A 2-bit dead-block counter per line (decayed periodically) tracks true reuse, allowing MRU bias for blocks with recent hits even if SHiP is uncertain. Streaming detection is omitted, relying on the DIP’s LIP/BIP logic and dead-block tracking to avoid pollution from streaming bursts and pointer-chasing. Metadata remains compact: 2b RRPV, 2b dead-block counter/line, 6b PC signature/line, 2b SHiP table/entry, 10b PSEL, 64 leader sets. By combining PC-based reuse, global insertion depth tuning, and per-line dead-block signals, SPLD improves hit rates across both regular/streaming and irregular workloads.",,ChampSim_CRC2/new_policies/009_02_ship_pc___dip_lip_hybrid_with_lightweight_dead_block_tracking__spld_t07.cc,0.247409767,0.247409767,0%
1890,all,SHiP-LIP with Dead-Block Decay (SLD),"SLD combines SHiP-lite’s PC-based reuse prediction with a DIP-style insertion policy (LIP vs. BIP) and augments per-block dead-block approximation via tiny reuse counters that periodically decay. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads. DIP set-dueling (32 leader sets, 8-bit PSEL) dynamically chooses between LIP (insert at LRU) and BIP (insert at LRU rarely, else near-MRU) to adapt to streaming and irregular phases. Each cache block has a 2-bit reuse counter, incremented on hits and decayed every N fills, approximating dead blocks and boosting eviction accuracy for workloads with weak locality (e.g., mcf, omnetpp). By integrating PC-based prediction, dynamic insertion, and dead-block tracking, SLD improves hit rates across diverse patterns while keeping metadata compact (<64KiB).",,ChampSim_CRC2/new_policies/009_01_ship_lip_with_dead_block_decay__sld_t04.cc,0.460165008,0.460165008,46%
1891,astar,SHiP-Lite with Streaming Bypass and Adaptive Insertion (SLSBAI),"SLSBAI combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and adaptive insertion depth, targeting improved performance across diverse workloads. The streaming detector monitors address deltas per set to identify streaming or scan-like phases (e.g., in lbm, milc), and selectively bypasses or inserts blocks at distant RRPV when streaming is detected, reducing cache pollution. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads (e.g., astar, mcf, omnetpp). A DIP-style set-dueling mechanism (32 leader sets, 8-bit PSEL) dynamically chooses between LIP and BIP for non-streaming sets. This hybrid approach improves hit rates by avoiding pollution from streaming phases, leveraging PC-based prediction for irregular workloads, and adapting insertion depth to workload phase changes. All metadata fits within 64 KiB by using compact counters and per-set streaming bits.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_adaptive_insertion__slsbai_t02.cc,0.457913117,0.457913117,0%
1892,lbm,SHiP-Lite with Streaming Bypass and Adaptive Insertion (SLSBAI),"SLSBAI combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and adaptive insertion depth, targeting improved performance across diverse workloads. The streaming detector monitors address deltas per set to identify streaming or scan-like phases (e.g., in lbm, milc), and selectively bypasses or inserts blocks at distant RRPV when streaming is detected, reducing cache pollution. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads (e.g., astar, mcf, omnetpp). A DIP-style set-dueling mechanism (32 leader sets, 8-bit PSEL) dynamically chooses between LIP and BIP for non-streaming sets. This hybrid approach improves hit rates by avoiding pollution from streaming phases, leveraging PC-based prediction for irregular workloads, and adapting insertion depth to workload phase changes. All metadata fits within 64 KiB by using compact counters and per-set streaming bits.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_adaptive_insertion__slsbai_t02.cc,0.437591196,0.437591196,0%
1893,mcf,SHiP-Lite with Streaming Bypass and Adaptive Insertion (SLSBAI),"SLSBAI combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and adaptive insertion depth, targeting improved performance across diverse workloads. The streaming detector monitors address deltas per set to identify streaming or scan-like phases (e.g., in lbm, milc), and selectively bypasses or inserts blocks at distant RRPV when streaming is detected, reducing cache pollution. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads (e.g., astar, mcf, omnetpp). A DIP-style set-dueling mechanism (32 leader sets, 8-bit PSEL) dynamically chooses between LIP and BIP for non-streaming sets. This hybrid approach improves hit rates by avoiding pollution from streaming phases, leveraging PC-based prediction for irregular workloads, and adapting insertion depth to workload phase changes. All metadata fits within 64 KiB by using compact counters and per-set streaming bits.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_adaptive_insertion__slsbai_t02.cc,0.512980122,0.512980122,0%
1894,milc,SHiP-Lite with Streaming Bypass and Adaptive Insertion (SLSBAI),"SLSBAI combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and adaptive insertion depth, targeting improved performance across diverse workloads. The streaming detector monitors address deltas per set to identify streaming or scan-like phases (e.g., in lbm, milc), and selectively bypasses or inserts blocks at distant RRPV when streaming is detected, reducing cache pollution. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads (e.g., astar, mcf, omnetpp). A DIP-style set-dueling mechanism (32 leader sets, 8-bit PSEL) dynamically chooses between LIP and BIP for non-streaming sets. This hybrid approach improves hit rates by avoiding pollution from streaming phases, leveraging PC-based prediction for irregular workloads, and adapting insertion depth to workload phase changes. All metadata fits within 64 KiB by using compact counters and per-set streaming bits.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_adaptive_insertion__slsbai_t02.cc,0.321603655,0.321603655,0%
1895,omnetpp,SHiP-Lite with Streaming Bypass and Adaptive Insertion (SLSBAI),"SLSBAI combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and adaptive insertion depth, targeting improved performance across diverse workloads. The streaming detector monitors address deltas per set to identify streaming or scan-like phases (e.g., in lbm, milc), and selectively bypasses or inserts blocks at distant RRPV when streaming is detected, reducing cache pollution. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads (e.g., astar, mcf, omnetpp). A DIP-style set-dueling mechanism (32 leader sets, 8-bit PSEL) dynamically chooses between LIP and BIP for non-streaming sets. This hybrid approach improves hit rates by avoiding pollution from streaming phases, leveraging PC-based prediction for irregular workloads, and adapting insertion depth to workload phase changes. All metadata fits within 64 KiB by using compact counters and per-set streaming bits.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_adaptive_insertion__slsbai_t02.cc,0.570780968,0.570780968,0%
1896,astar,SRRIP-SD: Streaming-aware RRIP with SHiP-Lite and Dynamic Bypass,"SRRIP-SD combines SRRIP (Static RRIP) for robust recency-based replacement with SHiP-lite’s PC-based reuse prediction to bias insertion depth, and introduces a compact streaming detector that monitors per-set address deltas to identify streaming or scan-like access patterns. When streaming is detected, the policy dynamically bypasses cache insertion or inserts blocks at distant RRPV (max), minimizing pollution from non-reused lines (common in LBM, mcf, omnetpp). SHiP-lite (6-bit PC signatures, 2-bit outcome counters, 64-entry table) enables adaptive insertion for control-heavy or pointer-chasing workloads (astar, milc, omnetpp). The streaming detector uses a 2-bit saturating counter per set, incremented when monotonic address deltas are observed, and triggers bypass/insertion at RRPV=3 when the counter saturates. This hybrid approach improves hit rates by preventing cache pollution during streaming phases, while retaining adaptive insertion for irregular workloads. All metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/010_01_srrip_sd__streaming_aware_rrip_with_ship_lite_and_dynamic_bypass_t04.cc,0.447007576,0.447007576,0%
1897,lbm,SRRIP-SD: Streaming-aware RRIP with SHiP-Lite and Dynamic Bypass,"SRRIP-SD combines SRRIP (Static RRIP) for robust recency-based replacement with SHiP-lite’s PC-based reuse prediction to bias insertion depth, and introduces a compact streaming detector that monitors per-set address deltas to identify streaming or scan-like access patterns. When streaming is detected, the policy dynamically bypasses cache insertion or inserts blocks at distant RRPV (max), minimizing pollution from non-reused lines (common in LBM, mcf, omnetpp). SHiP-lite (6-bit PC signatures, 2-bit outcome counters, 64-entry table) enables adaptive insertion for control-heavy or pointer-chasing workloads (astar, milc, omnetpp). The streaming detector uses a 2-bit saturating counter per set, incremented when monotonic address deltas are observed, and triggers bypass/insertion at RRPV=3 when the counter saturates. This hybrid approach improves hit rates by preventing cache pollution during streaming phases, while retaining adaptive insertion for irregular workloads. All metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/010_01_srrip_sd__streaming_aware_rrip_with_ship_lite_and_dynamic_bypass_t04.cc,0.425501473,0.425501473,0%
1898,mcf,SRRIP-SD: Streaming-aware RRIP with SHiP-Lite and Dynamic Bypass,"SRRIP-SD combines SRRIP (Static RRIP) for robust recency-based replacement with SHiP-lite’s PC-based reuse prediction to bias insertion depth, and introduces a compact streaming detector that monitors per-set address deltas to identify streaming or scan-like access patterns. When streaming is detected, the policy dynamically bypasses cache insertion or inserts blocks at distant RRPV (max), minimizing pollution from non-reused lines (common in LBM, mcf, omnetpp). SHiP-lite (6-bit PC signatures, 2-bit outcome counters, 64-entry table) enables adaptive insertion for control-heavy or pointer-chasing workloads (astar, milc, omnetpp). The streaming detector uses a 2-bit saturating counter per set, incremented when monotonic address deltas are observed, and triggers bypass/insertion at RRPV=3 when the counter saturates. This hybrid approach improves hit rates by preventing cache pollution during streaming phases, while retaining adaptive insertion for irregular workloads. All metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/010_01_srrip_sd__streaming_aware_rrip_with_ship_lite_and_dynamic_bypass_t04.cc,0.474705522,0.474705522,0%
1899,milc,SRRIP-SD: Streaming-aware RRIP with SHiP-Lite and Dynamic Bypass,"SRRIP-SD combines SRRIP (Static RRIP) for robust recency-based replacement with SHiP-lite’s PC-based reuse prediction to bias insertion depth, and introduces a compact streaming detector that monitors per-set address deltas to identify streaming or scan-like access patterns. When streaming is detected, the policy dynamically bypasses cache insertion or inserts blocks at distant RRPV (max), minimizing pollution from non-reused lines (common in LBM, mcf, omnetpp). SHiP-lite (6-bit PC signatures, 2-bit outcome counters, 64-entry table) enables adaptive insertion for control-heavy or pointer-chasing workloads (astar, milc, omnetpp). The streaming detector uses a 2-bit saturating counter per set, incremented when monotonic address deltas are observed, and triggers bypass/insertion at RRPV=3 when the counter saturates. This hybrid approach improves hit rates by preventing cache pollution during streaming phases, while retaining adaptive insertion for irregular workloads. All metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/010_01_srrip_sd__streaming_aware_rrip_with_ship_lite_and_dynamic_bypass_t04.cc,0.315640456,0.315640456,0%
1900,omnetpp,SRRIP-SD: Streaming-aware RRIP with SHiP-Lite and Dynamic Bypass,"SRRIP-SD combines SRRIP (Static RRIP) for robust recency-based replacement with SHiP-lite’s PC-based reuse prediction to bias insertion depth, and introduces a compact streaming detector that monitors per-set address deltas to identify streaming or scan-like access patterns. When streaming is detected, the policy dynamically bypasses cache insertion or inserts blocks at distant RRPV (max), minimizing pollution from non-reused lines (common in LBM, mcf, omnetpp). SHiP-lite (6-bit PC signatures, 2-bit outcome counters, 64-entry table) enables adaptive insertion for control-heavy or pointer-chasing workloads (astar, milc, omnetpp). The streaming detector uses a 2-bit saturating counter per set, incremented when monotonic address deltas are observed, and triggers bypass/insertion at RRPV=3 when the counter saturates. This hybrid approach improves hit rates by preventing cache pollution during streaming phases, while retaining adaptive insertion for irregular workloads. All metadata fits comfortably within 64 KiB.",,ChampSim_CRC2/new_policies/010_01_srrip_sd__streaming_aware_rrip_with_ship_lite_and_dynamic_bypass_t04.cc,0.611001426,0.611001426,0%
1901,astar,SHiP-Lite with Streaming Bypass and DRRIP (SLB-D),"SLB-D combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and DRRIP-style dynamic insertion depth control. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-flow and pointer-chasing accesses. A per-set streaming detector monitors recent address deltas to identify streaming phases: if near-monotonic, the policy bypasses the LLC for such blocks, preventing cache pollution by streaming or scan workloads (e.g., lbm), while retaining capacity for high-reuse phases (e.g., astar, milc). DRRIP employs set-dueling with 32 leader sets and a 10-bit PSEL to adapt between SRRIP (stable) and BRRIP (rare MRU) insertion, optimizing for both temporal and spatial locality. All metadata fits within 64 KiB, and this hybrid approach dynamically protects reusable lines while aggressively filtering out dead-on-arrival blocks—especially improving performance on streaming, irregular, and phase-changing workloads.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_bypass_and_drrip__slb_d_t07.cc,0.446740032,0.446740032,0%
1902,lbm,SHiP-Lite with Streaming Bypass and DRRIP (SLB-D),"SLB-D combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and DRRIP-style dynamic insertion depth control. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-flow and pointer-chasing accesses. A per-set streaming detector monitors recent address deltas to identify streaming phases: if near-monotonic, the policy bypasses the LLC for such blocks, preventing cache pollution by streaming or scan workloads (e.g., lbm), while retaining capacity for high-reuse phases (e.g., astar, milc). DRRIP employs set-dueling with 32 leader sets and a 10-bit PSEL to adapt between SRRIP (stable) and BRRIP (rare MRU) insertion, optimizing for both temporal and spatial locality. All metadata fits within 64 KiB, and this hybrid approach dynamically protects reusable lines while aggressively filtering out dead-on-arrival blocks—especially improving performance on streaming, irregular, and phase-changing workloads.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_bypass_and_drrip__slb_d_t07.cc,0.425509607,0.425509607,0%
1903,mcf,SHiP-Lite with Streaming Bypass and DRRIP (SLB-D),"SLB-D combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and DRRIP-style dynamic insertion depth control. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-flow and pointer-chasing accesses. A per-set streaming detector monitors recent address deltas to identify streaming phases: if near-monotonic, the policy bypasses the LLC for such blocks, preventing cache pollution by streaming or scan workloads (e.g., lbm), while retaining capacity for high-reuse phases (e.g., astar, milc). DRRIP employs set-dueling with 32 leader sets and a 10-bit PSEL to adapt between SRRIP (stable) and BRRIP (rare MRU) insertion, optimizing for both temporal and spatial locality. All metadata fits within 64 KiB, and this hybrid approach dynamically protects reusable lines while aggressively filtering out dead-on-arrival blocks—especially improving performance on streaming, irregular, and phase-changing workloads.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_bypass_and_drrip__slb_d_t07.cc,0.474659252,0.474659252,0%
1904,milc,SHiP-Lite with Streaming Bypass and DRRIP (SLB-D),"SLB-D combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and DRRIP-style dynamic insertion depth control. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-flow and pointer-chasing accesses. A per-set streaming detector monitors recent address deltas to identify streaming phases: if near-monotonic, the policy bypasses the LLC for such blocks, preventing cache pollution by streaming or scan workloads (e.g., lbm), while retaining capacity for high-reuse phases (e.g., astar, milc). DRRIP employs set-dueling with 32 leader sets and a 10-bit PSEL to adapt between SRRIP (stable) and BRRIP (rare MRU) insertion, optimizing for both temporal and spatial locality. All metadata fits within 64 KiB, and this hybrid approach dynamically protects reusable lines while aggressively filtering out dead-on-arrival blocks—especially improving performance on streaming, irregular, and phase-changing workloads.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_bypass_and_drrip__slb_d_t07.cc,0.315730972,0.315730972,0%
1905,omnetpp,SHiP-Lite with Streaming Bypass and DRRIP (SLB-D),"SLB-D combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and DRRIP-style dynamic insertion depth control. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-flow and pointer-chasing accesses. A per-set streaming detector monitors recent address deltas to identify streaming phases: if near-monotonic, the policy bypasses the LLC for such blocks, preventing cache pollution by streaming or scan workloads (e.g., lbm), while retaining capacity for high-reuse phases (e.g., astar, milc). DRRIP employs set-dueling with 32 leader sets and a 10-bit PSEL to adapt between SRRIP (stable) and BRRIP (rare MRU) insertion, optimizing for both temporal and spatial locality. All metadata fits within 64 KiB, and this hybrid approach dynamically protects reusable lines while aggressively filtering out dead-on-arrival blocks—especially improving performance on streaming, irregular, and phase-changing workloads.",,ChampSim_CRC2/new_policies/010_02_ship_lite_with_streaming_bypass_and_drrip__slb_d_t07.cc,0.611353347,0.611353347,0%
1906,all,SHiP-Lite with Streaming Bypass and Adaptive Insertion (SLSBAI),"SLSBAI combines SHiP-lite’s PC-based reuse prediction with a lightweight streaming detector and adaptive insertion depth, targeting improved performance across diverse workloads. The streaming detector monitors address deltas per set to identify streaming or scan-like phases (e.g., in lbm, milc), and selectively bypasses or inserts blocks at distant RRPV when streaming is detected, reducing cache pollution. SHiP-lite tracks 6-bit PC signatures and 2-bit outcome counters to bias insertion depth for control-heavy or pointer-chasing workloads (e.g., astar, mcf, omnetpp). A DIP-style set-dueling mechanism (32 leader sets, 8-bit PSEL) dynamically chooses between LIP and BIP for non-streaming sets. This hybrid approach improves hit rates by avoiding pollution from streaming phases, leveraging PC-based prediction for irregular workloads, and adapting insertion depth to workload phase changes. All metadata fits within 64 KiB by using compact counters and per-set streaming bits.",,ChampSim_CRC2/new_policies/010_00_ship_lite_with_streaming_bypass_and_adaptive_insertion__slsbai_t02.cc,0.460173812,0.460173812,46%
1907,astar,DBI-DRRIP: Dead-Block Informed Dynamic RRIP,"DBI-DRRIP combines Dynamic RRIP (SRRIP vs BRRIP, set-dueling, 10-bit PSEL) with a compact per-line dead-block approximation to guide insertion depth. Each cache line maintains a 2-bit reuse counter, incremented on hits and periodically decayed, providing a lightweight estimate of block ""liveness."" On fills, lines predicted dead (counter=0) are inserted at distant RRPV (LRU), while lines with recent reuse (counter>0) are inserted at MRU or intermediate RRPV, depending on the current DRRIP winner. This approach adapts to both streaming and irregular workloads: streaming phases naturally decay counters, causing aggressive eviction, while pointer-chasing or control-heavy phases retain reused blocks longer. The policy requires only 2 bits per line for dead-block tracking and leverages DRRIP's robust phase adaptation, fitting comfortably within 64 KiB metadata. By directly informing insertion depth with per-line reuse history, DBI-DRRIP improves hit rates across diverse access patterns and mitigates cache pollution from dead or streaming blocks.",,ChampSim_CRC2/new_policies/011_00_dbi_drrip__dead_block_informed_dynamic_rrip_t02.cc,0.279514947,0.279514947,0%
1908,lbm,DBI-DRRIP: Dead-Block Informed Dynamic RRIP,"DBI-DRRIP combines Dynamic RRIP (SRRIP vs BRRIP, set-dueling, 10-bit PSEL) with a compact per-line dead-block approximation to guide insertion depth. Each cache line maintains a 2-bit reuse counter, incremented on hits and periodically decayed, providing a lightweight estimate of block ""liveness."" On fills, lines predicted dead (counter=0) are inserted at distant RRPV (LRU), while lines with recent reuse (counter>0) are inserted at MRU or intermediate RRPV, depending on the current DRRIP winner. This approach adapts to both streaming and irregular workloads: streaming phases naturally decay counters, causing aggressive eviction, while pointer-chasing or control-heavy phases retain reused blocks longer. The policy requires only 2 bits per line for dead-block tracking and leverages DRRIP's robust phase adaptation, fitting comfortably within 64 KiB metadata. By directly informing insertion depth with per-line reuse history, DBI-DRRIP improves hit rates across diverse access patterns and mitigates cache pollution from dead or streaming blocks.",,ChampSim_CRC2/new_policies/011_00_dbi_drrip__dead_block_informed_dynamic_rrip_t02.cc,0.087192017,0.087192017,0%
1909,mcf,DBI-DRRIP: Dead-Block Informed Dynamic RRIP,"DBI-DRRIP combines Dynamic RRIP (SRRIP vs BRRIP, set-dueling, 10-bit PSEL) with a compact per-line dead-block approximation to guide insertion depth. Each cache line maintains a 2-bit reuse counter, incremented on hits and periodically decayed, providing a lightweight estimate of block ""liveness."" On fills, lines predicted dead (counter=0) are inserted at distant RRPV (LRU), while lines with recent reuse (counter>0) are inserted at MRU or intermediate RRPV, depending on the current DRRIP winner. This approach adapts to both streaming and irregular workloads: streaming phases naturally decay counters, causing aggressive eviction, while pointer-chasing or control-heavy phases retain reused blocks longer. The policy requires only 2 bits per line for dead-block tracking and leverages DRRIP's robust phase adaptation, fitting comfortably within 64 KiB metadata. By directly informing insertion depth with per-line reuse history, DBI-DRRIP improves hit rates across diverse access patterns and mitigates cache pollution from dead or streaming blocks.",,ChampSim_CRC2/new_policies/011_00_dbi_drrip__dead_block_informed_dynamic_rrip_t02.cc,0.471048357,0.471048357,0%
1910,milc,DBI-DRRIP: Dead-Block Informed Dynamic RRIP,"DBI-DRRIP combines Dynamic RRIP (SRRIP vs BRRIP, set-dueling, 10-bit PSEL) with a compact per-line dead-block approximation to guide insertion depth. Each cache line maintains a 2-bit reuse counter, incremented on hits and periodically decayed, providing a lightweight estimate of block ""liveness."" On fills, lines predicted dead (counter=0) are inserted at distant RRPV (LRU), while lines with recent reuse (counter>0) are inserted at MRU or intermediate RRPV, depending on the current DRRIP winner. This approach adapts to both streaming and irregular workloads: streaming phases naturally decay counters, causing aggressive eviction, while pointer-chasing or control-heavy phases retain reused blocks longer. The policy requires only 2 bits per line for dead-block tracking and leverages DRRIP's robust phase adaptation, fitting comfortably within 64 KiB metadata. By directly informing insertion depth with per-line reuse history, DBI-DRRIP improves hit rates across diverse access patterns and mitigates cache pollution from dead or streaming blocks.",,ChampSim_CRC2/new_policies/011_00_dbi_drrip__dead_block_informed_dynamic_rrip_t02.cc,0.104223843,0.104223843,0%
1911,omnetpp,DBI-DRRIP: Dead-Block Informed Dynamic RRIP,"DBI-DRRIP combines Dynamic RRIP (SRRIP vs BRRIP, set-dueling, 10-bit PSEL) with a compact per-line dead-block approximation to guide insertion depth. Each cache line maintains a 2-bit reuse counter, incremented on hits and periodically decayed, providing a lightweight estimate of block ""liveness."" On fills, lines predicted dead (counter=0) are inserted at distant RRPV (LRU), while lines with recent reuse (counter>0) are inserted at MRU or intermediate RRPV, depending on the current DRRIP winner. This approach adapts to both streaming and irregular workloads: streaming phases naturally decay counters, causing aggressive eviction, while pointer-chasing or control-heavy phases retain reused blocks longer. The policy requires only 2 bits per line for dead-block tracking and leverages DRRIP's robust phase adaptation, fitting comfortably within 64 KiB metadata. By directly informing insertion depth with per-line reuse history, DBI-DRRIP improves hit rates across diverse access patterns and mitigates cache pollution from dead or streaming blocks.",,ChampSim_CRC2/new_policies/011_00_dbi_drrip__dead_block_informed_dynamic_rrip_t02.cc,0.582877525,0.582877525,0%
1912,astar,Dead-block Guided RRIP with Streaming Bypass (DBG-RS),"DBG-RS combines a per-block dead-block approximation (tiny reuse counters) with RRIP and a lightweight streaming detector to dynamically adapt insertion and bypass decisions. Each cache line tracks a 2-bit reuse counter, which is periodically decayed to approximate deadness: blocks with low reuse are inserted at distant RRPV or bypassed, while blocks with high reuse are inserted at MRU. The streaming detector uses per-set address deltas and a 2-bit confidence counter to identify scan-like phases; sets in streaming mode bypass fills to minimize pollution. This approach improves performance by explicitly biasing insertion toward lines with demonstrated reuse, aggressively filtering out dead and streaming data, and adapting to phase changes in workload behavior. Metadata is compact: 2 bits/block for RRIP, 2 bits/block for reuse counter, 1 bit/set for streaming flag, and 2 bits/set for streaming confidence, totaling well under 64 KiB.",,ChampSim_CRC2/new_policies/011_01_dead_block_guided_rrip_with_streaming_bypass__dbg_rs_t04.cc,0.079874449,0.079874449,0%
1913,lbm,Dead-block Guided RRIP with Streaming Bypass (DBG-RS),"DBG-RS combines a per-block dead-block approximation (tiny reuse counters) with RRIP and a lightweight streaming detector to dynamically adapt insertion and bypass decisions. Each cache line tracks a 2-bit reuse counter, which is periodically decayed to approximate deadness: blocks with low reuse are inserted at distant RRPV or bypassed, while blocks with high reuse are inserted at MRU. The streaming detector uses per-set address deltas and a 2-bit confidence counter to identify scan-like phases; sets in streaming mode bypass fills to minimize pollution. This approach improves performance by explicitly biasing insertion toward lines with demonstrated reuse, aggressively filtering out dead and streaming data, and adapting to phase changes in workload behavior. Metadata is compact: 2 bits/block for RRIP, 2 bits/block for reuse counter, 1 bit/set for streaming flag, and 2 bits/set for streaming confidence, totaling well under 64 KiB.",,ChampSim_CRC2/new_policies/011_01_dead_block_guided_rrip_with_streaming_bypass__dbg_rs_t04.cc,0.070846352,0.070846352,0%
1914,mcf,Dead-block Guided RRIP with Streaming Bypass (DBG-RS),"DBG-RS combines a per-block dead-block approximation (tiny reuse counters) with RRIP and a lightweight streaming detector to dynamically adapt insertion and bypass decisions. Each cache line tracks a 2-bit reuse counter, which is periodically decayed to approximate deadness: blocks with low reuse are inserted at distant RRPV or bypassed, while blocks with high reuse are inserted at MRU. The streaming detector uses per-set address deltas and a 2-bit confidence counter to identify scan-like phases; sets in streaming mode bypass fills to minimize pollution. This approach improves performance by explicitly biasing insertion toward lines with demonstrated reuse, aggressively filtering out dead and streaming data, and adapting to phase changes in workload behavior. Metadata is compact: 2 bits/block for RRIP, 2 bits/block for reuse counter, 1 bit/set for streaming flag, and 2 bits/set for streaming confidence, totaling well under 64 KiB.",,ChampSim_CRC2/new_policies/011_01_dead_block_guided_rrip_with_streaming_bypass__dbg_rs_t04.cc,0.275264378,0.275264378,0%
1915,milc,Dead-block Guided RRIP with Streaming Bypass (DBG-RS),"DBG-RS combines a per-block dead-block approximation (tiny reuse counters) with RRIP and a lightweight streaming detector to dynamically adapt insertion and bypass decisions. Each cache line tracks a 2-bit reuse counter, which is periodically decayed to approximate deadness: blocks with low reuse are inserted at distant RRPV or bypassed, while blocks with high reuse are inserted at MRU. The streaming detector uses per-set address deltas and a 2-bit confidence counter to identify scan-like phases; sets in streaming mode bypass fills to minimize pollution. This approach improves performance by explicitly biasing insertion toward lines with demonstrated reuse, aggressively filtering out dead and streaming data, and adapting to phase changes in workload behavior. Metadata is compact: 2 bits/block for RRIP, 2 bits/block for reuse counter, 1 bit/set for streaming flag, and 2 bits/set for streaming confidence, totaling well under 64 KiB.",,ChampSim_CRC2/new_policies/011_01_dead_block_guided_rrip_with_streaming_bypass__dbg_rs_t04.cc,0.01108279,0.01108279,0%
1916,omnetpp,Dead-block Guided RRIP with Streaming Bypass (DBG-RS),"DBG-RS combines a per-block dead-block approximation (tiny reuse counters) with RRIP and a lightweight streaming detector to dynamically adapt insertion and bypass decisions. Each cache line tracks a 2-bit reuse counter, which is periodically decayed to approximate deadness: blocks with low reuse are inserted at distant RRPV or bypassed, while blocks with high reuse are inserted at MRU. The streaming detector uses per-set address deltas and a 2-bit confidence counter to identify scan-like phases; sets in streaming mode bypass fills to minimize pollution. This approach improves performance by explicitly biasing insertion toward lines with demonstrated reuse, aggressively filtering out dead and streaming data, and adapting to phase changes in workload behavior. Metadata is compact: 2 bits/block for RRIP, 2 bits/block for reuse counter, 1 bit/set for streaming flag, and 2 bits/set for streaming confidence, totaling well under 64 KiB.",,ChampSim_CRC2/new_policies/011_01_dead_block_guided_rrip_with_streaming_bypass__dbg_rs_t04.cc,0.107635596,0.107635596,0%
1917,astar,Hybrid Dead-Block and Streaming-Aware PC Predictor (HDSAP),"HDSAP combines a line-level dead-block predictor with a lightweight streaming set detector and a compact PC-based reuse filter to adapt cache insertion and replacement decisions dynamically. Each cache line maintains a tiny 2-bit reuse counter that estimates ""deadness"" and resets upon access, decaying periodically to reflect changing locality. Streaming sets are detected via monotonic address deltas and trigger aggressive bypass or LRU insertion to minimize pollution from scan-like phases (e.g., lbm, milc). For control and pointer-heavy workloads (e.g., astar, mcf, omnetpp), the policy leverages a 4-bit PC signature table with 2-bit reuse counters to bias insertion toward MRU when recent PCs have high reuse. Set-dueling between SRRIP and BRRIP (with 64 leader sets and a 10-bit PSEL) further adapts to workload phase changes. This composition improves performance by quickly evicting dead lines, avoiding scan pollution, and exploiting control-flow locality, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/011_02_hybrid_dead_block_and_streaming_aware_pc_predictor__hdsap_t07.cc,0.442541709,0.442541709,0%
1918,lbm,Hybrid Dead-Block and Streaming-Aware PC Predictor (HDSAP),"HDSAP combines a line-level dead-block predictor with a lightweight streaming set detector and a compact PC-based reuse filter to adapt cache insertion and replacement decisions dynamically. Each cache line maintains a tiny 2-bit reuse counter that estimates ""deadness"" and resets upon access, decaying periodically to reflect changing locality. Streaming sets are detected via monotonic address deltas and trigger aggressive bypass or LRU insertion to minimize pollution from scan-like phases (e.g., lbm, milc). For control and pointer-heavy workloads (e.g., astar, mcf, omnetpp), the policy leverages a 4-bit PC signature table with 2-bit reuse counters to bias insertion toward MRU when recent PCs have high reuse. Set-dueling between SRRIP and BRRIP (with 64 leader sets and a 10-bit PSEL) further adapts to workload phase changes. This composition improves performance by quickly evicting dead lines, avoiding scan pollution, and exploiting control-flow locality, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/011_02_hybrid_dead_block_and_streaming_aware_pc_predictor__hdsap_t07.cc,0.420144323,0.420144323,0%
1919,mcf,Hybrid Dead-Block and Streaming-Aware PC Predictor (HDSAP),"HDSAP combines a line-level dead-block predictor with a lightweight streaming set detector and a compact PC-based reuse filter to adapt cache insertion and replacement decisions dynamically. Each cache line maintains a tiny 2-bit reuse counter that estimates ""deadness"" and resets upon access, decaying periodically to reflect changing locality. Streaming sets are detected via monotonic address deltas and trigger aggressive bypass or LRU insertion to minimize pollution from scan-like phases (e.g., lbm, milc). For control and pointer-heavy workloads (e.g., astar, mcf, omnetpp), the policy leverages a 4-bit PC signature table with 2-bit reuse counters to bias insertion toward MRU when recent PCs have high reuse. Set-dueling between SRRIP and BRRIP (with 64 leader sets and a 10-bit PSEL) further adapts to workload phase changes. This composition improves performance by quickly evicting dead lines, avoiding scan pollution, and exploiting control-flow locality, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/011_02_hybrid_dead_block_and_streaming_aware_pc_predictor__hdsap_t07.cc,0.514984855,0.514984855,0%
1920,milc,Hybrid Dead-Block and Streaming-Aware PC Predictor (HDSAP),"HDSAP combines a line-level dead-block predictor with a lightweight streaming set detector and a compact PC-based reuse filter to adapt cache insertion and replacement decisions dynamically. Each cache line maintains a tiny 2-bit reuse counter that estimates ""deadness"" and resets upon access, decaying periodically to reflect changing locality. Streaming sets are detected via monotonic address deltas and trigger aggressive bypass or LRU insertion to minimize pollution from scan-like phases (e.g., lbm, milc). For control and pointer-heavy workloads (e.g., astar, mcf, omnetpp), the policy leverages a 4-bit PC signature table with 2-bit reuse counters to bias insertion toward MRU when recent PCs have high reuse. Set-dueling between SRRIP and BRRIP (with 64 leader sets and a 10-bit PSEL) further adapts to workload phase changes. This composition improves performance by quickly evicting dead lines, avoiding scan pollution, and exploiting control-flow locality, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/011_02_hybrid_dead_block_and_streaming_aware_pc_predictor__hdsap_t07.cc,0.243879302,0.243879302,0%
1921,omnetpp,Hybrid Dead-Block and Streaming-Aware PC Predictor (HDSAP),"HDSAP combines a line-level dead-block predictor with a lightweight streaming set detector and a compact PC-based reuse filter to adapt cache insertion and replacement decisions dynamically. Each cache line maintains a tiny 2-bit reuse counter that estimates ""deadness"" and resets upon access, decaying periodically to reflect changing locality. Streaming sets are detected via monotonic address deltas and trigger aggressive bypass or LRU insertion to minimize pollution from scan-like phases (e.g., lbm, milc). For control and pointer-heavy workloads (e.g., astar, mcf, omnetpp), the policy leverages a 4-bit PC signature table with 2-bit reuse counters to bias insertion toward MRU when recent PCs have high reuse. Set-dueling between SRRIP and BRRIP (with 64 leader sets and a 10-bit PSEL) further adapts to workload phase changes. This composition improves performance by quickly evicting dead lines, avoiding scan pollution, and exploiting control-flow locality, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/011_02_hybrid_dead_block_and_streaming_aware_pc_predictor__hdsap_t07.cc,0.607679048,0.607679048,0%
1922,all,Hybrid Dead-Block and Streaming-Aware PC Predictor (HDSAP),"HDSAP combines a line-level dead-block predictor with a lightweight streaming set detector and a compact PC-based reuse filter to adapt cache insertion and replacement decisions dynamically. Each cache line maintains a tiny 2-bit reuse counter that estimates ""deadness"" and resets upon access, decaying periodically to reflect changing locality. Streaming sets are detected via monotonic address deltas and trigger aggressive bypass or LRU insertion to minimize pollution from scan-like phases (e.g., lbm, milc). For control and pointer-heavy workloads (e.g., astar, mcf, omnetpp), the policy leverages a 4-bit PC signature table with 2-bit reuse counters to bias insertion toward MRU when recent PCs have high reuse. Set-dueling between SRRIP and BRRIP (with 64 leader sets and a 10-bit PSEL) further adapts to workload phase changes. This composition improves performance by quickly evicting dead lines, avoiding scan pollution, and exploiting control-flow locality, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/011_02_hybrid_dead_block_and_streaming_aware_pc_predictor__hdsap_t07.cc,0.445845847,0.445845847,45%
1923,astar,SHiP-Lite Streaming-Bypass with Dynamic Insertion Policy (SLSB-DIP),"SLSB-DIP combines a compact SHiP-lite PC-based reuse predictor with a streaming detector and DIP-style insertion depth control. Each cache line tracks a 4-bit PC signature, and a global table of 32 entries (2 bits each) records recent reuse outcomes for PCs. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). For control/pointer-heavy workloads (e.g., astar, mcf, omnetpp), the SHiP-lite predictor biases insertion toward MRU if the PC shows frequent reuse. DIP-style set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) dynamically selects between inserting at LRU (LIP) or BIP (insert at MRU rarely) for non-streaming, non-reused lines, adapting to workload phase changes. This design improves performance by avoiding scan pollution, exploiting control-flow locality, and dynamically tuning insertion depth, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/012_00_ship_lite_streaming_bypass_with_dynamic_insertion_policy__slsb_dip_t02.cc,0.215200605,0.215200605,0%
1924,lbm,SHiP-Lite Streaming-Bypass with Dynamic Insertion Policy (SLSB-DIP),"SLSB-DIP combines a compact SHiP-lite PC-based reuse predictor with a streaming detector and DIP-style insertion depth control. Each cache line tracks a 4-bit PC signature, and a global table of 32 entries (2 bits each) records recent reuse outcomes for PCs. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). For control/pointer-heavy workloads (e.g., astar, mcf, omnetpp), the SHiP-lite predictor biases insertion toward MRU if the PC shows frequent reuse. DIP-style set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) dynamically selects between inserting at LRU (LIP) or BIP (insert at MRU rarely) for non-streaming, non-reused lines, adapting to workload phase changes. This design improves performance by avoiding scan pollution, exploiting control-flow locality, and dynamically tuning insertion depth, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/012_00_ship_lite_streaming_bypass_with_dynamic_insertion_policy__slsb_dip_t02.cc,0.096050886,0.096050886,0%
1925,mcf,SHiP-Lite Streaming-Bypass with Dynamic Insertion Policy (SLSB-DIP),"SLSB-DIP combines a compact SHiP-lite PC-based reuse predictor with a streaming detector and DIP-style insertion depth control. Each cache line tracks a 4-bit PC signature, and a global table of 32 entries (2 bits each) records recent reuse outcomes for PCs. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). For control/pointer-heavy workloads (e.g., astar, mcf, omnetpp), the SHiP-lite predictor biases insertion toward MRU if the PC shows frequent reuse. DIP-style set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) dynamically selects between inserting at LRU (LIP) or BIP (insert at MRU rarely) for non-streaming, non-reused lines, adapting to workload phase changes. This design improves performance by avoiding scan pollution, exploiting control-flow locality, and dynamically tuning insertion depth, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/012_00_ship_lite_streaming_bypass_with_dynamic_insertion_policy__slsb_dip_t02.cc,0.46505408,0.46505408,0%
1926,milc,SHiP-Lite Streaming-Bypass with Dynamic Insertion Policy (SLSB-DIP),"SLSB-DIP combines a compact SHiP-lite PC-based reuse predictor with a streaming detector and DIP-style insertion depth control. Each cache line tracks a 4-bit PC signature, and a global table of 32 entries (2 bits each) records recent reuse outcomes for PCs. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). For control/pointer-heavy workloads (e.g., astar, mcf, omnetpp), the SHiP-lite predictor biases insertion toward MRU if the PC shows frequent reuse. DIP-style set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) dynamically selects between inserting at LRU (LIP) or BIP (insert at MRU rarely) for non-streaming, non-reused lines, adapting to workload phase changes. This design improves performance by avoiding scan pollution, exploiting control-flow locality, and dynamically tuning insertion depth, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/012_00_ship_lite_streaming_bypass_with_dynamic_insertion_policy__slsb_dip_t02.cc,0.016122725,0.016122725,0%
1927,omnetpp,SHiP-Lite Streaming-Bypass with Dynamic Insertion Policy (SLSB-DIP),"SLSB-DIP combines a compact SHiP-lite PC-based reuse predictor with a streaming detector and DIP-style insertion depth control. Each cache line tracks a 4-bit PC signature, and a global table of 32 entries (2 bits each) records recent reuse outcomes for PCs. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). For control/pointer-heavy workloads (e.g., astar, mcf, omnetpp), the SHiP-lite predictor biases insertion toward MRU if the PC shows frequent reuse. DIP-style set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) dynamically selects between inserting at LRU (LIP) or BIP (insert at MRU rarely) for non-streaming, non-reused lines, adapting to workload phase changes. This design improves performance by avoiding scan pollution, exploiting control-flow locality, and dynamically tuning insertion depth, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/012_00_ship_lite_streaming_bypass_with_dynamic_insertion_policy__slsb_dip_t02.cc,0.058013719,0.058013719,0%
1928,all,SHiP-Lite Streaming-Bypass with Dynamic Insertion Policy (SLSB-DIP),"SLSB-DIP combines a compact SHiP-lite PC-based reuse predictor with a streaming detector and DIP-style insertion depth control. Each cache line tracks a 4-bit PC signature, and a global table of 32 entries (2 bits each) records recent reuse outcomes for PCs. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). For control/pointer-heavy workloads (e.g., astar, mcf, omnetpp), the SHiP-lite predictor biases insertion toward MRU if the PC shows frequent reuse. DIP-style set-dueling (32 leader sets for LIP/BIP, 10-bit PSEL) dynamically selects between inserting at LRU (LIP) or BIP (insert at MRU rarely) for non-streaming, non-reused lines, adapting to workload phase changes. This design improves performance by avoiding scan pollution, exploiting control-flow locality, and dynamically tuning insertion depth, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/012_00_ship_lite_streaming_bypass_with_dynamic_insertion_policy__slsb_dip_t02.cc,0.170088403,0.170088403,17%
1929,astar,Hybrid Dead-Block SRRIP with Streaming Bypass (HDB-SRRIP-SB),"HDB-SRRIP-SB combines a compact per-line dead-block counter (DBC) with SRRIP set-dueling and a streaming detector for adaptive bypass. Each cache line tracks a 2-bit DBC that increments on eviction without reuse and decays periodically, approximating dead-block likelihood. SRRIP set-dueling (32 leader sets, 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for non-streaming sets. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). On fill, lines with high DBC are inserted at distant RRPV to evict likely dead blocks quickly, while lines with low DBC are inserted at MRU. This hybrid approach improves performance by aggressively evicting dead blocks, adapting insertion depth to workload phase changes, and avoiding scan pollution, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/013_00_hybrid_dead_block_srrip_with_streaming_bypass__hdb_srrip_sb_t02.cc,0.454947094,0.454947094,0%
1930,lbm,Hybrid Dead-Block SRRIP with Streaming Bypass (HDB-SRRIP-SB),"HDB-SRRIP-SB combines a compact per-line dead-block counter (DBC) with SRRIP set-dueling and a streaming detector for adaptive bypass. Each cache line tracks a 2-bit DBC that increments on eviction without reuse and decays periodically, approximating dead-block likelihood. SRRIP set-dueling (32 leader sets, 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for non-streaming sets. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). On fill, lines with high DBC are inserted at distant RRPV to evict likely dead blocks quickly, while lines with low DBC are inserted at MRU. This hybrid approach improves performance by aggressively evicting dead blocks, adapting insertion depth to workload phase changes, and avoiding scan pollution, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/013_00_hybrid_dead_block_srrip_with_streaming_bypass__hdb_srrip_sb_t02.cc,0.43992869,0.43992869,0%
1931,mcf,Hybrid Dead-Block SRRIP with Streaming Bypass (HDB-SRRIP-SB),"HDB-SRRIP-SB combines a compact per-line dead-block counter (DBC) with SRRIP set-dueling and a streaming detector for adaptive bypass. Each cache line tracks a 2-bit DBC that increments on eviction without reuse and decays periodically, approximating dead-block likelihood. SRRIP set-dueling (32 leader sets, 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for non-streaming sets. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). On fill, lines with high DBC are inserted at distant RRPV to evict likely dead blocks quickly, while lines with low DBC are inserted at MRU. This hybrid approach improves performance by aggressively evicting dead blocks, adapting insertion depth to workload phase changes, and avoiding scan pollution, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/013_00_hybrid_dead_block_srrip_with_streaming_bypass__hdb_srrip_sb_t02.cc,0.402761442,0.402761442,0%
1932,milc,Hybrid Dead-Block SRRIP with Streaming Bypass (HDB-SRRIP-SB),"HDB-SRRIP-SB combines a compact per-line dead-block counter (DBC) with SRRIP set-dueling and a streaming detector for adaptive bypass. Each cache line tracks a 2-bit DBC that increments on eviction without reuse and decays periodically, approximating dead-block likelihood. SRRIP set-dueling (32 leader sets, 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for non-streaming sets. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). On fill, lines with high DBC are inserted at distant RRPV to evict likely dead blocks quickly, while lines with low DBC are inserted at MRU. This hybrid approach improves performance by aggressively evicting dead blocks, adapting insertion depth to workload phase changes, and avoiding scan pollution, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/013_00_hybrid_dead_block_srrip_with_streaming_bypass__hdb_srrip_sb_t02.cc,0.321811842,0.321811842,0%
1933,omnetpp,Hybrid Dead-Block SRRIP with Streaming Bypass (HDB-SRRIP-SB),"HDB-SRRIP-SB combines a compact per-line dead-block counter (DBC) with SRRIP set-dueling and a streaming detector for adaptive bypass. Each cache line tracks a 2-bit DBC that increments on eviction without reuse and decays periodically, approximating dead-block likelihood. SRRIP set-dueling (32 leader sets, 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for non-streaming sets. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). On fill, lines with high DBC are inserted at distant RRPV to evict likely dead blocks quickly, while lines with low DBC are inserted at MRU. This hybrid approach improves performance by aggressively evicting dead blocks, adapting insertion depth to workload phase changes, and avoiding scan pollution, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/013_00_hybrid_dead_block_srrip_with_streaming_bypass__hdb_srrip_sb_t02.cc,0.460104622,0.460104622,0%
1934,astar,Hybrid SHiP-lite Dead-Block RRIP with Streaming Bypass (HSDSB-RRIP),"HSDSB-RRIP combines three compact mechanisms to improve performance across diverse workloads: (1) SHiP-lite PC-based reuse prediction, (2) per-block dead-block approximation, and (3) a streaming detector with aggressive bypass. Each cache line tracks a 4-bit PC signature and a 2-bit dead-block counter, while a global 32-entry SHiP-lite table biases insertion depth for lines with frequent PC reuse. The dead-block counter is incremented on eviction without reuse and decayed periodically, allowing the policy to identify blocks likely to be dead and insert them at distant RRPV. The streaming detector uses per-set address deltas and confidence to bypass insertion for detected scan phases (e.g., lbm, milc). This hybrid approach improves hit rate by (a) exploiting control-flow locality, (b) dynamically tuning insertion depth for dead/streaming lines, and (c) minimizing scan pollution. All metadata fits in <64 KiB, and the combination of dead-block approximation and streaming bypass provides a materially different mechanism from the previous design.",,ChampSim_CRC2/new_policies/013_01_hybrid_ship_lite_dead_block_rrip_with_streaming_bypass__hsdsb_rrip_t04.cc,0.050987611,0.050987611,0%
1935,lbm,Hybrid SHiP-lite Dead-Block RRIP with Streaming Bypass (HSDSB-RRIP),"HSDSB-RRIP combines three compact mechanisms to improve performance across diverse workloads: (1) SHiP-lite PC-based reuse prediction, (2) per-block dead-block approximation, and (3) a streaming detector with aggressive bypass. Each cache line tracks a 4-bit PC signature and a 2-bit dead-block counter, while a global 32-entry SHiP-lite table biases insertion depth for lines with frequent PC reuse. The dead-block counter is incremented on eviction without reuse and decayed periodically, allowing the policy to identify blocks likely to be dead and insert them at distant RRPV. The streaming detector uses per-set address deltas and confidence to bypass insertion for detected scan phases (e.g., lbm, milc). This hybrid approach improves hit rate by (a) exploiting control-flow locality, (b) dynamically tuning insertion depth for dead/streaming lines, and (c) minimizing scan pollution. All metadata fits in <64 KiB, and the combination of dead-block approximation and streaming bypass provides a materially different mechanism from the previous design.",,ChampSim_CRC2/new_policies/013_01_hybrid_ship_lite_dead_block_rrip_with_streaming_bypass__hsdsb_rrip_t04.cc,0.075114261,0.075114261,0%
1936,mcf,Hybrid SHiP-lite Dead-Block RRIP with Streaming Bypass (HSDSB-RRIP),"HSDSB-RRIP combines three compact mechanisms to improve performance across diverse workloads: (1) SHiP-lite PC-based reuse prediction, (2) per-block dead-block approximation, and (3) a streaming detector with aggressive bypass. Each cache line tracks a 4-bit PC signature and a 2-bit dead-block counter, while a global 32-entry SHiP-lite table biases insertion depth for lines with frequent PC reuse. The dead-block counter is incremented on eviction without reuse and decayed periodically, allowing the policy to identify blocks likely to be dead and insert them at distant RRPV. The streaming detector uses per-set address deltas and confidence to bypass insertion for detected scan phases (e.g., lbm, milc). This hybrid approach improves hit rate by (a) exploiting control-flow locality, (b) dynamically tuning insertion depth for dead/streaming lines, and (c) minimizing scan pollution. All metadata fits in <64 KiB, and the combination of dead-block approximation and streaming bypass provides a materially different mechanism from the previous design.",,ChampSim_CRC2/new_policies/013_01_hybrid_ship_lite_dead_block_rrip_with_streaming_bypass__hsdsb_rrip_t04.cc,0.436368183,0.436368183,0%
1937,milc,Hybrid SHiP-lite Dead-Block RRIP with Streaming Bypass (HSDSB-RRIP),"HSDSB-RRIP combines three compact mechanisms to improve performance across diverse workloads: (1) SHiP-lite PC-based reuse prediction, (2) per-block dead-block approximation, and (3) a streaming detector with aggressive bypass. Each cache line tracks a 4-bit PC signature and a 2-bit dead-block counter, while a global 32-entry SHiP-lite table biases insertion depth for lines with frequent PC reuse. The dead-block counter is incremented on eviction without reuse and decayed periodically, allowing the policy to identify blocks likely to be dead and insert them at distant RRPV. The streaming detector uses per-set address deltas and confidence to bypass insertion for detected scan phases (e.g., lbm, milc). This hybrid approach improves hit rate by (a) exploiting control-flow locality, (b) dynamically tuning insertion depth for dead/streaming lines, and (c) minimizing scan pollution. All metadata fits in <64 KiB, and the combination of dead-block approximation and streaming bypass provides a materially different mechanism from the previous design.",,ChampSim_CRC2/new_policies/013_01_hybrid_ship_lite_dead_block_rrip_with_streaming_bypass__hsdsb_rrip_t04.cc,0.012373549,0.012373549,0%
1938,omnetpp,Hybrid SHiP-lite Dead-Block RRIP with Streaming Bypass (HSDSB-RRIP),"HSDSB-RRIP combines three compact mechanisms to improve performance across diverse workloads: (1) SHiP-lite PC-based reuse prediction, (2) per-block dead-block approximation, and (3) a streaming detector with aggressive bypass. Each cache line tracks a 4-bit PC signature and a 2-bit dead-block counter, while a global 32-entry SHiP-lite table biases insertion depth for lines with frequent PC reuse. The dead-block counter is incremented on eviction without reuse and decayed periodically, allowing the policy to identify blocks likely to be dead and insert them at distant RRPV. The streaming detector uses per-set address deltas and confidence to bypass insertion for detected scan phases (e.g., lbm, milc). This hybrid approach improves hit rate by (a) exploiting control-flow locality, (b) dynamically tuning insertion depth for dead/streaming lines, and (c) minimizing scan pollution. All metadata fits in <64 KiB, and the combination of dead-block approximation and streaming bypass provides a materially different mechanism from the previous design.",,ChampSim_CRC2/new_policies/013_01_hybrid_ship_lite_dead_block_rrip_with_streaming_bypass__hsdsb_rrip_t04.cc,0.001383844,0.001383844,0%
1939,astar,Dead Block-SHiP Streaming Adaptive Replacement (DBSSAR),"DBSSAR fuses per-block dead-block prediction with SHiP-lite PC-based reuse tracking and a lightweight streaming detector, dynamically controlling insertion depth and bypassing logic. Each cache block maintains a 2-bit dead-block counter that is periodically decayed to predict likely dead (non-reused) lines, favoring their eviction. A compact 32-entry SHiP-lite table steers insertion depth to MRU for PCs showing frequent reuse and to LRU otherwise. Streaming phases are detected using per-set address delta tracking; when detected, new blocks are either bypassed or inserted with distant RRPV, minimizing scan pollution in streaming-heavy workloads like lbm and milc. This hybrid approach increases hit rates by evicting blocks unlikely to be reused, exploiting control-flow locality, and preventing streaming-induced cache pollution, all within a sub-64 KiB metadata budget.",,ChampSim_CRC2/new_policies/013_02_dead_block_ship_streaming_adaptive_replacement__dbssar_t07.cc,0.342696211,0.342696211,0%
1940,lbm,Dead Block-SHiP Streaming Adaptive Replacement (DBSSAR),"DBSSAR fuses per-block dead-block prediction with SHiP-lite PC-based reuse tracking and a lightweight streaming detector, dynamically controlling insertion depth and bypassing logic. Each cache block maintains a 2-bit dead-block counter that is periodically decayed to predict likely dead (non-reused) lines, favoring their eviction. A compact 32-entry SHiP-lite table steers insertion depth to MRU for PCs showing frequent reuse and to LRU otherwise. Streaming phases are detected using per-set address delta tracking; when detected, new blocks are either bypassed or inserted with distant RRPV, minimizing scan pollution in streaming-heavy workloads like lbm and milc. This hybrid approach increases hit rates by evicting blocks unlikely to be reused, exploiting control-flow locality, and preventing streaming-induced cache pollution, all within a sub-64 KiB metadata budget.",,ChampSim_CRC2/new_policies/013_02_dead_block_ship_streaming_adaptive_replacement__dbssar_t07.cc,0.234490355,0.234490355,0%
1941,mcf,Dead Block-SHiP Streaming Adaptive Replacement (DBSSAR),"DBSSAR fuses per-block dead-block prediction with SHiP-lite PC-based reuse tracking and a lightweight streaming detector, dynamically controlling insertion depth and bypassing logic. Each cache block maintains a 2-bit dead-block counter that is periodically decayed to predict likely dead (non-reused) lines, favoring their eviction. A compact 32-entry SHiP-lite table steers insertion depth to MRU for PCs showing frequent reuse and to LRU otherwise. Streaming phases are detected using per-set address delta tracking; when detected, new blocks are either bypassed or inserted with distant RRPV, minimizing scan pollution in streaming-heavy workloads like lbm and milc. This hybrid approach increases hit rates by evicting blocks unlikely to be reused, exploiting control-flow locality, and preventing streaming-induced cache pollution, all within a sub-64 KiB metadata budget.",,ChampSim_CRC2/new_policies/013_02_dead_block_ship_streaming_adaptive_replacement__dbssar_t07.cc,0.516763864,0.516763864,0%
1942,milc,Dead Block-SHiP Streaming Adaptive Replacement (DBSSAR),"DBSSAR fuses per-block dead-block prediction with SHiP-lite PC-based reuse tracking and a lightweight streaming detector, dynamically controlling insertion depth and bypassing logic. Each cache block maintains a 2-bit dead-block counter that is periodically decayed to predict likely dead (non-reused) lines, favoring their eviction. A compact 32-entry SHiP-lite table steers insertion depth to MRU for PCs showing frequent reuse and to LRU otherwise. Streaming phases are detected using per-set address delta tracking; when detected, new blocks are either bypassed or inserted with distant RRPV, minimizing scan pollution in streaming-heavy workloads like lbm and milc. This hybrid approach increases hit rates by evicting blocks unlikely to be reused, exploiting control-flow locality, and preventing streaming-induced cache pollution, all within a sub-64 KiB metadata budget.",,ChampSim_CRC2/new_policies/013_02_dead_block_ship_streaming_adaptive_replacement__dbssar_t07.cc,0.092458562,0.092458562,0%
1943,omnetpp,Dead Block-SHiP Streaming Adaptive Replacement (DBSSAR),"DBSSAR fuses per-block dead-block prediction with SHiP-lite PC-based reuse tracking and a lightweight streaming detector, dynamically controlling insertion depth and bypassing logic. Each cache block maintains a 2-bit dead-block counter that is periodically decayed to predict likely dead (non-reused) lines, favoring their eviction. A compact 32-entry SHiP-lite table steers insertion depth to MRU for PCs showing frequent reuse and to LRU otherwise. Streaming phases are detected using per-set address delta tracking; when detected, new blocks are either bypassed or inserted with distant RRPV, minimizing scan pollution in streaming-heavy workloads like lbm and milc. This hybrid approach increases hit rates by evicting blocks unlikely to be reused, exploiting control-flow locality, and preventing streaming-induced cache pollution, all within a sub-64 KiB metadata budget.",,ChampSim_CRC2/new_policies/013_02_dead_block_ship_streaming_adaptive_replacement__dbssar_t07.cc,0.737424769,0.737424769,0%
1944,all,Hybrid Dead-Block SRRIP with Streaming Bypass (HDB-SRRIP-SB),"HDB-SRRIP-SB combines a compact per-line dead-block counter (DBC) with SRRIP set-dueling and a streaming detector for adaptive bypass. Each cache line tracks a 2-bit DBC that increments on eviction without reuse and decays periodically, approximating dead-block likelihood. SRRIP set-dueling (32 leader sets, 10-bit PSEL) dynamically selects between SRRIP and BRRIP insertion depths for non-streaming sets. Streaming phases are detected via near-monotonic address deltas per set; when detected, incoming lines are bypassed (not inserted) to minimize scan pollution (e.g., lbm, milc). On fill, lines with high DBC are inserted at distant RRPV to evict likely dead blocks quickly, while lines with low DBC are inserted at MRU. This hybrid approach improves performance by aggressively evicting dead blocks, adapting insertion depth to workload phase changes, and avoiding scan pollution, all within a compact metadata footprint (<64 KiB).",,ChampSim_CRC2/new_policies/013_00_hybrid_dead_block_srrip_with_streaming_bypass__hdb_srrip_sb_t02.cc,0.415910738,0.415910738,42%
1945,astar,SHiP-Lite Streaming Adaptive Replacement (SHiP-SA),"SHiP-SA combines PC-based signature history prediction (SHiP-lite) with a lightweight streaming phase detector to adaptively control cache insertion depth and bypass behavior. Each cache line is tagged with a compact 6-bit PC signature, and a global table tracks 2-bit reuse outcome counters per signature, biasing insertion depth between MRU and LRU. This enables the cache to learn which instructions produce reusable blocks, improving retention for high-reuse PCs (e.g., mcf, omnetpp) and evicting dead blocks quickly for low-reuse PCs (e.g., astar). A per-set streaming detector monitors address deltas to identify scan-like phases (e.g., lbm, milc), triggering insertion at distant RRPV or bypassing fills to prevent cache pollution. The hybrid approach leverages program context and access phase changes for fine-grained adaptation, outperforming pure recency or dead-block heuristics with a compact metadata footprint (~40 KiB).",,ChampSim_CRC2/new_policies/014_01_ship_lite_streaming_adaptive_replacement__ship_sa_t04.cc,0.460745368,0.460745368,0%
1946,lbm,SHiP-Lite Streaming Adaptive Replacement (SHiP-SA),"SHiP-SA combines PC-based signature history prediction (SHiP-lite) with a lightweight streaming phase detector to adaptively control cache insertion depth and bypass behavior. Each cache line is tagged with a compact 6-bit PC signature, and a global table tracks 2-bit reuse outcome counters per signature, biasing insertion depth between MRU and LRU. This enables the cache to learn which instructions produce reusable blocks, improving retention for high-reuse PCs (e.g., mcf, omnetpp) and evicting dead blocks quickly for low-reuse PCs (e.g., astar). A per-set streaming detector monitors address deltas to identify scan-like phases (e.g., lbm, milc), triggering insertion at distant RRPV or bypassing fills to prevent cache pollution. The hybrid approach leverages program context and access phase changes for fine-grained adaptation, outperforming pure recency or dead-block heuristics with a compact metadata footprint (~40 KiB).",,ChampSim_CRC2/new_policies/014_01_ship_lite_streaming_adaptive_replacement__ship_sa_t04.cc,0.439847312,0.439847312,0%
1947,mcf,SHiP-Lite Streaming Adaptive Replacement (SHiP-SA),"SHiP-SA combines PC-based signature history prediction (SHiP-lite) with a lightweight streaming phase detector to adaptively control cache insertion depth and bypass behavior. Each cache line is tagged with a compact 6-bit PC signature, and a global table tracks 2-bit reuse outcome counters per signature, biasing insertion depth between MRU and LRU. This enables the cache to learn which instructions produce reusable blocks, improving retention for high-reuse PCs (e.g., mcf, omnetpp) and evicting dead blocks quickly for low-reuse PCs (e.g., astar). A per-set streaming detector monitors address deltas to identify scan-like phases (e.g., lbm, milc), triggering insertion at distant RRPV or bypassing fills to prevent cache pollution. The hybrid approach leverages program context and access phase changes for fine-grained adaptation, outperforming pure recency or dead-block heuristics with a compact metadata footprint (~40 KiB).",,ChampSim_CRC2/new_policies/014_01_ship_lite_streaming_adaptive_replacement__ship_sa_t04.cc,0.404369518,0.404369518,0%
1948,milc,SHiP-Lite Streaming Adaptive Replacement (SHiP-SA),"SHiP-SA combines PC-based signature history prediction (SHiP-lite) with a lightweight streaming phase detector to adaptively control cache insertion depth and bypass behavior. Each cache line is tagged with a compact 6-bit PC signature, and a global table tracks 2-bit reuse outcome counters per signature, biasing insertion depth between MRU and LRU. This enables the cache to learn which instructions produce reusable blocks, improving retention for high-reuse PCs (e.g., mcf, omnetpp) and evicting dead blocks quickly for low-reuse PCs (e.g., astar). A per-set streaming detector monitors address deltas to identify scan-like phases (e.g., lbm, milc), triggering insertion at distant RRPV or bypassing fills to prevent cache pollution. The hybrid approach leverages program context and access phase changes for fine-grained adaptation, outperforming pure recency or dead-block heuristics with a compact metadata footprint (~40 KiB).",,ChampSim_CRC2/new_policies/014_01_ship_lite_streaming_adaptive_replacement__ship_sa_t04.cc,0.319911005,0.319911005,0%
1949,omnetpp,SHiP-Lite Streaming Adaptive Replacement (SHiP-SA),"SHiP-SA combines PC-based signature history prediction (SHiP-lite) with a lightweight streaming phase detector to adaptively control cache insertion depth and bypass behavior. Each cache line is tagged with a compact 6-bit PC signature, and a global table tracks 2-bit reuse outcome counters per signature, biasing insertion depth between MRU and LRU. This enables the cache to learn which instructions produce reusable blocks, improving retention for high-reuse PCs (e.g., mcf, omnetpp) and evicting dead blocks quickly for low-reuse PCs (e.g., astar). A per-set streaming detector monitors address deltas to identify scan-like phases (e.g., lbm, milc), triggering insertion at distant RRPV or bypassing fills to prevent cache pollution. The hybrid approach leverages program context and access phase changes for fine-grained adaptation, outperforming pure recency or dead-block heuristics with a compact metadata footprint (~40 KiB).",,ChampSim_CRC2/new_policies/014_01_ship_lite_streaming_adaptive_replacement__ship_sa_t04.cc,0.41456606,0.41456606,0%
1950,astar,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"SHiP-DRRIP-SB combines compact PC-based signature tracking (SHiP-lite) with dynamic RRIP/BRRIP insertion via set-dueling and a streaming phase detector for adaptive scan bypass. Each cache line stores a 2-bit RRPV (for RRIP) and a 4-bit signature index (from PC low bits). A global table of compact 2-bit outcome counters (256 entries, indexed by PC signature) tracks recent reuse history to bias insertion depth: blocks from PCs with frequent reuse are inserted closer to MRU, while those with poor reuse are inserted at distant RRPV for quick eviction. Set-dueling (32 leader sets, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for ambiguous cases. Streaming is detected per-set by observing near-monotonic address deltas; when active, fills are bypassed (inserted at LRU RRPV) to limit scan pollution (critical for LBM, MILC). This hybrid design improves overall hit rate by learning PC-locality, adapting insertion policy to workload phases, and minimizing scan pollution, all within a compact metadata budget (<64 KiB).",,ChampSim_CRC2/new_policies/014_02_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t07.cc,0.454590958,0.454590958,0%
1951,lbm,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"SHiP-DRRIP-SB combines compact PC-based signature tracking (SHiP-lite) with dynamic RRIP/BRRIP insertion via set-dueling and a streaming phase detector for adaptive scan bypass. Each cache line stores a 2-bit RRPV (for RRIP) and a 4-bit signature index (from PC low bits). A global table of compact 2-bit outcome counters (256 entries, indexed by PC signature) tracks recent reuse history to bias insertion depth: blocks from PCs with frequent reuse are inserted closer to MRU, while those with poor reuse are inserted at distant RRPV for quick eviction. Set-dueling (32 leader sets, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for ambiguous cases. Streaming is detected per-set by observing near-monotonic address deltas; when active, fills are bypassed (inserted at LRU RRPV) to limit scan pollution (critical for LBM, MILC). This hybrid design improves overall hit rate by learning PC-locality, adapting insertion policy to workload phases, and minimizing scan pollution, all within a compact metadata budget (<64 KiB).",,ChampSim_CRC2/new_policies/014_02_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t07.cc,0.156698764,0.156698764,0%
1952,mcf,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"SHiP-DRRIP-SB combines compact PC-based signature tracking (SHiP-lite) with dynamic RRIP/BRRIP insertion via set-dueling and a streaming phase detector for adaptive scan bypass. Each cache line stores a 2-bit RRPV (for RRIP) and a 4-bit signature index (from PC low bits). A global table of compact 2-bit outcome counters (256 entries, indexed by PC signature) tracks recent reuse history to bias insertion depth: blocks from PCs with frequent reuse are inserted closer to MRU, while those with poor reuse are inserted at distant RRPV for quick eviction. Set-dueling (32 leader sets, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for ambiguous cases. Streaming is detected per-set by observing near-monotonic address deltas; when active, fills are bypassed (inserted at LRU RRPV) to limit scan pollution (critical for LBM, MILC). This hybrid design improves overall hit rate by learning PC-locality, adapting insertion policy to workload phases, and minimizing scan pollution, all within a compact metadata budget (<64 KiB).",,ChampSim_CRC2/new_policies/014_02_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t07.cc,0.492287,0.492287,0%
1953,milc,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"SHiP-DRRIP-SB combines compact PC-based signature tracking (SHiP-lite) with dynamic RRIP/BRRIP insertion via set-dueling and a streaming phase detector for adaptive scan bypass. Each cache line stores a 2-bit RRPV (for RRIP) and a 4-bit signature index (from PC low bits). A global table of compact 2-bit outcome counters (256 entries, indexed by PC signature) tracks recent reuse history to bias insertion depth: blocks from PCs with frequent reuse are inserted closer to MRU, while those with poor reuse are inserted at distant RRPV for quick eviction. Set-dueling (32 leader sets, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for ambiguous cases. Streaming is detected per-set by observing near-monotonic address deltas; when active, fills are bypassed (inserted at LRU RRPV) to limit scan pollution (critical for LBM, MILC). This hybrid design improves overall hit rate by learning PC-locality, adapting insertion policy to workload phases, and minimizing scan pollution, all within a compact metadata budget (<64 KiB).",,ChampSim_CRC2/new_policies/014_02_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t07.cc,0.083808845,0.083808845,0%
1954,omnetpp,SHiP-Lite DRRIP with Streaming Bypass (SHiP-DRRIP-SB),"SHiP-DRRIP-SB combines compact PC-based signature tracking (SHiP-lite) with dynamic RRIP/BRRIP insertion via set-dueling and a streaming phase detector for adaptive scan bypass. Each cache line stores a 2-bit RRPV (for RRIP) and a 4-bit signature index (from PC low bits). A global table of compact 2-bit outcome counters (256 entries, indexed by PC signature) tracks recent reuse history to bias insertion depth: blocks from PCs with frequent reuse are inserted closer to MRU, while those with poor reuse are inserted at distant RRPV for quick eviction. Set-dueling (32 leader sets, 10-bit PSEL) dynamically chooses between SRRIP and BRRIP for ambiguous cases. Streaming is detected per-set by observing near-monotonic address deltas; when active, fills are bypassed (inserted at LRU RRPV) to limit scan pollution (critical for LBM, MILC). This hybrid design improves overall hit rate by learning PC-locality, adapting insertion policy to workload phases, and minimizing scan pollution, all within a compact metadata budget (<64 KiB).",,ChampSim_CRC2/new_policies/014_02_ship_lite_drrip_with_streaming_bypass__ship_drrip_sb_t07.cc,0.464840651,0.464840651,0%
1955,all,SHiP-Lite Streaming Adaptive Replacement (SHiP-SA),"SHiP-SA combines PC-based signature history prediction (SHiP-lite) with a lightweight streaming phase detector to adaptively control cache insertion depth and bypass behavior. Each cache line is tagged with a compact 6-bit PC signature, and a global table tracks 2-bit reuse outcome counters per signature, biasing insertion depth between MRU and LRU. This enables the cache to learn which instructions produce reusable blocks, improving retention for high-reuse PCs (e.g., mcf, omnetpp) and evicting dead blocks quickly for low-reuse PCs (e.g., astar). A per-set streaming detector monitors address deltas to identify scan-like phases (e.g., lbm, milc), triggering insertion at distant RRPV or bypassing fills to prevent cache pollution. The hybrid approach leverages program context and access phase changes for fine-grained adaptation, outperforming pure recency or dead-block heuristics with a compact metadata footprint (~40 KiB).",,ChampSim_CRC2/new_policies/014_01_ship_lite_streaming_adaptive_replacement__ship_sa_t04.cc,0.407887853,0.407887853,41%
1956,astar,DRRIP-DeadBlock Hybrid with Streaming Bypass (DRRIP-DBS),"DRRIP-DBS combines dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact per-line dead-block counter and a lightweight streaming detector for phase-aware bypass. DRRIP adapts insertion depth globally using a 10-bit PSEL selector and 64 leader sets, balancing between SRRIP (insert at distant RRPV) and BRRIP (mostly insert at MRU) for diverse workloads. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing rapid identification and eviction of lines with repeated dead fills (e.g., astar, mcf). The streaming detector monitors address deltas per set, triggering bypass or distant insertion during scan-like phases (e.g., lbm, milc) to prevent cache pollution. This hybrid approach leverages global phase adaptation, local dead-block learning, and streaming awareness, improving retention for reusable blocks and evicting dead or streaming blocks quickly, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/015_00_drrip_deadblock_hybrid_with_streaming_bypass__drrip_dbs_t02.cc,0.427793094,0.427793094,0%
1957,lbm,DRRIP-DeadBlock Hybrid with Streaming Bypass (DRRIP-DBS),"DRRIP-DBS combines dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact per-line dead-block counter and a lightweight streaming detector for phase-aware bypass. DRRIP adapts insertion depth globally using a 10-bit PSEL selector and 64 leader sets, balancing between SRRIP (insert at distant RRPV) and BRRIP (mostly insert at MRU) for diverse workloads. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing rapid identification and eviction of lines with repeated dead fills (e.g., astar, mcf). The streaming detector monitors address deltas per set, triggering bypass or distant insertion during scan-like phases (e.g., lbm, milc) to prevent cache pollution. This hybrid approach leverages global phase adaptation, local dead-block learning, and streaming awareness, improving retention for reusable blocks and evicting dead or streaming blocks quickly, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/015_00_drrip_deadblock_hybrid_with_streaming_bypass__drrip_dbs_t02.cc,0.406509927,0.406509927,0%
1958,mcf,DRRIP-DeadBlock Hybrid with Streaming Bypass (DRRIP-DBS),"DRRIP-DBS combines dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact per-line dead-block counter and a lightweight streaming detector for phase-aware bypass. DRRIP adapts insertion depth globally using a 10-bit PSEL selector and 64 leader sets, balancing between SRRIP (insert at distant RRPV) and BRRIP (mostly insert at MRU) for diverse workloads. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing rapid identification and eviction of lines with repeated dead fills (e.g., astar, mcf). The streaming detector monitors address deltas per set, triggering bypass or distant insertion during scan-like phases (e.g., lbm, milc) to prevent cache pollution. This hybrid approach leverages global phase adaptation, local dead-block learning, and streaming awareness, improving retention for reusable blocks and evicting dead or streaming blocks quickly, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/015_00_drrip_deadblock_hybrid_with_streaming_bypass__drrip_dbs_t02.cc,0.458695995,0.458695995,0%
1959,milc,DRRIP-DeadBlock Hybrid with Streaming Bypass (DRRIP-DBS),"DRRIP-DBS combines dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact per-line dead-block counter and a lightweight streaming detector for phase-aware bypass. DRRIP adapts insertion depth globally using a 10-bit PSEL selector and 64 leader sets, balancing between SRRIP (insert at distant RRPV) and BRRIP (mostly insert at MRU) for diverse workloads. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing rapid identification and eviction of lines with repeated dead fills (e.g., astar, mcf). The streaming detector monitors address deltas per set, triggering bypass or distant insertion during scan-like phases (e.g., lbm, milc) to prevent cache pollution. This hybrid approach leverages global phase adaptation, local dead-block learning, and streaming awareness, improving retention for reusable blocks and evicting dead or streaming blocks quickly, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/015_00_drrip_deadblock_hybrid_with_streaming_bypass__drrip_dbs_t02.cc,0.306614191,0.306614191,0%
1960,omnetpp,DRRIP-DeadBlock Hybrid with Streaming Bypass (DRRIP-DBS),"DRRIP-DBS combines dynamic RRIP (SRRIP vs BRRIP) set-dueling with a compact per-line dead-block counter and a lightweight streaming detector for phase-aware bypass. DRRIP adapts insertion depth globally using a 10-bit PSEL selector and 64 leader sets, balancing between SRRIP (insert at distant RRPV) and BRRIP (mostly insert at MRU) for diverse workloads. Each cache line tracks a 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically, allowing rapid identification and eviction of lines with repeated dead fills (e.g., astar, mcf). The streaming detector monitors address deltas per set, triggering bypass or distant insertion during scan-like phases (e.g., lbm, milc) to prevent cache pollution. This hybrid approach leverages global phase adaptation, local dead-block learning, and streaming awareness, improving retention for reusable blocks and evicting dead or streaming blocks quickly, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/015_00_drrip_deadblock_hybrid_with_streaming_bypass__drrip_dbs_t02.cc,0.444858665,0.444858665,0%
1961,astar,DRRIP-DeadBlock Hybrid (DRRIP-DBH),"DRRIP-DBH combines Dynamic RRIP (DRRIP) with a lightweight dead-block predictor to improve cache replacement decisions across diverse workloads. DRRIP uses set-dueling (with a 10-bit PSEL selector) to dynamically choose between SRRIP (aggressive retention) and BRRIP (aggressive eviction) insertion depths, adapting to workload locality. To further reduce cache pollution from dead-on-arrival blocks (common in astar, mcf, omnetpp), each cache line maintains a tiny 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically. Blocks predicted dead are inserted at distant RRPV or bypassed, while blocks with recent reuse are retained aggressively. This hybrid approach leverages both global phase adaptation and fine-grained dead-block detection, outperforming pure recency or signature-based policies, while keeping metadata under 32 KiB.",,ChampSim_CRC2/new_policies/015_01_drrip_deadblock_hybrid__drrip_dbh_t04.cc,0.416095551,0.416095551,0%
1962,lbm,DRRIP-DeadBlock Hybrid (DRRIP-DBH),"DRRIP-DBH combines Dynamic RRIP (DRRIP) with a lightweight dead-block predictor to improve cache replacement decisions across diverse workloads. DRRIP uses set-dueling (with a 10-bit PSEL selector) to dynamically choose between SRRIP (aggressive retention) and BRRIP (aggressive eviction) insertion depths, adapting to workload locality. To further reduce cache pollution from dead-on-arrival blocks (common in astar, mcf, omnetpp), each cache line maintains a tiny 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically. Blocks predicted dead are inserted at distant RRPV or bypassed, while blocks with recent reuse are retained aggressively. This hybrid approach leverages both global phase adaptation and fine-grained dead-block detection, outperforming pure recency or signature-based policies, while keeping metadata under 32 KiB.",,ChampSim_CRC2/new_policies/015_01_drrip_deadblock_hybrid__drrip_dbh_t04.cc,0.397853125,0.397853125,0%
1963,mcf,DRRIP-DeadBlock Hybrid (DRRIP-DBH),"DRRIP-DBH combines Dynamic RRIP (DRRIP) with a lightweight dead-block predictor to improve cache replacement decisions across diverse workloads. DRRIP uses set-dueling (with a 10-bit PSEL selector) to dynamically choose between SRRIP (aggressive retention) and BRRIP (aggressive eviction) insertion depths, adapting to workload locality. To further reduce cache pollution from dead-on-arrival blocks (common in astar, mcf, omnetpp), each cache line maintains a tiny 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically. Blocks predicted dead are inserted at distant RRPV or bypassed, while blocks with recent reuse are retained aggressively. This hybrid approach leverages both global phase adaptation and fine-grained dead-block detection, outperforming pure recency or signature-based policies, while keeping metadata under 32 KiB.",,ChampSim_CRC2/new_policies/015_01_drrip_deadblock_hybrid__drrip_dbh_t04.cc,0.460432945,0.460432945,0%
1964,milc,DRRIP-DeadBlock Hybrid (DRRIP-DBH),"DRRIP-DBH combines Dynamic RRIP (DRRIP) with a lightweight dead-block predictor to improve cache replacement decisions across diverse workloads. DRRIP uses set-dueling (with a 10-bit PSEL selector) to dynamically choose between SRRIP (aggressive retention) and BRRIP (aggressive eviction) insertion depths, adapting to workload locality. To further reduce cache pollution from dead-on-arrival blocks (common in astar, mcf, omnetpp), each cache line maintains a tiny 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically. Blocks predicted dead are inserted at distant RRPV or bypassed, while blocks with recent reuse are retained aggressively. This hybrid approach leverages both global phase adaptation and fine-grained dead-block detection, outperforming pure recency or signature-based policies, while keeping metadata under 32 KiB.",,ChampSim_CRC2/new_policies/015_01_drrip_deadblock_hybrid__drrip_dbh_t04.cc,0.307799952,0.307799952,0%
1965,omnetpp,DRRIP-DeadBlock Hybrid (DRRIP-DBH),"DRRIP-DBH combines Dynamic RRIP (DRRIP) with a lightweight dead-block predictor to improve cache replacement decisions across diverse workloads. DRRIP uses set-dueling (with a 10-bit PSEL selector) to dynamically choose between SRRIP (aggressive retention) and BRRIP (aggressive eviction) insertion depths, adapting to workload locality. To further reduce cache pollution from dead-on-arrival blocks (common in astar, mcf, omnetpp), each cache line maintains a tiny 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically. Blocks predicted dead are inserted at distant RRPV or bypassed, while blocks with recent reuse are retained aggressively. This hybrid approach leverages both global phase adaptation and fine-grained dead-block detection, outperforming pure recency or signature-based policies, while keeping metadata under 32 KiB.",,ChampSim_CRC2/new_policies/015_01_drrip_deadblock_hybrid__drrip_dbh_t04.cc,0.852401715,0.852401715,0%
1966,astar,DRRIP-Lite with Streaming-Aware Bypass (DRRIP-SA),"DRRIP-SA combines Dynamic RRIP (DRRIP) set-dueling for insertion depth control with a compact, per-set streaming detector to adaptively bypass or insert cache lines. DRRIP uses a small number of leader sets and a 10-bit PSEL selector to switch between SRRIP (aggressive retention) and BRRIP (quick eviction), providing robust phase adaptation across workloads like mcf and milc. The streaming detector monitors address deltas within each set for scan-like behavior (e.g., lbm, milc), and triggers bypass or distant RRPV insertion to prevent cache pollution. This design significantly differs from prior SHiP-lite insertion and prediction by relying on set-dueling rather than PC signatures, and by directly controlling bypass based on streaming phases. The compact metadata (~19 KiB: RRIP bits, PSEL, leader set map, streaming flags and counters) ensures efficiency and scalability, while the hybrid approach targets both irregular and streaming workloads for improved overall hit rates.",,ChampSim_CRC2/new_policies/015_02_drrip_lite_with_streaming_aware_bypass__drrip_sa_t07.cc,0.43017176,0.43017176,0%
1967,lbm,DRRIP-Lite with Streaming-Aware Bypass (DRRIP-SA),"DRRIP-SA combines Dynamic RRIP (DRRIP) set-dueling for insertion depth control with a compact, per-set streaming detector to adaptively bypass or insert cache lines. DRRIP uses a small number of leader sets and a 10-bit PSEL selector to switch between SRRIP (aggressive retention) and BRRIP (quick eviction), providing robust phase adaptation across workloads like mcf and milc. The streaming detector monitors address deltas within each set for scan-like behavior (e.g., lbm, milc), and triggers bypass or distant RRPV insertion to prevent cache pollution. This design significantly differs from prior SHiP-lite insertion and prediction by relying on set-dueling rather than PC signatures, and by directly controlling bypass based on streaming phases. The compact metadata (~19 KiB: RRIP bits, PSEL, leader set map, streaming flags and counters) ensures efficiency and scalability, while the hybrid approach targets both irregular and streaming workloads for improved overall hit rates.",,ChampSim_CRC2/new_policies/015_02_drrip_lite_with_streaming_aware_bypass__drrip_sa_t07.cc,0.407419043,0.407419043,0%
1968,mcf,DRRIP-Lite with Streaming-Aware Bypass (DRRIP-SA),"DRRIP-SA combines Dynamic RRIP (DRRIP) set-dueling for insertion depth control with a compact, per-set streaming detector to adaptively bypass or insert cache lines. DRRIP uses a small number of leader sets and a 10-bit PSEL selector to switch between SRRIP (aggressive retention) and BRRIP (quick eviction), providing robust phase adaptation across workloads like mcf and milc. The streaming detector monitors address deltas within each set for scan-like behavior (e.g., lbm, milc), and triggers bypass or distant RRPV insertion to prevent cache pollution. This design significantly differs from prior SHiP-lite insertion and prediction by relying on set-dueling rather than PC signatures, and by directly controlling bypass based on streaming phases. The compact metadata (~19 KiB: RRIP bits, PSEL, leader set map, streaming flags and counters) ensures efficiency and scalability, while the hybrid approach targets both irregular and streaming workloads for improved overall hit rates.",,ChampSim_CRC2/new_policies/015_02_drrip_lite_with_streaming_aware_bypass__drrip_sa_t07.cc,0.459855022,0.459855022,0%
1969,milc,DRRIP-Lite with Streaming-Aware Bypass (DRRIP-SA),"DRRIP-SA combines Dynamic RRIP (DRRIP) set-dueling for insertion depth control with a compact, per-set streaming detector to adaptively bypass or insert cache lines. DRRIP uses a small number of leader sets and a 10-bit PSEL selector to switch between SRRIP (aggressive retention) and BRRIP (quick eviction), providing robust phase adaptation across workloads like mcf and milc. The streaming detector monitors address deltas within each set for scan-like behavior (e.g., lbm, milc), and triggers bypass or distant RRPV insertion to prevent cache pollution. This design significantly differs from prior SHiP-lite insertion and prediction by relying on set-dueling rather than PC signatures, and by directly controlling bypass based on streaming phases. The compact metadata (~19 KiB: RRIP bits, PSEL, leader set map, streaming flags and counters) ensures efficiency and scalability, while the hybrid approach targets both irregular and streaming workloads for improved overall hit rates.",,ChampSim_CRC2/new_policies/015_02_drrip_lite_with_streaming_aware_bypass__drrip_sa_t07.cc,0.306809706,0.306809706,0%
1970,omnetpp,DRRIP-Lite with Streaming-Aware Bypass (DRRIP-SA),"DRRIP-SA combines Dynamic RRIP (DRRIP) set-dueling for insertion depth control with a compact, per-set streaming detector to adaptively bypass or insert cache lines. DRRIP uses a small number of leader sets and a 10-bit PSEL selector to switch between SRRIP (aggressive retention) and BRRIP (quick eviction), providing robust phase adaptation across workloads like mcf and milc. The streaming detector monitors address deltas within each set for scan-like behavior (e.g., lbm, milc), and triggers bypass or distant RRPV insertion to prevent cache pollution. This design significantly differs from prior SHiP-lite insertion and prediction by relying on set-dueling rather than PC signatures, and by directly controlling bypass based on streaming phases. The compact metadata (~19 KiB: RRIP bits, PSEL, leader set map, streaming flags and counters) ensures efficiency and scalability, while the hybrid approach targets both irregular and streaming workloads for improved overall hit rates.",,ChampSim_CRC2/new_policies/015_02_drrip_lite_with_streaming_aware_bypass__drrip_sa_t07.cc,0.445950218,0.445950218,0%
1971,all,DRRIP-DeadBlock Hybrid (DRRIP-DBH),"DRRIP-DBH combines Dynamic RRIP (DRRIP) with a lightweight dead-block predictor to improve cache replacement decisions across diverse workloads. DRRIP uses set-dueling (with a 10-bit PSEL selector) to dynamically choose between SRRIP (aggressive retention) and BRRIP (aggressive eviction) insertion depths, adapting to workload locality. To further reduce cache pollution from dead-on-arrival blocks (common in astar, mcf, omnetpp), each cache line maintains a tiny 2-bit dead-block counter, incremented on eviction without reuse and decayed periodically. Blocks predicted dead are inserted at distant RRPV or bypassed, while blocks with recent reuse are retained aggressively. This hybrid approach leverages both global phase adaptation and fine-grained dead-block detection, outperforming pure recency or signature-based policies, while keeping metadata under 32 KiB.",,ChampSim_CRC2/new_policies/015_01_drrip_deadblock_hybrid__drrip_dbh_t04.cc,0.486916658,0.486916658,49%
1972,astar,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH fuses SHiP-lite signature-based prediction with streaming detection and dead-block counters to optimize cache replacement for diverse workloads. Each cache line tracks a 2-bit dead-block counter, while a compact SHiP table (2048 entries, 2 bits each) uses PC signatures to bias insertion depth toward blocks with demonstrated reuse. A streaming detector monitors address deltas per set, identifying monotonic or stride-like access patterns (common in lbm, milc) and triggers distant RRPV insertion or bypass for streaming candidates. Dead-block counters further guide victim selection and insertion, reducing pollution from dead-on-arrival blocks (astar, mcf, omnetpp). This hybrid approach adapts to both control-dominated and regular workloads, leveraging fine-grained reuse signals, streaming awareness, and dead-block approximation, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/016_00_ship_streaming_deadblock_hybrid__ship_sdbh_t02.cc,0.25101348,0.25101348,0%
1973,lbm,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH fuses SHiP-lite signature-based prediction with streaming detection and dead-block counters to optimize cache replacement for diverse workloads. Each cache line tracks a 2-bit dead-block counter, while a compact SHiP table (2048 entries, 2 bits each) uses PC signatures to bias insertion depth toward blocks with demonstrated reuse. A streaming detector monitors address deltas per set, identifying monotonic or stride-like access patterns (common in lbm, milc) and triggers distant RRPV insertion or bypass for streaming candidates. Dead-block counters further guide victim selection and insertion, reducing pollution from dead-on-arrival blocks (astar, mcf, omnetpp). This hybrid approach adapts to both control-dominated and regular workloads, leveraging fine-grained reuse signals, streaming awareness, and dead-block approximation, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/016_00_ship_streaming_deadblock_hybrid__ship_sdbh_t02.cc,0.118342837,0.118342837,0%
1974,mcf,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH fuses SHiP-lite signature-based prediction with streaming detection and dead-block counters to optimize cache replacement for diverse workloads. Each cache line tracks a 2-bit dead-block counter, while a compact SHiP table (2048 entries, 2 bits each) uses PC signatures to bias insertion depth toward blocks with demonstrated reuse. A streaming detector monitors address deltas per set, identifying monotonic or stride-like access patterns (common in lbm, milc) and triggers distant RRPV insertion or bypass for streaming candidates. Dead-block counters further guide victim selection and insertion, reducing pollution from dead-on-arrival blocks (astar, mcf, omnetpp). This hybrid approach adapts to both control-dominated and regular workloads, leveraging fine-grained reuse signals, streaming awareness, and dead-block approximation, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/016_00_ship_streaming_deadblock_hybrid__ship_sdbh_t02.cc,0.292568689,0.292568689,0%
1975,milc,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH fuses SHiP-lite signature-based prediction with streaming detection and dead-block counters to optimize cache replacement for diverse workloads. Each cache line tracks a 2-bit dead-block counter, while a compact SHiP table (2048 entries, 2 bits each) uses PC signatures to bias insertion depth toward blocks with demonstrated reuse. A streaming detector monitors address deltas per set, identifying monotonic or stride-like access patterns (common in lbm, milc) and triggers distant RRPV insertion or bypass for streaming candidates. Dead-block counters further guide victim selection and insertion, reducing pollution from dead-on-arrival blocks (astar, mcf, omnetpp). This hybrid approach adapts to both control-dominated and regular workloads, leveraging fine-grained reuse signals, streaming awareness, and dead-block approximation, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/016_00_ship_streaming_deadblock_hybrid__ship_sdbh_t02.cc,0.062285929,0.062285929,0%
1976,omnetpp,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH fuses SHiP-lite signature-based prediction with streaming detection and dead-block counters to optimize cache replacement for diverse workloads. Each cache line tracks a 2-bit dead-block counter, while a compact SHiP table (2048 entries, 2 bits each) uses PC signatures to bias insertion depth toward blocks with demonstrated reuse. A streaming detector monitors address deltas per set, identifying monotonic or stride-like access patterns (common in lbm, milc) and triggers distant RRPV insertion or bypass for streaming candidates. Dead-block counters further guide victim selection and insertion, reducing pollution from dead-on-arrival blocks (astar, mcf, omnetpp). This hybrid approach adapts to both control-dominated and regular workloads, leveraging fine-grained reuse signals, streaming awareness, and dead-block approximation, all within ~32 KiB metadata.",,ChampSim_CRC2/new_policies/016_00_ship_streaming_deadblock_hybrid__ship_sdbh_t02.cc,0.854716047,0.854716047,0%
1977,astar,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH combines SHiP-lite signature-based insertion, a streaming access detector, and per-block dead-block counters to adaptively manage cache replacement across diverse workloads. SHiP-lite uses compact 6-bit PC signatures with 2-bit saturating outcome counters to bias insertion depth: frequently reused PCs get aggressive retention, while others are inserted at distant RRPV. For streaming or near-monotonic accesses (detected via small per-set address delta history), the policy bypasses or inserts at distant RRPV, minimizing pollution for workloads like lbm. Dead-block counters (2 bits per block) further help identify blocks that are never reused, accelerating their eviction. Periodic decay prevents stuck dead predictions. This hybrid leverages PC-based reuse, streaming detection, and dead-block approximation, improving performance for both regular and irregular workloads, while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/016_01_ship_streaming_deadblock_hybrid__ship_sdbh_t04.cc,0.374900778,0.374900778,0%
1978,lbm,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH combines SHiP-lite signature-based insertion, a streaming access detector, and per-block dead-block counters to adaptively manage cache replacement across diverse workloads. SHiP-lite uses compact 6-bit PC signatures with 2-bit saturating outcome counters to bias insertion depth: frequently reused PCs get aggressive retention, while others are inserted at distant RRPV. For streaming or near-monotonic accesses (detected via small per-set address delta history), the policy bypasses or inserts at distant RRPV, minimizing pollution for workloads like lbm. Dead-block counters (2 bits per block) further help identify blocks that are never reused, accelerating their eviction. Periodic decay prevents stuck dead predictions. This hybrid leverages PC-based reuse, streaming detection, and dead-block approximation, improving performance for both regular and irregular workloads, while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/016_01_ship_streaming_deadblock_hybrid__ship_sdbh_t04.cc,0.202772547,0.202772547,0%
1979,mcf,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH combines SHiP-lite signature-based insertion, a streaming access detector, and per-block dead-block counters to adaptively manage cache replacement across diverse workloads. SHiP-lite uses compact 6-bit PC signatures with 2-bit saturating outcome counters to bias insertion depth: frequently reused PCs get aggressive retention, while others are inserted at distant RRPV. For streaming or near-monotonic accesses (detected via small per-set address delta history), the policy bypasses or inserts at distant RRPV, minimizing pollution for workloads like lbm. Dead-block counters (2 bits per block) further help identify blocks that are never reused, accelerating their eviction. Periodic decay prevents stuck dead predictions. This hybrid leverages PC-based reuse, streaming detection, and dead-block approximation, improving performance for both regular and irregular workloads, while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/016_01_ship_streaming_deadblock_hybrid__ship_sdbh_t04.cc,0.447921636,0.447921636,0%
1980,milc,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH combines SHiP-lite signature-based insertion, a streaming access detector, and per-block dead-block counters to adaptively manage cache replacement across diverse workloads. SHiP-lite uses compact 6-bit PC signatures with 2-bit saturating outcome counters to bias insertion depth: frequently reused PCs get aggressive retention, while others are inserted at distant RRPV. For streaming or near-monotonic accesses (detected via small per-set address delta history), the policy bypasses or inserts at distant RRPV, minimizing pollution for workloads like lbm. Dead-block counters (2 bits per block) further help identify blocks that are never reused, accelerating their eviction. Periodic decay prevents stuck dead predictions. This hybrid leverages PC-based reuse, streaming detection, and dead-block approximation, improving performance for both regular and irregular workloads, while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/016_01_ship_streaming_deadblock_hybrid__ship_sdbh_t04.cc,0.07450198,0.07450198,0%
1981,omnetpp,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH combines SHiP-lite signature-based insertion, a streaming access detector, and per-block dead-block counters to adaptively manage cache replacement across diverse workloads. SHiP-lite uses compact 6-bit PC signatures with 2-bit saturating outcome counters to bias insertion depth: frequently reused PCs get aggressive retention, while others are inserted at distant RRPV. For streaming or near-monotonic accesses (detected via small per-set address delta history), the policy bypasses or inserts at distant RRPV, minimizing pollution for workloads like lbm. Dead-block counters (2 bits per block) further help identify blocks that are never reused, accelerating their eviction. Periodic decay prevents stuck dead predictions. This hybrid leverages PC-based reuse, streaming detection, and dead-block approximation, improving performance for both regular and irregular workloads, while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/016_01_ship_streaming_deadblock_hybrid__ship_sdbh_t04.cc,0.710809956,0.710809956,0%
1982,all,SHiP-Streaming DeadBlock Hybrid (SHiP-SDBH),"SHiP-SDBH combines SHiP-lite signature-based insertion, a streaming access detector, and per-block dead-block counters to adaptively manage cache replacement across diverse workloads. SHiP-lite uses compact 6-bit PC signatures with 2-bit saturating outcome counters to bias insertion depth: frequently reused PCs get aggressive retention, while others are inserted at distant RRPV. For streaming or near-monotonic accesses (detected via small per-set address delta history), the policy bypasses or inserts at distant RRPV, minimizing pollution for workloads like lbm. Dead-block counters (2 bits per block) further help identify blocks that are never reused, accelerating their eviction. Periodic decay prevents stuck dead predictions. This hybrid leverages PC-based reuse, streaming detection, and dead-block approximation, improving performance for both regular and irregular workloads, while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/016_01_ship_streaming_deadblock_hybrid__ship_sdbh_t04.cc,0.36218138,0.36218138,36%
1983,astar,DRRIP-Streaming Hybrid with Adaptive Bypass (DRRIP-SAB),"DRRIP-SAB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector and adaptive bypass logic. DRRIP uses a small set of leader sets and a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), adapting to workload locality. A per-set streaming detector tracks address strides and, when streaming is detected, triggers block bypass (no insertion) or distant RRPV insertion, minimizing pollution for workloads like lbm and mcf. This hybrid approach leverages DRRIP’s proven adaptability for mixed locality and the streaming detector’s ability to avoid cache pollution, improving hit rates for both regular and irregular workloads. Metadata is kept compact: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and 2-bit streaming counters per set, well under 64 KiB.",,ChampSim_CRC2/new_policies/017_00_drrip_streaming_hybrid_with_adaptive_bypass__drrip_sab_t02.cc,0.432050773,0.432050773,0%
1984,lbm,DRRIP-Streaming Hybrid with Adaptive Bypass (DRRIP-SAB),"DRRIP-SAB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector and adaptive bypass logic. DRRIP uses a small set of leader sets and a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), adapting to workload locality. A per-set streaming detector tracks address strides and, when streaming is detected, triggers block bypass (no insertion) or distant RRPV insertion, minimizing pollution for workloads like lbm and mcf. This hybrid approach leverages DRRIP’s proven adaptability for mixed locality and the streaming detector’s ability to avoid cache pollution, improving hit rates for both regular and irregular workloads. Metadata is kept compact: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and 2-bit streaming counters per set, well under 64 KiB.",,ChampSim_CRC2/new_policies/017_00_drrip_streaming_hybrid_with_adaptive_bypass__drrip_sab_t02.cc,0.408476613,0.408476613,0%
1985,mcf,DRRIP-Streaming Hybrid with Adaptive Bypass (DRRIP-SAB),"DRRIP-SAB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector and adaptive bypass logic. DRRIP uses a small set of leader sets and a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), adapting to workload locality. A per-set streaming detector tracks address strides and, when streaming is detected, triggers block bypass (no insertion) or distant RRPV insertion, minimizing pollution for workloads like lbm and mcf. This hybrid approach leverages DRRIP’s proven adaptability for mixed locality and the streaming detector’s ability to avoid cache pollution, improving hit rates for both regular and irregular workloads. Metadata is kept compact: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and 2-bit streaming counters per set, well under 64 KiB.",,ChampSim_CRC2/new_policies/017_00_drrip_streaming_hybrid_with_adaptive_bypass__drrip_sab_t02.cc,0.460831914,0.460831914,0%
1986,milc,DRRIP-Streaming Hybrid with Adaptive Bypass (DRRIP-SAB),"DRRIP-SAB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector and adaptive bypass logic. DRRIP uses a small set of leader sets and a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), adapting to workload locality. A per-set streaming detector tracks address strides and, when streaming is detected, triggers block bypass (no insertion) or distant RRPV insertion, minimizing pollution for workloads like lbm and mcf. This hybrid approach leverages DRRIP’s proven adaptability for mixed locality and the streaming detector’s ability to avoid cache pollution, improving hit rates for both regular and irregular workloads. Metadata is kept compact: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and 2-bit streaming counters per set, well under 64 KiB.",,ChampSim_CRC2/new_policies/017_00_drrip_streaming_hybrid_with_adaptive_bypass__drrip_sab_t02.cc,0.307932106,0.307932106,0%
1987,omnetpp,DRRIP-Streaming Hybrid with Adaptive Bypass (DRRIP-SAB),"DRRIP-SAB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector and adaptive bypass logic. DRRIP uses a small set of leader sets and a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), adapting to workload locality. A per-set streaming detector tracks address strides and, when streaming is detected, triggers block bypass (no insertion) or distant RRPV insertion, minimizing pollution for workloads like lbm and mcf. This hybrid approach leverages DRRIP’s proven adaptability for mixed locality and the streaming detector’s ability to avoid cache pollution, improving hit rates for both regular and irregular workloads. Metadata is kept compact: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and 2-bit streaming counters per set, well under 64 KiB.",,ChampSim_CRC2/new_policies/017_00_drrip_streaming_hybrid_with_adaptive_bypass__drrip_sab_t02.cc,0.458249578,0.458249578,0%
1988,astar,DRRIP-Streaming Hybrid (DRRIP-SH),"DRRIP-SH combines Dynamic RRIP (DRRIP) with a lightweight streaming detector to adapt insertion depth based on both global workload behavior and local access patterns. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using set-dueling and a global 10-bit PSEL counter, adapting to workloads with varying locality. To further reduce cache pollution from streaming or near-monotonic access patterns (e.g., lbm), a compact per-set streaming detector monitors address strides and, when streaming is detected, forces distant RRPV insertion or bypasses the cache. This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (e.g., mcf, omnetpp, milc, astar) while actively mitigating streaming pollution for regular workloads. All metadata fits within 64 KiB: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and a 2-bit streaming counter per set.",,ChampSim_CRC2/new_policies/017_01_drrip_streaming_hybrid__drrip_sh_t04.cc,0.342977044,0.342977044,0%
1989,lbm,DRRIP-Streaming Hybrid (DRRIP-SH),"DRRIP-SH combines Dynamic RRIP (DRRIP) with a lightweight streaming detector to adapt insertion depth based on both global workload behavior and local access patterns. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using set-dueling and a global 10-bit PSEL counter, adapting to workloads with varying locality. To further reduce cache pollution from streaming or near-monotonic access patterns (e.g., lbm), a compact per-set streaming detector monitors address strides and, when streaming is detected, forces distant RRPV insertion or bypasses the cache. This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (e.g., mcf, omnetpp, milc, astar) while actively mitigating streaming pollution for regular workloads. All metadata fits within 64 KiB: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and a 2-bit streaming counter per set.",,ChampSim_CRC2/new_policies/017_01_drrip_streaming_hybrid__drrip_sh_t04.cc,0.192595284,0.192595284,0%
1990,mcf,DRRIP-Streaming Hybrid (DRRIP-SH),"DRRIP-SH combines Dynamic RRIP (DRRIP) with a lightweight streaming detector to adapt insertion depth based on both global workload behavior and local access patterns. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using set-dueling and a global 10-bit PSEL counter, adapting to workloads with varying locality. To further reduce cache pollution from streaming or near-monotonic access patterns (e.g., lbm), a compact per-set streaming detector monitors address strides and, when streaming is detected, forces distant RRPV insertion or bypasses the cache. This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (e.g., mcf, omnetpp, milc, astar) while actively mitigating streaming pollution for regular workloads. All metadata fits within 64 KiB: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and a 2-bit streaming counter per set.",,ChampSim_CRC2/new_policies/017_01_drrip_streaming_hybrid__drrip_sh_t04.cc,0.445063159,0.445063159,0%
1991,milc,DRRIP-Streaming Hybrid (DRRIP-SH),"DRRIP-SH combines Dynamic RRIP (DRRIP) with a lightweight streaming detector to adapt insertion depth based on both global workload behavior and local access patterns. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using set-dueling and a global 10-bit PSEL counter, adapting to workloads with varying locality. To further reduce cache pollution from streaming or near-monotonic access patterns (e.g., lbm), a compact per-set streaming detector monitors address strides and, when streaming is detected, forces distant RRPV insertion or bypasses the cache. This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (e.g., mcf, omnetpp, milc, astar) while actively mitigating streaming pollution for regular workloads. All metadata fits within 64 KiB: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and a 2-bit streaming counter per set.",,ChampSim_CRC2/new_policies/017_01_drrip_streaming_hybrid__drrip_sh_t04.cc,0.079891308,0.079891308,0%
1992,omnetpp,DRRIP-Streaming Hybrid (DRRIP-SH),"DRRIP-SH combines Dynamic RRIP (DRRIP) with a lightweight streaming detector to adapt insertion depth based on both global workload behavior and local access patterns. DRRIP dynamically chooses between SRRIP (aggressive retention) and BRRIP (mostly distant insertion) using set-dueling and a global 10-bit PSEL counter, adapting to workloads with varying locality. To further reduce cache pollution from streaming or near-monotonic access patterns (e.g., lbm), a compact per-set streaming detector monitors address strides and, when streaming is detected, forces distant RRPV insertion or bypasses the cache. This hybrid approach improves performance by leveraging DRRIP's adaptability for irregular workloads (e.g., mcf, omnetpp, milc, astar) while actively mitigating streaming pollution for regular workloads. All metadata fits within 64 KiB: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and a 2-bit streaming counter per set.",,ChampSim_CRC2/new_policies/017_01_drrip_streaming_hybrid__drrip_sh_t04.cc,0.844277696,0.844277696,0%
1993,all,DRRIP-Streaming Hybrid with Adaptive Bypass (DRRIP-SAB),"DRRIP-SAB combines Dynamic RRIP (SRRIP vs BRRIP) set-dueling with a lightweight streaming detector and adaptive bypass logic. DRRIP uses a small set of leader sets and a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), adapting to workload locality. A per-set streaming detector tracks address strides and, when streaming is detected, triggers block bypass (no insertion) or distant RRPV insertion, minimizing pollution for workloads like lbm and mcf. This hybrid approach leverages DRRIP’s proven adaptability for mixed locality and the streaming detector’s ability to avoid cache pollution, improving hit rates for both regular and irregular workloads. Metadata is kept compact: 2-bit RRPV per block, 10-bit PSEL, 64 leader sets, and 2-bit streaming counters per set, well under 64 KiB.",,ChampSim_CRC2/new_policies/017_00_drrip_streaming_hybrid_with_adaptive_bypass__drrip_sab_t02.cc,0.413508197,0.413508197,41%
1994,astar,SHiP-Lite with Dead-Block Decay (SHiP-DBD),"SHiP-Lite with Dead-Block Decay (SHiP-DBD) combines lightweight signature-based insertion control with per-block dead-block prediction to adaptively manage cache retention. Each cache block tracks a compact 2-bit dead-counter, which is periodically decayed to approximate block ""deadness"" and bias victim selection toward likely non-reused lines. On fills, a 6-bit PC signature indexes a small outcome table (2-bit counters per signature) to predict whether the block should be inserted with high or low priority (MRU or distant RRPV). On hits, the outcome table is updated to reinforce the signature's reuse tendency, and the dead-counter is reset to indicate liveness. This hybrid approach enables phase-aware retention (via SHiP) and fine-grained dead-block eviction (via decay), improving hit rates for workloads with mixed or irregular locality (e.g., astar, mcf, milc, omnetpp) while retaining spatial reuse for regular workloads (e.g., lbm). Total metadata is compact: 2 bits per block (dead-counter), 2 bits per block (RRPV), 6 bits per block (signature), and a 2K-entry signature table (2 bits per entry), well under 64 KiB.",,ChampSim_CRC2/new_policies/019_01_ship_lite_with_dead_block_decay__ship_dbd_t04.cc,0.459535217,0.459535217,0%
1995,lbm,SHiP-Lite with Dead-Block Decay (SHiP-DBD),"SHiP-Lite with Dead-Block Decay (SHiP-DBD) combines lightweight signature-based insertion control with per-block dead-block prediction to adaptively manage cache retention. Each cache block tracks a compact 2-bit dead-counter, which is periodically decayed to approximate block ""deadness"" and bias victim selection toward likely non-reused lines. On fills, a 6-bit PC signature indexes a small outcome table (2-bit counters per signature) to predict whether the block should be inserted with high or low priority (MRU or distant RRPV). On hits, the outcome table is updated to reinforce the signature's reuse tendency, and the dead-counter is reset to indicate liveness. This hybrid approach enables phase-aware retention (via SHiP) and fine-grained dead-block eviction (via decay), improving hit rates for workloads with mixed or irregular locality (e.g., astar, mcf, milc, omnetpp) while retaining spatial reuse for regular workloads (e.g., lbm). Total metadata is compact: 2 bits per block (dead-counter), 2 bits per block (RRPV), 6 bits per block (signature), and a 2K-entry signature table (2 bits per entry), well under 64 KiB.",,ChampSim_CRC2/new_policies/019_01_ship_lite_with_dead_block_decay__ship_dbd_t04.cc,0.174519062,0.174519062,0%
1996,mcf,SHiP-Lite with Dead-Block Decay (SHiP-DBD),"SHiP-Lite with Dead-Block Decay (SHiP-DBD) combines lightweight signature-based insertion control with per-block dead-block prediction to adaptively manage cache retention. Each cache block tracks a compact 2-bit dead-counter, which is periodically decayed to approximate block ""deadness"" and bias victim selection toward likely non-reused lines. On fills, a 6-bit PC signature indexes a small outcome table (2-bit counters per signature) to predict whether the block should be inserted with high or low priority (MRU or distant RRPV). On hits, the outcome table is updated to reinforce the signature's reuse tendency, and the dead-counter is reset to indicate liveness. This hybrid approach enables phase-aware retention (via SHiP) and fine-grained dead-block eviction (via decay), improving hit rates for workloads with mixed or irregular locality (e.g., astar, mcf, milc, omnetpp) while retaining spatial reuse for regular workloads (e.g., lbm). Total metadata is compact: 2 bits per block (dead-counter), 2 bits per block (RRPV), 6 bits per block (signature), and a 2K-entry signature table (2 bits per entry), well under 64 KiB.",,ChampSim_CRC2/new_policies/019_01_ship_lite_with_dead_block_decay__ship_dbd_t04.cc,0.403102437,0.403102437,0%
1997,milc,SHiP-Lite with Dead-Block Decay (SHiP-DBD),"SHiP-Lite with Dead-Block Decay (SHiP-DBD) combines lightweight signature-based insertion control with per-block dead-block prediction to adaptively manage cache retention. Each cache block tracks a compact 2-bit dead-counter, which is periodically decayed to approximate block ""deadness"" and bias victim selection toward likely non-reused lines. On fills, a 6-bit PC signature indexes a small outcome table (2-bit counters per signature) to predict whether the block should be inserted with high or low priority (MRU or distant RRPV). On hits, the outcome table is updated to reinforce the signature's reuse tendency, and the dead-counter is reset to indicate liveness. This hybrid approach enables phase-aware retention (via SHiP) and fine-grained dead-block eviction (via decay), improving hit rates for workloads with mixed or irregular locality (e.g., astar, mcf, milc, omnetpp) while retaining spatial reuse for regular workloads (e.g., lbm). Total metadata is compact: 2 bits per block (dead-counter), 2 bits per block (RRPV), 6 bits per block (signature), and a 2K-entry signature table (2 bits per entry), well under 64 KiB.",,ChampSim_CRC2/new_policies/019_01_ship_lite_with_dead_block_decay__ship_dbd_t04.cc,0.036001868,0.036001868,0%
1998,omnetpp,SHiP-Lite with Dead-Block Decay (SHiP-DBD),"SHiP-Lite with Dead-Block Decay (SHiP-DBD) combines lightweight signature-based insertion control with per-block dead-block prediction to adaptively manage cache retention. Each cache block tracks a compact 2-bit dead-counter, which is periodically decayed to approximate block ""deadness"" and bias victim selection toward likely non-reused lines. On fills, a 6-bit PC signature indexes a small outcome table (2-bit counters per signature) to predict whether the block should be inserted with high or low priority (MRU or distant RRPV). On hits, the outcome table is updated to reinforce the signature's reuse tendency, and the dead-counter is reset to indicate liveness. This hybrid approach enables phase-aware retention (via SHiP) and fine-grained dead-block eviction (via decay), improving hit rates for workloads with mixed or irregular locality (e.g., astar, mcf, milc, omnetpp) while retaining spatial reuse for regular workloads (e.g., lbm). Total metadata is compact: 2 bits per block (dead-counter), 2 bits per block (RRPV), 6 bits per block (signature), and a 2K-entry signature table (2 bits per entry), well under 64 KiB.",,ChampSim_CRC2/new_policies/019_01_ship_lite_with_dead_block_decay__ship_dbd_t04.cc,0.531747499,0.531747499,0%
1999,all,SHiP-Lite with Dead-Block Decay (SHiP-DBD),"SHiP-Lite with Dead-Block Decay (SHiP-DBD) combines lightweight signature-based insertion control with per-block dead-block prediction to adaptively manage cache retention. Each cache block tracks a compact 2-bit dead-counter, which is periodically decayed to approximate block ""deadness"" and bias victim selection toward likely non-reused lines. On fills, a 6-bit PC signature indexes a small outcome table (2-bit counters per signature) to predict whether the block should be inserted with high or low priority (MRU or distant RRPV). On hits, the outcome table is updated to reinforce the signature's reuse tendency, and the dead-counter is reset to indicate liveness. This hybrid approach enables phase-aware retention (via SHiP) and fine-grained dead-block eviction (via decay), improving hit rates for workloads with mixed or irregular locality (e.g., astar, mcf, milc, omnetpp) while retaining spatial reuse for regular workloads (e.g., lbm). Total metadata is compact: 2 bits per block (dead-counter), 2 bits per block (RRPV), 6 bits per block (signature), and a 2K-entry signature table (2 bits per entry), well under 64 KiB.",,ChampSim_CRC2/new_policies/019_01_ship_lite_with_dead_block_decay__ship_dbd_t04.cc,0.320981217,0.320981217,32%
2000,astar,DRRIP with Streaming Bypass and Dead-Block Decay (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) for adaptive insertion depth, a lightweight streaming detector to identify streaming (monotonic) access patterns and bypass them, and per-block dead-block decay to accelerate eviction of non-reused lines. DRRIP adapts insertion aggressiveness based on workload phase, improving retention for workloads with reuse (lbm, milc) and early eviction for streaming or pointer-chasing workloads (mcf, omnetpp). The streaming detector uses a small per-set delta history to identify monotonic address streams and triggers bypass or distant insertion for those blocks, reducing pollution. Dead-block counters (2 bits per block, decayed periodically) further bias victim selection toward blocks unlikely to be reused. This hybrid approach improves hit rates across diverse workloads by combining adaptive insertion, streaming awareness, and fine-grained dead-block eviction, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/020_01_drrip_with_streaming_bypass_and_dead_block_decay__drrip_sbd_t04.cc,0.429982176,0.429982176,0%
2001,lbm,DRRIP with Streaming Bypass and Dead-Block Decay (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) for adaptive insertion depth, a lightweight streaming detector to identify streaming (monotonic) access patterns and bypass them, and per-block dead-block decay to accelerate eviction of non-reused lines. DRRIP adapts insertion aggressiveness based on workload phase, improving retention for workloads with reuse (lbm, milc) and early eviction for streaming or pointer-chasing workloads (mcf, omnetpp). The streaming detector uses a small per-set delta history to identify monotonic address streams and triggers bypass or distant insertion for those blocks, reducing pollution. Dead-block counters (2 bits per block, decayed periodically) further bias victim selection toward blocks unlikely to be reused. This hybrid approach improves hit rates across diverse workloads by combining adaptive insertion, streaming awareness, and fine-grained dead-block eviction, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/020_01_drrip_with_streaming_bypass_and_dead_block_decay__drrip_sbd_t04.cc,0.408509905,0.408509905,0%
2002,mcf,DRRIP with Streaming Bypass and Dead-Block Decay (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) for adaptive insertion depth, a lightweight streaming detector to identify streaming (monotonic) access patterns and bypass them, and per-block dead-block decay to accelerate eviction of non-reused lines. DRRIP adapts insertion aggressiveness based on workload phase, improving retention for workloads with reuse (lbm, milc) and early eviction for streaming or pointer-chasing workloads (mcf, omnetpp). The streaming detector uses a small per-set delta history to identify monotonic address streams and triggers bypass or distant insertion for those blocks, reducing pollution. Dead-block counters (2 bits per block, decayed periodically) further bias victim selection toward blocks unlikely to be reused. This hybrid approach improves hit rates across diverse workloads by combining adaptive insertion, streaming awareness, and fine-grained dead-block eviction, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/020_01_drrip_with_streaming_bypass_and_dead_block_decay__drrip_sbd_t04.cc,0.460630222,0.460630222,0%
2003,milc,DRRIP with Streaming Bypass and Dead-Block Decay (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) for adaptive insertion depth, a lightweight streaming detector to identify streaming (monotonic) access patterns and bypass them, and per-block dead-block decay to accelerate eviction of non-reused lines. DRRIP adapts insertion aggressiveness based on workload phase, improving retention for workloads with reuse (lbm, milc) and early eviction for streaming or pointer-chasing workloads (mcf, omnetpp). The streaming detector uses a small per-set delta history to identify monotonic address streams and triggers bypass or distant insertion for those blocks, reducing pollution. Dead-block counters (2 bits per block, decayed periodically) further bias victim selection toward blocks unlikely to be reused. This hybrid approach improves hit rates across diverse workloads by combining adaptive insertion, streaming awareness, and fine-grained dead-block eviction, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/020_01_drrip_with_streaming_bypass_and_dead_block_decay__drrip_sbd_t04.cc,0.292169634,0.292169634,0%
2004,omnetpp,DRRIP with Streaming Bypass and Dead-Block Decay (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) for adaptive insertion depth, a lightweight streaming detector to identify streaming (monotonic) access patterns and bypass them, and per-block dead-block decay to accelerate eviction of non-reused lines. DRRIP adapts insertion aggressiveness based on workload phase, improving retention for workloads with reuse (lbm, milc) and early eviction for streaming or pointer-chasing workloads (mcf, omnetpp). The streaming detector uses a small per-set delta history to identify monotonic address streams and triggers bypass or distant insertion for those blocks, reducing pollution. Dead-block counters (2 bits per block, decayed periodically) further bias victim selection toward blocks unlikely to be reused. This hybrid approach improves hit rates across diverse workloads by combining adaptive insertion, streaming awareness, and fine-grained dead-block eviction, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/020_01_drrip_with_streaming_bypass_and_dead_block_decay__drrip_sbd_t04.cc,0.831829217,0.831829217,0%
2005,astar,DRRIP with Streaming Detector (DRRIP-SD),"DRRIP-SD combines Dynamic Re-Reference Interval Prediction (DRRIP) with a compact streaming detector to dynamically adjust cache insertion and bypass behavior. DRRIP uses set-dueling and a global 10-bit PSEL counter to select between SRRIP (favoring recency for regular reuse, e.g., lbm, milc) and BRRIP (conservatively inserts at distant positions to avoid pollution from transient blocks, e.g., mcf, omnetpp). To further protect the cache from streaming or nearly-monotonic access patterns (common in astar and parts of lbm), DRRIP-SD uses a lightweight per-set streaming detector (4 bits per set) that tracks address delta monotonicity. When streaming is detected, new blocks are inserted at the most distant RRPV or bypassed entirely, reducing pollution from one-shot accesses. This hybrid approach adapts to both spatially regular and irregular workloads, significantly improving overall hit rate compared to dead-block only schemes. Total metadata: 2 bits/block (RRPV), 4 bits/set (streaming detector), 10 bits (PSEL), 32 leader sets (SRRIP/BRRIP), well under 64 KiB.",,ChampSim_CRC2/new_policies/020_02_drrip_with_streaming_detector__drrip_sd_t07.cc,0.454487307,0.454487307,0%
2006,lbm,DRRIP with Streaming Detector (DRRIP-SD),"DRRIP-SD combines Dynamic Re-Reference Interval Prediction (DRRIP) with a compact streaming detector to dynamically adjust cache insertion and bypass behavior. DRRIP uses set-dueling and a global 10-bit PSEL counter to select between SRRIP (favoring recency for regular reuse, e.g., lbm, milc) and BRRIP (conservatively inserts at distant positions to avoid pollution from transient blocks, e.g., mcf, omnetpp). To further protect the cache from streaming or nearly-monotonic access patterns (common in astar and parts of lbm), DRRIP-SD uses a lightweight per-set streaming detector (4 bits per set) that tracks address delta monotonicity. When streaming is detected, new blocks are inserted at the most distant RRPV or bypassed entirely, reducing pollution from one-shot accesses. This hybrid approach adapts to both spatially regular and irregular workloads, significantly improving overall hit rate compared to dead-block only schemes. Total metadata: 2 bits/block (RRPV), 4 bits/set (streaming detector), 10 bits (PSEL), 32 leader sets (SRRIP/BRRIP), well under 64 KiB.",,ChampSim_CRC2/new_policies/020_02_drrip_with_streaming_detector__drrip_sd_t07.cc,0.439196056,0.439196056,0%
2007,mcf,DRRIP with Streaming Detector (DRRIP-SD),"DRRIP-SD combines Dynamic Re-Reference Interval Prediction (DRRIP) with a compact streaming detector to dynamically adjust cache insertion and bypass behavior. DRRIP uses set-dueling and a global 10-bit PSEL counter to select between SRRIP (favoring recency for regular reuse, e.g., lbm, milc) and BRRIP (conservatively inserts at distant positions to avoid pollution from transient blocks, e.g., mcf, omnetpp). To further protect the cache from streaming or nearly-monotonic access patterns (common in astar and parts of lbm), DRRIP-SD uses a lightweight per-set streaming detector (4 bits per set) that tracks address delta monotonicity. When streaming is detected, new blocks are inserted at the most distant RRPV or bypassed entirely, reducing pollution from one-shot accesses. This hybrid approach adapts to both spatially regular and irregular workloads, significantly improving overall hit rate compared to dead-block only schemes. Total metadata: 2 bits/block (RRPV), 4 bits/set (streaming detector), 10 bits (PSEL), 32 leader sets (SRRIP/BRRIP), well under 64 KiB.",,ChampSim_CRC2/new_policies/020_02_drrip_with_streaming_detector__drrip_sd_t07.cc,0.403482275,0.403482275,0%
2008,milc,DRRIP with Streaming Detector (DRRIP-SD),"DRRIP-SD combines Dynamic Re-Reference Interval Prediction (DRRIP) with a compact streaming detector to dynamically adjust cache insertion and bypass behavior. DRRIP uses set-dueling and a global 10-bit PSEL counter to select between SRRIP (favoring recency for regular reuse, e.g., lbm, milc) and BRRIP (conservatively inserts at distant positions to avoid pollution from transient blocks, e.g., mcf, omnetpp). To further protect the cache from streaming or nearly-monotonic access patterns (common in astar and parts of lbm), DRRIP-SD uses a lightweight per-set streaming detector (4 bits per set) that tracks address delta monotonicity. When streaming is detected, new blocks are inserted at the most distant RRPV or bypassed entirely, reducing pollution from one-shot accesses. This hybrid approach adapts to both spatially regular and irregular workloads, significantly improving overall hit rate compared to dead-block only schemes. Total metadata: 2 bits/block (RRPV), 4 bits/set (streaming detector), 10 bits (PSEL), 32 leader sets (SRRIP/BRRIP), well under 64 KiB.",,ChampSim_CRC2/new_policies/020_02_drrip_with_streaming_detector__drrip_sd_t07.cc,0.321639862,0.321639862,0%
2009,omnetpp,DRRIP with Streaming Detector (DRRIP-SD),"DRRIP-SD combines Dynamic Re-Reference Interval Prediction (DRRIP) with a compact streaming detector to dynamically adjust cache insertion and bypass behavior. DRRIP uses set-dueling and a global 10-bit PSEL counter to select between SRRIP (favoring recency for regular reuse, e.g., lbm, milc) and BRRIP (conservatively inserts at distant positions to avoid pollution from transient blocks, e.g., mcf, omnetpp). To further protect the cache from streaming or nearly-monotonic access patterns (common in astar and parts of lbm), DRRIP-SD uses a lightweight per-set streaming detector (4 bits per set) that tracks address delta monotonicity. When streaming is detected, new blocks are inserted at the most distant RRPV or bypassed entirely, reducing pollution from one-shot accesses. This hybrid approach adapts to both spatially regular and irregular workloads, significantly improving overall hit rate compared to dead-block only schemes. Total metadata: 2 bits/block (RRPV), 4 bits/set (streaming detector), 10 bits (PSEL), 32 leader sets (SRRIP/BRRIP), well under 64 KiB.",,ChampSim_CRC2/new_policies/020_02_drrip_with_streaming_detector__drrip_sd_t07.cc,0.46016427,0.46016427,0%
2010,all,DRRIP with Streaming Bypass and Dead-Block Decay (DRRIP-SBD),"This policy combines Dynamic RRIP (DRRIP) set-dueling (SRRIP vs BRRIP) for adaptive insertion depth, a lightweight streaming detector to identify streaming (monotonic) access patterns and bypass them, and per-block dead-block decay to accelerate eviction of non-reused lines. DRRIP adapts insertion aggressiveness based on workload phase, improving retention for workloads with reuse (lbm, milc) and early eviction for streaming or pointer-chasing workloads (mcf, omnetpp). The streaming detector uses a small per-set delta history to identify monotonic address streams and triggers bypass or distant insertion for those blocks, reducing pollution. Dead-block counters (2 bits per block, decayed periodically) further bias victim selection toward blocks unlikely to be reused. This hybrid approach improves hit rates across diverse workloads by combining adaptive insertion, streaming awareness, and fine-grained dead-block eviction, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/020_01_drrip_with_streaming_bypass_and_dead_block_decay__drrip_sbd_t04.cc,0.484624231,0.484624231,48%
2011,astar,SHiP-Lite with Streaming Bypass and Adaptive Dead-Block Decay (SHiP-SBD),"This policy blends SHiP-lite's PC-based signature prediction with a streaming detector and adaptive dead-block decay to improve cache hit rates across diverse workloads. SHiP-lite tracks a small per-PC signature table (6 bits per entry, 2048 entries) to bias insertion depth: blocks from PCs with high reuse are inserted with low RRPV, while those with low reuse are inserted at distant RRPV. The streaming detector identifies monotonic access patterns and triggers bypass for detected streaming sets, minimizing pollution from workloads like lbm and mcf. Dead-block decay uses a 2-bit counter per block, periodically decremented, to accelerate eviction of non-reused blocks. This combination enables phase-aware retention for milc and astar, aggressive bypass for streaming and pointer-chasing workloads, and fine-grained victim selection, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/021_01_ship_lite_with_streaming_bypass_and_adaptive_dead_block_decay__ship_sbd_t04.cc,0.287617472,0.287617472,0%
2012,lbm,SHiP-Lite with Streaming Bypass and Adaptive Dead-Block Decay (SHiP-SBD),"This policy blends SHiP-lite's PC-based signature prediction with a streaming detector and adaptive dead-block decay to improve cache hit rates across diverse workloads. SHiP-lite tracks a small per-PC signature table (6 bits per entry, 2048 entries) to bias insertion depth: blocks from PCs with high reuse are inserted with low RRPV, while those with low reuse are inserted at distant RRPV. The streaming detector identifies monotonic access patterns and triggers bypass for detected streaming sets, minimizing pollution from workloads like lbm and mcf. Dead-block decay uses a 2-bit counter per block, periodically decremented, to accelerate eviction of non-reused blocks. This combination enables phase-aware retention for milc and astar, aggressive bypass for streaming and pointer-chasing workloads, and fine-grained victim selection, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/021_01_ship_lite_with_streaming_bypass_and_adaptive_dead_block_decay__ship_sbd_t04.cc,0.140685886,0.140685886,0%
2013,mcf,SHiP-Lite with Streaming Bypass and Adaptive Dead-Block Decay (SHiP-SBD),"This policy blends SHiP-lite's PC-based signature prediction with a streaming detector and adaptive dead-block decay to improve cache hit rates across diverse workloads. SHiP-lite tracks a small per-PC signature table (6 bits per entry, 2048 entries) to bias insertion depth: blocks from PCs with high reuse are inserted with low RRPV, while those with low reuse are inserted at distant RRPV. The streaming detector identifies monotonic access patterns and triggers bypass for detected streaming sets, minimizing pollution from workloads like lbm and mcf. Dead-block decay uses a 2-bit counter per block, periodically decremented, to accelerate eviction of non-reused blocks. This combination enables phase-aware retention for milc and astar, aggressive bypass for streaming and pointer-chasing workloads, and fine-grained victim selection, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/021_01_ship_lite_with_streaming_bypass_and_adaptive_dead_block_decay__ship_sbd_t04.cc,0.519312394,0.519312394,0%
2014,milc,SHiP-Lite with Streaming Bypass and Adaptive Dead-Block Decay (SHiP-SBD),"This policy blends SHiP-lite's PC-based signature prediction with a streaming detector and adaptive dead-block decay to improve cache hit rates across diverse workloads. SHiP-lite tracks a small per-PC signature table (6 bits per entry, 2048 entries) to bias insertion depth: blocks from PCs with high reuse are inserted with low RRPV, while those with low reuse are inserted at distant RRPV. The streaming detector identifies monotonic access patterns and triggers bypass for detected streaming sets, minimizing pollution from workloads like lbm and mcf. Dead-block decay uses a 2-bit counter per block, periodically decremented, to accelerate eviction of non-reused blocks. This combination enables phase-aware retention for milc and astar, aggressive bypass for streaming and pointer-chasing workloads, and fine-grained victim selection, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/021_01_ship_lite_with_streaming_bypass_and_adaptive_dead_block_decay__ship_sbd_t04.cc,0.072680797,0.072680797,0%
2015,omnetpp,SHiP-Lite with Streaming Bypass and Adaptive Dead-Block Decay (SHiP-SBD),"This policy blends SHiP-lite's PC-based signature prediction with a streaming detector and adaptive dead-block decay to improve cache hit rates across diverse workloads. SHiP-lite tracks a small per-PC signature table (6 bits per entry, 2048 entries) to bias insertion depth: blocks from PCs with high reuse are inserted with low RRPV, while those with low reuse are inserted at distant RRPV. The streaming detector identifies monotonic access patterns and triggers bypass for detected streaming sets, minimizing pollution from workloads like lbm and mcf. Dead-block decay uses a 2-bit counter per block, periodically decremented, to accelerate eviction of non-reused blocks. This combination enables phase-aware retention for milc and astar, aggressive bypass for streaming and pointer-chasing workloads, and fine-grained victim selection, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/021_01_ship_lite_with_streaming_bypass_and_adaptive_dead_block_decay__ship_sbd_t04.cc,0.704147306,0.704147306,0%
2016,all,SHiP-Lite with Streaming Bypass and Adaptive Dead-Block Decay (SHiP-SBD),"This policy blends SHiP-lite's PC-based signature prediction with a streaming detector and adaptive dead-block decay to improve cache hit rates across diverse workloads. SHiP-lite tracks a small per-PC signature table (6 bits per entry, 2048 entries) to bias insertion depth: blocks from PCs with high reuse are inserted with low RRPV, while those with low reuse are inserted at distant RRPV. The streaming detector identifies monotonic access patterns and triggers bypass for detected streaming sets, minimizing pollution from workloads like lbm and mcf. Dead-block decay uses a 2-bit counter per block, periodically decremented, to accelerate eviction of non-reused blocks. This combination enables phase-aware retention for milc and astar, aggressive bypass for streaming and pointer-chasing workloads, and fine-grained victim selection, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/021_01_ship_lite_with_streaming_bypass_and_adaptive_dead_block_decay__ship_sbd_t04.cc,0.344888771,0.344888771,34%
2017,astar,DRRIP with Streaming Bypass and DIP-style Leader Set Insertion (DRRIP-SB-DIP),"This policy combines DRRIP's dynamic insertion depth control (SRRIP vs BRRIP) with DIP-style leader sets and a streaming detector that triggers bypass for monotonic access patterns. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to select between SRRIP (insert at distant RRPV) and BRRIP (insert at MRU with low probability), adapting to workload locality. DIP-style leader sets (64 sets) track which insertion policy works best, steering PSEL updates. The streaming detector monitors address deltas per set and bypasses cache insertion for detected streaming accesses, reducing pollution from workloads like lbm and mcf. This approach improves performance by dynamically adapting insertion policy to workload phase and aggressively bypassing streaming accesses, while maintaining a compact metadata footprint (<64 KiB). It is robust across diverse workloads, handling both spatial locality and irregular pointer-chasing patterns.",,ChampSim_CRC2/new_policies/022_00_drrip_with_streaming_bypass_and_dip_style_leader_set_insertion__drrip_sb_dip_t02.cc,0.433237891,0.433237891,0%
2018,lbm,DRRIP with Streaming Bypass and DIP-style Leader Set Insertion (DRRIP-SB-DIP),"This policy combines DRRIP's dynamic insertion depth control (SRRIP vs BRRIP) with DIP-style leader sets and a streaming detector that triggers bypass for monotonic access patterns. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to select between SRRIP (insert at distant RRPV) and BRRIP (insert at MRU with low probability), adapting to workload locality. DIP-style leader sets (64 sets) track which insertion policy works best, steering PSEL updates. The streaming detector monitors address deltas per set and bypasses cache insertion for detected streaming accesses, reducing pollution from workloads like lbm and mcf. This approach improves performance by dynamically adapting insertion policy to workload phase and aggressively bypassing streaming accesses, while maintaining a compact metadata footprint (<64 KiB). It is robust across diverse workloads, handling both spatial locality and irregular pointer-chasing patterns.",,ChampSim_CRC2/new_policies/022_00_drrip_with_streaming_bypass_and_dip_style_leader_set_insertion__drrip_sb_dip_t02.cc,0.413264698,0.413264698,0%
2019,mcf,DRRIP with Streaming Bypass and DIP-style Leader Set Insertion (DRRIP-SB-DIP),"This policy combines DRRIP's dynamic insertion depth control (SRRIP vs BRRIP) with DIP-style leader sets and a streaming detector that triggers bypass for monotonic access patterns. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to select between SRRIP (insert at distant RRPV) and BRRIP (insert at MRU with low probability), adapting to workload locality. DIP-style leader sets (64 sets) track which insertion policy works best, steering PSEL updates. The streaming detector monitors address deltas per set and bypasses cache insertion for detected streaming accesses, reducing pollution from workloads like lbm and mcf. This approach improves performance by dynamically adapting insertion policy to workload phase and aggressively bypassing streaming accesses, while maintaining a compact metadata footprint (<64 KiB). It is robust across diverse workloads, handling both spatial locality and irregular pointer-chasing patterns.",,ChampSim_CRC2/new_policies/022_00_drrip_with_streaming_bypass_and_dip_style_leader_set_insertion__drrip_sb_dip_t02.cc,0.459439997,0.459439997,0%
2020,milc,DRRIP with Streaming Bypass and DIP-style Leader Set Insertion (DRRIP-SB-DIP),"This policy combines DRRIP's dynamic insertion depth control (SRRIP vs BRRIP) with DIP-style leader sets and a streaming detector that triggers bypass for monotonic access patterns. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to select between SRRIP (insert at distant RRPV) and BRRIP (insert at MRU with low probability), adapting to workload locality. DIP-style leader sets (64 sets) track which insertion policy works best, steering PSEL updates. The streaming detector monitors address deltas per set and bypasses cache insertion for detected streaming accesses, reducing pollution from workloads like lbm and mcf. This approach improves performance by dynamically adapting insertion policy to workload phase and aggressively bypassing streaming accesses, while maintaining a compact metadata footprint (<64 KiB). It is robust across diverse workloads, handling both spatial locality and irregular pointer-chasing patterns.",,ChampSim_CRC2/new_policies/022_00_drrip_with_streaming_bypass_and_dip_style_leader_set_insertion__drrip_sb_dip_t02.cc,0.311301114,0.311301114,0%
2021,omnetpp,DRRIP with Streaming Bypass and DIP-style Leader Set Insertion (DRRIP-SB-DIP),"This policy combines DRRIP's dynamic insertion depth control (SRRIP vs BRRIP) with DIP-style leader sets and a streaming detector that triggers bypass for monotonic access patterns. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to select between SRRIP (insert at distant RRPV) and BRRIP (insert at MRU with low probability), adapting to workload locality. DIP-style leader sets (64 sets) track which insertion policy works best, steering PSEL updates. The streaming detector monitors address deltas per set and bypasses cache insertion for detected streaming accesses, reducing pollution from workloads like lbm and mcf. This approach improves performance by dynamically adapting insertion policy to workload phase and aggressively bypassing streaming accesses, while maintaining a compact metadata footprint (<64 KiB). It is robust across diverse workloads, handling both spatial locality and irregular pointer-chasing patterns.",,ChampSim_CRC2/new_policies/022_00_drrip_with_streaming_bypass_and_dip_style_leader_set_insertion__drrip_sb_dip_t02.cc,0.473429923,0.473429923,0%
2022,astar,DRRIP-Stream: Dynamic RRIP with Streaming Bypass and Set-Dueling,"DRRIP-Stream combines Dynamic RRIP (SRRIP vs. BRRIP) with a lightweight streaming detector and set-dueling to adapt insertion depth based on workload behavior. The policy uses a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), guided by 64 leader sets. For each set, a simple streaming detector tracks monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution from pointer-chasing and streaming workloads like mcf and lbm. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits streaming confidence per set, and a global PSEL counter. This approach improves performance by dynamically tuning insertion depth for mixed locality workloads (milc, astar, omnetpp), while aggressively bypassing cache for streaming phases, achieving robust hit rates across diverse patterns.",,ChampSim_CRC2/new_policies/022_01_drrip_stream__dynamic_rrip_with_streaming_bypass_and_set_dueling_t04.cc,0.429819168,0.429819168,0%
2023,lbm,DRRIP-Stream: Dynamic RRIP with Streaming Bypass and Set-Dueling,"DRRIP-Stream combines Dynamic RRIP (SRRIP vs. BRRIP) with a lightweight streaming detector and set-dueling to adapt insertion depth based on workload behavior. The policy uses a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), guided by 64 leader sets. For each set, a simple streaming detector tracks monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution from pointer-chasing and streaming workloads like mcf and lbm. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits streaming confidence per set, and a global PSEL counter. This approach improves performance by dynamically tuning insertion depth for mixed locality workloads (milc, astar, omnetpp), while aggressively bypassing cache for streaming phases, achieving robust hit rates across diverse patterns.",,ChampSim_CRC2/new_policies/022_01_drrip_stream__dynamic_rrip_with_streaming_bypass_and_set_dueling_t04.cc,0.390541996,0.390541996,0%
2024,mcf,DRRIP-Stream: Dynamic RRIP with Streaming Bypass and Set-Dueling,"DRRIP-Stream combines Dynamic RRIP (SRRIP vs. BRRIP) with a lightweight streaming detector and set-dueling to adapt insertion depth based on workload behavior. The policy uses a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), guided by 64 leader sets. For each set, a simple streaming detector tracks monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution from pointer-chasing and streaming workloads like mcf and lbm. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits streaming confidence per set, and a global PSEL counter. This approach improves performance by dynamically tuning insertion depth for mixed locality workloads (milc, astar, omnetpp), while aggressively bypassing cache for streaming phases, achieving robust hit rates across diverse patterns.",,ChampSim_CRC2/new_policies/022_01_drrip_stream__dynamic_rrip_with_streaming_bypass_and_set_dueling_t04.cc,0.456016986,0.456016986,0%
2025,milc,DRRIP-Stream: Dynamic RRIP with Streaming Bypass and Set-Dueling,"DRRIP-Stream combines Dynamic RRIP (SRRIP vs. BRRIP) with a lightweight streaming detector and set-dueling to adapt insertion depth based on workload behavior. The policy uses a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), guided by 64 leader sets. For each set, a simple streaming detector tracks monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution from pointer-chasing and streaming workloads like mcf and lbm. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits streaming confidence per set, and a global PSEL counter. This approach improves performance by dynamically tuning insertion depth for mixed locality workloads (milc, astar, omnetpp), while aggressively bypassing cache for streaming phases, achieving robust hit rates across diverse patterns.",,ChampSim_CRC2/new_policies/022_01_drrip_stream__dynamic_rrip_with_streaming_bypass_and_set_dueling_t04.cc,0.30187658,0.30187658,0%
2026,omnetpp,DRRIP-Stream: Dynamic RRIP with Streaming Bypass and Set-Dueling,"DRRIP-Stream combines Dynamic RRIP (SRRIP vs. BRRIP) with a lightweight streaming detector and set-dueling to adapt insertion depth based on workload behavior. The policy uses a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), guided by 64 leader sets. For each set, a simple streaming detector tracks monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution from pointer-chasing and streaming workloads like mcf and lbm. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits streaming confidence per set, and a global PSEL counter. This approach improves performance by dynamically tuning insertion depth for mixed locality workloads (milc, astar, omnetpp), while aggressively bypassing cache for streaming phases, achieving robust hit rates across diverse patterns.",,ChampSim_CRC2/new_policies/022_01_drrip_stream__dynamic_rrip_with_streaming_bypass_and_set_dueling_t04.cc,0.832503236,0.832503236,0%
2027,astar,DRRIP-LIP Hybrid with Streaming Bypass (DLHB),"DLHB combines Dynamic RRIP (DRRIP) set-dueling with a DIP-style leader set mechanism, enabling adaptive selection between SRRIP and LIP insertion depth based on workload phase. Critically, it replaces the previous PC-based SHiP prediction with a compact set-dueling PSEL counter (10 bits) and leader sets that steer insertion policy globally. To further reduce cache pollution from streaming and pointer-chasing workloads like lbm and mcf, DLHB includes a lightweight streaming detector per set that triggers full bypass for detected streaming sets. Per-block metadata consists only of 2-bit RRPV, minimizing overhead. DLHB dynamically shifts between recency- and MRU-oriented insertion, aggressively bypasses streaming accesses, and leverages set-dueling to adapt to changing workload characteristics—all within a compact metadata budget (<10 KiB). This materially changes the prediction source and insertion depth logic compared to prior SHiP-based designs.",,ChampSim_CRC2/new_policies/022_02_drrip_lip_hybrid_with_streaming_bypass__dlhb_t07.cc,0.300138025,0.300138025,0%
2028,lbm,DRRIP-LIP Hybrid with Streaming Bypass (DLHB),"DLHB combines Dynamic RRIP (DRRIP) set-dueling with a DIP-style leader set mechanism, enabling adaptive selection between SRRIP and LIP insertion depth based on workload phase. Critically, it replaces the previous PC-based SHiP prediction with a compact set-dueling PSEL counter (10 bits) and leader sets that steer insertion policy globally. To further reduce cache pollution from streaming and pointer-chasing workloads like lbm and mcf, DLHB includes a lightweight streaming detector per set that triggers full bypass for detected streaming sets. Per-block metadata consists only of 2-bit RRPV, minimizing overhead. DLHB dynamically shifts between recency- and MRU-oriented insertion, aggressively bypasses streaming accesses, and leverages set-dueling to adapt to changing workload characteristics—all within a compact metadata budget (<10 KiB). This materially changes the prediction source and insertion depth logic compared to prior SHiP-based designs.",,ChampSim_CRC2/new_policies/022_02_drrip_lip_hybrid_with_streaming_bypass__dlhb_t07.cc,0.168415036,0.168415036,0%
2029,mcf,DRRIP-LIP Hybrid with Streaming Bypass (DLHB),"DLHB combines Dynamic RRIP (DRRIP) set-dueling with a DIP-style leader set mechanism, enabling adaptive selection between SRRIP and LIP insertion depth based on workload phase. Critically, it replaces the previous PC-based SHiP prediction with a compact set-dueling PSEL counter (10 bits) and leader sets that steer insertion policy globally. To further reduce cache pollution from streaming and pointer-chasing workloads like lbm and mcf, DLHB includes a lightweight streaming detector per set that triggers full bypass for detected streaming sets. Per-block metadata consists only of 2-bit RRPV, minimizing overhead. DLHB dynamically shifts between recency- and MRU-oriented insertion, aggressively bypasses streaming accesses, and leverages set-dueling to adapt to changing workload characteristics—all within a compact metadata budget (<10 KiB). This materially changes the prediction source and insertion depth logic compared to prior SHiP-based designs.",,ChampSim_CRC2/new_policies/022_02_drrip_lip_hybrid_with_streaming_bypass__dlhb_t07.cc,0.399845745,0.399845745,0%
2030,milc,DRRIP-LIP Hybrid with Streaming Bypass (DLHB),"DLHB combines Dynamic RRIP (DRRIP) set-dueling with a DIP-style leader set mechanism, enabling adaptive selection between SRRIP and LIP insertion depth based on workload phase. Critically, it replaces the previous PC-based SHiP prediction with a compact set-dueling PSEL counter (10 bits) and leader sets that steer insertion policy globally. To further reduce cache pollution from streaming and pointer-chasing workloads like lbm and mcf, DLHB includes a lightweight streaming detector per set that triggers full bypass for detected streaming sets. Per-block metadata consists only of 2-bit RRPV, minimizing overhead. DLHB dynamically shifts between recency- and MRU-oriented insertion, aggressively bypasses streaming accesses, and leverages set-dueling to adapt to changing workload characteristics—all within a compact metadata budget (<10 KiB). This materially changes the prediction source and insertion depth logic compared to prior SHiP-based designs.",,ChampSim_CRC2/new_policies/022_02_drrip_lip_hybrid_with_streaming_bypass__dlhb_t07.cc,0.069662991,0.069662991,0%
2031,omnetpp,DRRIP-LIP Hybrid with Streaming Bypass (DLHB),"DLHB combines Dynamic RRIP (DRRIP) set-dueling with a DIP-style leader set mechanism, enabling adaptive selection between SRRIP and LIP insertion depth based on workload phase. Critically, it replaces the previous PC-based SHiP prediction with a compact set-dueling PSEL counter (10 bits) and leader sets that steer insertion policy globally. To further reduce cache pollution from streaming and pointer-chasing workloads like lbm and mcf, DLHB includes a lightweight streaming detector per set that triggers full bypass for detected streaming sets. Per-block metadata consists only of 2-bit RRPV, minimizing overhead. DLHB dynamically shifts between recency- and MRU-oriented insertion, aggressively bypasses streaming accesses, and leverages set-dueling to adapt to changing workload characteristics—all within a compact metadata budget (<10 KiB). This materially changes the prediction source and insertion depth logic compared to prior SHiP-based designs.",,ChampSim_CRC2/new_policies/022_02_drrip_lip_hybrid_with_streaming_bypass__dlhb_t07.cc,0.601702346,0.601702346,0%
2032,all,DRRIP-Stream: Dynamic RRIP with Streaming Bypass and Set-Dueling,"DRRIP-Stream combines Dynamic RRIP (SRRIP vs. BRRIP) with a lightweight streaming detector and set-dueling to adapt insertion depth based on workload behavior. The policy uses a 10-bit PSEL counter to select between SRRIP (aggressive retention) and BRRIP (mostly distant insertion), guided by 64 leader sets. For each set, a simple streaming detector tracks monotonic address deltas and triggers bypass for detected streaming sets, minimizing pollution from pointer-chasing and streaming workloads like mcf and lbm. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits streaming confidence per set, and a global PSEL counter. This approach improves performance by dynamically tuning insertion depth for mixed locality workloads (milc, astar, omnetpp), while aggressively bypassing cache for streaming phases, achieving robust hit rates across diverse patterns.",,ChampSim_CRC2/new_policies/022_01_drrip_stream__dynamic_rrip_with_streaming_bypass_and_set_dueling_t04.cc,0.482151593,0.482151593,48%
2033,astar,SHiP-Stream-DIP: Signature-based Hit Predictor with Streaming Bypass and Dynamic Insertion Policy,"SHiP-Stream-DIP combines PC-based signature prediction (SHiP-lite), a streaming detector, and DIP-style insertion control to adaptively optimize cache retention and bypass decisions. Each cache line tracks a compact 6-bit PC signature and a 2-bit outcome counter, biasing insertion depth toward blocks with demonstrated reuse. A per-set streaming detector identifies monotonic address patterns and triggers bypass for streaming sets, minimizing pollution from pointer-chasing and regular streaming workloads. DIP-style set-dueling (LIP vs. BIP) further tunes insertion depth for non-streaming sets using a 10-bit PSEL counter and 64 leader sets. This hybrid approach leverages program context, access patterns, and dynamic insertion control to improve hit rates across diverse workloads, especially those with mixed or phase-changing locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 2 bits outcome per signature, 2 bits streaming confidence per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/023_00_ship_stream_dip__signature_based_hit_predictor_with_streaming_bypass_and_dynamic_insertion_policy_t02.cc,0.324203745,0.324203745,0%
2034,lbm,SHiP-Stream-DIP: Signature-based Hit Predictor with Streaming Bypass and Dynamic Insertion Policy,"SHiP-Stream-DIP combines PC-based signature prediction (SHiP-lite), a streaming detector, and DIP-style insertion control to adaptively optimize cache retention and bypass decisions. Each cache line tracks a compact 6-bit PC signature and a 2-bit outcome counter, biasing insertion depth toward blocks with demonstrated reuse. A per-set streaming detector identifies monotonic address patterns and triggers bypass for streaming sets, minimizing pollution from pointer-chasing and regular streaming workloads. DIP-style set-dueling (LIP vs. BIP) further tunes insertion depth for non-streaming sets using a 10-bit PSEL counter and 64 leader sets. This hybrid approach leverages program context, access patterns, and dynamic insertion control to improve hit rates across diverse workloads, especially those with mixed or phase-changing locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 2 bits outcome per signature, 2 bits streaming confidence per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/023_00_ship_stream_dip__signature_based_hit_predictor_with_streaming_bypass_and_dynamic_insertion_policy_t02.cc,0.174218065,0.174218065,0%
2035,mcf,SHiP-Stream-DIP: Signature-based Hit Predictor with Streaming Bypass and Dynamic Insertion Policy,"SHiP-Stream-DIP combines PC-based signature prediction (SHiP-lite), a streaming detector, and DIP-style insertion control to adaptively optimize cache retention and bypass decisions. Each cache line tracks a compact 6-bit PC signature and a 2-bit outcome counter, biasing insertion depth toward blocks with demonstrated reuse. A per-set streaming detector identifies monotonic address patterns and triggers bypass for streaming sets, minimizing pollution from pointer-chasing and regular streaming workloads. DIP-style set-dueling (LIP vs. BIP) further tunes insertion depth for non-streaming sets using a 10-bit PSEL counter and 64 leader sets. This hybrid approach leverages program context, access patterns, and dynamic insertion control to improve hit rates across diverse workloads, especially those with mixed or phase-changing locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 2 bits outcome per signature, 2 bits streaming confidence per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/023_00_ship_stream_dip__signature_based_hit_predictor_with_streaming_bypass_and_dynamic_insertion_policy_t02.cc,0.443089858,0.443089858,0%
2036,milc,SHiP-Stream-DIP: Signature-based Hit Predictor with Streaming Bypass and Dynamic Insertion Policy,"SHiP-Stream-DIP combines PC-based signature prediction (SHiP-lite), a streaming detector, and DIP-style insertion control to adaptively optimize cache retention and bypass decisions. Each cache line tracks a compact 6-bit PC signature and a 2-bit outcome counter, biasing insertion depth toward blocks with demonstrated reuse. A per-set streaming detector identifies monotonic address patterns and triggers bypass for streaming sets, minimizing pollution from pointer-chasing and regular streaming workloads. DIP-style set-dueling (LIP vs. BIP) further tunes insertion depth for non-streaming sets using a 10-bit PSEL counter and 64 leader sets. This hybrid approach leverages program context, access patterns, and dynamic insertion control to improve hit rates across diverse workloads, especially those with mixed or phase-changing locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 2 bits outcome per signature, 2 bits streaming confidence per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/023_00_ship_stream_dip__signature_based_hit_predictor_with_streaming_bypass_and_dynamic_insertion_policy_t02.cc,0.065642266,0.065642266,0%
2037,omnetpp,SHiP-Stream-DIP: Signature-based Hit Predictor with Streaming Bypass and Dynamic Insertion Policy,"SHiP-Stream-DIP combines PC-based signature prediction (SHiP-lite), a streaming detector, and DIP-style insertion control to adaptively optimize cache retention and bypass decisions. Each cache line tracks a compact 6-bit PC signature and a 2-bit outcome counter, biasing insertion depth toward blocks with demonstrated reuse. A per-set streaming detector identifies monotonic address patterns and triggers bypass for streaming sets, minimizing pollution from pointer-chasing and regular streaming workloads. DIP-style set-dueling (LIP vs. BIP) further tunes insertion depth for non-streaming sets using a 10-bit PSEL counter and 64 leader sets. This hybrid approach leverages program context, access patterns, and dynamic insertion control to improve hit rates across diverse workloads, especially those with mixed or phase-changing locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 2 bits outcome per signature, 2 bits streaming confidence per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/023_00_ship_stream_dip__signature_based_hit_predictor_with_streaming_bypass_and_dynamic_insertion_policy_t02.cc,0.854483421,0.854483421,0%
2038,astar,SHiP-Stream-Lite: Signature Hit Predictor with Streaming Bypass,"SHiP-Stream-Lite combines a lightweight PC-based signature hit predictor (SHiP-lite) with a streaming detector for dynamic bypass. Each cache line is tagged with a 6-bit PC signature; a global table of 4-bit saturating counters tracks reuse outcomes per signature, biasing insertion depth toward MRU for PCs with frequent hits and toward distant for PCs with poor reuse. Simultaneously, a per-set streaming detector monitors address deltas and triggers bypass for streaming sets (e.g., lbm, mcf), preventing pollution. This hybrid approach adapts to both control-heavy (astar, milc, omnetpp) and memory-bound (lbm, mcf) workloads, improving hit rate by learning fine-grained reuse patterns and avoiding streaming pollution. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 4 bits outcome per signature (1024 entries), and 2 bits streaming confidence per set.",,ChampSim_CRC2/new_policies/023_01_ship_stream_lite__signature_hit_predictor_with_streaming_bypass_t04.cc,0.31495131,0.31495131,0%
2039,lbm,SHiP-Stream-Lite: Signature Hit Predictor with Streaming Bypass,"SHiP-Stream-Lite combines a lightweight PC-based signature hit predictor (SHiP-lite) with a streaming detector for dynamic bypass. Each cache line is tagged with a 6-bit PC signature; a global table of 4-bit saturating counters tracks reuse outcomes per signature, biasing insertion depth toward MRU for PCs with frequent hits and toward distant for PCs with poor reuse. Simultaneously, a per-set streaming detector monitors address deltas and triggers bypass for streaming sets (e.g., lbm, mcf), preventing pollution. This hybrid approach adapts to both control-heavy (astar, milc, omnetpp) and memory-bound (lbm, mcf) workloads, improving hit rate by learning fine-grained reuse patterns and avoiding streaming pollution. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 4 bits outcome per signature (1024 entries), and 2 bits streaming confidence per set.",,ChampSim_CRC2/new_policies/023_01_ship_stream_lite__signature_hit_predictor_with_streaming_bypass_t04.cc,0.191222921,0.191222921,0%
2040,mcf,SHiP-Stream-Lite: Signature Hit Predictor with Streaming Bypass,"SHiP-Stream-Lite combines a lightweight PC-based signature hit predictor (SHiP-lite) with a streaming detector for dynamic bypass. Each cache line is tagged with a 6-bit PC signature; a global table of 4-bit saturating counters tracks reuse outcomes per signature, biasing insertion depth toward MRU for PCs with frequent hits and toward distant for PCs with poor reuse. Simultaneously, a per-set streaming detector monitors address deltas and triggers bypass for streaming sets (e.g., lbm, mcf), preventing pollution. This hybrid approach adapts to both control-heavy (astar, milc, omnetpp) and memory-bound (lbm, mcf) workloads, improving hit rate by learning fine-grained reuse patterns and avoiding streaming pollution. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 4 bits outcome per signature (1024 entries), and 2 bits streaming confidence per set.",,ChampSim_CRC2/new_policies/023_01_ship_stream_lite__signature_hit_predictor_with_streaming_bypass_t04.cc,0.520801678,0.520801678,0%
2041,milc,SHiP-Stream-Lite: Signature Hit Predictor with Streaming Bypass,"SHiP-Stream-Lite combines a lightweight PC-based signature hit predictor (SHiP-lite) with a streaming detector for dynamic bypass. Each cache line is tagged with a 6-bit PC signature; a global table of 4-bit saturating counters tracks reuse outcomes per signature, biasing insertion depth toward MRU for PCs with frequent hits and toward distant for PCs with poor reuse. Simultaneously, a per-set streaming detector monitors address deltas and triggers bypass for streaming sets (e.g., lbm, mcf), preventing pollution. This hybrid approach adapts to both control-heavy (astar, milc, omnetpp) and memory-bound (lbm, mcf) workloads, improving hit rate by learning fine-grained reuse patterns and avoiding streaming pollution. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 4 bits outcome per signature (1024 entries), and 2 bits streaming confidence per set.",,ChampSim_CRC2/new_policies/023_01_ship_stream_lite__signature_hit_predictor_with_streaming_bypass_t04.cc,0.067952236,0.067952236,0%
2042,omnetpp,SHiP-Stream-Lite: Signature Hit Predictor with Streaming Bypass,"SHiP-Stream-Lite combines a lightweight PC-based signature hit predictor (SHiP-lite) with a streaming detector for dynamic bypass. Each cache line is tagged with a 6-bit PC signature; a global table of 4-bit saturating counters tracks reuse outcomes per signature, biasing insertion depth toward MRU for PCs with frequent hits and toward distant for PCs with poor reuse. Simultaneously, a per-set streaming detector monitors address deltas and triggers bypass for streaming sets (e.g., lbm, mcf), preventing pollution. This hybrid approach adapts to both control-heavy (astar, milc, omnetpp) and memory-bound (lbm, mcf) workloads, improving hit rate by learning fine-grained reuse patterns and avoiding streaming pollution. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 4 bits outcome per signature (1024 entries), and 2 bits streaming confidence per set.",,ChampSim_CRC2/new_policies/023_01_ship_stream_lite__signature_hit_predictor_with_streaming_bypass_t04.cc,0.635367519,0.635367519,0%
2043,all,SHiP-Stream-DIP: Signature-based Hit Predictor with Streaming Bypass and Dynamic Insertion Policy,"SHiP-Stream-DIP combines PC-based signature prediction (SHiP-lite), a streaming detector, and DIP-style insertion control to adaptively optimize cache retention and bypass decisions. Each cache line tracks a compact 6-bit PC signature and a 2-bit outcome counter, biasing insertion depth toward blocks with demonstrated reuse. A per-set streaming detector identifies monotonic address patterns and triggers bypass for streaming sets, minimizing pollution from pointer-chasing and regular streaming workloads. DIP-style set-dueling (LIP vs. BIP) further tunes insertion depth for non-streaming sets using a 10-bit PSEL counter and 64 leader sets. This hybrid approach leverages program context, access patterns, and dynamic insertion control to improve hit rates across diverse workloads, especially those with mixed or phase-changing locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 6 bits signature per block, 2 bits outcome per signature, 2 bits streaming confidence per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/023_00_ship_stream_dip__signature_based_hit_predictor_with_streaming_bypass_and_dynamic_insertion_policy_t02.cc,0.372327471,0.372327471,37%
2044,astar,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Set-Dueling and Periodic Decay,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with SRRIP/BIP set-dueling to adaptively control insertion depth and minimize cache pollution. Each cache block maintains a compact 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block likelihood without relying on PC signatures. On fill, blocks predicted dead (counter=0) are inserted at distant RRPV=3, while others use SRRIP or BIP insertion depth, selected via DIP-style set-dueling with 64 leader sets and a 10-bit PSEL. This approach improves performance by directly tracking block-level reuse, enabling rapid adaptation to phase changes and irregular access patterns (e.g., mcf, omnetpp), while set-dueling ensures robust insertion policy selection for streaming and regular workloads (e.g., lbm, milc). The metadata footprint remains under 64 KiB: 2 bits RRPV and 2 bits reuse counter per block, plus leader set and PSEL state. No PC or streaming detector is used, providing a materially different prediction source and insertion logic.",,ChampSim_CRC2/new_policies/024_00_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_set_dueling_and_periodic_decay_t02.cc,0.291507498,0.291507498,0%
2045,lbm,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Set-Dueling and Periodic Decay,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with SRRIP/BIP set-dueling to adaptively control insertion depth and minimize cache pollution. Each cache block maintains a compact 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block likelihood without relying on PC signatures. On fill, blocks predicted dead (counter=0) are inserted at distant RRPV=3, while others use SRRIP or BIP insertion depth, selected via DIP-style set-dueling with 64 leader sets and a 10-bit PSEL. This approach improves performance by directly tracking block-level reuse, enabling rapid adaptation to phase changes and irregular access patterns (e.g., mcf, omnetpp), while set-dueling ensures robust insertion policy selection for streaming and regular workloads (e.g., lbm, milc). The metadata footprint remains under 64 KiB: 2 bits RRPV and 2 bits reuse counter per block, plus leader set and PSEL state. No PC or streaming detector is used, providing a materially different prediction source and insertion logic.",,ChampSim_CRC2/new_policies/024_00_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_set_dueling_and_periodic_decay_t02.cc,0.161952706,0.161952706,0%
2046,mcf,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Set-Dueling and Periodic Decay,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with SRRIP/BIP set-dueling to adaptively control insertion depth and minimize cache pollution. Each cache block maintains a compact 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block likelihood without relying on PC signatures. On fill, blocks predicted dead (counter=0) are inserted at distant RRPV=3, while others use SRRIP or BIP insertion depth, selected via DIP-style set-dueling with 64 leader sets and a 10-bit PSEL. This approach improves performance by directly tracking block-level reuse, enabling rapid adaptation to phase changes and irregular access patterns (e.g., mcf, omnetpp), while set-dueling ensures robust insertion policy selection for streaming and regular workloads (e.g., lbm, milc). The metadata footprint remains under 64 KiB: 2 bits RRPV and 2 bits reuse counter per block, plus leader set and PSEL state. No PC or streaming detector is used, providing a materially different prediction source and insertion logic.",,ChampSim_CRC2/new_policies/024_00_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_set_dueling_and_periodic_decay_t02.cc,0.409580385,0.409580385,0%
2047,milc,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Set-Dueling and Periodic Decay,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with SRRIP/BIP set-dueling to adaptively control insertion depth and minimize cache pollution. Each cache block maintains a compact 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block likelihood without relying on PC signatures. On fill, blocks predicted dead (counter=0) are inserted at distant RRPV=3, while others use SRRIP or BIP insertion depth, selected via DIP-style set-dueling with 64 leader sets and a 10-bit PSEL. This approach improves performance by directly tracking block-level reuse, enabling rapid adaptation to phase changes and irregular access patterns (e.g., mcf, omnetpp), while set-dueling ensures robust insertion policy selection for streaming and regular workloads (e.g., lbm, milc). The metadata footprint remains under 64 KiB: 2 bits RRPV and 2 bits reuse counter per block, plus leader set and PSEL state. No PC or streaming detector is used, providing a materially different prediction source and insertion logic.",,ChampSim_CRC2/new_policies/024_00_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_set_dueling_and_periodic_decay_t02.cc,0.064337024,0.064337024,0%
2048,omnetpp,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Set-Dueling and Periodic Decay,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with SRRIP/BIP set-dueling to adaptively control insertion depth and minimize cache pollution. Each cache block maintains a compact 2-bit reuse counter that is incremented on hits and periodically decayed, approximating dead-block likelihood without relying on PC signatures. On fill, blocks predicted dead (counter=0) are inserted at distant RRPV=3, while others use SRRIP or BIP insertion depth, selected via DIP-style set-dueling with 64 leader sets and a 10-bit PSEL. This approach improves performance by directly tracking block-level reuse, enabling rapid adaptation to phase changes and irregular access patterns (e.g., mcf, omnetpp), while set-dueling ensures robust insertion policy selection for streaming and regular workloads (e.g., lbm, milc). The metadata footprint remains under 64 KiB: 2 bits RRPV and 2 bits reuse counter per block, plus leader set and PSEL state. No PC or streaming detector is used, providing a materially different prediction source and insertion logic.",,ChampSim_CRC2/new_policies/024_00_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_set_dueling_and_periodic_decay_t02.cc,0.853564846,0.853564846,0%
2049,astar,SRRIP-DeadBlock-Streaming (SDS): Static RRIP with Per-Line Dead-Block Prediction and Streaming Bypass,"SDS combines Static RRIP (SRRIP) for robust baseline replacement, a compact per-line dead-block predictor (2-bit reuse counters per block, periodically decayed), and a streaming detector that identifies monotonic access patterns to trigger bypass in streaming sets. Unlike prior designs, SDS replaces SHiP signatures with direct per-block reuse counters, enabling fine-grained dead-block prediction without relying on PC context. The streaming detector uses per-set address deltas and saturating confidence to bypass insertion in detected streaming sets, reducing pollution from workloads like LBM and pointer-chasing in MCF. Periodic decay of reuse counters prevents stale reuse bias and adapts to phase changes in workloads such as MILC and OMNETPP. This design is simple, metadata-efficient (~32 KiB for reuse counters, ~8 KiB for streaming detector), and improves hit rate by combining dead-block prediction with streaming-aware bypass, making it effective across diverse workloads.",,ChampSim_CRC2/new_policies/024_01_srrip_deadblock_streaming__sds___static_rrip_with_per_line_dead_block_prediction_and_streaming_bypass_t04.cc,0.29316592,0.29316592,0%
2050,lbm,SRRIP-DeadBlock-Streaming (SDS): Static RRIP with Per-Line Dead-Block Prediction and Streaming Bypass,"SDS combines Static RRIP (SRRIP) for robust baseline replacement, a compact per-line dead-block predictor (2-bit reuse counters per block, periodically decayed), and a streaming detector that identifies monotonic access patterns to trigger bypass in streaming sets. Unlike prior designs, SDS replaces SHiP signatures with direct per-block reuse counters, enabling fine-grained dead-block prediction without relying on PC context. The streaming detector uses per-set address deltas and saturating confidence to bypass insertion in detected streaming sets, reducing pollution from workloads like LBM and pointer-chasing in MCF. Periodic decay of reuse counters prevents stale reuse bias and adapts to phase changes in workloads such as MILC and OMNETPP. This design is simple, metadata-efficient (~32 KiB for reuse counters, ~8 KiB for streaming detector), and improves hit rate by combining dead-block prediction with streaming-aware bypass, making it effective across diverse workloads.",,ChampSim_CRC2/new_policies/024_01_srrip_deadblock_streaming__sds___static_rrip_with_per_line_dead_block_prediction_and_streaming_bypass_t04.cc,0.164051514,0.164051514,0%
2051,mcf,SRRIP-DeadBlock-Streaming (SDS): Static RRIP with Per-Line Dead-Block Prediction and Streaming Bypass,"SDS combines Static RRIP (SRRIP) for robust baseline replacement, a compact per-line dead-block predictor (2-bit reuse counters per block, periodically decayed), and a streaming detector that identifies monotonic access patterns to trigger bypass in streaming sets. Unlike prior designs, SDS replaces SHiP signatures with direct per-block reuse counters, enabling fine-grained dead-block prediction without relying on PC context. The streaming detector uses per-set address deltas and saturating confidence to bypass insertion in detected streaming sets, reducing pollution from workloads like LBM and pointer-chasing in MCF. Periodic decay of reuse counters prevents stale reuse bias and adapts to phase changes in workloads such as MILC and OMNETPP. This design is simple, metadata-efficient (~32 KiB for reuse counters, ~8 KiB for streaming detector), and improves hit rate by combining dead-block prediction with streaming-aware bypass, making it effective across diverse workloads.",,ChampSim_CRC2/new_policies/024_01_srrip_deadblock_streaming__sds___static_rrip_with_per_line_dead_block_prediction_and_streaming_bypass_t04.cc,0.421378819,0.421378819,0%
2052,milc,SRRIP-DeadBlock-Streaming (SDS): Static RRIP with Per-Line Dead-Block Prediction and Streaming Bypass,"SDS combines Static RRIP (SRRIP) for robust baseline replacement, a compact per-line dead-block predictor (2-bit reuse counters per block, periodically decayed), and a streaming detector that identifies monotonic access patterns to trigger bypass in streaming sets. Unlike prior designs, SDS replaces SHiP signatures with direct per-block reuse counters, enabling fine-grained dead-block prediction without relying on PC context. The streaming detector uses per-set address deltas and saturating confidence to bypass insertion in detected streaming sets, reducing pollution from workloads like LBM and pointer-chasing in MCF. Periodic decay of reuse counters prevents stale reuse bias and adapts to phase changes in workloads such as MILC and OMNETPP. This design is simple, metadata-efficient (~32 KiB for reuse counters, ~8 KiB for streaming detector), and improves hit rate by combining dead-block prediction with streaming-aware bypass, making it effective across diverse workloads.",,ChampSim_CRC2/new_policies/024_01_srrip_deadblock_streaming__sds___static_rrip_with_per_line_dead_block_prediction_and_streaming_bypass_t04.cc,0.064255559,0.064255559,0%
2053,omnetpp,SRRIP-DeadBlock-Streaming (SDS): Static RRIP with Per-Line Dead-Block Prediction and Streaming Bypass,"SDS combines Static RRIP (SRRIP) for robust baseline replacement, a compact per-line dead-block predictor (2-bit reuse counters per block, periodically decayed), and a streaming detector that identifies monotonic access patterns to trigger bypass in streaming sets. Unlike prior designs, SDS replaces SHiP signatures with direct per-block reuse counters, enabling fine-grained dead-block prediction without relying on PC context. The streaming detector uses per-set address deltas and saturating confidence to bypass insertion in detected streaming sets, reducing pollution from workloads like LBM and pointer-chasing in MCF. Periodic decay of reuse counters prevents stale reuse bias and adapts to phase changes in workloads such as MILC and OMNETPP. This design is simple, metadata-efficient (~32 KiB for reuse counters, ~8 KiB for streaming detector), and improves hit rate by combining dead-block prediction with streaming-aware bypass, making it effective across diverse workloads.",,ChampSim_CRC2/new_policies/024_01_srrip_deadblock_streaming__sds___static_rrip_with_per_line_dead_block_prediction_and_streaming_bypass_t04.cc,0.854340266,0.854340266,0%
2054,astar,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Dynamic Insertion Policy,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with dynamic insertion depth control via DIP-style set-dueling between Static RRIP (SRRIP) and Bimodal Insertion Policy (BIP). Each cache block tracks a compact 2-bit reuse counter, periodically decayed, which estimates whether a block is likely dead or live. On insertion, blocks predicted as dead are inserted with distant RRPV (3), while predicted live blocks get a more favorable insertion (RRPV=2). DIP uses 64 leader sets each for SRRIP and BIP, with a 10-bit PSEL counter to select the dominant policy for normal sets. This approach improves performance by aggressively evicting blocks with low observed reuse (taming pointer-chasing and streaming pollution), while still dynamically adapting insertion depth for workloads with phase changes or mixed locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits reuse counter per block, 2 bits DBP decay epoch per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/024_02_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_dynamic_insertion_policy_t07.cc,0.429917504,0.429917504,0%
2055,lbm,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Dynamic Insertion Policy,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with dynamic insertion depth control via DIP-style set-dueling between Static RRIP (SRRIP) and Bimodal Insertion Policy (BIP). Each cache block tracks a compact 2-bit reuse counter, periodically decayed, which estimates whether a block is likely dead or live. On insertion, blocks predicted as dead are inserted with distant RRPV (3), while predicted live blocks get a more favorable insertion (RRPV=2). DIP uses 64 leader sets each for SRRIP and BIP, with a 10-bit PSEL counter to select the dominant policy for normal sets. This approach improves performance by aggressively evicting blocks with low observed reuse (taming pointer-chasing and streaming pollution), while still dynamically adapting insertion depth for workloads with phase changes or mixed locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits reuse counter per block, 2 bits DBP decay epoch per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/024_02_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_dynamic_insertion_policy_t07.cc,0.390549151,0.390549151,0%
2056,mcf,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Dynamic Insertion Policy,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with dynamic insertion depth control via DIP-style set-dueling between Static RRIP (SRRIP) and Bimodal Insertion Policy (BIP). Each cache block tracks a compact 2-bit reuse counter, periodically decayed, which estimates whether a block is likely dead or live. On insertion, blocks predicted as dead are inserted with distant RRPV (3), while predicted live blocks get a more favorable insertion (RRPV=2). DIP uses 64 leader sets each for SRRIP and BIP, with a 10-bit PSEL counter to select the dominant policy for normal sets. This approach improves performance by aggressively evicting blocks with low observed reuse (taming pointer-chasing and streaming pollution), while still dynamically adapting insertion depth for workloads with phase changes or mixed locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits reuse counter per block, 2 bits DBP decay epoch per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/024_02_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_dynamic_insertion_policy_t07.cc,0.456252938,0.456252938,0%
2057,milc,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Dynamic Insertion Policy,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with dynamic insertion depth control via DIP-style set-dueling between Static RRIP (SRRIP) and Bimodal Insertion Policy (BIP). Each cache block tracks a compact 2-bit reuse counter, periodically decayed, which estimates whether a block is likely dead or live. On insertion, blocks predicted as dead are inserted with distant RRPV (3), while predicted live blocks get a more favorable insertion (RRPV=2). DIP uses 64 leader sets each for SRRIP and BIP, with a 10-bit PSEL counter to select the dominant policy for normal sets. This approach improves performance by aggressively evicting blocks with low observed reuse (taming pointer-chasing and streaming pollution), while still dynamically adapting insertion depth for workloads with phase changes or mixed locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits reuse counter per block, 2 bits DBP decay epoch per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/024_02_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_dynamic_insertion_policy_t07.cc,0.301818649,0.301818649,0%
2058,omnetpp,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Dynamic Insertion Policy,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with dynamic insertion depth control via DIP-style set-dueling between Static RRIP (SRRIP) and Bimodal Insertion Policy (BIP). Each cache block tracks a compact 2-bit reuse counter, periodically decayed, which estimates whether a block is likely dead or live. On insertion, blocks predicted as dead are inserted with distant RRPV (3), while predicted live blocks get a more favorable insertion (RRPV=2). DIP uses 64 leader sets each for SRRIP and BIP, with a 10-bit PSEL counter to select the dominant policy for normal sets. This approach improves performance by aggressively evicting blocks with low observed reuse (taming pointer-chasing and streaming pollution), while still dynamically adapting insertion depth for workloads with phase changes or mixed locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits reuse counter per block, 2 bits DBP decay epoch per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/024_02_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_dynamic_insertion_policy_t07.cc,0.832318328,0.832318328,0%
2059,all,DBP-SRRIP-DIP: Dead-Block Predictor with SRRIP/BIP Dynamic Insertion Policy,"DBP-SRRIP-DIP combines a per-block dead-block predictor (DBP) with dynamic insertion depth control via DIP-style set-dueling between Static RRIP (SRRIP) and Bimodal Insertion Policy (BIP). Each cache block tracks a compact 2-bit reuse counter, periodically decayed, which estimates whether a block is likely dead or live. On insertion, blocks predicted as dead are inserted with distant RRPV (3), while predicted live blocks get a more favorable insertion (RRPV=2). DIP uses 64 leader sets each for SRRIP and BIP, with a 10-bit PSEL counter to select the dominant policy for normal sets. This approach improves performance by aggressively evicting blocks with low observed reuse (taming pointer-chasing and streaming pollution), while still dynamically adapting insertion depth for workloads with phase changes or mixed locality. All metadata fits within 64 KiB: 2 bits RRPV per block, 2 bits reuse counter per block, 2 bits DBP decay epoch per set, and a global PSEL counter.",,ChampSim_CRC2/new_policies/024_02_dbp_srrip_dip__dead_block_predictor_with_srrip_bip_dynamic_insertion_policy_t07.cc,0.482171314,0.482171314,48%
2060,astar,SHiP-Lite + Streaming Detector DRRIP,"This policy combines a compact SHiP-lite signature predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within each set. On cache fill, the SHiP-lite predictor biases insertion depth: blocks with high signature reuse are inserted at RRPV=2 (SRRIP), while low-reuse signatures get RRPV=3 (distant). Additionally, if the streaming detector observes consecutive fills with monotonically increasing or decreasing addresses (detected via small per-set stride counters), it triggers bypass or distant insertion to prevent streaming pollution (e.g., in LBM or pointer-chasing phases of MCF/omnetpp). DRRIP set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically selects between SRRIP and BRRIP for normal sets. This hybrid approach adapts to both code-phase locality and streaming patterns, improving hit rates for mixed workloads while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/025_00_ship_lite___streaming_detector_drrip_t02.cc,0.429917504,0.429917504,0%
2061,lbm,SHiP-Lite + Streaming Detector DRRIP,"This policy combines a compact SHiP-lite signature predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within each set. On cache fill, the SHiP-lite predictor biases insertion depth: blocks with high signature reuse are inserted at RRPV=2 (SRRIP), while low-reuse signatures get RRPV=3 (distant). Additionally, if the streaming detector observes consecutive fills with monotonically increasing or decreasing addresses (detected via small per-set stride counters), it triggers bypass or distant insertion to prevent streaming pollution (e.g., in LBM or pointer-chasing phases of MCF/omnetpp). DRRIP set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically selects between SRRIP and BRRIP for normal sets. This hybrid approach adapts to both code-phase locality and streaming patterns, improving hit rates for mixed workloads while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/025_00_ship_lite___streaming_detector_drrip_t02.cc,0.390549151,0.390549151,0%
2062,mcf,SHiP-Lite + Streaming Detector DRRIP,"This policy combines a compact SHiP-lite signature predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within each set. On cache fill, the SHiP-lite predictor biases insertion depth: blocks with high signature reuse are inserted at RRPV=2 (SRRIP), while low-reuse signatures get RRPV=3 (distant). Additionally, if the streaming detector observes consecutive fills with monotonically increasing or decreasing addresses (detected via small per-set stride counters), it triggers bypass or distant insertion to prevent streaming pollution (e.g., in LBM or pointer-chasing phases of MCF/omnetpp). DRRIP set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically selects between SRRIP and BRRIP for normal sets. This hybrid approach adapts to both code-phase locality and streaming patterns, improving hit rates for mixed workloads while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/025_00_ship_lite___streaming_detector_drrip_t02.cc,0.456252938,0.456252938,0%
2063,milc,SHiP-Lite + Streaming Detector DRRIP,"This policy combines a compact SHiP-lite signature predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within each set. On cache fill, the SHiP-lite predictor biases insertion depth: blocks with high signature reuse are inserted at RRPV=2 (SRRIP), while low-reuse signatures get RRPV=3 (distant). Additionally, if the streaming detector observes consecutive fills with monotonically increasing or decreasing addresses (detected via small per-set stride counters), it triggers bypass or distant insertion to prevent streaming pollution (e.g., in LBM or pointer-chasing phases of MCF/omnetpp). DRRIP set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically selects between SRRIP and BRRIP for normal sets. This hybrid approach adapts to both code-phase locality and streaming patterns, improving hit rates for mixed workloads while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/025_00_ship_lite___streaming_detector_drrip_t02.cc,0.301818649,0.301818649,0%
2064,omnetpp,SHiP-Lite + Streaming Detector DRRIP,"This policy combines a compact SHiP-lite signature predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within each set. On cache fill, the SHiP-lite predictor biases insertion depth: blocks with high signature reuse are inserted at RRPV=2 (SRRIP), while low-reuse signatures get RRPV=3 (distant). Additionally, if the streaming detector observes consecutive fills with monotonically increasing or decreasing addresses (detected via small per-set stride counters), it triggers bypass or distant insertion to prevent streaming pollution (e.g., in LBM or pointer-chasing phases of MCF/omnetpp). DRRIP set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically selects between SRRIP and BRRIP for normal sets. This hybrid approach adapts to both code-phase locality and streaming patterns, improving hit rates for mixed workloads while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/025_00_ship_lite___streaming_detector_drrip_t02.cc,0.832318328,0.832318328,0%
2065,astar,SHiP-Lite + Streaming Detector (SHiP-Stream-DRRIP),"This policy combines a compact SHiP-lite signature-based predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within sets. On fill, the SHiP outcome counter biases insertion depth: blocks from PCs with high reuse are inserted at RRPV=2 (SRRIP), while blocks from low-reuse PCs are inserted at RRPV=3 (distant). If the streaming detector observes consecutive fills with monotonically increasing addresses in a set, it triggers aggressive distant insertion (RRPV=3) or bypasses the cache for extreme streaming. DRRIP-style set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically adapts between SRRIP and BRRIP for normal sets. This hybrid approach improves performance by learning per-PC reuse, adapting to phase changes, and suppressing cache pollution from streaming or pointer-chasing workloads, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/025_01_ship_lite___streaming_detector__ship_stream_drrip_t04.cc,0.429917504,0.429917504,0%
2066,lbm,SHiP-Lite + Streaming Detector (SHiP-Stream-DRRIP),"This policy combines a compact SHiP-lite signature-based predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within sets. On fill, the SHiP outcome counter biases insertion depth: blocks from PCs with high reuse are inserted at RRPV=2 (SRRIP), while blocks from low-reuse PCs are inserted at RRPV=3 (distant). If the streaming detector observes consecutive fills with monotonically increasing addresses in a set, it triggers aggressive distant insertion (RRPV=3) or bypasses the cache for extreme streaming. DRRIP-style set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically adapts between SRRIP and BRRIP for normal sets. This hybrid approach improves performance by learning per-PC reuse, adapting to phase changes, and suppressing cache pollution from streaming or pointer-chasing workloads, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/025_01_ship_lite___streaming_detector__ship_stream_drrip_t04.cc,0.390549151,0.390549151,0%
2067,mcf,SHiP-Lite + Streaming Detector (SHiP-Stream-DRRIP),"This policy combines a compact SHiP-lite signature-based predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within sets. On fill, the SHiP outcome counter biases insertion depth: blocks from PCs with high reuse are inserted at RRPV=2 (SRRIP), while blocks from low-reuse PCs are inserted at RRPV=3 (distant). If the streaming detector observes consecutive fills with monotonically increasing addresses in a set, it triggers aggressive distant insertion (RRPV=3) or bypasses the cache for extreme streaming. DRRIP-style set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically adapts between SRRIP and BRRIP for normal sets. This hybrid approach improves performance by learning per-PC reuse, adapting to phase changes, and suppressing cache pollution from streaming or pointer-chasing workloads, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/025_01_ship_lite___streaming_detector__ship_stream_drrip_t04.cc,0.456252938,0.456252938,0%
2068,milc,SHiP-Lite + Streaming Detector (SHiP-Stream-DRRIP),"This policy combines a compact SHiP-lite signature-based predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within sets. On fill, the SHiP outcome counter biases insertion depth: blocks from PCs with high reuse are inserted at RRPV=2 (SRRIP), while blocks from low-reuse PCs are inserted at RRPV=3 (distant). If the streaming detector observes consecutive fills with monotonically increasing addresses in a set, it triggers aggressive distant insertion (RRPV=3) or bypasses the cache for extreme streaming. DRRIP-style set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically adapts between SRRIP and BRRIP for normal sets. This hybrid approach improves performance by learning per-PC reuse, adapting to phase changes, and suppressing cache pollution from streaming or pointer-chasing workloads, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/025_01_ship_lite___streaming_detector__ship_stream_drrip_t04.cc,0.301818649,0.301818649,0%
2069,omnetpp,SHiP-Lite + Streaming Detector (SHiP-Stream-DRRIP),"This policy combines a compact SHiP-lite signature-based predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within sets. On fill, the SHiP outcome counter biases insertion depth: blocks from PCs with high reuse are inserted at RRPV=2 (SRRIP), while blocks from low-reuse PCs are inserted at RRPV=3 (distant). If the streaming detector observes consecutive fills with monotonically increasing addresses in a set, it triggers aggressive distant insertion (RRPV=3) or bypasses the cache for extreme streaming. DRRIP-style set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically adapts between SRRIP and BRRIP for normal sets. This hybrid approach improves performance by learning per-PC reuse, adapting to phase changes, and suppressing cache pollution from streaming or pointer-chasing workloads, all within 64 KiB metadata.",,ChampSim_CRC2/new_policies/025_01_ship_lite___streaming_detector__ship_stream_drrip_t04.cc,0.832318328,0.832318328,0%
2070,astar,SHiP-Delta Streaming Hybrid (SHiP-DSH),"SHiP-DSH blends SHiP-lite signature-based prediction with a streaming pattern detector, dynamically adjusting insertion depth and applying selective bypass for streaming accesses. Each cache block tracks a 4-bit compressed PC signature (per-block), and a global SHCT (Signature History Counter Table, 16K entries × 2 bits) biases insertion depth based on the observed reuse of PC signatures. Additionally, a compact per-set streaming detector monitors recent address deltas; if accesses within a set exhibit near-monotonic stride (as in LBM, MILC streaming phases), incoming blocks are either bypassed or inserted at distant RRPV. DIP-style set-dueling (64 leader sets each for SRRIP and BRRIP, 10-bit PSEL) is retained for non-streaming accesses, but streaming sets override with aggressive eviction or bypass. This hybrid approach improves hit rates on workloads with variable locality (MILC, OMNETPP), streaming phases (LBM), and pointer-chasing (MCF), while keeping metadata under 64 KiB via compressed signatures, small SHCT, per-set delta windows, and conventional RRIP bits.",,ChampSim_CRC2/new_policies/025_02_ship_delta_streaming_hybrid__ship_dsh_t07.cc,0.43072191,0.43072191,0%
2071,lbm,SHiP-Delta Streaming Hybrid (SHiP-DSH),"SHiP-DSH blends SHiP-lite signature-based prediction with a streaming pattern detector, dynamically adjusting insertion depth and applying selective bypass for streaming accesses. Each cache block tracks a 4-bit compressed PC signature (per-block), and a global SHCT (Signature History Counter Table, 16K entries × 2 bits) biases insertion depth based on the observed reuse of PC signatures. Additionally, a compact per-set streaming detector monitors recent address deltas; if accesses within a set exhibit near-monotonic stride (as in LBM, MILC streaming phases), incoming blocks are either bypassed or inserted at distant RRPV. DIP-style set-dueling (64 leader sets each for SRRIP and BRRIP, 10-bit PSEL) is retained for non-streaming accesses, but streaming sets override with aggressive eviction or bypass. This hybrid approach improves hit rates on workloads with variable locality (MILC, OMNETPP), streaming phases (LBM), and pointer-chasing (MCF), while keeping metadata under 64 KiB via compressed signatures, small SHCT, per-set delta windows, and conventional RRIP bits.",,ChampSim_CRC2/new_policies/025_02_ship_delta_streaming_hybrid__ship_dsh_t07.cc,0.402280861,0.402280861,0%
2072,mcf,SHiP-Delta Streaming Hybrid (SHiP-DSH),"SHiP-DSH blends SHiP-lite signature-based prediction with a streaming pattern detector, dynamically adjusting insertion depth and applying selective bypass for streaming accesses. Each cache block tracks a 4-bit compressed PC signature (per-block), and a global SHCT (Signature History Counter Table, 16K entries × 2 bits) biases insertion depth based on the observed reuse of PC signatures. Additionally, a compact per-set streaming detector monitors recent address deltas; if accesses within a set exhibit near-monotonic stride (as in LBM, MILC streaming phases), incoming blocks are either bypassed or inserted at distant RRPV. DIP-style set-dueling (64 leader sets each for SRRIP and BRRIP, 10-bit PSEL) is retained for non-streaming accesses, but streaming sets override with aggressive eviction or bypass. This hybrid approach improves hit rates on workloads with variable locality (MILC, OMNETPP), streaming phases (LBM), and pointer-chasing (MCF), while keeping metadata under 64 KiB via compressed signatures, small SHCT, per-set delta windows, and conventional RRIP bits.",,ChampSim_CRC2/new_policies/025_02_ship_delta_streaming_hybrid__ship_dsh_t07.cc,0.460493244,0.460493244,0%
2073,milc,SHiP-Delta Streaming Hybrid (SHiP-DSH),"SHiP-DSH blends SHiP-lite signature-based prediction with a streaming pattern detector, dynamically adjusting insertion depth and applying selective bypass for streaming accesses. Each cache block tracks a 4-bit compressed PC signature (per-block), and a global SHCT (Signature History Counter Table, 16K entries × 2 bits) biases insertion depth based on the observed reuse of PC signatures. Additionally, a compact per-set streaming detector monitors recent address deltas; if accesses within a set exhibit near-monotonic stride (as in LBM, MILC streaming phases), incoming blocks are either bypassed or inserted at distant RRPV. DIP-style set-dueling (64 leader sets each for SRRIP and BRRIP, 10-bit PSEL) is retained for non-streaming accesses, but streaming sets override with aggressive eviction or bypass. This hybrid approach improves hit rates on workloads with variable locality (MILC, OMNETPP), streaming phases (LBM), and pointer-chasing (MCF), while keeping metadata under 64 KiB via compressed signatures, small SHCT, per-set delta windows, and conventional RRIP bits.",,ChampSim_CRC2/new_policies/025_02_ship_delta_streaming_hybrid__ship_dsh_t07.cc,0.303819055,0.303819055,0%
2074,omnetpp,SHiP-Delta Streaming Hybrid (SHiP-DSH),"SHiP-DSH blends SHiP-lite signature-based prediction with a streaming pattern detector, dynamically adjusting insertion depth and applying selective bypass for streaming accesses. Each cache block tracks a 4-bit compressed PC signature (per-block), and a global SHCT (Signature History Counter Table, 16K entries × 2 bits) biases insertion depth based on the observed reuse of PC signatures. Additionally, a compact per-set streaming detector monitors recent address deltas; if accesses within a set exhibit near-monotonic stride (as in LBM, MILC streaming phases), incoming blocks are either bypassed or inserted at distant RRPV. DIP-style set-dueling (64 leader sets each for SRRIP and BRRIP, 10-bit PSEL) is retained for non-streaming accesses, but streaming sets override with aggressive eviction or bypass. This hybrid approach improves hit rates on workloads with variable locality (MILC, OMNETPP), streaming phases (LBM), and pointer-chasing (MCF), while keeping metadata under 64 KiB via compressed signatures, small SHCT, per-set delta windows, and conventional RRIP bits.",,ChampSim_CRC2/new_policies/025_02_ship_delta_streaming_hybrid__ship_dsh_t07.cc,0.465598177,0.465598177,0%
2075,all,SHiP-Lite + Streaming Detector DRRIP,"This policy combines a compact SHiP-lite signature predictor (using 6-bit PC signatures and 2-bit outcome counters) with a streaming detector that identifies near-monotonic address strides within each set. On cache fill, the SHiP-lite predictor biases insertion depth: blocks with high signature reuse are inserted at RRPV=2 (SRRIP), while low-reuse signatures get RRPV=3 (distant). Additionally, if the streaming detector observes consecutive fills with monotonically increasing or decreasing addresses (detected via small per-set stride counters), it triggers bypass or distant insertion to prevent streaming pollution (e.g., in LBM or pointer-chasing phases of MCF/omnetpp). DRRIP set-dueling (64 leader sets per policy, 10-bit PSEL) dynamically selects between SRRIP and BRRIP for normal sets. This hybrid approach adapts to both code-phase locality and streaming patterns, improving hit rates for mixed workloads while keeping metadata under 64 KiB.",,ChampSim_CRC2/new_policies/025_00_ship_lite___streaming_detector_drrip_t02.cc,0.482171314,0.482171314,48%
2076,astar,DIP-LIP + Per-Line Dead-Block Counter,"This policy combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a compact per-line dead-block counter to approximate block reusability. DIP uses 64 leader sets for each policy and a 10-bit PSEL selector to dynamically choose between LIP (always insert at distant RRPV) and BIP (insert at MRU only 1/32 fills, else distant). Additionally, each cache line maintains a 2-bit dead-block counter that is incremented on eviction and reset on hit, biasing insertion depth: blocks with high dead-block counts are inserted at distant RRPV, while others follow the DIP-selected policy. This approach improves performance by quickly identifying and evicting dead blocks (especially in pointer-chasing and streaming workloads like MCF, omnetpp, LBM), while DIP adapts to phase changes and mixed locality. The metadata footprint remains under 64 KiB, and the mechanism is robust across diverse workloads due to its hybrid phase-adaptive and dead-block-aware insertion.",,ChampSim_CRC2/new_policies/026_00_dip_lip___per_line_dead_block_counter_t02.cc,0.291793647,0.291793647,0%
2077,lbm,DIP-LIP + Per-Line Dead-Block Counter,"This policy combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a compact per-line dead-block counter to approximate block reusability. DIP uses 64 leader sets for each policy and a 10-bit PSEL selector to dynamically choose between LIP (always insert at distant RRPV) and BIP (insert at MRU only 1/32 fills, else distant). Additionally, each cache line maintains a 2-bit dead-block counter that is incremented on eviction and reset on hit, biasing insertion depth: blocks with high dead-block counts are inserted at distant RRPV, while others follow the DIP-selected policy. This approach improves performance by quickly identifying and evicting dead blocks (especially in pointer-chasing and streaming workloads like MCF, omnetpp, LBM), while DIP adapts to phase changes and mixed locality. The metadata footprint remains under 64 KiB, and the mechanism is robust across diverse workloads due to its hybrid phase-adaptive and dead-block-aware insertion.",,ChampSim_CRC2/new_policies/026_00_dip_lip___per_line_dead_block_counter_t02.cc,0.162236584,0.162236584,0%
2078,mcf,DIP-LIP + Per-Line Dead-Block Counter,"This policy combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a compact per-line dead-block counter to approximate block reusability. DIP uses 64 leader sets for each policy and a 10-bit PSEL selector to dynamically choose between LIP (always insert at distant RRPV) and BIP (insert at MRU only 1/32 fills, else distant). Additionally, each cache line maintains a 2-bit dead-block counter that is incremented on eviction and reset on hit, biasing insertion depth: blocks with high dead-block counts are inserted at distant RRPV, while others follow the DIP-selected policy. This approach improves performance by quickly identifying and evicting dead blocks (especially in pointer-chasing and streaming workloads like MCF, omnetpp, LBM), while DIP adapts to phase changes and mixed locality. The metadata footprint remains under 64 KiB, and the mechanism is robust across diverse workloads due to its hybrid phase-adaptive and dead-block-aware insertion.",,ChampSim_CRC2/new_policies/026_00_dip_lip___per_line_dead_block_counter_t02.cc,0.409585449,0.409585449,0%
2079,milc,DIP-LIP + Per-Line Dead-Block Counter,"This policy combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a compact per-line dead-block counter to approximate block reusability. DIP uses 64 leader sets for each policy and a 10-bit PSEL selector to dynamically choose between LIP (always insert at distant RRPV) and BIP (insert at MRU only 1/32 fills, else distant). Additionally, each cache line maintains a 2-bit dead-block counter that is incremented on eviction and reset on hit, biasing insertion depth: blocks with high dead-block counts are inserted at distant RRPV, while others follow the DIP-selected policy. This approach improves performance by quickly identifying and evicting dead blocks (especially in pointer-chasing and streaming workloads like MCF, omnetpp, LBM), while DIP adapts to phase changes and mixed locality. The metadata footprint remains under 64 KiB, and the mechanism is robust across diverse workloads due to its hybrid phase-adaptive and dead-block-aware insertion.",,ChampSim_CRC2/new_policies/026_00_dip_lip___per_line_dead_block_counter_t02.cc,0.064380472,0.064380472,0%
2080,omnetpp,DIP-LIP + Per-Line Dead-Block Counter,"This policy combines DIP-style set-dueling between LRU Insertion Policy (LIP) and Bimodal Insertion Policy (BIP) with a compact per-line dead-block counter to approximate block reusability. DIP uses 64 leader sets for each policy and a 10-bit PSEL selector to dynamically choose between LIP (always insert at distant RRPV) and BIP (insert at MRU only 1/32 fills, else distant). Additionally, each cache line maintains a 2-bit dead-block counter that is incremented on eviction and reset on hit, biasing insertion depth: blocks with high dead-block counts are inserted at distant RRPV, while others follow the DIP-selected policy. This approach improves performance by quickly identifying and evicting dead blocks (especially in pointer-chasing and streaming workloads like MCF, omnetpp, LBM), while DIP adapts to phase changes and mixed locality. The metadata footprint remains under 64 KiB, and the mechanism is robust across diverse workloads due to its hybrid phase-adaptive and dead-block-aware insertion.",,ChampSim_CRC2/new_policies/026_00_dip_lip___per_line_dead_block_counter_t02.cc,0.854322372,0.854322372,0%
2081,astar,SHiP-Lite + Per-Block Dead Counter + Adaptive Streaming Bypass,"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a compact per-block dead-block counter (2 bits per line) and an adaptive streaming detector. On cache fill, insertion depth is chosen by blending SHiP signature reuse and dead-block confidence: blocks with high signature reuse and low dead-block count are inserted at RRPV=2 (SRRIP), while those with low reuse or a high dead-block count are inserted at RRPV=3 (distant). The streaming detector tracks monotonic address strides per set and triggers bypass (no fill) for blocks when streaming is detected for at least 4 consecutive fills. Dead-block counters decay periodically to avoid stale predictions. This design improves performance by more accurately identifying dead-on-arrival blocks (common in pointer-chasing and streaming phases of mcf, omnetpp, lbm), while still leveraging phase-adaptive SHiP prediction for control-dominated workloads (astar, milc). Metadata remains under 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/026_01_ship_lite___per_block_dead_counter___adaptive_streaming_bypass_t04.cc,0.335133205,0.335133205,0%
2082,lbm,SHiP-Lite + Per-Block Dead Counter + Adaptive Streaming Bypass,"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a compact per-block dead-block counter (2 bits per line) and an adaptive streaming detector. On cache fill, insertion depth is chosen by blending SHiP signature reuse and dead-block confidence: blocks with high signature reuse and low dead-block count are inserted at RRPV=2 (SRRIP), while those with low reuse or a high dead-block count are inserted at RRPV=3 (distant). The streaming detector tracks monotonic address strides per set and triggers bypass (no fill) for blocks when streaming is detected for at least 4 consecutive fills. Dead-block counters decay periodically to avoid stale predictions. This design improves performance by more accurately identifying dead-on-arrival blocks (common in pointer-chasing and streaming phases of mcf, omnetpp, lbm), while still leveraging phase-adaptive SHiP prediction for control-dominated workloads (astar, milc). Metadata remains under 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/026_01_ship_lite___per_block_dead_counter___adaptive_streaming_bypass_t04.cc,0.185379554,0.185379554,0%
2083,mcf,SHiP-Lite + Per-Block Dead Counter + Adaptive Streaming Bypass,"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a compact per-block dead-block counter (2 bits per line) and an adaptive streaming detector. On cache fill, insertion depth is chosen by blending SHiP signature reuse and dead-block confidence: blocks with high signature reuse and low dead-block count are inserted at RRPV=2 (SRRIP), while those with low reuse or a high dead-block count are inserted at RRPV=3 (distant). The streaming detector tracks monotonic address strides per set and triggers bypass (no fill) for blocks when streaming is detected for at least 4 consecutive fills. Dead-block counters decay periodically to avoid stale predictions. This design improves performance by more accurately identifying dead-on-arrival blocks (common in pointer-chasing and streaming phases of mcf, omnetpp, lbm), while still leveraging phase-adaptive SHiP prediction for control-dominated workloads (astar, milc). Metadata remains under 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/026_01_ship_lite___per_block_dead_counter___adaptive_streaming_bypass_t04.cc,0.521726369,0.521726369,0%
2084,milc,SHiP-Lite + Per-Block Dead Counter + Adaptive Streaming Bypass,"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a compact per-block dead-block counter (2 bits per line) and an adaptive streaming detector. On cache fill, insertion depth is chosen by blending SHiP signature reuse and dead-block confidence: blocks with high signature reuse and low dead-block count are inserted at RRPV=2 (SRRIP), while those with low reuse or a high dead-block count are inserted at RRPV=3 (distant). The streaming detector tracks monotonic address strides per set and triggers bypass (no fill) for blocks when streaming is detected for at least 4 consecutive fills. Dead-block counters decay periodically to avoid stale predictions. This design improves performance by more accurately identifying dead-on-arrival blocks (common in pointer-chasing and streaming phases of mcf, omnetpp, lbm), while still leveraging phase-adaptive SHiP prediction for control-dominated workloads (astar, milc). Metadata remains under 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/026_01_ship_lite___per_block_dead_counter___adaptive_streaming_bypass_t04.cc,0.066737511,0.066737511,0%
2085,omnetpp,SHiP-Lite + Per-Block Dead Counter + Adaptive Streaming Bypass,"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a compact per-block dead-block counter (2 bits per line) and an adaptive streaming detector. On cache fill, insertion depth is chosen by blending SHiP signature reuse and dead-block confidence: blocks with high signature reuse and low dead-block count are inserted at RRPV=2 (SRRIP), while those with low reuse or a high dead-block count are inserted at RRPV=3 (distant). The streaming detector tracks monotonic address strides per set and triggers bypass (no fill) for blocks when streaming is detected for at least 4 consecutive fills. Dead-block counters decay periodically to avoid stale predictions. This design improves performance by more accurately identifying dead-on-arrival blocks (common in pointer-chasing and streaming phases of mcf, omnetpp, lbm), while still leveraging phase-adaptive SHiP prediction for control-dominated workloads (astar, milc). Metadata remains under 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/026_01_ship_lite___per_block_dead_counter___adaptive_streaming_bypass_t04.cc,0.765894626,0.765894626,0%
2086,astar,Hybrid SHiP-Lite + Per-Line Dead-Block Counter + DIP Set-Dueling,"This policy integrates SHiP-lite PC-based signatures for insertion depth prediction, but augments them with a per-line 2-bit dead-block reuse counter to track block-specific reuse frequency. Dead blocks (counter=0) are inserted at distant RRPV=3, while frequently reused blocks are promoted to RRPV=2 for longer retention. Additionally, DIP-style set dueling (using 64 leader sets each for LIP and BIP, plus a 10-bit PSEL) dynamically chooses between always inserting at LRU (LIP) or mostly at LRU with rare MRU insertions (BIP) for non-SHiP-guided blocks, improving adaptation to phase changes and streaming patterns. The dead-block counters are periodically decayed to avoid stale information, ensuring responsiveness to changing workload phases. This hybrid mechanism improves performance for both memory-bound, streaming, and pointer-chasing workloads by balancing recency and reuse, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/026_02_hybrid_ship_lite___per_line_dead_block_counter___dip_set_dueling_t07.cc,0.313517024,0.313517024,0%
2087,lbm,Hybrid SHiP-Lite + Per-Line Dead-Block Counter + DIP Set-Dueling,"This policy integrates SHiP-lite PC-based signatures for insertion depth prediction, but augments them with a per-line 2-bit dead-block reuse counter to track block-specific reuse frequency. Dead blocks (counter=0) are inserted at distant RRPV=3, while frequently reused blocks are promoted to RRPV=2 for longer retention. Additionally, DIP-style set dueling (using 64 leader sets each for LIP and BIP, plus a 10-bit PSEL) dynamically chooses between always inserting at LRU (LIP) or mostly at LRU with rare MRU insertions (BIP) for non-SHiP-guided blocks, improving adaptation to phase changes and streaming patterns. The dead-block counters are periodically decayed to avoid stale information, ensuring responsiveness to changing workload phases. This hybrid mechanism improves performance for both memory-bound, streaming, and pointer-chasing workloads by balancing recency and reuse, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/026_02_hybrid_ship_lite___per_line_dead_block_counter___dip_set_dueling_t07.cc,0.169620569,0.169620569,0%
2088,mcf,Hybrid SHiP-Lite + Per-Line Dead-Block Counter + DIP Set-Dueling,"This policy integrates SHiP-lite PC-based signatures for insertion depth prediction, but augments them with a per-line 2-bit dead-block reuse counter to track block-specific reuse frequency. Dead blocks (counter=0) are inserted at distant RRPV=3, while frequently reused blocks are promoted to RRPV=2 for longer retention. Additionally, DIP-style set dueling (using 64 leader sets each for LIP and BIP, plus a 10-bit PSEL) dynamically chooses between always inserting at LRU (LIP) or mostly at LRU with rare MRU insertions (BIP) for non-SHiP-guided blocks, improving adaptation to phase changes and streaming patterns. The dead-block counters are periodically decayed to avoid stale information, ensuring responsiveness to changing workload phases. This hybrid mechanism improves performance for both memory-bound, streaming, and pointer-chasing workloads by balancing recency and reuse, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/026_02_hybrid_ship_lite___per_line_dead_block_counter___dip_set_dueling_t07.cc,0.410599112,0.410599112,0%
2089,milc,Hybrid SHiP-Lite + Per-Line Dead-Block Counter + DIP Set-Dueling,"This policy integrates SHiP-lite PC-based signatures for insertion depth prediction, but augments them with a per-line 2-bit dead-block reuse counter to track block-specific reuse frequency. Dead blocks (counter=0) are inserted at distant RRPV=3, while frequently reused blocks are promoted to RRPV=2 for longer retention. Additionally, DIP-style set dueling (using 64 leader sets each for LIP and BIP, plus a 10-bit PSEL) dynamically chooses between always inserting at LRU (LIP) or mostly at LRU with rare MRU insertions (BIP) for non-SHiP-guided blocks, improving adaptation to phase changes and streaming patterns. The dead-block counters are periodically decayed to avoid stale information, ensuring responsiveness to changing workload phases. This hybrid mechanism improves performance for both memory-bound, streaming, and pointer-chasing workloads by balancing recency and reuse, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/026_02_hybrid_ship_lite___per_line_dead_block_counter___dip_set_dueling_t07.cc,0.071976582,0.071976582,0%
2090,omnetpp,Hybrid SHiP-Lite + Per-Line Dead-Block Counter + DIP Set-Dueling,"This policy integrates SHiP-lite PC-based signatures for insertion depth prediction, but augments them with a per-line 2-bit dead-block reuse counter to track block-specific reuse frequency. Dead blocks (counter=0) are inserted at distant RRPV=3, while frequently reused blocks are promoted to RRPV=2 for longer retention. Additionally, DIP-style set dueling (using 64 leader sets each for LIP and BIP, plus a 10-bit PSEL) dynamically chooses between always inserting at LRU (LIP) or mostly at LRU with rare MRU insertions (BIP) for non-SHiP-guided blocks, improving adaptation to phase changes and streaming patterns. The dead-block counters are periodically decayed to avoid stale information, ensuring responsiveness to changing workload phases. This hybrid mechanism improves performance for both memory-bound, streaming, and pointer-chasing workloads by balancing recency and reuse, all within a compact metadata budget.",,ChampSim_CRC2/new_policies/026_02_hybrid_ship_lite___per_line_dead_block_counter___dip_set_dueling_t07.cc,0.854280619,0.854280619,0%
2091,all,SHiP-Lite + Per-Block Dead Counter + Adaptive Streaming Bypass,"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a compact per-block dead-block counter (2 bits per line) and an adaptive streaming detector. On cache fill, insertion depth is chosen by blending SHiP signature reuse and dead-block confidence: blocks with high signature reuse and low dead-block count are inserted at RRPV=2 (SRRIP), while those with low reuse or a high dead-block count are inserted at RRPV=3 (distant). The streaming detector tracks monotonic address strides per set and triggers bypass (no fill) for blocks when streaming is detected for at least 4 consecutive fills. Dead-block counters decay periodically to avoid stale predictions. This design improves performance by more accurately identifying dead-on-arrival blocks (common in pointer-chasing and streaming phases of mcf, omnetpp, lbm), while still leveraging phase-adaptive SHiP prediction for control-dominated workloads (astar, milc). Metadata remains under 64 KiB by using compact counters and signatures.",,ChampSim_CRC2/new_policies/026_01_ship_lite___per_block_dead_counter___adaptive_streaming_bypass_t04.cc,0.374974253,0.374974253,37%
2092,astar,DRRIP + SHiP-Lite + DIP-style Streaming Bypass,"This policy combines DRRIP (Dynamic RRIP with set-dueling via a compact 10-bit PSEL), SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters), and a DIP-style streaming bypass using leader sets. Each cache fill chooses insertion depth via DRRIP: either SRRIP (insert at RRPV=2) or BRRIP (insert at RRPV=3), with the global PSEL selector adapted using 32 leader sets. SHiP-lite further biases insertion depth: blocks with strong signature reuse (ctr≥2) are promoted to RRPV=1 (very likely reused), regardless of DRRIP. Streaming leader sets (selected by address stride monotonicity) trigger bypass (no fill) when detected, helping eliminate pollution from streaming accesses (e.g., lbm). Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature outcome, 10 bits for PSEL, and 32 sets for streaming detection (3 bits per-set). This design adapts to phase changes and workload diversity—DRRIP handles control-dominated and irregular workloads (astar, mcf, milc, omnetpp), SHiP-lite boosts reuse prediction, and DIP-style streaming bypass improves performance in spatially regular workloads (lbm), all within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/029_02_drrip___ship_lite___dip_style_streaming_bypass_t07.cc,0.314665162,0.314665162,0%
2093,lbm,DRRIP + SHiP-Lite + DIP-style Streaming Bypass,"This policy combines DRRIP (Dynamic RRIP with set-dueling via a compact 10-bit PSEL), SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters), and a DIP-style streaming bypass using leader sets. Each cache fill chooses insertion depth via DRRIP: either SRRIP (insert at RRPV=2) or BRRIP (insert at RRPV=3), with the global PSEL selector adapted using 32 leader sets. SHiP-lite further biases insertion depth: blocks with strong signature reuse (ctr≥2) are promoted to RRPV=1 (very likely reused), regardless of DRRIP. Streaming leader sets (selected by address stride monotonicity) trigger bypass (no fill) when detected, helping eliminate pollution from streaming accesses (e.g., lbm). Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature outcome, 10 bits for PSEL, and 32 sets for streaming detection (3 bits per-set). This design adapts to phase changes and workload diversity—DRRIP handles control-dominated and irregular workloads (astar, mcf, milc, omnetpp), SHiP-lite boosts reuse prediction, and DIP-style streaming bypass improves performance in spatially regular workloads (lbm), all within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/029_02_drrip___ship_lite___dip_style_streaming_bypass_t07.cc,0.193134355,0.193134355,0%
2094,mcf,DRRIP + SHiP-Lite + DIP-style Streaming Bypass,"This policy combines DRRIP (Dynamic RRIP with set-dueling via a compact 10-bit PSEL), SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters), and a DIP-style streaming bypass using leader sets. Each cache fill chooses insertion depth via DRRIP: either SRRIP (insert at RRPV=2) or BRRIP (insert at RRPV=3), with the global PSEL selector adapted using 32 leader sets. SHiP-lite further biases insertion depth: blocks with strong signature reuse (ctr≥2) are promoted to RRPV=1 (very likely reused), regardless of DRRIP. Streaming leader sets (selected by address stride monotonicity) trigger bypass (no fill) when detected, helping eliminate pollution from streaming accesses (e.g., lbm). Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature outcome, 10 bits for PSEL, and 32 sets for streaming detection (3 bits per-set). This design adapts to phase changes and workload diversity—DRRIP handles control-dominated and irregular workloads (astar, mcf, milc, omnetpp), SHiP-lite boosts reuse prediction, and DIP-style streaming bypass improves performance in spatially regular workloads (lbm), all within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/029_02_drrip___ship_lite___dip_style_streaming_bypass_t07.cc,0.484879774,0.484879774,0%
2095,milc,DRRIP + SHiP-Lite + DIP-style Streaming Bypass,"This policy combines DRRIP (Dynamic RRIP with set-dueling via a compact 10-bit PSEL), SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters), and a DIP-style streaming bypass using leader sets. Each cache fill chooses insertion depth via DRRIP: either SRRIP (insert at RRPV=2) or BRRIP (insert at RRPV=3), with the global PSEL selector adapted using 32 leader sets. SHiP-lite further biases insertion depth: blocks with strong signature reuse (ctr≥2) are promoted to RRPV=1 (very likely reused), regardless of DRRIP. Streaming leader sets (selected by address stride monotonicity) trigger bypass (no fill) when detected, helping eliminate pollution from streaming accesses (e.g., lbm). Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature outcome, 10 bits for PSEL, and 32 sets for streaming detection (3 bits per-set). This design adapts to phase changes and workload diversity—DRRIP handles control-dominated and irregular workloads (astar, mcf, milc, omnetpp), SHiP-lite boosts reuse prediction, and DIP-style streaming bypass improves performance in spatially regular workloads (lbm), all within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/029_02_drrip___ship_lite___dip_style_streaming_bypass_t07.cc,0.070399791,0.070399791,0%
2096,omnetpp,DRRIP + SHiP-Lite + DIP-style Streaming Bypass,"This policy combines DRRIP (Dynamic RRIP with set-dueling via a compact 10-bit PSEL), SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters), and a DIP-style streaming bypass using leader sets. Each cache fill chooses insertion depth via DRRIP: either SRRIP (insert at RRPV=2) or BRRIP (insert at RRPV=3), with the global PSEL selector adapted using 32 leader sets. SHiP-lite further biases insertion depth: blocks with strong signature reuse (ctr≥2) are promoted to RRPV=1 (very likely reused), regardless of DRRIP. Streaming leader sets (selected by address stride monotonicity) trigger bypass (no fill) when detected, helping eliminate pollution from streaming accesses (e.g., lbm). Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature outcome, 10 bits for PSEL, and 32 sets for streaming detection (3 bits per-set). This design adapts to phase changes and workload diversity—DRRIP handles control-dominated and irregular workloads (astar, mcf, milc, omnetpp), SHiP-lite boosts reuse prediction, and DIP-style streaming bypass improves performance in spatially regular workloads (lbm), all within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/029_02_drrip___ship_lite___dip_style_streaming_bypass_t07.cc,0.632194261,0.632194261,0%
2097,all,DRRIP + SHiP-Lite + DIP-style Streaming Bypass,"This policy combines DRRIP (Dynamic RRIP with set-dueling via a compact 10-bit PSEL), SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters), and a DIP-style streaming bypass using leader sets. Each cache fill chooses insertion depth via DRRIP: either SRRIP (insert at RRPV=2) or BRRIP (insert at RRPV=3), with the global PSEL selector adapted using 32 leader sets. SHiP-lite further biases insertion depth: blocks with strong signature reuse (ctr≥2) are promoted to RRPV=1 (very likely reused), regardless of DRRIP. Streaming leader sets (selected by address stride monotonicity) trigger bypass (no fill) when detected, helping eliminate pollution from streaming accesses (e.g., lbm). Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature outcome, 10 bits for PSEL, and 32 sets for streaming detection (3 bits per-set). This design adapts to phase changes and workload diversity—DRRIP handles control-dominated and irregular workloads (astar, mcf, milc, omnetpp), SHiP-lite boosts reuse prediction, and DIP-style streaming bypass improves performance in spatially regular workloads (lbm), all within a 64 KiB metadata budget.",,ChampSim_CRC2/new_policies/029_02_drrip___ship_lite___dip_style_streaming_bypass_t07.cc,0.339054669,0.339054669,34%
2098,astar,SHiP-Lite + Dead-Block + Adaptive Streaming Bypass (SDS),"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse indicator, periodically decayed), and an adaptive streaming bypass detector using address stride history per leader set. On cache fill, SHiP-lite predicts reuse likelihood and biases insertion depth (RRPV=1 for strong reuse, RRPV=3 for weak). The dead-block bit further demotes blocks that have not been reused recently, improving victim selection in irregular workloads (mcf, omnetpp, astar). Streaming detection uses 32 leader sets to track monotonic strides and triggers bypass for streaming accesses (lbm), but adapts by disabling bypass if reuse is detected. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 1 bit per-block dead indicator, and 32 sets for streaming detection (last_addr, stride, stream_cnt, reuse_cnt). This hybrid approach improves hit rate by combining phase-aware prediction, dead-block filtering, and adaptive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_00_ship_lite___dead_block___adaptive_streaming_bypass__sds_t02.cc,0.312511517,0.312511517,0%
2099,lbm,SHiP-Lite + Dead-Block + Adaptive Streaming Bypass (SDS),"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse indicator, periodically decayed), and an adaptive streaming bypass detector using address stride history per leader set. On cache fill, SHiP-lite predicts reuse likelihood and biases insertion depth (RRPV=1 for strong reuse, RRPV=3 for weak). The dead-block bit further demotes blocks that have not been reused recently, improving victim selection in irregular workloads (mcf, omnetpp, astar). Streaming detection uses 32 leader sets to track monotonic strides and triggers bypass for streaming accesses (lbm), but adapts by disabling bypass if reuse is detected. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 1 bit per-block dead indicator, and 32 sets for streaming detection (last_addr, stride, stream_cnt, reuse_cnt). This hybrid approach improves hit rate by combining phase-aware prediction, dead-block filtering, and adaptive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_00_ship_lite___dead_block___adaptive_streaming_bypass__sds_t02.cc,0.188678924,0.188678924,0%
2100,mcf,SHiP-Lite + Dead-Block + Adaptive Streaming Bypass (SDS),"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse indicator, periodically decayed), and an adaptive streaming bypass detector using address stride history per leader set. On cache fill, SHiP-lite predicts reuse likelihood and biases insertion depth (RRPV=1 for strong reuse, RRPV=3 for weak). The dead-block bit further demotes blocks that have not been reused recently, improving victim selection in irregular workloads (mcf, omnetpp, astar). Streaming detection uses 32 leader sets to track monotonic strides and triggers bypass for streaming accesses (lbm), but adapts by disabling bypass if reuse is detected. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 1 bit per-block dead indicator, and 32 sets for streaming detection (last_addr, stride, stream_cnt, reuse_cnt). This hybrid approach improves hit rate by combining phase-aware prediction, dead-block filtering, and adaptive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_00_ship_lite___dead_block___adaptive_streaming_bypass__sds_t02.cc,0.521390148,0.521390148,0%
2101,milc,SHiP-Lite + Dead-Block + Adaptive Streaming Bypass (SDS),"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse indicator, periodically decayed), and an adaptive streaming bypass detector using address stride history per leader set. On cache fill, SHiP-lite predicts reuse likelihood and biases insertion depth (RRPV=1 for strong reuse, RRPV=3 for weak). The dead-block bit further demotes blocks that have not been reused recently, improving victim selection in irregular workloads (mcf, omnetpp, astar). Streaming detection uses 32 leader sets to track monotonic strides and triggers bypass for streaming accesses (lbm), but adapts by disabling bypass if reuse is detected. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 1 bit per-block dead indicator, and 32 sets for streaming detection (last_addr, stride, stream_cnt, reuse_cnt). This hybrid approach improves hit rate by combining phase-aware prediction, dead-block filtering, and adaptive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_00_ship_lite___dead_block___adaptive_streaming_bypass__sds_t02.cc,0.066710356,0.066710356,0%
2102,omnetpp,SHiP-Lite + Dead-Block + Adaptive Streaming Bypass (SDS),"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse indicator, periodically decayed), and an adaptive streaming bypass detector using address stride history per leader set. On cache fill, SHiP-lite predicts reuse likelihood and biases insertion depth (RRPV=1 for strong reuse, RRPV=3 for weak). The dead-block bit further demotes blocks that have not been reused recently, improving victim selection in irregular workloads (mcf, omnetpp, astar). Streaming detection uses 32 leader sets to track monotonic strides and triggers bypass for streaming accesses (lbm), but adapts by disabling bypass if reuse is detected. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 1 bit per-block dead indicator, and 32 sets for streaming detection (last_addr, stride, stream_cnt, reuse_cnt). This hybrid approach improves hit rate by combining phase-aware prediction, dead-block filtering, and adaptive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_00_ship_lite___dead_block___adaptive_streaming_bypass__sds_t02.cc,0.74041312,0.74041312,0%
2103,astar,SHiP-Lite + Dead-Block Counter + Streaming Distant Insert (SDS),"This policy combines SHiP-lite signature-based prediction (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse counter), and a streaming detector that inserts streaming blocks at the most distant RRPV rather than bypassing fills. SHiP-lite boosts insertion depth for blocks with strong signature reuse, while the dead-block counter helps identify and evict blocks with no reuse. The streaming detector (using 32 leader sets) tracks monotonic address strides and, upon detection, inserts at RRPV=3 (distant), reducing pollution from regular streaming accesses (e.g., lbm) without bypassing fills. This design improves over the previous policy by changing the streaming logic (no bypass, only distant insert), adding dead-block approximation to better handle irregular workloads (mcf, omnetpp), and keeping metadata compact (2 bits RRPV + 6 bits signature + 2 bits SHiP outcome + 1 bit dead-block per block, plus streaming metadata). The combination adapts to phase changes and workload diversity, improving hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/030_01_ship_lite___dead_block_counter___streaming_distant_insert__sds_t04.cc,0.291598747,0.291598747,0%
2104,lbm,SHiP-Lite + Dead-Block Counter + Streaming Distant Insert (SDS),"This policy combines SHiP-lite signature-based prediction (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse counter), and a streaming detector that inserts streaming blocks at the most distant RRPV rather than bypassing fills. SHiP-lite boosts insertion depth for blocks with strong signature reuse, while the dead-block counter helps identify and evict blocks with no reuse. The streaming detector (using 32 leader sets) tracks monotonic address strides and, upon detection, inserts at RRPV=3 (distant), reducing pollution from regular streaming accesses (e.g., lbm) without bypassing fills. This design improves over the previous policy by changing the streaming logic (no bypass, only distant insert), adding dead-block approximation to better handle irregular workloads (mcf, omnetpp), and keeping metadata compact (2 bits RRPV + 6 bits signature + 2 bits SHiP outcome + 1 bit dead-block per block, plus streaming metadata). The combination adapts to phase changes and workload diversity, improving hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/030_01_ship_lite___dead_block_counter___streaming_distant_insert__sds_t04.cc,0.161945136,0.161945136,0%
2105,mcf,SHiP-Lite + Dead-Block Counter + Streaming Distant Insert (SDS),"This policy combines SHiP-lite signature-based prediction (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse counter), and a streaming detector that inserts streaming blocks at the most distant RRPV rather than bypassing fills. SHiP-lite boosts insertion depth for blocks with strong signature reuse, while the dead-block counter helps identify and evict blocks with no reuse. The streaming detector (using 32 leader sets) tracks monotonic address strides and, upon detection, inserts at RRPV=3 (distant), reducing pollution from regular streaming accesses (e.g., lbm) without bypassing fills. This design improves over the previous policy by changing the streaming logic (no bypass, only distant insert), adding dead-block approximation to better handle irregular workloads (mcf, omnetpp), and keeping metadata compact (2 bits RRPV + 6 bits signature + 2 bits SHiP outcome + 1 bit dead-block per block, plus streaming metadata). The combination adapts to phase changes and workload diversity, improving hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/030_01_ship_lite___dead_block_counter___streaming_distant_insert__sds_t04.cc,0.409632638,0.409632638,0%
2106,milc,SHiP-Lite + Dead-Block Counter + Streaming Distant Insert (SDS),"This policy combines SHiP-lite signature-based prediction (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse counter), and a streaming detector that inserts streaming blocks at the most distant RRPV rather than bypassing fills. SHiP-lite boosts insertion depth for blocks with strong signature reuse, while the dead-block counter helps identify and evict blocks with no reuse. The streaming detector (using 32 leader sets) tracks monotonic address strides and, upon detection, inserts at RRPV=3 (distant), reducing pollution from regular streaming accesses (e.g., lbm) without bypassing fills. This design improves over the previous policy by changing the streaming logic (no bypass, only distant insert), adding dead-block approximation to better handle irregular workloads (mcf, omnetpp), and keeping metadata compact (2 bits RRPV + 6 bits signature + 2 bits SHiP outcome + 1 bit dead-block per block, plus streaming metadata). The combination adapts to phase changes and workload diversity, improving hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/030_01_ship_lite___dead_block_counter___streaming_distant_insert__sds_t04.cc,0.064337024,0.064337024,0%
2107,omnetpp,SHiP-Lite + Dead-Block Counter + Streaming Distant Insert (SDS),"This policy combines SHiP-lite signature-based prediction (using 6-bit PC signatures and 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse counter), and a streaming detector that inserts streaming blocks at the most distant RRPV rather than bypassing fills. SHiP-lite boosts insertion depth for blocks with strong signature reuse, while the dead-block counter helps identify and evict blocks with no reuse. The streaming detector (using 32 leader sets) tracks monotonic address strides and, upon detection, inserts at RRPV=3 (distant), reducing pollution from regular streaming accesses (e.g., lbm) without bypassing fills. This design improves over the previous policy by changing the streaming logic (no bypass, only distant insert), adding dead-block approximation to better handle irregular workloads (mcf, omnetpp), and keeping metadata compact (2 bits RRPV + 6 bits signature + 2 bits SHiP outcome + 1 bit dead-block per block, plus streaming metadata). The combination adapts to phase changes and workload diversity, improving hit rates for both regular and irregular access patterns.",,ChampSim_CRC2/new_policies/030_01_ship_lite___dead_block_counter___streaming_distant_insert__sds_t04.cc,0.854340266,0.854340266,0%
2108,astar,SHiP-Lite + Dead-Block Predictor + Streaming-Aware SRRIP,"This policy combines SHiP-lite signature-based reuse prediction (using 6-bit PC signatures and 2-bit outcome counters) with a lightweight per-block dead-block predictor (1-bit reuse flag plus periodic decay) and a streaming-aware SRRIP insertion policy. On fills, the SHiP signature outcome and dead-block bit bias insertion depth: blocks with strong reuse (SHiP counter ≥2 or reused recently) get RRPV=1 (high priority), all others get RRPV=3 (long distance). Streaming leader sets (32 sets) use stride-based detection to bypass fills for high-confidence streaming, minimizing pollution in LBM. Periodic decay clears dead-block bits to maintain adaptivity across phase changes in workloads like MILC and OMNETPP. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 1 bit per-block dead-block flag, 2 bits per signature counter, and 32 leader sets with stride tracking (3 bits per-set). This hybrid approach improves hit rates by combining signature learning, dead-block retention, and aggressive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_02_ship_lite___dead_block_predictor___streaming_aware_srrip_t07.cc,0.287529767,0.287529767,0%
2109,lbm,SHiP-Lite + Dead-Block Predictor + Streaming-Aware SRRIP,"This policy combines SHiP-lite signature-based reuse prediction (using 6-bit PC signatures and 2-bit outcome counters) with a lightweight per-block dead-block predictor (1-bit reuse flag plus periodic decay) and a streaming-aware SRRIP insertion policy. On fills, the SHiP signature outcome and dead-block bit bias insertion depth: blocks with strong reuse (SHiP counter ≥2 or reused recently) get RRPV=1 (high priority), all others get RRPV=3 (long distance). Streaming leader sets (32 sets) use stride-based detection to bypass fills for high-confidence streaming, minimizing pollution in LBM. Periodic decay clears dead-block bits to maintain adaptivity across phase changes in workloads like MILC and OMNETPP. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 1 bit per-block dead-block flag, 2 bits per signature counter, and 32 leader sets with stride tracking (3 bits per-set). This hybrid approach improves hit rates by combining signature learning, dead-block retention, and aggressive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_02_ship_lite___dead_block_predictor___streaming_aware_srrip_t07.cc,0.179329179,0.179329179,0%
2110,mcf,SHiP-Lite + Dead-Block Predictor + Streaming-Aware SRRIP,"This policy combines SHiP-lite signature-based reuse prediction (using 6-bit PC signatures and 2-bit outcome counters) with a lightweight per-block dead-block predictor (1-bit reuse flag plus periodic decay) and a streaming-aware SRRIP insertion policy. On fills, the SHiP signature outcome and dead-block bit bias insertion depth: blocks with strong reuse (SHiP counter ≥2 or reused recently) get RRPV=1 (high priority), all others get RRPV=3 (long distance). Streaming leader sets (32 sets) use stride-based detection to bypass fills for high-confidence streaming, minimizing pollution in LBM. Periodic decay clears dead-block bits to maintain adaptivity across phase changes in workloads like MILC and OMNETPP. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 1 bit per-block dead-block flag, 2 bits per signature counter, and 32 leader sets with stride tracking (3 bits per-set). This hybrid approach improves hit rates by combining signature learning, dead-block retention, and aggressive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_02_ship_lite___dead_block_predictor___streaming_aware_srrip_t07.cc,0.513638812,0.513638812,0%
2111,milc,SHiP-Lite + Dead-Block Predictor + Streaming-Aware SRRIP,"This policy combines SHiP-lite signature-based reuse prediction (using 6-bit PC signatures and 2-bit outcome counters) with a lightweight per-block dead-block predictor (1-bit reuse flag plus periodic decay) and a streaming-aware SRRIP insertion policy. On fills, the SHiP signature outcome and dead-block bit bias insertion depth: blocks with strong reuse (SHiP counter ≥2 or reused recently) get RRPV=1 (high priority), all others get RRPV=3 (long distance). Streaming leader sets (32 sets) use stride-based detection to bypass fills for high-confidence streaming, minimizing pollution in LBM. Periodic decay clears dead-block bits to maintain adaptivity across phase changes in workloads like MILC and OMNETPP. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 1 bit per-block dead-block flag, 2 bits per signature counter, and 32 leader sets with stride tracking (3 bits per-set). This hybrid approach improves hit rates by combining signature learning, dead-block retention, and aggressive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_02_ship_lite___dead_block_predictor___streaming_aware_srrip_t07.cc,0.071943996,0.071943996,0%
2112,omnetpp,SHiP-Lite + Dead-Block Predictor + Streaming-Aware SRRIP,"This policy combines SHiP-lite signature-based reuse prediction (using 6-bit PC signatures and 2-bit outcome counters) with a lightweight per-block dead-block predictor (1-bit reuse flag plus periodic decay) and a streaming-aware SRRIP insertion policy. On fills, the SHiP signature outcome and dead-block bit bias insertion depth: blocks with strong reuse (SHiP counter ≥2 or reused recently) get RRPV=1 (high priority), all others get RRPV=3 (long distance). Streaming leader sets (32 sets) use stride-based detection to bypass fills for high-confidence streaming, minimizing pollution in LBM. Periodic decay clears dead-block bits to maintain adaptivity across phase changes in workloads like MILC and OMNETPP. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 1 bit per-block dead-block flag, 2 bits per signature counter, and 32 leader sets with stride tracking (3 bits per-set). This hybrid approach improves hit rates by combining signature learning, dead-block retention, and aggressive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_02_ship_lite___dead_block_predictor___streaming_aware_srrip_t07.cc,0.695200148,0.695200148,0%
2113,all,SHiP-Lite + Dead-Block + Adaptive Streaming Bypass (SDS),"This policy combines SHiP-lite signature-based prediction (6-bit PC signatures, 2-bit outcome counters) with a per-block dead-block approximation (1-bit reuse indicator, periodically decayed), and an adaptive streaming bypass detector using address stride history per leader set. On cache fill, SHiP-lite predicts reuse likelihood and biases insertion depth (RRPV=1 for strong reuse, RRPV=3 for weak). The dead-block bit further demotes blocks that have not been reused recently, improving victim selection in irregular workloads (mcf, omnetpp, astar). Streaming detection uses 32 leader sets to track monotonic strides and triggers bypass for streaming accesses (lbm), but adapts by disabling bypass if reuse is detected. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 1 bit per-block dead indicator, and 32 sets for streaming detection (last_addr, stride, stream_cnt, reuse_cnt). This hybrid approach improves hit rate by combining phase-aware prediction, dead-block filtering, and adaptive streaming bypass, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/030_00_ship_lite___dead_block___adaptive_streaming_bypass__sds_t02.cc,0.365940813,0.365940813,37%
2114,astar,DRRIP + SHiP-Lite + Streaming Bypass (DSS),"This policy combines DRRIP (Dynamic RRIP) set-dueling for adaptive insertion depth, SHiP-lite signature-based prediction for phase-aware reuse, and a lightweight streaming bypass detector. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to dynamically select between SRRIP and BRRIP insertion depths, adapting to workload locality. SHiP-lite augments insertion decisions by biasing toward MRU for blocks with strong PC-based reuse signatures, improving hit rates in control-dominated and phase-changing workloads (astar, milc, mcf, omnetpp). A compact streaming detector tracks monotonic address strides in 32 leader sets and triggers bypass for streaming accesses (lbm), reducing pollution. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 10 bits PSEL, and 32 sets for streaming detection. This hybrid approach leverages adaptive insertion, phase-aware prediction, and streaming bypass to boost hit rates across diverse workloads, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_00_drrip___ship_lite___streaming_bypass__dss_t02.cc,0.306049696,0.306049696,0%
2115,lbm,DRRIP + SHiP-Lite + Streaming Bypass (DSS),"This policy combines DRRIP (Dynamic RRIP) set-dueling for adaptive insertion depth, SHiP-lite signature-based prediction for phase-aware reuse, and a lightweight streaming bypass detector. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to dynamically select between SRRIP and BRRIP insertion depths, adapting to workload locality. SHiP-lite augments insertion decisions by biasing toward MRU for blocks with strong PC-based reuse signatures, improving hit rates in control-dominated and phase-changing workloads (astar, milc, mcf, omnetpp). A compact streaming detector tracks monotonic address strides in 32 leader sets and triggers bypass for streaming accesses (lbm), reducing pollution. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 10 bits PSEL, and 32 sets for streaming detection. This hybrid approach leverages adaptive insertion, phase-aware prediction, and streaming bypass to boost hit rates across diverse workloads, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_00_drrip___ship_lite___streaming_bypass__dss_t02.cc,0.194816378,0.194816378,0%
2116,mcf,DRRIP + SHiP-Lite + Streaming Bypass (DSS),"This policy combines DRRIP (Dynamic RRIP) set-dueling for adaptive insertion depth, SHiP-lite signature-based prediction for phase-aware reuse, and a lightweight streaming bypass detector. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to dynamically select between SRRIP and BRRIP insertion depths, adapting to workload locality. SHiP-lite augments insertion decisions by biasing toward MRU for blocks with strong PC-based reuse signatures, improving hit rates in control-dominated and phase-changing workloads (astar, milc, mcf, omnetpp). A compact streaming detector tracks monotonic address strides in 32 leader sets and triggers bypass for streaming accesses (lbm), reducing pollution. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 10 bits PSEL, and 32 sets for streaming detection. This hybrid approach leverages adaptive insertion, phase-aware prediction, and streaming bypass to boost hit rates across diverse workloads, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_00_drrip___ship_lite___streaming_bypass__dss_t02.cc,0.497222432,0.497222432,0%
2117,milc,DRRIP + SHiP-Lite + Streaming Bypass (DSS),"This policy combines DRRIP (Dynamic RRIP) set-dueling for adaptive insertion depth, SHiP-lite signature-based prediction for phase-aware reuse, and a lightweight streaming bypass detector. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to dynamically select between SRRIP and BRRIP insertion depths, adapting to workload locality. SHiP-lite augments insertion decisions by biasing toward MRU for blocks with strong PC-based reuse signatures, improving hit rates in control-dominated and phase-changing workloads (astar, milc, mcf, omnetpp). A compact streaming detector tracks monotonic address strides in 32 leader sets and triggers bypass for streaming accesses (lbm), reducing pollution. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 10 bits PSEL, and 32 sets for streaming detection. This hybrid approach leverages adaptive insertion, phase-aware prediction, and streaming bypass to boost hit rates across diverse workloads, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_00_drrip___ship_lite___streaming_bypass__dss_t02.cc,0.110322817,0.110322817,0%
2118,omnetpp,DRRIP + SHiP-Lite + Streaming Bypass (DSS),"This policy combines DRRIP (Dynamic RRIP) set-dueling for adaptive insertion depth, SHiP-lite signature-based prediction for phase-aware reuse, and a lightweight streaming bypass detector. DRRIP uses a 2-bit RRPV per block and a 10-bit PSEL counter to dynamically select between SRRIP and BRRIP insertion depths, adapting to workload locality. SHiP-lite augments insertion decisions by biasing toward MRU for blocks with strong PC-based reuse signatures, improving hit rates in control-dominated and phase-changing workloads (astar, milc, mcf, omnetpp). A compact streaming detector tracks monotonic address strides in 32 leader sets and triggers bypass for streaming accesses (lbm), reducing pollution. Metadata is compact: 2 bits per-block RRPV, 6 bits per-block signature, 2 bits per signature, 10 bits PSEL, and 32 sets for streaming detection. This hybrid approach leverages adaptive insertion, phase-aware prediction, and streaming bypass to boost hit rates across diverse workloads, all within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_00_drrip___ship_lite___streaming_bypass__dss_t02.cc,0.611651586,0.611651586,0%
2119,astar,DIP-SHiP Hybrid with Streaming-Aware Bypass (DSS),"DSS combines DIP-style dynamic insertion control (set-dueling between LIP and BIP using 32 leader sets and a 10-bit PSEL), SHiP-lite signature-based prediction (4-bit PC signatures, 2-bit outcome counters), and a lightweight streaming detector (per-block stride history, 1 bit per-block streaming flag). On cache fill, DIP chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) based on workload phase, while SHiP-lite further biases insertion depth for blocks with strong reuse signatures. The streaming detector marks blocks as streaming if they show monotonic strides and triggers bypass (insert at distant RRPV) for those blocks. This hybrid approach leverages phase-adaptive insertion, signature-based reuse prediction, and streaming-aware bypass to improve hit rates in both irregular (mcf, omnetpp, astar) and regular (lbm, milc) workloads. Metadata is compact: 2 bits per-block RRPV, 4 bits per-block signature, 2 bits per signature (SHiP), 1 bit per-block streaming flag, and 32 sets for DIP leader sets and 10-bit PSEL. All structures fit within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_01_dip_ship_hybrid_with_streaming_aware_bypass__dss_t04.cc,0.31010716,0.31010716,0%
2120,lbm,DIP-SHiP Hybrid with Streaming-Aware Bypass (DSS),"DSS combines DIP-style dynamic insertion control (set-dueling between LIP and BIP using 32 leader sets and a 10-bit PSEL), SHiP-lite signature-based prediction (4-bit PC signatures, 2-bit outcome counters), and a lightweight streaming detector (per-block stride history, 1 bit per-block streaming flag). On cache fill, DIP chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) based on workload phase, while SHiP-lite further biases insertion depth for blocks with strong reuse signatures. The streaming detector marks blocks as streaming if they show monotonic strides and triggers bypass (insert at distant RRPV) for those blocks. This hybrid approach leverages phase-adaptive insertion, signature-based reuse prediction, and streaming-aware bypass to improve hit rates in both irregular (mcf, omnetpp, astar) and regular (lbm, milc) workloads. Metadata is compact: 2 bits per-block RRPV, 4 bits per-block signature, 2 bits per signature (SHiP), 1 bit per-block streaming flag, and 32 sets for DIP leader sets and 10-bit PSEL. All structures fit within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_01_dip_ship_hybrid_with_streaming_aware_bypass__dss_t04.cc,0.186555512,0.186555512,0%
2121,mcf,DIP-SHiP Hybrid with Streaming-Aware Bypass (DSS),"DSS combines DIP-style dynamic insertion control (set-dueling between LIP and BIP using 32 leader sets and a 10-bit PSEL), SHiP-lite signature-based prediction (4-bit PC signatures, 2-bit outcome counters), and a lightweight streaming detector (per-block stride history, 1 bit per-block streaming flag). On cache fill, DIP chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) based on workload phase, while SHiP-lite further biases insertion depth for blocks with strong reuse signatures. The streaming detector marks blocks as streaming if they show monotonic strides and triggers bypass (insert at distant RRPV) for those blocks. This hybrid approach leverages phase-adaptive insertion, signature-based reuse prediction, and streaming-aware bypass to improve hit rates in both irregular (mcf, omnetpp, astar) and regular (lbm, milc) workloads. Metadata is compact: 2 bits per-block RRPV, 4 bits per-block signature, 2 bits per signature (SHiP), 1 bit per-block streaming flag, and 32 sets for DIP leader sets and 10-bit PSEL. All structures fit within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_01_dip_ship_hybrid_with_streaming_aware_bypass__dss_t04.cc,0.518319076,0.518319076,0%
2122,milc,DIP-SHiP Hybrid with Streaming-Aware Bypass (DSS),"DSS combines DIP-style dynamic insertion control (set-dueling between LIP and BIP using 32 leader sets and a 10-bit PSEL), SHiP-lite signature-based prediction (4-bit PC signatures, 2-bit outcome counters), and a lightweight streaming detector (per-block stride history, 1 bit per-block streaming flag). On cache fill, DIP chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) based on workload phase, while SHiP-lite further biases insertion depth for blocks with strong reuse signatures. The streaming detector marks blocks as streaming if they show monotonic strides and triggers bypass (insert at distant RRPV) for those blocks. This hybrid approach leverages phase-adaptive insertion, signature-based reuse prediction, and streaming-aware bypass to improve hit rates in both irregular (mcf, omnetpp, astar) and regular (lbm, milc) workloads. Metadata is compact: 2 bits per-block RRPV, 4 bits per-block signature, 2 bits per signature (SHiP), 1 bit per-block streaming flag, and 32 sets for DIP leader sets and 10-bit PSEL. All structures fit within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_01_dip_ship_hybrid_with_streaming_aware_bypass__dss_t04.cc,0.075693172,0.075693172,0%
2123,omnetpp,DIP-SHiP Hybrid with Streaming-Aware Bypass (DSS),"DSS combines DIP-style dynamic insertion control (set-dueling between LIP and BIP using 32 leader sets and a 10-bit PSEL), SHiP-lite signature-based prediction (4-bit PC signatures, 2-bit outcome counters), and a lightweight streaming detector (per-block stride history, 1 bit per-block streaming flag). On cache fill, DIP chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) based on workload phase, while SHiP-lite further biases insertion depth for blocks with strong reuse signatures. The streaming detector marks blocks as streaming if they show monotonic strides and triggers bypass (insert at distant RRPV) for those blocks. This hybrid approach leverages phase-adaptive insertion, signature-based reuse prediction, and streaming-aware bypass to improve hit rates in both irregular (mcf, omnetpp, astar) and regular (lbm, milc) workloads. Metadata is compact: 2 bits per-block RRPV, 4 bits per-block signature, 2 bits per signature (SHiP), 1 bit per-block streaming flag, and 32 sets for DIP leader sets and 10-bit PSEL. All structures fit within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_01_dip_ship_hybrid_with_streaming_aware_bypass__dss_t04.cc,0.739834537,0.739834537,0%
2124,all,DIP-SHiP Hybrid with Streaming-Aware Bypass (DSS),"DSS combines DIP-style dynamic insertion control (set-dueling between LIP and BIP using 32 leader sets and a 10-bit PSEL), SHiP-lite signature-based prediction (4-bit PC signatures, 2-bit outcome counters), and a lightweight streaming detector (per-block stride history, 1 bit per-block streaming flag). On cache fill, DIP chooses between LIP (insert at LRU) and BIP (insert at MRU with low probability) based on workload phase, while SHiP-lite further biases insertion depth for blocks with strong reuse signatures. The streaming detector marks blocks as streaming if they show monotonic strides and triggers bypass (insert at distant RRPV) for those blocks. This hybrid approach leverages phase-adaptive insertion, signature-based reuse prediction, and streaming-aware bypass to improve hit rates in both irregular (mcf, omnetpp, astar) and regular (lbm, milc) workloads. Metadata is compact: 2 bits per-block RRPV, 4 bits per-block signature, 2 bits per signature (SHiP), 1 bit per-block streaming flag, and 32 sets for DIP leader sets and 10-bit PSEL. All structures fit within a 64 KiB budget.",,ChampSim_CRC2/new_policies/031_01_dip_ship_hybrid_with_streaming_aware_bypass__dss_t04.cc,0.366101892,0.366101892,37%
,,,,,,,,
,,,,,,,,49%